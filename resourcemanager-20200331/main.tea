import Util;

import RPC;
import EndpointUtil;

extends RPC;

init(config: RPC.Config){
  super(config);
  @endpointRule = 'central';
  
  checkConfig(config);
  @endpoint = getEndpoint('resourcemanager', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

model CreateServiceLinkedRoleRequest = {
  serviceName: string(name='ServiceName'),
  customSuffix?: string(name='CustomSuffix'),
  description?: string(name='Description'),
}

model CreateServiceLinkedRoleResponse = {
  requestId: string(name='RequestId'),
  role: {
    roleName: string(name='RoleName'),
    description: string(name='Description'),
    assumeRolePolicyDocument: string(name='AssumeRolePolicyDocument'),
    isServiceLinkedRole: boolean(name='IsServiceLinkedRole'),
    arn: string(name='Arn'),
    roleId: string(name='RoleId'),
    createDate: string(name='CreateDate'),
    rolePrincipalName: string(name='RolePrincipalName'),
  }(name='Role'),
}

async function createServiceLinkedRoleWithOptions(request: CreateServiceLinkedRoleRequest, runtime: Util.RuntimeOptions): CreateServiceLinkedRoleResponse {
  Util.validateModel(request);
  return doRequest('CreateServiceLinkedRole', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function createServiceLinkedRole(request: CreateServiceLinkedRoleRequest): CreateServiceLinkedRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createServiceLinkedRoleWithOptions(request, runtime);
}

model GetServiceLinkedRoleDeletionStatusRequest = {
  deletionTaskId?: string(name='DeletionTaskId'),
}

model GetServiceLinkedRoleDeletionStatusResponse = {
  status: string(name='Status'),
  requestId: string(name='RequestId'),
  reason: {
    message: string(name='Message'),
    roleUsages: {
      roleUsage: [
        {
          region: string(name='Region'),
          resources: {
            resource: [ string ](name='Resource', description='Resource'),
          }(name='Resources'),
        }
      ](name='RoleUsage'),
    }(name='RoleUsages'),
  }(name='Reason'),
}

async function getServiceLinkedRoleDeletionStatusWithOptions(request: GetServiceLinkedRoleDeletionStatusRequest, runtime: Util.RuntimeOptions): GetServiceLinkedRoleDeletionStatusResponse {
  Util.validateModel(request);
  return doRequest('GetServiceLinkedRoleDeletionStatus', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function getServiceLinkedRoleDeletionStatus(request: GetServiceLinkedRoleDeletionStatusRequest): GetServiceLinkedRoleDeletionStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getServiceLinkedRoleDeletionStatusWithOptions(request, runtime);
}

model ListTrustedServiceStatusRequest = {
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model ListTrustedServiceStatusResponse = {
  totalCount: integer(name='TotalCount'),
  pageSize: integer(name='PageSize'),
  requestId: string(name='RequestId'),
  pageNumber: integer(name='PageNumber'),
  enabledServicePrincipals: {
    enabledServicePrincipal: [
      {
        servicePrincipal: string(name='ServicePrincipal'),
        enableTime: string(name='EnableTime'),
      }
    ](name='EnabledServicePrincipal'),
  }(name='EnabledServicePrincipals'),
}

async function listTrustedServiceStatusWithOptions(request: ListTrustedServiceStatusRequest, runtime: Util.RuntimeOptions): ListTrustedServiceStatusResponse {
  Util.validateModel(request);
  return doRequest('ListTrustedServiceStatus', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function listTrustedServiceStatus(request: ListTrustedServiceStatusRequest): ListTrustedServiceStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTrustedServiceStatusWithOptions(request, runtime);
}

model DeleteServiceLinkedRoleRequest = {
  roleName: string(name='RoleName'),
}

model DeleteServiceLinkedRoleResponse = {
  requestId: string(name='RequestId'),
  deletionTaskId: string(name='DeletionTaskId'),
}

async function deleteServiceLinkedRoleWithOptions(request: DeleteServiceLinkedRoleRequest, runtime: Util.RuntimeOptions): DeleteServiceLinkedRoleResponse {
  Util.validateModel(request);
  return doRequest('DeleteServiceLinkedRole', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function deleteServiceLinkedRole(request: DeleteServiceLinkedRoleRequest): DeleteServiceLinkedRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteServiceLinkedRoleWithOptions(request, runtime);
}

model UpdateRoleRequest = {
  roleName: string(name='RoleName'),
  newAssumeRolePolicyDocument: string(name='NewAssumeRolePolicyDocument'),
  newMaxSessionDuration?: long(name='NewMaxSessionDuration'),
}

model UpdateRoleResponse = {
  requestId: string(name='RequestId'),
  role: {
    maxSessionDuration: long(name='MaxSessionDuration'),
    updateDate: string(name='UpdateDate'),
    roleName: string(name='RoleName'),
    description: string(name='Description'),
    assumeRolePolicyDocument: string(name='AssumeRolePolicyDocument'),
    arn: string(name='Arn'),
    roleId: string(name='RoleId'),
    createDate: string(name='CreateDate'),
    rolePrincipalName: string(name='RolePrincipalName'),
  }(name='Role'),
}

async function updateRoleWithOptions(request: UpdateRoleRequest, runtime: Util.RuntimeOptions): UpdateRoleResponse {
  Util.validateModel(request);
  return doRequest('UpdateRole', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function updateRole(request: UpdateRoleRequest): UpdateRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateRoleWithOptions(request, runtime);
}

model ListResourcesRequest = {
  resourceGroupId?: string(name='ResourceGroupId'),
  service?: string(name='Service'),
  region?: string(name='Region'),
  resourceType?: string(name='ResourceType'),
  resourceId?: string(name='ResourceId'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model ListResourcesResponse = {
  totalCount: integer(name='TotalCount'),
  pageSize: integer(name='PageSize'),
  requestId: string(name='RequestId'),
  pageNumber: integer(name='PageNumber'),
  resources: {
    resource: [
      {
        resourceGroupId: string(name='ResourceGroupId'),
        resourceId: string(name='ResourceId'),
        service: string(name='Service'),
        resourceType: string(name='ResourceType'),
        regionId: string(name='RegionId'),
        createDate: string(name='CreateDate'),
      }
    ](name='Resource'),
  }(name='Resources'),
}

async function listResourcesWithOptions(request: ListResourcesRequest, runtime: Util.RuntimeOptions): ListResourcesResponse {
  Util.validateModel(request);
  return doRequest('ListResources', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function listResources(request: ListResourcesRequest): ListResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listResourcesWithOptions(request, runtime);
}

model CreateCloudAccountRequest = {
  displayName: string(name='DisplayName'),
  parentFolderId?: string(name='ParentFolderId'),
  email: string(name='Email'),
  payerAccountId?: string(name='PayerAccountId'),
}

model CreateCloudAccountResponse = {
  requestId: string(name='RequestId'),
  account: {
    resourceDirectoryId: string(name='ResourceDirectoryId'),
    accountId: string(name='AccountId'),
    displayName: string(name='DisplayName'),
    accountName: string(name='AccountName'),
    folderId: string(name='FolderId'),
    joinMethod: string(name='JoinMethod'),
    modifyTime: string(name='ModifyTime'),
    type: string(name='Type'),
    status: string(name='Status'),
    recordId: string(name='RecordId'),
  }(name='Account'),
}

async function createCloudAccountWithOptions(request: CreateCloudAccountRequest, runtime: Util.RuntimeOptions): CreateCloudAccountResponse {
  Util.validateModel(request);
  return doRequest('CreateCloudAccount', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function createCloudAccount(request: CreateCloudAccountRequest): CreateCloudAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCloudAccountWithOptions(request, runtime);
}

model DeleteRoleRequest = {
  roleName: string(name='RoleName'),
}

model DeleteRoleResponse = {
  requestId: string(name='RequestId'),
}

async function deleteRoleWithOptions(request: DeleteRoleRequest, runtime: Util.RuntimeOptions): DeleteRoleResponse {
  Util.validateModel(request);
  return doRequest('DeleteRole', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function deleteRole(request: DeleteRoleRequest): DeleteRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRoleWithOptions(request, runtime);
}

model GetRoleRequest = {
  roleName: string(name='RoleName'),
  language?: string(name='Language'),
}

model GetRoleResponse = {
  requestId: string(name='RequestId'),
  role: {
    maxSessionDuration: long(name='MaxSessionDuration'),
    updateDate: string(name='UpdateDate'),
    roleName: string(name='RoleName'),
    description: string(name='Description'),
    assumeRolePolicyDocument: string(name='AssumeRolePolicyDocument'),
    isServiceLinkedRole: boolean(name='IsServiceLinkedRole'),
    arn: string(name='Arn'),
    roleId: string(name='RoleId'),
    createDate: string(name='CreateDate'),
    rolePrincipalName: string(name='RolePrincipalName'),
    latestDeletionTask: {
      createDate: string(name='CreateDate'),
      deletionTaskId: string(name='DeletionTaskId'),
    }(name='LatestDeletionTask'),
  }(name='Role'),
}

async function getRoleWithOptions(request: GetRoleRequest, runtime: Util.RuntimeOptions): GetRoleResponse {
  Util.validateModel(request);
  return doRequest('GetRole', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function getRole(request: GetRoleRequest): GetRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRoleWithOptions(request, runtime);
}

model ListRolesRequest = {
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  language?: string(name='Language'),
}

model ListRolesResponse = {
  totalCount: integer(name='TotalCount'),
  pageSize: integer(name='PageSize'),
  requestId: string(name='RequestId'),
  pageNumber: integer(name='PageNumber'),
  roles: {
    role: [
      {
        maxSessionDuration: long(name='MaxSessionDuration'),
        updateDate: string(name='UpdateDate'),
        roleName: string(name='RoleName'),
        description: string(name='Description'),
        isServiceLinkedRole: boolean(name='IsServiceLinkedRole'),
        arn: string(name='Arn'),
        roleId: string(name='RoleId'),
        createDate: string(name='CreateDate'),
        rolePrincipalName: string(name='RolePrincipalName'),
        latestDeletionTask: {
          createDate: string(name='CreateDate'),
          deletionTaskId: string(name='DeletionTaskId'),
        }(name='LatestDeletionTask'),
      }
    ](name='Role'),
  }(name='Roles'),
}

async function listRolesWithOptions(request: ListRolesRequest, runtime: Util.RuntimeOptions): ListRolesResponse {
  Util.validateModel(request);
  return doRequest('ListRoles', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function listRoles(request: ListRolesRequest): ListRolesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRolesWithOptions(request, runtime);
}

model CreateRoleRequest = {
  roleName: string(name='RoleName'),
  description?: string(name='Description'),
  assumeRolePolicyDocument: string(name='AssumeRolePolicyDocument'),
  maxSessionDuration?: long(name='MaxSessionDuration'),
}

model CreateRoleResponse = {
  requestId: string(name='RequestId'),
  role: {
    maxSessionDuration: long(name='MaxSessionDuration'),
    roleName: string(name='RoleName'),
    description: string(name='Description'),
    assumeRolePolicyDocument: string(name='AssumeRolePolicyDocument'),
    arn: string(name='Arn'),
    roleId: string(name='RoleId'),
    createDate: string(name='CreateDate'),
    rolePrincipalName: string(name='RolePrincipalName'),
  }(name='Role'),
}

async function createRoleWithOptions(request: CreateRoleRequest, runtime: Util.RuntimeOptions): CreateRoleResponse {
  Util.validateModel(request);
  return doRequest('CreateRole', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function createRole(request: CreateRoleRequest): CreateRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRoleWithOptions(request, runtime);
}

model ListPolicyAttachmentsRequest = {
  resourceGroupId?: string(name='ResourceGroupId'),
  policyType?: string(name='PolicyType'),
  policyName?: string(name='PolicyName'),
  principalType?: string(name='PrincipalType'),
  principalName?: string(name='PrincipalName'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  language?: string(name='Language'),
}

model ListPolicyAttachmentsResponse = {
  totalCount: integer(name='TotalCount'),
  pageSize: integer(name='PageSize'),
  requestId: string(name='RequestId'),
  pageNumber: integer(name='PageNumber'),
  policyAttachments: {
    policyAttachment: [
      {
        policyType: string(name='PolicyType'),
        description: string(name='Description'),
        resourceGroupId: string(name='ResourceGroupId'),
        attachDate: string(name='AttachDate'),
        policyName: string(name='PolicyName'),
        principalName: string(name='PrincipalName'),
        principalType: string(name='PrincipalType'),
      }
    ](name='PolicyAttachment'),
  }(name='PolicyAttachments'),
}

async function listPolicyAttachmentsWithOptions(request: ListPolicyAttachmentsRequest, runtime: Util.RuntimeOptions): ListPolicyAttachmentsResponse {
  Util.validateModel(request);
  return doRequest('ListPolicyAttachments', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function listPolicyAttachments(request: ListPolicyAttachmentsRequest): ListPolicyAttachmentsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPolicyAttachmentsWithOptions(request, runtime);
}

model DetachPolicyRequest = {
  resourceGroupId: string(name='ResourceGroupId'),
  policyType: string(name='PolicyType'),
  policyName: string(name='PolicyName'),
  principalType: string(name='PrincipalType'),
  principalName: string(name='PrincipalName'),
}

model DetachPolicyResponse = {
  requestId: string(name='RequestId'),
}

async function detachPolicyWithOptions(request: DetachPolicyRequest, runtime: Util.RuntimeOptions): DetachPolicyResponse {
  Util.validateModel(request);
  return doRequest('DetachPolicy', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function detachPolicy(request: DetachPolicyRequest): DetachPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachPolicyWithOptions(request, runtime);
}

model AttachPolicyRequest = {
  resourceGroupId: string(name='ResourceGroupId'),
  policyType: string(name='PolicyType'),
  policyName: string(name='PolicyName'),
  principalType: string(name='PrincipalType'),
  principalName: string(name='PrincipalName'),
}

model AttachPolicyResponse = {
  requestId: string(name='RequestId'),
}

async function attachPolicyWithOptions(request: AttachPolicyRequest, runtime: Util.RuntimeOptions): AttachPolicyResponse {
  Util.validateModel(request);
  return doRequest('AttachPolicy', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function attachPolicy(request: AttachPolicyRequest): AttachPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachPolicyWithOptions(request, runtime);
}

model GetPolicyVersionRequest = {
  policyType: string(name='PolicyType'),
  policyName: string(name='PolicyName'),
  versionId: string(name='VersionId'),
}

model GetPolicyVersionResponse = {
  requestId: string(name='RequestId'),
  policyVersion: {
    versionId: string(name='VersionId'),
    isDefaultVersion: boolean(name='IsDefaultVersion'),
    policyDocument: string(name='PolicyDocument'),
    createDate: string(name='CreateDate'),
  }(name='PolicyVersion'),
}

async function getPolicyVersionWithOptions(request: GetPolicyVersionRequest, runtime: Util.RuntimeOptions): GetPolicyVersionResponse {
  Util.validateModel(request);
  return doRequest('GetPolicyVersion', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function getPolicyVersion(request: GetPolicyVersionRequest): GetPolicyVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPolicyVersionWithOptions(request, runtime);
}

model SetDefaultPolicyVersionRequest = {
  policyName: string(name='PolicyName'),
  versionId: string(name='VersionId'),
}

model SetDefaultPolicyVersionResponse = {
  requestId: string(name='RequestId'),
}

async function setDefaultPolicyVersionWithOptions(request: SetDefaultPolicyVersionRequest, runtime: Util.RuntimeOptions): SetDefaultPolicyVersionResponse {
  Util.validateModel(request);
  return doRequest('SetDefaultPolicyVersion', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function setDefaultPolicyVersion(request: SetDefaultPolicyVersionRequest): SetDefaultPolicyVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDefaultPolicyVersionWithOptions(request, runtime);
}

model DeleteResourceGroupRequest = {
  resourceGroupId: string(name='ResourceGroupId'),
}

model DeleteResourceGroupResponse = {
  requestId: string(name='RequestId'),
  resourceGroup: {
    status: string(name='Status'),
    accountId: string(name='AccountId'),
    displayName: string(name='DisplayName'),
    id: string(name='Id'),
    createDate: string(name='CreateDate'),
    name: string(name='Name'),
    regionStatuses: {
      regionStatus: [
        {
          status: string(name='Status'),
          regionId: string(name='RegionId'),
        }
      ](name='RegionStatus'),
    }(name='RegionStatuses'),
  }(name='ResourceGroup'),
}

async function deleteResourceGroupWithOptions(request: DeleteResourceGroupRequest, runtime: Util.RuntimeOptions): DeleteResourceGroupResponse {
  Util.validateModel(request);
  return doRequest('DeleteResourceGroup', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function deleteResourceGroup(request: DeleteResourceGroupRequest): DeleteResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteResourceGroupWithOptions(request, runtime);
}

model GetPolicyRequest = {
  policyName: string(name='PolicyName'),
  policyType: string(name='PolicyType'),
  language?: string(name='Language'),
}

model GetPolicyResponse = {
  requestId: string(name='RequestId'),
  policy: {
    policyType: string(name='PolicyType'),
    updateDate: string(name='UpdateDate'),
    description: string(name='Description'),
    attachmentCount: integer(name='AttachmentCount'),
    policyName: string(name='PolicyName'),
    defaultVersion: string(name='DefaultVersion'),
    policyDocument: string(name='PolicyDocument'),
    createDate: string(name='CreateDate'),
  }(name='Policy'),
}

async function getPolicyWithOptions(request: GetPolicyRequest, runtime: Util.RuntimeOptions): GetPolicyResponse {
  Util.validateModel(request);
  return doRequest('GetPolicy', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function getPolicy(request: GetPolicyRequest): GetPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPolicyWithOptions(request, runtime);
}

model UpdateResourceGroupRequest = {
  resourceGroupId: string(name='ResourceGroupId'),
  newDisplayName: string(name='NewDisplayName'),
}

model UpdateResourceGroupResponse = {
  requestId: string(name='RequestId'),
  resourceGroup: {
    accountId: string(name='AccountId'),
    displayName: string(name='DisplayName'),
    id: string(name='Id'),
    createDate: string(name='CreateDate'),
    name: string(name='Name'),
  }(name='ResourceGroup'),
}

async function updateResourceGroupWithOptions(request: UpdateResourceGroupRequest, runtime: Util.RuntimeOptions): UpdateResourceGroupResponse {
  Util.validateModel(request);
  return doRequest('UpdateResourceGroup', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function updateResourceGroup(request: UpdateResourceGroupRequest): UpdateResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateResourceGroupWithOptions(request, runtime);
}

model ListResourceGroupsRequest = {
  status?: string(name='Status'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model ListResourceGroupsResponse = {
  totalCount: integer(name='TotalCount'),
  pageSize: integer(name='PageSize'),
  requestId: string(name='RequestId'),
  pageNumber: integer(name='PageNumber'),
  resourceGroups: {
    resourceGroup: [
      {
        status: string(name='Status'),
        accountId: string(name='AccountId'),
        displayName: string(name='DisplayName'),
        id: string(name='Id'),
        createDate: string(name='CreateDate'),
        name: string(name='Name'),
      }
    ](name='ResourceGroup'),
  }(name='ResourceGroups'),
}

async function listResourceGroupsWithOptions(request: ListResourceGroupsRequest, runtime: Util.RuntimeOptions): ListResourceGroupsResponse {
  Util.validateModel(request);
  return doRequest('ListResourceGroups', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function listResourceGroups(request: ListResourceGroupsRequest): ListResourceGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listResourceGroupsWithOptions(request, runtime);
}

model ListPoliciesRequest = {
  policyType?: string(name='PolicyType'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  language?: string(name='Language'),
}

model ListPoliciesResponse = {
  totalCount: integer(name='TotalCount'),
  pageSize: integer(name='PageSize'),
  requestId: string(name='RequestId'),
  pageNumber: integer(name='PageNumber'),
  policies: {
    policy: [
      {
        policyType: string(name='PolicyType'),
        updateDate: string(name='UpdateDate'),
        description: string(name='Description'),
        attachmentCount: integer(name='AttachmentCount'),
        policyName: string(name='PolicyName'),
        defaultVersion: string(name='DefaultVersion'),
        createDate: string(name='CreateDate'),
      }
    ](name='Policy'),
  }(name='Policies'),
}

async function listPoliciesWithOptions(request: ListPoliciesRequest, runtime: Util.RuntimeOptions): ListPoliciesResponse {
  Util.validateModel(request);
  return doRequest('ListPolicies', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function listPolicies(request: ListPoliciesRequest): ListPoliciesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPoliciesWithOptions(request, runtime);
}

model ListPolicyVersionsRequest = {
  policyType: string(name='PolicyType'),
  policyName: string(name='PolicyName'),
}

model ListPolicyVersionsResponse = {
  requestId: string(name='RequestId'),
  policyVersions: {
    policyVersion: [
      {
        versionId: string(name='VersionId'),
        isDefaultVersion: boolean(name='IsDefaultVersion'),
        createDate: string(name='CreateDate'),
      }
    ](name='PolicyVersion'),
  }(name='PolicyVersions'),
}

async function listPolicyVersionsWithOptions(request: ListPolicyVersionsRequest, runtime: Util.RuntimeOptions): ListPolicyVersionsResponse {
  Util.validateModel(request);
  return doRequest('ListPolicyVersions', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function listPolicyVersions(request: ListPolicyVersionsRequest): ListPolicyVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPolicyVersionsWithOptions(request, runtime);
}

model CreateResourceAccountRequest = {
  displayName: string(name='DisplayName'),
  parentFolderId?: string(name='ParentFolderId'),
  payerAccountId?: string(name='PayerAccountId'),
  accountNamePrefix?: string(name='AccountNamePrefix'),
}

model CreateResourceAccountResponse = {
  requestId: string(name='RequestId'),
  account: {
    status: string(name='Status'),
    modifyTime: string(name='ModifyTime'),
    joinMethod: string(name='JoinMethod'),
    resourceDirectoryId: string(name='ResourceDirectoryId'),
    type: string(name='Type'),
    accountId: string(name='AccountId'),
    displayName: string(name='DisplayName'),
    joinTime: string(name='JoinTime'),
    folderId: string(name='FolderId'),
    accountName: string(name='AccountName'),
  }(name='Account'),
}

async function createResourceAccountWithOptions(request: CreateResourceAccountRequest, runtime: Util.RuntimeOptions): CreateResourceAccountResponse {
  Util.validateModel(request);
  return doRequest('CreateResourceAccount', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function createResourceAccount(request: CreateResourceAccountRequest): CreateResourceAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return createResourceAccountWithOptions(request, runtime);
}

model ListHandshakesForResourceDirectoryRequest = {
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model ListHandshakesForResourceDirectoryResponse = {
  totalCount: integer(name='TotalCount'),
  pageSize: integer(name='PageSize'),
  requestId: string(name='RequestId'),
  pageNumber: integer(name='PageNumber'),
  handshakes: {
    handshake: [
      {
        status: string(name='Status'),
        modifyTime: string(name='ModifyTime'),
        resourceDirectoryId: string(name='ResourceDirectoryId'),
        handshakeId: string(name='HandshakeId'),
        masterAccountName: string(name='MasterAccountName'),
        note: string(name='Note'),
        createTime: string(name='CreateTime'),
        targetType: string(name='TargetType'),
        masterAccountId: string(name='MasterAccountId'),
        expireTime: string(name='ExpireTime'),
        targetEntity: string(name='TargetEntity'),
      }
    ](name='Handshake'),
  }(name='Handshakes'),
}

async function listHandshakesForResourceDirectoryWithOptions(request: ListHandshakesForResourceDirectoryRequest, runtime: Util.RuntimeOptions): ListHandshakesForResourceDirectoryResponse {
  Util.validateModel(request);
  return doRequest('ListHandshakesForResourceDirectory', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function listHandshakesForResourceDirectory(request: ListHandshakesForResourceDirectoryRequest): ListHandshakesForResourceDirectoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHandshakesForResourceDirectoryWithOptions(request, runtime);
}

model DestroyResourceDirectoryRequest = {
}

model DestroyResourceDirectoryResponse = {
  requestId: string(name='RequestId'),
}

async function destroyResourceDirectoryWithOptions(request: DestroyResourceDirectoryRequest, runtime: Util.RuntimeOptions): DestroyResourceDirectoryResponse {
  Util.validateModel(request);
  return doRequest('DestroyResourceDirectory', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function destroyResourceDirectory(request: DestroyResourceDirectoryRequest): DestroyResourceDirectoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return destroyResourceDirectoryWithOptions(request, runtime);
}

model CreatePolicyVersionRequest = {
  policyName: string(name='PolicyName'),
  policyDocument: string(name='PolicyDocument'),
  setAsDefault?: boolean(name='SetAsDefault'),
}

model CreatePolicyVersionResponse = {
  requestId: string(name='RequestId'),
  policyVersion: {
    versionId: string(name='VersionId'),
    isDefaultVersion: boolean(name='IsDefaultVersion'),
    createDate: string(name='CreateDate'),
  }(name='PolicyVersion'),
}

async function createPolicyVersionWithOptions(request: CreatePolicyVersionRequest, runtime: Util.RuntimeOptions): CreatePolicyVersionResponse {
  Util.validateModel(request);
  return doRequest('CreatePolicyVersion', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function createPolicyVersion(request: CreatePolicyVersionRequest): CreatePolicyVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPolicyVersionWithOptions(request, runtime);
}

model DeletePolicyVersionRequest = {
  policyName: string(name='PolicyName'),
  versionId: string(name='VersionId'),
}

model DeletePolicyVersionResponse = {
  requestId: string(name='RequestId'),
}

async function deletePolicyVersionWithOptions(request: DeletePolicyVersionRequest, runtime: Util.RuntimeOptions): DeletePolicyVersionResponse {
  Util.validateModel(request);
  return doRequest('DeletePolicyVersion', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function deletePolicyVersion(request: DeletePolicyVersionRequest): DeletePolicyVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePolicyVersionWithOptions(request, runtime);
}

model GetResourceGroupRequest = {
  resourceGroupId: string(name='ResourceGroupId'),
}

model GetResourceGroupResponse = {
  requestId: string(name='RequestId'),
  resourceGroup: {
    status: string(name='Status'),
    accountId: string(name='AccountId'),
    displayName: string(name='DisplayName'),
    id: string(name='Id'),
    createDate: string(name='CreateDate'),
    name: string(name='Name'),
    regionStatuses: {
      regionStatus: [
        {
          status: string(name='Status'),
          regionId: string(name='RegionId'),
        }
      ](name='RegionStatus'),
    }(name='RegionStatuses'),
  }(name='ResourceGroup'),
}

async function getResourceGroupWithOptions(request: GetResourceGroupRequest, runtime: Util.RuntimeOptions): GetResourceGroupResponse {
  Util.validateModel(request);
  return doRequest('GetResourceGroup', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function getResourceGroup(request: GetResourceGroupRequest): GetResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return getResourceGroupWithOptions(request, runtime);
}

model InitResourceDirectoryRequest = {
}

model InitResourceDirectoryResponse = {
  requestId: string(name='RequestId'),
  resourceDirectory: {
    resourceDirectoryId: string(name='ResourceDirectoryId'),
    masterAccountId: string(name='MasterAccountId'),
    masterAccountName: string(name='MasterAccountName'),
    rootFolderId: string(name='RootFolderId'),
    createTime: string(name='CreateTime'),
  }(name='ResourceDirectory'),
}

async function initResourceDirectoryWithOptions(request: InitResourceDirectoryRequest, runtime: Util.RuntimeOptions): InitResourceDirectoryResponse {
  Util.validateModel(request);
  return doRequest('InitResourceDirectory', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function initResourceDirectory(request: InitResourceDirectoryRequest): InitResourceDirectoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return initResourceDirectoryWithOptions(request, runtime);
}

model GetHandshakeRequest = {
  handshakeId: string(name='HandshakeId'),
}

model GetHandshakeResponse = {
  requestId: string(name='RequestId'),
  handshake: {
    status: string(name='Status'),
    modifyTime: string(name='ModifyTime'),
    resourceDirectoryId: string(name='ResourceDirectoryId'),
    handshakeId: string(name='HandshakeId'),
    masterAccountName: string(name='MasterAccountName'),
    note: string(name='Note'),
    createTime: string(name='CreateTime'),
    targetType: string(name='TargetType'),
    masterAccountId: string(name='MasterAccountId'),
    masterAccountRealName: string(name='MasterAccountRealName'),
    expireTime: string(name='ExpireTime'),
    invitedAccountRealName: string(name='InvitedAccountRealName'),
    targetEntity: string(name='TargetEntity'),
  }(name='Handshake'),
}

async function getHandshakeWithOptions(request: GetHandshakeRequest, runtime: Util.RuntimeOptions): GetHandshakeResponse {
  Util.validateModel(request);
  return doRequest('GetHandshake', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function getHandshake(request: GetHandshakeRequest): GetHandshakeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getHandshakeWithOptions(request, runtime);
}

model CancelHandshakeRequest = {
  handshakeId: string(name='HandshakeId'),
}

model CancelHandshakeResponse = {
  requestId: string(name='RequestId'),
  handshake: {
    handshakeId: string(name='HandshakeId'),
    resourceDirectoryId: string(name='ResourceDirectoryId'),
    masterAccountId: string(name='MasterAccountId'),
    masterAccountName: string(name='MasterAccountName'),
    targetEntity: string(name='TargetEntity'),
    targetType: string(name='TargetType'),
    note: string(name='Note'),
    status: string(name='Status'),
    createTime: string(name='CreateTime'),
    modifyTime: string(name='ModifyTime'),
    expireTime: string(name='ExpireTime'),
  }(name='Handshake'),
}

async function cancelHandshakeWithOptions(request: CancelHandshakeRequest, runtime: Util.RuntimeOptions): CancelHandshakeResponse {
  Util.validateModel(request);
  return doRequest('CancelHandshake', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function cancelHandshake(request: CancelHandshakeRequest): CancelHandshakeResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelHandshakeWithOptions(request, runtime);
}

model CreatePolicyRequest = {
  policyName: string(name='PolicyName'),
  description?: string(name='Description'),
  policyDocument: string(name='PolicyDocument'),
}

model CreatePolicyResponse = {
  requestId: string(name='RequestId'),
  policy: {
    policyType: string(name='PolicyType'),
    description: string(name='Description'),
    policyName: string(name='PolicyName'),
    defaultVersion: string(name='DefaultVersion'),
    createDate: string(name='CreateDate'),
  }(name='Policy'),
}

async function createPolicyWithOptions(request: CreatePolicyRequest, runtime: Util.RuntimeOptions): CreatePolicyResponse {
  Util.validateModel(request);
  return doRequest('CreatePolicy', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function createPolicy(request: CreatePolicyRequest): CreatePolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPolicyWithOptions(request, runtime);
}

model DeclineHandshakeRequest = {
  handshakeId: string(name='HandshakeId'),
}

model DeclineHandshakeResponse = {
  requestId: string(name='RequestId'),
  handshake: {
    handshakeId: string(name='HandshakeId'),
    resourceDirectoryId: string(name='ResourceDirectoryId'),
    masterAccountId: string(name='MasterAccountId'),
    masterAccountName: string(name='MasterAccountName'),
    targetEntity: string(name='TargetEntity'),
    targetType: string(name='TargetType'),
    note: string(name='Note'),
    status: string(name='Status'),
    createTime: string(name='CreateTime'),
    modifyTime: string(name='ModifyTime'),
    expireTime: string(name='ExpireTime'),
  }(name='Handshake'),
}

async function declineHandshakeWithOptions(request: DeclineHandshakeRequest, runtime: Util.RuntimeOptions): DeclineHandshakeResponse {
  Util.validateModel(request);
  return doRequest('DeclineHandshake', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function declineHandshake(request: DeclineHandshakeRequest): DeclineHandshakeResponse {
  var runtime = new Util.RuntimeOptions{};
  return declineHandshakeWithOptions(request, runtime);
}

model DeletePolicyRequest = {
  policyName: string(name='PolicyName'),
}

model DeletePolicyResponse = {
  requestId: string(name='RequestId'),
}

async function deletePolicyWithOptions(request: DeletePolicyRequest, runtime: Util.RuntimeOptions): DeletePolicyResponse {
  Util.validateModel(request);
  return doRequest('DeletePolicy', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function deletePolicy(request: DeletePolicyRequest): DeletePolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePolicyWithOptions(request, runtime);
}

model ListHandshakesForAccountRequest = {
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model ListHandshakesForAccountResponse = {
  totalCount: integer(name='TotalCount'),
  pageSize: integer(name='PageSize'),
  requestId: string(name='RequestId'),
  pageNumber: integer(name='PageNumber'),
  handshakes: {
    handshake: [
      {
        status: string(name='Status'),
        modifyTime: string(name='ModifyTime'),
        resourceDirectoryId: string(name='ResourceDirectoryId'),
        handshakeId: string(name='HandshakeId'),
        masterAccountName: string(name='MasterAccountName'),
        note: string(name='Note'),
        createTime: string(name='CreateTime'),
        targetType: string(name='TargetType'),
        masterAccountId: string(name='MasterAccountId'),
        expireTime: string(name='ExpireTime'),
        targetEntity: string(name='TargetEntity'),
      }
    ](name='Handshake'),
  }(name='Handshakes'),
}

async function listHandshakesForAccountWithOptions(request: ListHandshakesForAccountRequest, runtime: Util.RuntimeOptions): ListHandshakesForAccountResponse {
  Util.validateModel(request);
  return doRequest('ListHandshakesForAccount', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function listHandshakesForAccount(request: ListHandshakesForAccountRequest): ListHandshakesForAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHandshakesForAccountWithOptions(request, runtime);
}

model InviteAccountToResourceDirectoryRequest = {
  targetEntity: string(name='TargetEntity'),
  targetType: string(name='TargetType'),
  note?: string(name='Note'),
}

model InviteAccountToResourceDirectoryResponse = {
  requestId: string(name='RequestId'),
  handshake: {
    status: string(name='Status'),
    modifyTime: string(name='ModifyTime'),
    resourceDirectoryId: string(name='ResourceDirectoryId'),
    handshakeId: string(name='HandshakeId'),
    masterAccountName: string(name='MasterAccountName'),
    note: string(name='Note'),
    createTime: string(name='CreateTime'),
    targetType: string(name='TargetType'),
    masterAccountId: string(name='MasterAccountId'),
    expireTime: string(name='ExpireTime'),
    targetEntity: string(name='TargetEntity'),
  }(name='Handshake'),
}

async function inviteAccountToResourceDirectoryWithOptions(request: InviteAccountToResourceDirectoryRequest, runtime: Util.RuntimeOptions): InviteAccountToResourceDirectoryResponse {
  Util.validateModel(request);
  return doRequest('InviteAccountToResourceDirectory', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function inviteAccountToResourceDirectory(request: InviteAccountToResourceDirectoryRequest): InviteAccountToResourceDirectoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return inviteAccountToResourceDirectoryWithOptions(request, runtime);
}

model AcceptHandshakeRequest = {
  handshakeId: string(name='HandshakeId'),
}

model AcceptHandshakeResponse = {
  requestId: string(name='RequestId'),
  handshake: {
    handshakeId: string(name='HandshakeId'),
    resourceDirectoryId: string(name='ResourceDirectoryId'),
    masterAccountId: string(name='MasterAccountId'),
    masterAccountName: string(name='MasterAccountName'),
    targetEntity: string(name='TargetEntity'),
    targetType: string(name='TargetType'),
    note: string(name='Note'),
    status: string(name='Status'),
    createTime: string(name='CreateTime'),
    modifyTime: string(name='ModifyTime'),
    expireTime: string(name='ExpireTime'),
  }(name='Handshake'),
}

async function acceptHandshakeWithOptions(request: AcceptHandshakeRequest, runtime: Util.RuntimeOptions): AcceptHandshakeResponse {
  Util.validateModel(request);
  return doRequest('AcceptHandshake', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function acceptHandshake(request: AcceptHandshakeRequest): AcceptHandshakeResponse {
  var runtime = new Util.RuntimeOptions{};
  return acceptHandshakeWithOptions(request, runtime);
}

model UpdateAccountRequest = {
  newDisplayName: string(name='NewDisplayName'),
  accountId: string(name='AccountId'),
}

model UpdateAccountResponse = {
  requestId: string(name='RequestId'),
  account: {
    status: string(name='Status'),
    modifyTime: string(name='ModifyTime'),
    joinMethod: string(name='JoinMethod'),
    resourceDirectoryId: string(name='ResourceDirectoryId'),
    type: string(name='Type'),
    accountId: string(name='AccountId'),
    displayName: string(name='DisplayName'),
    joinTime: string(name='JoinTime'),
    folderId: string(name='FolderId'),
    accountName: string(name='AccountName'),
  }(name='Account'),
}

async function updateAccountWithOptions(request: UpdateAccountRequest, runtime: Util.RuntimeOptions): UpdateAccountResponse {
  Util.validateModel(request);
  return doRequest('UpdateAccount', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function updateAccount(request: UpdateAccountRequest): UpdateAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAccountWithOptions(request, runtime);
}

model GetFolderRequest = {
  folderId: string(name='FolderId'),
}

model GetFolderResponse = {
  requestId: string(name='RequestId'),
  folder: {
    createTime: string(name='CreateTime'),
    folderId: string(name='FolderId'),
    folderName: string(name='FolderName'),
    parentFolderId: string(name='ParentFolderId'),
  }(name='Folder'),
}

async function getFolderWithOptions(request: GetFolderRequest, runtime: Util.RuntimeOptions): GetFolderResponse {
  Util.validateModel(request);
  return doRequest('GetFolder', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function getFolder(request: GetFolderRequest): GetFolderResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFolderWithOptions(request, runtime);
}

model ListAccountsForParentRequest = {
  parentFolderId?: string(name='ParentFolderId'),
  queryKeyword?: string(name='QueryKeyword'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model ListAccountsForParentResponse = {
  totalCount: integer(name='TotalCount'),
  pageSize: integer(name='PageSize'),
  requestId: string(name='RequestId'),
  pageNumber: integer(name='PageNumber'),
  accounts: {
    account: [
      {
        status: string(name='Status'),
        modifyTime: string(name='ModifyTime'),
        joinMethod: string(name='JoinMethod'),
        resourceDirectoryId: string(name='ResourceDirectoryId'),
        type: string(name='Type'),
        accountId: string(name='AccountId'),
        displayName: string(name='DisplayName'),
        joinTime: string(name='JoinTime'),
        folderId: string(name='FolderId'),
      }
    ](name='Account'),
  }(name='Accounts'),
}

async function listAccountsForParentWithOptions(request: ListAccountsForParentRequest, runtime: Util.RuntimeOptions): ListAccountsForParentResponse {
  Util.validateModel(request);
  return doRequest('ListAccountsForParent', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function listAccountsForParent(request: ListAccountsForParentRequest): ListAccountsForParentResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAccountsForParentWithOptions(request, runtime);
}

model CreateResourceGroupRequest = {
  name: string(name='Name'),
  displayName: string(name='DisplayName'),
}

model CreateResourceGroupResponse = {
  requestId: string(name='RequestId'),
  resourceGroup: {
    status: string(name='Status'),
    accountId: string(name='AccountId'),
    displayName: string(name='DisplayName'),
    id: string(name='Id'),
    createDate: string(name='CreateDate'),
    name: string(name='Name'),
    regionStatuses: {
      regionStatus: [
        {
          status: string(name='Status'),
          regionId: string(name='RegionId'),
        }
      ](name='RegionStatus'),
    }(name='RegionStatuses'),
  }(name='ResourceGroup'),
}

async function createResourceGroupWithOptions(request: CreateResourceGroupRequest, runtime: Util.RuntimeOptions): CreateResourceGroupResponse {
  Util.validateModel(request);
  return doRequest('CreateResourceGroup', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function createResourceGroup(request: CreateResourceGroupRequest): CreateResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createResourceGroupWithOptions(request, runtime);
}

model PromoteResourceAccountRequest = {
  accountId: string(name='AccountId'),
  email: string(name='Email'),
}

model PromoteResourceAccountResponse = {
  requestId: string(name='RequestId'),
  account: {
    resourceDirectoryId: string(name='ResourceDirectoryId'),
    accountId: string(name='AccountId'),
    displayName: string(name='DisplayName'),
    folderId: string(name='FolderId'),
    joinMethod: string(name='JoinMethod'),
    joinTime: string(name='JoinTime'),
    type: string(name='Type'),
    status: string(name='Status'),
    recordId: string(name='RecordId'),
    modifyTime: string(name='ModifyTime'),
    accountName: string(name='AccountName'),
  }(name='Account'),
}

async function promoteResourceAccountWithOptions(request: PromoteResourceAccountRequest, runtime: Util.RuntimeOptions): PromoteResourceAccountResponse {
  Util.validateModel(request);
  return doRequest('PromoteResourceAccount', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function promoteResourceAccount(request: PromoteResourceAccountRequest): PromoteResourceAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return promoteResourceAccountWithOptions(request, runtime);
}

model ListAccountsRequest = {
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model ListAccountsResponse = {
  totalCount: integer(name='TotalCount'),
  pageSize: integer(name='PageSize'),
  requestId: string(name='RequestId'),
  pageNumber: integer(name='PageNumber'),
  accounts: {
    account: [
      {
        status: string(name='Status'),
        modifyTime: string(name='ModifyTime'),
        joinMethod: string(name='JoinMethod'),
        resourceDirectoryId: string(name='ResourceDirectoryId'),
        type: string(name='Type'),
        accountId: string(name='AccountId'),
        displayName: string(name='DisplayName'),
        joinTime: string(name='JoinTime'),
        folderId: string(name='FolderId'),
      }
    ](name='Account'),
  }(name='Accounts'),
}

async function listAccountsWithOptions(request: ListAccountsRequest, runtime: Util.RuntimeOptions): ListAccountsResponse {
  Util.validateModel(request);
  return doRequest('ListAccounts', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function listAccounts(request: ListAccountsRequest): ListAccountsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAccountsWithOptions(request, runtime);
}

model CancelPromoteResourceAccountRequest = {
  recordId: string(name='RecordId'),
}

model CancelPromoteResourceAccountResponse = {
  requestId: string(name='RequestId'),
}

async function cancelPromoteResourceAccountWithOptions(request: CancelPromoteResourceAccountRequest, runtime: Util.RuntimeOptions): CancelPromoteResourceAccountResponse {
  Util.validateModel(request);
  return doRequest('CancelPromoteResourceAccount', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function cancelPromoteResourceAccount(request: CancelPromoteResourceAccountRequest): CancelPromoteResourceAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelPromoteResourceAccountWithOptions(request, runtime);
}

model CreateFolderRequest = {
  parentFolderId?: string(name='ParentFolderId'),
  folderName: string(name='FolderName'),
}

model CreateFolderResponse = {
  requestId: string(name='RequestId'),
  folder: {
    folderId: string(name='FolderId'),
    parentFolderId: string(name='ParentFolderId'),
    folderName: string(name='FolderName'),
    createTime: string(name='CreateTime'),
  }(name='Folder'),
}

async function createFolderWithOptions(request: CreateFolderRequest, runtime: Util.RuntimeOptions): CreateFolderResponse {
  Util.validateModel(request);
  return doRequest('CreateFolder', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function createFolder(request: CreateFolderRequest): CreateFolderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFolderWithOptions(request, runtime);
}

model DeleteFolderRequest = {
  folderId: string(name='FolderId'),
}

model DeleteFolderResponse = {
  requestId: string(name='RequestId'),
}

async function deleteFolderWithOptions(request: DeleteFolderRequest, runtime: Util.RuntimeOptions): DeleteFolderResponse {
  Util.validateModel(request);
  return doRequest('DeleteFolder', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function deleteFolder(request: DeleteFolderRequest): DeleteFolderResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFolderWithOptions(request, runtime);
}

model GetAccountRequest = {
  accountId: string(name='AccountId'),
}

model GetAccountResponse = {
  requestId: string(name='RequestId'),
  account: {
    identityInformation: string(name='IdentityInformation'),
    status: string(name='Status'),
    modifyTime: string(name='ModifyTime'),
    joinMethod: string(name='JoinMethod'),
    resourceDirectoryId: string(name='ResourceDirectoryId'),
    type: string(name='Type'),
    accountId: string(name='AccountId'),
    displayName: string(name='DisplayName'),
    joinTime: string(name='JoinTime'),
    folderId: string(name='FolderId'),
    accountName: string(name='AccountName'),
  }(name='Account'),
}

async function getAccountWithOptions(request: GetAccountRequest, runtime: Util.RuntimeOptions): GetAccountResponse {
  Util.validateModel(request);
  return doRequest('GetAccount', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function getAccount(request: GetAccountRequest): GetAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAccountWithOptions(request, runtime);
}

model GetResourceDirectoryRequest = {
}

model GetResourceDirectoryResponse = {
  requestId: string(name='RequestId'),
  resourceDirectory: {
    resourceDirectoryId: string(name='ResourceDirectoryId'),
    masterAccountName: string(name='MasterAccountName'),
    createTime: string(name='CreateTime'),
    rootFolderId: string(name='RootFolderId'),
    masterAccountId: string(name='MasterAccountId'),
  }(name='ResourceDirectory'),
}

async function getResourceDirectoryWithOptions(request: GetResourceDirectoryRequest, runtime: Util.RuntimeOptions): GetResourceDirectoryResponse {
  Util.validateModel(request);
  return doRequest('GetResourceDirectory', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function getResourceDirectory(request: GetResourceDirectoryRequest): GetResourceDirectoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getResourceDirectoryWithOptions(request, runtime);
}

model UpdateFolderRequest = {
  folderId: string(name='FolderId'),
  newFolderName: string(name='NewFolderName'),
}

model UpdateFolderResponse = {
  requestId: string(name='RequestId'),
  folder: {
    createTime: string(name='CreateTime'),
    folderId: string(name='FolderId'),
    folderName: string(name='FolderName'),
    parentFolderId: string(name='ParentFolderId'),
  }(name='Folder'),
}

async function updateFolderWithOptions(request: UpdateFolderRequest, runtime: Util.RuntimeOptions): UpdateFolderResponse {
  Util.validateModel(request);
  return doRequest('UpdateFolder', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function updateFolder(request: UpdateFolderRequest): UpdateFolderResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateFolderWithOptions(request, runtime);
}

model MoveAccountRequest = {
  accountId: string(name='AccountId'),
  destinationFolderId: string(name='DestinationFolderId'),
}

model MoveAccountResponse = {
  requestId: string(name='RequestId'),
}

async function moveAccountWithOptions(request: MoveAccountRequest, runtime: Util.RuntimeOptions): MoveAccountResponse {
  Util.validateModel(request);
  return doRequest('MoveAccount', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function moveAccount(request: MoveAccountRequest): MoveAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return moveAccountWithOptions(request, runtime);
}

model ListAncestorsRequest = {
  childId: string(name='ChildId'),
}

model ListAncestorsResponse = {
  requestId: string(name='RequestId'),
  folders: {
    folder: [
      {
        createTime: string(name='CreateTime'),
        folderId: string(name='FolderId'),
        folderName: string(name='FolderName'),
      }
    ](name='Folder'),
  }(name='Folders'),
}

async function listAncestorsWithOptions(request: ListAncestorsRequest, runtime: Util.RuntimeOptions): ListAncestorsResponse {
  Util.validateModel(request);
  return doRequest('ListAncestors', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function listAncestors(request: ListAncestorsRequest): ListAncestorsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAncestorsWithOptions(request, runtime);
}

model ResendCreateCloudAccountEmailRequest = {
  recordId: string(name='RecordId'),
}

model ResendCreateCloudAccountEmailResponse = {
  requestId: string(name='RequestId'),
  account: {
    resourceDirectoryId: string(name='ResourceDirectoryId'),
    accountId: string(name='AccountId'),
    displayName: string(name='DisplayName'),
    folderId: string(name='FolderId'),
    joinMethod: string(name='JoinMethod'),
    joinTime: string(name='JoinTime'),
    type: string(name='Type'),
    status: string(name='Status'),
    recordId: string(name='RecordId'),
    modifyTime: string(name='ModifyTime'),
    accountName: string(name='AccountName'),
  }(name='Account'),
}

async function resendCreateCloudAccountEmailWithOptions(request: ResendCreateCloudAccountEmailRequest, runtime: Util.RuntimeOptions): ResendCreateCloudAccountEmailResponse {
  Util.validateModel(request);
  return doRequest('ResendCreateCloudAccountEmail', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function resendCreateCloudAccountEmail(request: ResendCreateCloudAccountEmailRequest): ResendCreateCloudAccountEmailResponse {
  var runtime = new Util.RuntimeOptions{};
  return resendCreateCloudAccountEmailWithOptions(request, runtime);
}

model GetPayerForAccountRequest = {
  accountId: string(name='AccountId'),
}

model GetPayerForAccountResponse = {
  payerAccountName: string(name='PayerAccountName'),
  requestId: string(name='RequestId'),
  payerAccountId: string(name='PayerAccountId'),
}

async function getPayerForAccountWithOptions(request: GetPayerForAccountRequest, runtime: Util.RuntimeOptions): GetPayerForAccountResponse {
  Util.validateModel(request);
  return doRequest('GetPayerForAccount', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function getPayerForAccount(request: GetPayerForAccountRequest): GetPayerForAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPayerForAccountWithOptions(request, runtime);
}

model ResendPromoteResourceAccountEmailRequest = {
  recordId: string(name='RecordId'),
}

model ResendPromoteResourceAccountEmailResponse = {
  requestId: string(name='RequestId'),
  account: {
    resourceDirectoryId: string(name='ResourceDirectoryId'),
    accountId: string(name='AccountId'),
    displayName: string(name='DisplayName'),
    folderId: string(name='FolderId'),
    joinMethod: string(name='JoinMethod'),
    joinTime: string(name='JoinTime'),
    type: string(name='Type'),
    status: string(name='Status'),
    recordId: string(name='RecordId'),
    modifyTime: string(name='ModifyTime'),
    accountName: string(name='AccountName'),
  }(name='Account'),
}

async function resendPromoteResourceAccountEmailWithOptions(request: ResendPromoteResourceAccountEmailRequest, runtime: Util.RuntimeOptions): ResendPromoteResourceAccountEmailResponse {
  Util.validateModel(request);
  return doRequest('ResendPromoteResourceAccountEmail', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function resendPromoteResourceAccountEmail(request: ResendPromoteResourceAccountEmailRequest): ResendPromoteResourceAccountEmailResponse {
  var runtime = new Util.RuntimeOptions{};
  return resendPromoteResourceAccountEmailWithOptions(request, runtime);
}

model ListFoldersForParentRequest = {
  parentFolderId?: string(name='ParentFolderId'),
  queryKeyword?: string(name='QueryKeyword'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model ListFoldersForParentResponse = {
  totalCount: integer(name='TotalCount'),
  pageSize: integer(name='PageSize'),
  requestId: string(name='RequestId'),
  pageNumber: integer(name='PageNumber'),
  folders: {
    folder: [
      {
        createTime: string(name='CreateTime'),
        folderId: string(name='FolderId'),
        folderName: string(name='FolderName'),
      }
    ](name='Folder'),
  }(name='Folders'),
}

async function listFoldersForParentWithOptions(request: ListFoldersForParentRequest, runtime: Util.RuntimeOptions): ListFoldersForParentResponse {
  Util.validateModel(request);
  return doRequest('ListFoldersForParent', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function listFoldersForParent(request: ListFoldersForParentRequest): ListFoldersForParentResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFoldersForParentWithOptions(request, runtime);
}

model RemoveCloudAccountRequest = {
  accountId: string(name='AccountId'),
}

model RemoveCloudAccountResponse = {
  requestId: string(name='RequestId'),
}

async function removeCloudAccountWithOptions(request: RemoveCloudAccountRequest, runtime: Util.RuntimeOptions): RemoveCloudAccountResponse {
  Util.validateModel(request);
  return doRequest('RemoveCloudAccount', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function removeCloudAccount(request: RemoveCloudAccountRequest): RemoveCloudAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeCloudAccountWithOptions(request, runtime);
}

model CancelCreateCloudAccountRequest = {
  recordId: string(name='RecordId'),
}

model CancelCreateCloudAccountResponse = {
  requestId: string(name='RequestId'),
}

async function cancelCreateCloudAccountWithOptions(request: CancelCreateCloudAccountRequest, runtime: Util.RuntimeOptions): CancelCreateCloudAccountResponse {
  Util.validateModel(request);
  return doRequest('CancelCreateCloudAccount', 'HTTPS', 'POST', '2020-03-31', 'AK', null, request, runtime);
}

async function cancelCreateCloudAccount(request: CancelCreateCloudAccountRequest): CancelCreateCloudAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelCreateCloudAccountWithOptions(request, runtime);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
