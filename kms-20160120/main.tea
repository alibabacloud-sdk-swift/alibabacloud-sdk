import Util;
import RPC;
import EndpointUtil;

extends RPC;

init(config: RPC.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('kms', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

model GenerateAndExportDataKeyRequest = {
  keyId: string(name='KeyId'),
  keySpec?: string(name='KeySpec'),
  numberOfBytes?: integer(name='NumberOfBytes'),
  encryptionContext?: map[string]any(name='EncryptionContext'),
  publicKeyBlob: string(name='PublicKeyBlob'),
  wrappingKeySpec: string(name='WrappingKeySpec'),
  wrappingAlgorithm: string(name='WrappingAlgorithm'),
}

model GenerateAndExportDataKeyResponse = {
  ciphertextBlob: string(name='CiphertextBlob'),
  keyId: string(name='KeyId'),
  exportedDataKey: string(name='ExportedDataKey'),
  requestId: string(name='RequestId'),
  keyVersionId: string(name='KeyVersionId'),
}

async function generateAndExportDataKeyWithOptions(request: GenerateAndExportDataKeyRequest, runtime: Util.RuntimeOptions): GenerateAndExportDataKeyResponse {
  Util.validateModel(request);
  return doRequest('GenerateAndExportDataKey', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function generateAndExportDataKey(request: GenerateAndExportDataKeyRequest): GenerateAndExportDataKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateAndExportDataKeyWithOptions(request, runtime);
}

model ExportDataKeyRequest = {
  ciphertextBlob: string(name='CiphertextBlob'),
  encryptionContext?: map[string]any(name='EncryptionContext'),
  publicKeyBlob: string(name='PublicKeyBlob'),
  wrappingKeySpec: string(name='WrappingKeySpec'),
  wrappingAlgorithm: string(name='WrappingAlgorithm'),
}

model ExportDataKeyResponse = {
  exportedDataKey: string(name='ExportedDataKey'),
  keyId: string(name='KeyId'),
  requestId: string(name='RequestId'),
  keyVersionId: string(name='KeyVersionId'),
}

async function exportDataKeyWithOptions(request: ExportDataKeyRequest, runtime: Util.RuntimeOptions): ExportDataKeyResponse {
  Util.validateModel(request);
  return doRequest('ExportDataKey', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function exportDataKey(request: ExportDataKeyRequest): ExportDataKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return exportDataKeyWithOptions(request, runtime);
}

model ReEncryptRequest = {
  ciphertextBlob: string(name='CiphertextBlob'),
  sourceKeyId?: string(name='SourceKeyId'),
  sourceKeyVersionId?: string(name='SourceKeyVersionId'),
  sourceEncryptionAlgorithm?: string(name='SourceEncryptionAlgorithm'),
  sourceEncryptionContext?: map[string]any(name='SourceEncryptionContext'),
  destinationKeyId: string(name='DestinationKeyId'),
  destinationEncryptionContext?: map[string]any(name='DestinationEncryptionContext'),
}

model ReEncryptResponse = {
  requestId: string(name='RequestId'),
  keyId: string(name='KeyId'),
  keyVersionId: string(name='KeyVersionId'),
  ciphertextBlob: string(name='CiphertextBlob'),
}

async function reEncryptWithOptions(request: ReEncryptRequest, runtime: Util.RuntimeOptions): ReEncryptResponse {
  Util.validateModel(request);
  return doRequest('ReEncrypt', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function reEncrypt(request: ReEncryptRequest): ReEncryptResponse {
  var runtime = new Util.RuntimeOptions{};
  return reEncryptWithOptions(request, runtime);
}

model ListSecretsRequest = {
  fetchTags?: string(name='FetchTags'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model ListSecretsResponse = {
  requestId: string(name='RequestId'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  totalCount: integer(name='TotalCount'),
  secretList: {
    secret: [
      {
        secretName: string(name='SecretName'),
        createTime: string(name='CreateTime'),
        updateTime: string(name='UpdateTime'),
        plannedDeleteTime: string(name='PlannedDeleteTime'),
        tags: {
          tag: [
            {
              tagKey: string(name='TagKey'),
              tagValue: string(name='TagValue'),
            }
          ](name='Tag'),
        }(name='Tags'),
      }
    ](name='Secret'),
  }(name='SecretList'),
}

async function listSecretsWithOptions(request: ListSecretsRequest, runtime: Util.RuntimeOptions): ListSecretsResponse {
  Util.validateModel(request);
  return doRequest('ListSecrets', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function listSecrets(request: ListSecretsRequest): ListSecretsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSecretsWithOptions(request, runtime);
}

model ListSecretVersionIdsRequest = {
  secretName: string(name='SecretName'),
  includeDeprecated?: string(name='IncludeDeprecated'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model ListSecretVersionIdsResponse = {
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  requestId: string(name='RequestId'),
  secretName: string(name='SecretName'),
  totalCount: integer(name='TotalCount'),
  versionIds: {
    versionId: [
      {
        createTime: string(name='CreateTime'),
        versionId: string(name='VersionId'),
        versionStages: {
          versionStage: [ string ](name='VersionStage', description='VersionStage'),
        }(name='VersionStages'),
      }
    ](name='VersionId'),
  }(name='VersionIds'),
}

async function listSecretVersionIdsWithOptions(request: ListSecretVersionIdsRequest, runtime: Util.RuntimeOptions): ListSecretVersionIdsResponse {
  Util.validateModel(request);
  return doRequest('ListSecretVersionIds', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function listSecretVersionIds(request: ListSecretVersionIdsRequest): ListSecretVersionIdsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSecretVersionIdsWithOptions(request, runtime);
}

model DescribeSecretRequest = {
  secretName: string(name='SecretName'),
  fetchTags?: string(name='FetchTags'),
}

model DescribeSecretResponse = {
  requestId: string(name='RequestId'),
  arn: string(name='Arn'),
  secretName: string(name='SecretName'),
  encryptionKeyId: string(name='EncryptionKeyId'),
  description: string(name='Description'),
  createTime: string(name='CreateTime'),
  updateTime: string(name='UpdateTime'),
  plannedDeleteTime: string(name='PlannedDeleteTime'),
  tags: {
    tag: [
      {
        tagKey: string(name='TagKey'),
        tagValue: string(name='TagValue'),
      }
    ](name='Tag'),
  }(name='Tags'),
}

async function describeSecretWithOptions(request: DescribeSecretRequest, runtime: Util.RuntimeOptions): DescribeSecretResponse {
  Util.validateModel(request);
  return doRequest('DescribeSecret', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function describeSecret(request: DescribeSecretRequest): DescribeSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSecretWithOptions(request, runtime);
}

model UpdateSecretRequest = {
  secretName: string(name='SecretName'),
  description?: string(name='Description'),
}

model UpdateSecretResponse = {
  requestId: string(name='RequestId'),
  secretName: string(name='SecretName'),
}

async function updateSecretWithOptions(request: UpdateSecretRequest, runtime: Util.RuntimeOptions): UpdateSecretResponse {
  Util.validateModel(request);
  return doRequest('UpdateSecret', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function updateSecret(request: UpdateSecretRequest): UpdateSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSecretWithOptions(request, runtime);
}

model GetSecretValueRequest = {
  secretName: string(name='SecretName'),
  versionStage?: string(name='VersionStage'),
  versionId?: string(name='VersionId'),
}

model GetSecretValueResponse = {
  requestId: string(name='RequestId'),
  secretName: string(name='SecretName'),
  versionId: string(name='VersionId'),
  createTime: string(name='CreateTime'),
  secretData: string(name='SecretData'),
  secretDataType: string(name='SecretDataType'),
  versionStages: {
    versionStage: [ string ](name='VersionStage'),
  }(name='VersionStages'),
}

async function getSecretValueWithOptions(request: GetSecretValueRequest, runtime: Util.RuntimeOptions): GetSecretValueResponse {
  Util.validateModel(request);
  return doRequest('GetSecretValue', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function getSecretValue(request: GetSecretValueRequest): GetSecretValueResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSecretValueWithOptions(request, runtime);
}

model GetRandomPasswordRequest = {
  passwordLength?: string(name='PasswordLength'),
  excludeCharacters?: string(name='ExcludeCharacters'),
  excludeLowercase?: string(name='ExcludeLowercase'),
  excludeUppercase?: string(name='ExcludeUppercase'),
  excludeNumbers?: string(name='ExcludeNumbers'),
  excludePunctuation?: string(name='ExcludePunctuation'),
  requireEachIncludedType?: string(name='RequireEachIncludedType'),
}

model GetRandomPasswordResponse = {
  requestId: string(name='RequestId'),
  randomPassword: string(name='RandomPassword'),
}

async function getRandomPasswordWithOptions(request: GetRandomPasswordRequest, runtime: Util.RuntimeOptions): GetRandomPasswordResponse {
  Util.validateModel(request);
  return doRequest('GetRandomPassword', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function getRandomPassword(request: GetRandomPasswordRequest): GetRandomPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRandomPasswordWithOptions(request, runtime);
}

model RestoreSecretRequest = {
  secretName: string(name='SecretName'),
}

model RestoreSecretResponse = {
  requestId: string(name='RequestId'),
  secretName: string(name='SecretName'),
}

async function restoreSecretWithOptions(request: RestoreSecretRequest, runtime: Util.RuntimeOptions): RestoreSecretResponse {
  Util.validateModel(request);
  return doRequest('RestoreSecret', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function restoreSecret(request: RestoreSecretRequest): RestoreSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return restoreSecretWithOptions(request, runtime);
}

model CreateSecretRequest = {
  secretName: string(name='SecretName'),
  versionId: string(name='VersionId'),
  encryptionKeyId?: string(name='EncryptionKeyId'),
  secretData: string(name='SecretData'),
  secretDataType?: string(name='SecretDataType'),
  description?: string(name='Description'),
  tags?: string(name='Tags'),
}

model CreateSecretResponse = {
  requestId: string(name='RequestId'),
  arn: string(name='Arn'),
  versionId: string(name='VersionId'),
  secretName: string(name='SecretName'),
}

async function createSecretWithOptions(request: CreateSecretRequest, runtime: Util.RuntimeOptions): CreateSecretResponse {
  Util.validateModel(request);
  return doRequest('CreateSecret', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function createSecret(request: CreateSecretRequest): CreateSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSecretWithOptions(request, runtime);
}

model PutSecretValueRequest = {
  versionId: string(name='VersionId'),
  secretName: string(name='SecretName'),
  secretData: string(name='SecretData'),
  secretDataType?: string(name='SecretDataType'),
  versionStages?: string(name='VersionStages'),
}

model PutSecretValueResponse = {
  requestId: string(name='RequestId'),
  secretName: string(name='SecretName'),
  versionId: string(name='VersionId'),
  versionStages: {
    versionStage: [ string ](name='VersionStage'),
  }(name='VersionStages'),
}

async function putSecretValueWithOptions(request: PutSecretValueRequest, runtime: Util.RuntimeOptions): PutSecretValueResponse {
  Util.validateModel(request);
  return doRequest('PutSecretValue', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function putSecretValue(request: PutSecretValueRequest): PutSecretValueResponse {
  var runtime = new Util.RuntimeOptions{};
  return putSecretValueWithOptions(request, runtime);
}

model DeleteSecretRequest = {
  secretName: string(name='SecretName'),
  forceDeleteWithoutRecovery?: string(name='ForceDeleteWithoutRecovery'),
  recoveryWindowInDays?: string(name='RecoveryWindowInDays'),
}

model DeleteSecretResponse = {
  requestId: string(name='RequestId'),
  secretName: string(name='SecretName'),
  plannedDeleteTime: string(name='PlannedDeleteTime'),
}

async function deleteSecretWithOptions(request: DeleteSecretRequest, runtime: Util.RuntimeOptions): DeleteSecretResponse {
  Util.validateModel(request);
  return doRequest('DeleteSecret', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function deleteSecret(request: DeleteSecretRequest): DeleteSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSecretWithOptions(request, runtime);
}

model UpdateSecretVersionStageRequest = {
  secretName: string(name='SecretName'),
  versionStage: string(name='VersionStage'),
  removeFromVersion?: string(name='RemoveFromVersion'),
  moveToVersion?: string(name='MoveToVersion'),
}

model UpdateSecretVersionStageResponse = {
  secretName: string(name='SecretName'),
  requestId: string(name='RequestId'),
}

async function updateSecretVersionStageWithOptions(request: UpdateSecretVersionStageRequest, runtime: Util.RuntimeOptions): UpdateSecretVersionStageResponse {
  Util.validateModel(request);
  return doRequest('UpdateSecretVersionStage', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function updateSecretVersionStage(request: UpdateSecretVersionStageRequest): UpdateSecretVersionStageResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSecretVersionStageWithOptions(request, runtime);
}

model AsymmetricDecryptRequest = {
  ciphertextBlob: string(name='CiphertextBlob'),
  keyId: string(name='KeyId'),
  keyVersionId: string(name='KeyVersionId'),
  algorithm: string(name='Algorithm'),
}

model AsymmetricDecryptResponse = {
  plaintext: string(name='Plaintext'),
  keyId: string(name='KeyId'),
  requestId: string(name='RequestId'),
  keyVersionId: string(name='KeyVersionId'),
}

async function asymmetricDecryptWithOptions(request: AsymmetricDecryptRequest, runtime: Util.RuntimeOptions): AsymmetricDecryptResponse {
  Util.validateModel(request);
  return doRequest('AsymmetricDecrypt', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function asymmetricDecrypt(request: AsymmetricDecryptRequest): AsymmetricDecryptResponse {
  var runtime = new Util.RuntimeOptions{};
  return asymmetricDecryptWithOptions(request, runtime);
}

model AsymmetricVerifyRequest = {
  keyId: string(name='KeyId'),
  keyVersionId: string(name='KeyVersionId'),
  algorithm: string(name='Algorithm'),
  digest: string(name='Digest'),
  value: string(name='Value'),
}

model AsymmetricVerifyResponse = {
  value: boolean(name='Value'),
  keyId: string(name='KeyId'),
  requestId: string(name='RequestId'),
  keyVersionId: string(name='KeyVersionId'),
}

async function asymmetricVerifyWithOptions(request: AsymmetricVerifyRequest, runtime: Util.RuntimeOptions): AsymmetricVerifyResponse {
  Util.validateModel(request);
  return doRequest('AsymmetricVerify', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function asymmetricVerify(request: AsymmetricVerifyRequest): AsymmetricVerifyResponse {
  var runtime = new Util.RuntimeOptions{};
  return asymmetricVerifyWithOptions(request, runtime);
}

model AsymmetricSignRequest = {
  keyId: string(name='KeyId'),
  keyVersionId: string(name='KeyVersionId'),
  algorithm: string(name='Algorithm'),
  digest: string(name='Digest'),
}

model AsymmetricSignResponse = {
  value: string(name='Value'),
  keyId: string(name='KeyId'),
  requestId: string(name='RequestId'),
  keyVersionId: string(name='KeyVersionId'),
}

async function asymmetricSignWithOptions(request: AsymmetricSignRequest, runtime: Util.RuntimeOptions): AsymmetricSignResponse {
  Util.validateModel(request);
  return doRequest('AsymmetricSign', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function asymmetricSign(request: AsymmetricSignRequest): AsymmetricSignResponse {
  var runtime = new Util.RuntimeOptions{};
  return asymmetricSignWithOptions(request, runtime);
}

model AsymmetricEncryptRequest = {
  plaintext: string(name='Plaintext'),
  keyId: string(name='KeyId'),
  keyVersionId: string(name='KeyVersionId'),
  algorithm: string(name='Algorithm'),
}

model AsymmetricEncryptResponse = {
  ciphertextBlob: string(name='CiphertextBlob'),
  keyId: string(name='KeyId'),
  requestId: string(name='RequestId'),
  keyVersionId: string(name='KeyVersionId'),
}

async function asymmetricEncryptWithOptions(request: AsymmetricEncryptRequest, runtime: Util.RuntimeOptions): AsymmetricEncryptResponse {
  Util.validateModel(request);
  return doRequest('AsymmetricEncrypt', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function asymmetricEncrypt(request: AsymmetricEncryptRequest): AsymmetricEncryptResponse {
  var runtime = new Util.RuntimeOptions{};
  return asymmetricEncryptWithOptions(request, runtime);
}

model GetPublicKeyRequest = {
  keyId: string(name='KeyId'),
  keyVersionId: string(name='KeyVersionId'),
}

model GetPublicKeyResponse = {
  publicKey: string(name='PublicKey'),
  keyId: string(name='KeyId'),
  requestId: string(name='RequestId'),
  keyVersionId: string(name='KeyVersionId'),
}

async function getPublicKeyWithOptions(request: GetPublicKeyRequest, runtime: Util.RuntimeOptions): GetPublicKeyResponse {
  Util.validateModel(request);
  return doRequest('GetPublicKey', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function getPublicKey(request: GetPublicKeyRequest): GetPublicKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPublicKeyWithOptions(request, runtime);
}

model GenerateDataKeyWithoutPlaintextRequest = {
  keyId: string(name='KeyId'),
  keySpec?: string(name='KeySpec'),
  numberOfBytes?: integer(name='NumberOfBytes'),
  encryptionContext?: map[string]any(name='EncryptionContext'),
}

model GenerateDataKeyWithoutPlaintextResponse = {
  ciphertextBlob: string(name='CiphertextBlob'),
  keyId: string(name='KeyId'),
  requestId: string(name='RequestId'),
  keyVersionId: string(name='KeyVersionId'),
}

async function generateDataKeyWithoutPlaintextWithOptions(request: GenerateDataKeyWithoutPlaintextRequest, runtime: Util.RuntimeOptions): GenerateDataKeyWithoutPlaintextResponse {
  Util.validateModel(request);
  return doRequest('GenerateDataKeyWithoutPlaintext', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function generateDataKeyWithoutPlaintext(request: GenerateDataKeyWithoutPlaintextRequest): GenerateDataKeyWithoutPlaintextResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateDataKeyWithoutPlaintextWithOptions(request, runtime);
}

model UpdateKeyDescriptionRequest = {
  keyId: string(name='KeyId'),
  description: string(name='Description'),
}

model UpdateKeyDescriptionResponse = {
  requestId: string(name='RequestId'),
}

async function updateKeyDescriptionWithOptions(request: UpdateKeyDescriptionRequest, runtime: Util.RuntimeOptions): UpdateKeyDescriptionResponse {
  Util.validateModel(request);
  return doRequest('UpdateKeyDescription', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function updateKeyDescription(request: UpdateKeyDescriptionRequest): UpdateKeyDescriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateKeyDescriptionWithOptions(request, runtime);
}

model DescribeKeyVersionRequest = {
  keyId: string(name='KeyId'),
  keyVersionId: string(name='KeyVersionId'),
}

model DescribeKeyVersionResponse = {
  requestId: string(name='RequestId'),
  keyVersion: {
    keyId: string(name='KeyId'),
    keyVersionId: string(name='KeyVersionId'),
    creationDate: string(name='CreationDate'),
  }(name='KeyVersion'),
}

async function describeKeyVersionWithOptions(request: DescribeKeyVersionRequest, runtime: Util.RuntimeOptions): DescribeKeyVersionResponse {
  Util.validateModel(request);
  return doRequest('DescribeKeyVersion', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function describeKeyVersion(request: DescribeKeyVersionRequest): DescribeKeyVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeKeyVersionWithOptions(request, runtime);
}

model UpdateRotationPolicyRequest = {
  keyId: string(name='KeyId'),
  enableAutomaticRotation: boolean(name='EnableAutomaticRotation'),
  rotationInterval?: string(name='RotationInterval'),
}

model UpdateRotationPolicyResponse = {
  requestId: string(name='RequestId'),
}

async function updateRotationPolicyWithOptions(request: UpdateRotationPolicyRequest, runtime: Util.RuntimeOptions): UpdateRotationPolicyResponse {
  Util.validateModel(request);
  return doRequest('UpdateRotationPolicy', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function updateRotationPolicy(request: UpdateRotationPolicyRequest): UpdateRotationPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateRotationPolicyWithOptions(request, runtime);
}

model ListKeyVersionsRequest = {
  keyId: string(name='KeyId'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model ListKeyVersionsResponse = {
  requestId: string(name='RequestId'),
  totalCount: integer(name='TotalCount'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  keyVersions: {
    keyVersion: [
      {
        keyId: string(name='KeyId'),
        keyVersionId: string(name='KeyVersionId'),
        creationDate: string(name='CreationDate'),
      }
    ](name='KeyVersion'),
  }(name='KeyVersions'),
}

async function listKeyVersionsWithOptions(request: ListKeyVersionsRequest, runtime: Util.RuntimeOptions): ListKeyVersionsResponse {
  Util.validateModel(request);
  return doRequest('ListKeyVersions', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function listKeyVersions(request: ListKeyVersionsRequest): ListKeyVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listKeyVersionsWithOptions(request, runtime);
}

model CreateKeyVersionRequest = {
  keyId: string(name='KeyId'),
}

model CreateKeyVersionResponse = {
  requestId: string(name='RequestId'),
  keyVersion: {
    keyId: string(name='KeyId'),
    keyVersionId: string(name='KeyVersionId'),
    creationDate: string(name='CreationDate'),
  }(name='KeyVersion'),
}

async function createKeyVersionWithOptions(request: CreateKeyVersionRequest, runtime: Util.RuntimeOptions): CreateKeyVersionResponse {
  Util.validateModel(request);
  return doRequest('CreateKeyVersion', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function createKeyVersion(request: CreateKeyVersionRequest): CreateKeyVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createKeyVersionWithOptions(request, runtime);
}

model DescribeServiceRequest = {
}

model DescribeServiceResponse = {
  requestId: string(name='RequestId'),
  protectionLevels: {
    protectionLevel: [
      {
        type: string(name='Type'),
      }
    ](name='ProtectionLevel'),
  }(name='ProtectionLevels'),
  keySpecs: {
    keySpec: [
      {
        name: string(name='Name'),
        supportedProtectionLevels: {
          supportedProtectionLevel: [ string ](name='SupportedProtectionLevel', description='SupportedProtectionLevel'),
        }(name='SupportedProtectionLevels'),
        usages: {
          usage: [ string ](name='Usage', description='Usage'),
        }(name='Usages'),
      }
    ](name='KeySpec'),
  }(name='KeySpecs'),
}

async function describeServiceWithOptions(request: DescribeServiceRequest, runtime: Util.RuntimeOptions): DescribeServiceResponse {
  Util.validateModel(request);
  return doRequest('DescribeService', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function describeService(request: DescribeServiceRequest): DescribeServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceWithOptions(request, runtime);
}

model UpdateAliasRequest = {
  keyId: string(name='KeyId'),
  aliasName: string(name='AliasName'),
}

model UpdateAliasResponse = {
  requestId: string(name='RequestId'),
}

async function updateAliasWithOptions(request: UpdateAliasRequest, runtime: Util.RuntimeOptions): UpdateAliasResponse {
  Util.validateModel(request);
  return doRequest('UpdateAlias', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function updateAlias(request: UpdateAliasRequest): UpdateAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAliasWithOptions(request, runtime);
}

model UntagResourceRequest = {
  keyId?: string(name='KeyId'),
  tagKeys: string(name='TagKeys'),
  secretName?: string(name='SecretName'),
}

model UntagResourceResponse = {
  requestId: string(name='RequestId'),
}

async function untagResourceWithOptions(request: UntagResourceRequest, runtime: Util.RuntimeOptions): UntagResourceResponse {
  Util.validateModel(request);
  return doRequest('UntagResource', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function untagResource(request: UntagResourceRequest): UntagResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourceWithOptions(request, runtime);
}

model TagResourceRequest = {
  keyId?: string(name='KeyId'),
  tags: string(name='Tags'),
  secretName?: string(name='SecretName'),
}

model TagResourceResponse = {
  requestId: string(name='RequestId'),
}

async function tagResourceWithOptions(request: TagResourceRequest, runtime: Util.RuntimeOptions): TagResourceResponse {
  Util.validateModel(request);
  return doRequest('TagResource', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function tagResource(request: TagResourceRequest): TagResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourceWithOptions(request, runtime);
}

model ScheduleKeyDeletionRequest = {
  keyId: string(name='KeyId'),
  pendingWindowInDays?: integer(name='PendingWindowInDays'),
}

model ScheduleKeyDeletionResponse = {
  requestId: string(name='RequestId'),
}

async function scheduleKeyDeletionWithOptions(request: ScheduleKeyDeletionRequest, runtime: Util.RuntimeOptions): ScheduleKeyDeletionResponse {
  Util.validateModel(request);
  return doRequest('ScheduleKeyDeletion', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function scheduleKeyDeletion(request: ScheduleKeyDeletionRequest): ScheduleKeyDeletionResponse {
  var runtime = new Util.RuntimeOptions{};
  return scheduleKeyDeletionWithOptions(request, runtime);
}

model ListResourceTagsRequest = {
  keyId: string(name='KeyId'),
}

model ListResourceTagsResponse = {
  requestId: string(name='RequestId'),
  tags: {
    tag: [
      {
        keyId: string(name='KeyId'),
        tagKey: string(name='TagKey'),
        tagValue: string(name='TagValue'),
      }
    ](name='Tag'),
  }(name='Tags'),
}

async function listResourceTagsWithOptions(request: ListResourceTagsRequest, runtime: Util.RuntimeOptions): ListResourceTagsResponse {
  Util.validateModel(request);
  return doRequest('ListResourceTags', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function listResourceTags(request: ListResourceTagsRequest): ListResourceTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listResourceTagsWithOptions(request, runtime);
}

model ListKeysRequest = {
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model ListKeysResponse = {
  totalCount: integer(name='TotalCount'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  requestId: string(name='RequestId'),
  keys: {
    key: [
      {
        keyId: string(name='KeyId'),
        keyArn: string(name='KeyArn'),
      }
    ](name='Key'),
  }(name='Keys'),
}

async function listKeysWithOptions(request: ListKeysRequest, runtime: Util.RuntimeOptions): ListKeysResponse {
  Util.validateModel(request);
  return doRequest('ListKeys', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function listKeys(request: ListKeysRequest): ListKeysResponse {
  var runtime = new Util.RuntimeOptions{};
  return listKeysWithOptions(request, runtime);
}

model ListAliasesByKeyIdRequest = {
  keyId: string(name='KeyId'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model ListAliasesByKeyIdResponse = {
  totalCount: integer(name='TotalCount'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  requestId: string(name='RequestId'),
  aliases: {
    alias: [
      {
        keyId: string(name='KeyId'),
        aliasName: string(name='AliasName'),
        aliasArn: string(name='AliasArn'),
      }
    ](name='Alias'),
  }(name='Aliases'),
}

async function listAliasesByKeyIdWithOptions(request: ListAliasesByKeyIdRequest, runtime: Util.RuntimeOptions): ListAliasesByKeyIdResponse {
  Util.validateModel(request);
  return doRequest('ListAliasesByKeyId', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function listAliasesByKeyId(request: ListAliasesByKeyIdRequest): ListAliasesByKeyIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAliasesByKeyIdWithOptions(request, runtime);
}

model ListAliasesRequest = {
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model ListAliasesResponse = {
  totalCount: integer(name='TotalCount'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  requestId: string(name='RequestId'),
  aliases: {
    alias: [
      {
        keyId: string(name='KeyId'),
        aliasName: string(name='AliasName'),
        aliasArn: string(name='AliasArn'),
      }
    ](name='Alias'),
  }(name='Aliases'),
}

async function listAliasesWithOptions(request: ListAliasesRequest, runtime: Util.RuntimeOptions): ListAliasesResponse {
  Util.validateModel(request);
  return doRequest('ListAliases', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function listAliases(request: ListAliasesRequest): ListAliasesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAliasesWithOptions(request, runtime);
}

model ImportKeyMaterialRequest = {
  keyId: string(name='KeyId'),
  encryptedKeyMaterial: string(name='EncryptedKeyMaterial'),
  importToken: string(name='ImportToken'),
  keyMaterialExpireUnix: long(name='KeyMaterialExpireUnix'),
}

model ImportKeyMaterialResponse = {
  requestId: string(name='RequestId'),
}

async function importKeyMaterialWithOptions(request: ImportKeyMaterialRequest, runtime: Util.RuntimeOptions): ImportKeyMaterialResponse {
  Util.validateModel(request);
  return doRequest('ImportKeyMaterial', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function importKeyMaterial(request: ImportKeyMaterialRequest): ImportKeyMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return importKeyMaterialWithOptions(request, runtime);
}

model GetParametersForImportRequest = {
  keyId: string(name='KeyId'),
  wrappingAlgorithm: string(name='WrappingAlgorithm'),
  wrappingKeySpec: string(name='WrappingKeySpec'),
}

model GetParametersForImportResponse = {
  keyId: string(name='KeyId'),
  requestId: string(name='RequestId'),
  importToken: string(name='ImportToken'),
  publicKey: string(name='PublicKey'),
  tokenExpireTime: string(name='TokenExpireTime'),
}

async function getParametersForImportWithOptions(request: GetParametersForImportRequest, runtime: Util.RuntimeOptions): GetParametersForImportResponse {
  Util.validateModel(request);
  return doRequest('GetParametersForImport', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function getParametersForImport(request: GetParametersForImportRequest): GetParametersForImportResponse {
  var runtime = new Util.RuntimeOptions{};
  return getParametersForImportWithOptions(request, runtime);
}

model GenerateDataKeyRequest = {
  keyId: string(name='KeyId'),
  keySpec?: string(name='KeySpec'),
  numberOfBytes?: integer(name='NumberOfBytes'),
  encryptionContext?: map[string]any(name='EncryptionContext'),
}

model GenerateDataKeyResponse = {
  ciphertextBlob: string(name='CiphertextBlob'),
  keyId: string(name='KeyId'),
  plaintext: string(name='Plaintext'),
  requestId: string(name='RequestId'),
  keyVersionId: string(name='KeyVersionId'),
}

async function generateDataKeyWithOptions(request: GenerateDataKeyRequest, runtime: Util.RuntimeOptions): GenerateDataKeyResponse {
  Util.validateModel(request);
  return doRequest('GenerateDataKey', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function generateDataKey(request: GenerateDataKeyRequest): GenerateDataKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateDataKeyWithOptions(request, runtime);
}

model EncryptRequest = {
  keyId: string(name='KeyId'),
  plaintext: string(name='Plaintext'),
  encryptionContext?: map[string]any(name='EncryptionContext'),
}

model EncryptResponse = {
  ciphertextBlob: string(name='CiphertextBlob'),
  keyId: string(name='KeyId'),
  requestId: string(name='RequestId'),
  keyVersionId: string(name='KeyVersionId'),
}

async function encryptWithOptions(request: EncryptRequest, runtime: Util.RuntimeOptions): EncryptResponse {
  Util.validateModel(request);
  return doRequest('Encrypt', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function encrypt(request: EncryptRequest): EncryptResponse {
  var runtime = new Util.RuntimeOptions{};
  return encryptWithOptions(request, runtime);
}

model EnableKeyRequest = {
  keyId: string(name='KeyId'),
}

model EnableKeyResponse = {
  requestId: string(name='RequestId'),
}

async function enableKeyWithOptions(request: EnableKeyRequest, runtime: Util.RuntimeOptions): EnableKeyResponse {
  Util.validateModel(request);
  return doRequest('EnableKey', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function enableKey(request: EnableKeyRequest): EnableKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableKeyWithOptions(request, runtime);
}

model DisableKeyRequest = {
  keyId: string(name='KeyId'),
}

model DisableKeyResponse = {
  requestId: string(name='RequestId'),
}

async function disableKeyWithOptions(request: DisableKeyRequest, runtime: Util.RuntimeOptions): DisableKeyResponse {
  Util.validateModel(request);
  return doRequest('DisableKey', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function disableKey(request: DisableKeyRequest): DisableKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableKeyWithOptions(request, runtime);
}

model DescribeRegionsRequest = {
}

model DescribeRegionsResponse = {
  requestId: string(name='RequestId'),
  regions: {
    region: [
      {
        regionId: string(name='RegionId'),
      }
    ](name='Region'),
  }(name='Regions'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  return doRequest('DescribeRegions', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model DescribeKeyRequest = {
  keyId: string(name='KeyId'),
}

model DescribeKeyResponse = {
  requestId: string(name='RequestId'),
  keyMetadata: {
    creationDate: string(name='CreationDate'),
    description: string(name='Description'),
    keyId: string(name='KeyId'),
    keyState: string(name='KeyState'),
    keyUsage: string(name='KeyUsage'),
    deleteDate: string(name='DeleteDate'),
    creator: string(name='Creator'),
    arn: string(name='Arn'),
    origin: string(name='Origin'),
    materialExpireTime: string(name='MaterialExpireTime'),
    protectionLevel: string(name='ProtectionLevel'),
    primaryKeyVersion: string(name='PrimaryKeyVersion'),
    lastRotationDate: string(name='LastRotationDate'),
    automaticRotation: string(name='AutomaticRotation'),
    rotationInterval: string(name='RotationInterval'),
    nextRotationDate: string(name='NextRotationDate'),
    keySpec: string(name='KeySpec'),
  }(name='KeyMetadata'),
}

async function describeKeyWithOptions(request: DescribeKeyRequest, runtime: Util.RuntimeOptions): DescribeKeyResponse {
  Util.validateModel(request);
  return doRequest('DescribeKey', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function describeKey(request: DescribeKeyRequest): DescribeKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeKeyWithOptions(request, runtime);
}

model DeleteKeyMaterialRequest = {
  keyId: string(name='KeyId'),
}

model DeleteKeyMaterialResponse = {
  requestId: string(name='RequestId'),
}

async function deleteKeyMaterialWithOptions(request: DeleteKeyMaterialRequest, runtime: Util.RuntimeOptions): DeleteKeyMaterialResponse {
  Util.validateModel(request);
  return doRequest('DeleteKeyMaterial', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function deleteKeyMaterial(request: DeleteKeyMaterialRequest): DeleteKeyMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteKeyMaterialWithOptions(request, runtime);
}

model DeleteAliasRequest = {
  aliasName: string(name='AliasName'),
}

model DeleteAliasResponse = {
  requestId: string(name='RequestId'),
}

async function deleteAliasWithOptions(request: DeleteAliasRequest, runtime: Util.RuntimeOptions): DeleteAliasResponse {
  Util.validateModel(request);
  return doRequest('DeleteAlias', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function deleteAlias(request: DeleteAliasRequest): DeleteAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAliasWithOptions(request, runtime);
}

model DecryptRequest = {
  ciphertextBlob: string(name='CiphertextBlob'),
  encryptionContext?: map[string]any(name='EncryptionContext'),
}

model DecryptResponse = {
  plaintext: string(name='Plaintext'),
  keyId: string(name='KeyId'),
  requestId: string(name='RequestId'),
  keyVersionId: string(name='KeyVersionId'),
}

async function decryptWithOptions(request: DecryptRequest, runtime: Util.RuntimeOptions): DecryptResponse {
  Util.validateModel(request);
  return doRequest('Decrypt', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function decrypt(request: DecryptRequest): DecryptResponse {
  var runtime = new Util.RuntimeOptions{};
  return decryptWithOptions(request, runtime);
}

model CreateKeyRequest = {
  description?: string(name='Description'),
  keyUsage?: string(name='KeyUsage'),
  origin?: string(name='Origin'),
  protectionLevel?: string(name='ProtectionLevel'),
  enableAutomaticRotation?: boolean(name='EnableAutomaticRotation'),
  rotationInterval?: string(name='RotationInterval'),
  keySpec?: string(name='KeySpec'),
}

model CreateKeyResponse = {
  requestId: string(name='RequestId'),
  keyMetadata: {
    creationDate: string(name='CreationDate'),
    description: string(name='Description'),
    keyId: string(name='KeyId'),
    keyState: string(name='KeyState'),
    keyUsage: string(name='KeyUsage'),
    deleteDate: string(name='DeleteDate'),
    creator: string(name='Creator'),
    arn: string(name='Arn'),
    origin: string(name='Origin'),
    materialExpireTime: string(name='MaterialExpireTime'),
    protectionLevel: string(name='ProtectionLevel'),
    primaryKeyVersion: string(name='PrimaryKeyVersion'),
    lastRotationDate: string(name='LastRotationDate'),
    automaticRotation: string(name='AutomaticRotation'),
    rotationInterval: string(name='RotationInterval'),
    nextRotationDate: string(name='NextRotationDate'),
    keySpec: string(name='KeySpec'),
  }(name='KeyMetadata'),
}

async function createKeyWithOptions(request: CreateKeyRequest, runtime: Util.RuntimeOptions): CreateKeyResponse {
  Util.validateModel(request);
  return doRequest('CreateKey', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function createKey(request: CreateKeyRequest): CreateKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createKeyWithOptions(request, runtime);
}

model CreateAliasRequest = {
  keyId: string(name='KeyId'),
  aliasName: string(name='AliasName'),
}

model CreateAliasResponse = {
  requestId: string(name='RequestId'),
}

async function createAliasWithOptions(request: CreateAliasRequest, runtime: Util.RuntimeOptions): CreateAliasResponse {
  Util.validateModel(request);
  return doRequest('CreateAlias', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function createAlias(request: CreateAliasRequest): CreateAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAliasWithOptions(request, runtime);
}

model CancelKeyDeletionRequest = {
  keyId: string(name='KeyId'),
}

model CancelKeyDeletionResponse = {
  requestId: string(name='RequestId'),
}

async function cancelKeyDeletionWithOptions(request: CancelKeyDeletionRequest, runtime: Util.RuntimeOptions): CancelKeyDeletionResponse {
  Util.validateModel(request);
  return doRequest('CancelKeyDeletion', 'HTTPS', 'POST', '2016-01-20', 'AK', null, request, runtime);
}

async function cancelKeyDeletion(request: CancelKeyDeletionRequest): CancelKeyDeletionResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelKeyDeletionWithOptions(request, runtime);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
