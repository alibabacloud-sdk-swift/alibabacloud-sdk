import Util;

import RPC;
import EndpointUtil;

extends RPC;

init(config: RPC.Config){
  super(config);
  @endpointRule = 'central';
  
  checkConfig(config);
  @endpoint = getEndpoint('pcdn', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

model StopDomainRequest = {
  securityToken?: string(name='SecurityToken'),
  version: string(name='Version'),
  domain: string(name='Domain'),
}

model StopDomainResponse = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  resourceId: string(name='ResourceId'),
}

async function stopDomainWithOptions(request: StopDomainRequest, runtime: Util.RuntimeOptions): StopDomainResponse {
  Util.validateModel(request);
  return doRequest('StopDomain', 'HTTPS', 'GET', '2017-04-11', 'AK', request, null, runtime);
}

async function stopDomain(request: StopDomainRequest): StopDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopDomainWithOptions(request, runtime);
}

model StartDomainRequest = {
  securityToken?: string(name='SecurityToken'),
  version: string(name='Version'),
  domain: string(name='Domain'),
}

model StartDomainResponse = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  resourceId: string(name='ResourceId'),
}

async function startDomainWithOptions(request: StartDomainRequest, runtime: Util.RuntimeOptions): StartDomainResponse {
  Util.validateModel(request);
  return doRequest('StartDomain', 'HTTPS', 'GET', '2017-04-11', 'AK', request, null, runtime);
}

async function startDomain(request: StartDomainRequest): StartDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return startDomainWithOptions(request, runtime);
}

model DeleteDomainRequest = {
  securityToken?: string(name='SecurityToken'),
  version: string(name='Version'),
  domain: string(name='Domain'),
}

model DeleteDomainResponse = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  resourceId: string(name='ResourceId'),
}

async function deleteDomainWithOptions(request: DeleteDomainRequest, runtime: Util.RuntimeOptions): DeleteDomainResponse {
  Util.validateModel(request);
  return doRequest('DeleteDomain', 'HTTPS', 'GET', '2017-04-11', 'AK', request, null, runtime);
}

async function deleteDomain(request: DeleteDomainRequest): DeleteDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDomainWithOptions(request, runtime);
}

model AddDomainRequest = {
  securityToken?: string(name='SecurityToken'),
  version: string(name='Version'),
  businessType: string(name='BusinessType'),
  domain: string(name='Domain'),
  liveFormat?: string(name='LiveFormat'),
  sliceDomain?: string(name='SliceDomain'),
  region?: string(name='Region'),
  demoUrls?: string(name='DemoUrls'),
}

model AddDomainResponse = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  resourceId: string(name='ResourceId'),
}

async function addDomainWithOptions(request: AddDomainRequest, runtime: Util.RuntimeOptions): AddDomainResponse {
  Util.validateModel(request);
  return doRequest('AddDomain', 'HTTPS', 'GET', '2017-04-11', 'AK', request, null, runtime);
}

async function addDomain(request: AddDomainRequest): AddDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDomainWithOptions(request, runtime);
}

model GetBalanceTrafficDataRequest = {
  securityToken?: string(name='SecurityToken'),
  version: string(name='Version'),
  dataInterval?: integer(name='DataInterval'),
  resourceId: string(name='ResourceId'),
}

model GetBalanceTrafficDataResponse = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  dataList: {
    usageData: [
      {
        date: string(name='Date'),
        values: {
          values: [ string ](name='Values', description='Values'),
        }(name='Values'),
      }
    ](name='UsageData'),
  }(name='DataList'),
  labels: {
    label: [ string ](name='Label'),
  }(name='Labels'),
}

async function getBalanceTrafficDataWithOptions(request: GetBalanceTrafficDataRequest, runtime: Util.RuntimeOptions): GetBalanceTrafficDataResponse {
  Util.validateModel(request);
  return doRequest('GetBalanceTrafficData', 'HTTPS', 'GET', '2017-04-11', 'AK', request, null, runtime);
}

async function getBalanceTrafficData(request: GetBalanceTrafficDataRequest): GetBalanceTrafficDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBalanceTrafficDataWithOptions(request, runtime);
}

model AddPcdnControlRuleRequest = {
  securityToken?: string(name='SecurityToken'),
  version: string(name='Version'),
  name: string(name='Name'),
  region: string(name='Region'),
  ispName: string(name='IspName'),
  platformType: string(name='PlatformType'),
  businessType: string(name='BusinessType'),
  market: string(name='Market'),
  appVersion: string(name='AppVersion'),
}

model AddPcdnControlRuleResponse = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  resourceId: string(name='ResourceId'),
}

async function addPcdnControlRuleWithOptions(request: AddPcdnControlRuleRequest, runtime: Util.RuntimeOptions): AddPcdnControlRuleResponse {
  Util.validateModel(request);
  return doRequest('AddPcdnControlRule', 'HTTPS', 'GET', '2017-04-11', 'AK', request, null, runtime);
}

async function addPcdnControlRule(request: AddPcdnControlRuleRequest): AddPcdnControlRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return addPcdnControlRuleWithOptions(request, runtime);
}

model AddConsumerRequest = {
  securityToken?: string(name='SecurityToken'),
  version: string(name='Version'),
  businessType: string(name='BusinessType'),
  company: string(name='Company'),
  site: string(name='Site'),
  requirement: string(name='Requirement'),
  mobile: string(name='Mobile'),
  ca?: string(name='Ca'),
  operator?: string(name='Operator'),
  email?: string(name='Email'),
  bandwidthRequirement?: string(name='BandwidthRequirement'),
}

model AddConsumerResponse = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  resourceId: string(name='ResourceId'),
}

async function addConsumerWithOptions(request: AddConsumerRequest, runtime: Util.RuntimeOptions): AddConsumerResponse {
  Util.validateModel(request);
  return doRequest('AddConsumer', 'HTTPS', 'GET', '2017-04-11', 'AK', request, null, runtime);
}

async function addConsumer(request: AddConsumerRequest): AddConsumerResponse {
  var runtime = new Util.RuntimeOptions{};
  return addConsumerWithOptions(request, runtime);
}

model GetAccessDataRequest = {
  securityToken?: string(name='SecurityToken'),
  version: string(name='Version'),
  domain?: string(name='Domain'),
  region: string(name='Region'),
  ispName: string(name='IspName'),
  platformType: string(name='PlatformType'),
  businessType: string(name='BusinessType'),
  startDate: string(name='StartDate'),
  endDate: string(name='EndDate'),
}

model GetAccessDataResponse = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  dataList: {
    usageData: [
      {
        date: string(name='Date'),
        values: {
          values: [ string ](name='Values', description='Values'),
        }(name='Values'),
      }
    ](name='UsageData'),
  }(name='DataList'),
  labels: {
    label: [ string ](name='Label'),
  }(name='Labels'),
}

async function getAccessDataWithOptions(request: GetAccessDataRequest, runtime: Util.RuntimeOptions): GetAccessDataResponse {
  Util.validateModel(request);
  return doRequest('GetAccessData', 'HTTPS', 'GET', '2017-04-11', 'AK', request, null, runtime);
}

async function getAccessData(request: GetAccessDataRequest): GetAccessDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAccessDataWithOptions(request, runtime);
}

model EnablePcdnControlRuleRequest = {
  securityToken?: string(name='SecurityToken'),
  version: string(name='Version'),
  resourceId: string(name='ResourceId'),
}

model EnablePcdnControlRuleResponse = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  resourceId: string(name='ResourceId'),
}

async function enablePcdnControlRuleWithOptions(request: EnablePcdnControlRuleRequest, runtime: Util.RuntimeOptions): EnablePcdnControlRuleResponse {
  Util.validateModel(request);
  return doRequest('EnablePcdnControlRule', 'HTTPS', 'GET', '2017-04-11', 'AK', request, null, runtime);
}

async function enablePcdnControlRule(request: EnablePcdnControlRuleRequest): EnablePcdnControlRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return enablePcdnControlRuleWithOptions(request, runtime);
}

model EditPcdnControlRuleRequest = {
  securityToken?: string(name='SecurityToken'),
  version: string(name='Version'),
  name: string(name='Name'),
  resourceId: string(name='ResourceId'),
  region: string(name='Region'),
  ispName: string(name='IspName'),
  platformType: string(name='PlatformType'),
  businessType: string(name='BusinessType'),
  market: string(name='Market'),
  appVersion: string(name='AppVersion'),
}

model EditPcdnControlRuleResponse = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  resourceId: string(name='ResourceId'),
}

async function editPcdnControlRuleWithOptions(request: EditPcdnControlRuleRequest, runtime: Util.RuntimeOptions): EditPcdnControlRuleResponse {
  Util.validateModel(request);
  return doRequest('EditPcdnControlRule', 'HTTPS', 'GET', '2017-04-11', 'AK', request, null, runtime);
}

async function editPcdnControlRule(request: EditPcdnControlRuleRequest): EditPcdnControlRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return editPcdnControlRuleWithOptions(request, runtime);
}

model DisablePcdnControlRuleRequest = {
  securityToken?: string(name='SecurityToken'),
  version: string(name='Version'),
  resourceId: string(name='ResourceId'),
}

model DisablePcdnControlRuleResponse = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  resourceId: string(name='ResourceId'),
}

async function disablePcdnControlRuleWithOptions(request: DisablePcdnControlRuleRequest, runtime: Util.RuntimeOptions): DisablePcdnControlRuleResponse {
  Util.validateModel(request);
  return doRequest('DisablePcdnControlRule', 'HTTPS', 'GET', '2017-04-11', 'AK', request, null, runtime);
}

async function disablePcdnControlRule(request: DisablePcdnControlRuleRequest): DisablePcdnControlRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return disablePcdnControlRuleWithOptions(request, runtime);
}

model DeletePcdnControlRuleRequest = {
  securityToken?: string(name='SecurityToken'),
  version: string(name='Version'),
  resourceId: string(name='ResourceId'),
}

model DeletePcdnControlRuleResponse = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
}

async function deletePcdnControlRuleWithOptions(request: DeletePcdnControlRuleRequest, runtime: Util.RuntimeOptions): DeletePcdnControlRuleResponse {
  Util.validateModel(request);
  return doRequest('DeletePcdnControlRule', 'HTTPS', 'GET', '2017-04-11', 'AK', request, null, runtime);
}

async function deletePcdnControlRule(request: DeletePcdnControlRuleRequest): DeletePcdnControlRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePcdnControlRuleWithOptions(request, runtime);
}

model GetAllPlatformTypesRequest = {
  securityToken?: string(name='SecurityToken'),
  version: string(name='Version'),
}

model GetAllPlatformTypesResponse = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  dataList: {
    usageData: [
      {
        code: integer(name='Code'),
        name: string(name='Name'),
      }
    ](name='UsageData'),
  }(name='DataList'),
}

async function getAllPlatformTypesWithOptions(request: GetAllPlatformTypesRequest, runtime: Util.RuntimeOptions): GetAllPlatformTypesResponse {
  Util.validateModel(request);
  return doRequest('GetAllPlatformTypes', 'HTTPS', 'GET', '2017-04-11', 'AK', request, null, runtime);
}

async function getAllPlatformTypes(request: GetAllPlatformTypesRequest): GetAllPlatformTypesResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAllPlatformTypesWithOptions(request, runtime);
}

model GetAllMarketsRequest = {
  securityToken?: string(name='SecurityToken'),
  version: string(name='Version'),
}

model GetAllMarketsResponse = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  dataList: {
    usageData: [
      {
        code: integer(name='Code'),
        marketCode: string(name='MarketCode'),
        marketName: string(name='MarketName'),
      }
    ](name='UsageData'),
  }(name='DataList'),
}

async function getAllMarketsWithOptions(request: GetAllMarketsRequest, runtime: Util.RuntimeOptions): GetAllMarketsResponse {
  Util.validateModel(request);
  return doRequest('GetAllMarkets', 'HTTPS', 'GET', '2017-04-11', 'AK', request, null, runtime);
}

async function getAllMarkets(request: GetAllMarketsRequest): GetAllMarketsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAllMarketsWithOptions(request, runtime);
}

model GetAllIspRequest = {
  securityToken?: string(name='SecurityToken'),
  version: string(name='Version'),
}

model GetAllIspResponse = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  dataList: {
    usageData: [
      {
        nameCn: string(name='NameCn'),
        nameEn: string(name='NameEn'),
        resourceId: string(name='ResourceId'),
      }
    ](name='UsageData'),
  }(name='DataList'),
}

async function getAllIspWithOptions(request: GetAllIspRequest, runtime: Util.RuntimeOptions): GetAllIspResponse {
  Util.validateModel(request);
  return doRequest('GetAllIsp', 'HTTPS', 'GET', '2017-04-11', 'AK', request, null, runtime);
}

async function getAllIsp(request: GetAllIspRequest): GetAllIspResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAllIspWithOptions(request, runtime);
}

model GetAllAppVersionsRequest = {
  securityToken?: string(name='SecurityToken'),
  version: string(name='Version'),
}

model GetAllAppVersionsResponse = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  dataList: {
    usageData: [
      {
        code: integer(name='Code'),
        value: string(name='Value'),
      }
    ](name='UsageData'),
  }(name='DataList'),
}

async function getAllAppVersionsWithOptions(request: GetAllAppVersionsRequest, runtime: Util.RuntimeOptions): GetAllAppVersionsResponse {
  Util.validateModel(request);
  return doRequest('GetAllAppVersions', 'HTTPS', 'GET', '2017-04-11', 'AK', request, null, runtime);
}

async function getAllAppVersions(request: GetAllAppVersionsRequest): GetAllAppVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAllAppVersionsWithOptions(request, runtime);
}

model GetConsumerStatusRequest = {
  securityToken?: string(name='SecurityToken'),
  version: string(name='Version'),
}

model GetConsumerStatusResponse = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  integreatedMode: integer(name='IntegreatedMode'),
  inservice: boolean(name='Inservice'),
  realtimeMonitor: boolean(name='RealtimeMonitor'),
  liveMonitor: boolean(name='LiveMonitor'),
  cdnUrlRedirectFlag: boolean(name='CdnUrlRedirectFlag'),
  businessType: string(name='BusinessType'),
  audit: integer(name='Audit'),
  comment: string(name='Comment'),
  createdAt: string(name='CreatedAt'),
  updatedAt: string(name='UpdatedAt'),
}

async function getConsumerStatusWithOptions(request: GetConsumerStatusRequest, runtime: Util.RuntimeOptions): GetConsumerStatusResponse {
  Util.validateModel(request);
  return doRequest('GetConsumerStatus', 'HTTPS', 'GET', '2017-04-11', 'AK', request, null, runtime);
}

async function getConsumerStatus(request: GetConsumerStatusRequest): GetConsumerStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getConsumerStatusWithOptions(request, runtime);
}

model GetClientsRatioRequest = {
  securityToken?: string(name='SecurityToken'),
  version: string(name='Version'),
}

model GetClientsRatioResponse = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  dataList: {
    usageData: [
      {
        name: string(name='Name'),
        rate: string(name='Rate'),
        value: string(name='Value'),
      }
    ](name='UsageData'),
  }(name='DataList'),
}

async function getClientsRatioWithOptions(request: GetClientsRatioRequest, runtime: Util.RuntimeOptions): GetClientsRatioResponse {
  Util.validateModel(request);
  return doRequest('GetClientsRatio', 'HTTPS', 'GET', '2017-04-11', 'AK', request, null, runtime);
}

async function getClientsRatio(request: GetClientsRatioRequest): GetClientsRatioResponse {
  var runtime = new Util.RuntimeOptions{};
  return getClientsRatioWithOptions(request, runtime);
}

model GetBandwidthDataRequest = {
  securityToken?: string(name='SecurityToken'),
  version: string(name='Version'),
  domain?: string(name='Domain'),
  region: string(name='Region'),
  ispName: string(name='IspName'),
  platformType: string(name='PlatformType'),
  businessType: string(name='BusinessType'),
  startDate: string(name='StartDate'),
  endDate: string(name='EndDate'),
}

model GetBandwidthDataResponse = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  dataList: {
    usageData: [
      {
        date: string(name='Date'),
        values: {
          values: [ string ](name='Values', description='Values'),
        }(name='Values'),
      }
    ](name='UsageData'),
  }(name='DataList'),
  labels: {
    label: [ string ](name='Label'),
  }(name='Labels'),
}

async function getBandwidthDataWithOptions(request: GetBandwidthDataRequest, runtime: Util.RuntimeOptions): GetBandwidthDataResponse {
  Util.validateModel(request);
  return doRequest('GetBandwidthData', 'HTTPS', 'GET', '2017-04-11', 'AK', request, null, runtime);
}

async function getBandwidthData(request: GetBandwidthDataRequest): GetBandwidthDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBandwidthDataWithOptions(request, runtime);
}

model GetBalanceBandwidthDataRequest = {
  securityToken?: string(name='SecurityToken'),
  version: string(name='Version'),
  dataInterval?: integer(name='DataInterval'),
  resourceId: string(name='ResourceId'),
}

model GetBalanceBandwidthDataResponse = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  dataList: {
    usageData: [
      {
        date: string(name='Date'),
        values: {
          values: [ string ](name='Values', description='Values'),
        }(name='Values'),
      }
    ](name='UsageData'),
  }(name='DataList'),
  labels: {
    label: [ string ](name='Label'),
  }(name='Labels'),
}

async function getBalanceBandwidthDataWithOptions(request: GetBalanceBandwidthDataRequest, runtime: Util.RuntimeOptions): GetBalanceBandwidthDataResponse {
  Util.validateModel(request);
  return doRequest('GetBalanceBandwidthData', 'HTTPS', 'GET', '2017-04-11', 'AK', request, null, runtime);
}

async function getBalanceBandwidthData(request: GetBalanceBandwidthDataRequest): GetBalanceBandwidthDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBalanceBandwidthDataWithOptions(request, runtime);
}

model GetControlRulesRequest = {
  securityToken?: string(name='SecurityToken'),
  version: string(name='Version'),
  page: string(name='Page'),
  pageSize: string(name='PageSize'),
}

model GetControlRulesResponse = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  settingList: {
    setting: [
      {
        platformType: string(name='PlatformType'),
        appVersion: string(name='AppVersion'),
        ispName: string(name='IspName'),
        businessType: string(name='BusinessType'),
        clientId: string(name='ClientId'),
        createdAt: string(name='CreatedAt'),
        marketType: string(name='MarketType'),
        name: string(name='Name'),
        onoff: boolean(name='Onoff'),
        usable: boolean(name='Usable'),
        region: string(name='Region'),
        resourceId: string(name='ResourceId'),
        updatedAt: string(name='UpdatedAt'),
      }
    ](name='Setting'),
  }(name='SettingList'),
  pager: {
    page: integer(name='Page'),
    total: integer(name='Total'),
    pageSize: integer(name='PageSize'),
  }(name='Pager'),
}

async function getControlRulesWithOptions(request: GetControlRulesRequest, runtime: Util.RuntimeOptions): GetControlRulesResponse {
  Util.validateModel(request);
  return doRequest('GetControlRules', 'HTTPS', 'GET', '2017-04-11', 'AK', request, null, runtime);
}

async function getControlRules(request: GetControlRulesRequest): GetControlRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return getControlRulesWithOptions(request, runtime);
}

model GetDomainCountRequest = {
  securityToken?: string(name='SecurityToken'),
  version: string(name='Version'),
}

model GetDomainCountResponse = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  data: integer(name='Data'),
}

async function getDomainCountWithOptions(request: GetDomainCountRequest, runtime: Util.RuntimeOptions): GetDomainCountResponse {
  Util.validateModel(request);
  return doRequest('GetDomainCount', 'HTTPS', 'GET', '2017-04-11', 'AK', request, null, runtime);
}

async function getDomainCount(request: GetDomainCountRequest): GetDomainCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDomainCountWithOptions(request, runtime);
}

model GetCurrentModeRequest = {
  securityToken?: string(name='SecurityToken'),
  version: string(name='Version'),
}

model GetCurrentModeResponse = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  modeCode: integer(name='ModeCode'),
  paddingModeCode: integer(name='PaddingModeCode'),
  effectiveAt: integer(name='EffectiveAt'),
  estimateBandwidth: integer(name='EstimateBandwidth'),
}

async function getCurrentModeWithOptions(request: GetCurrentModeRequest, runtime: Util.RuntimeOptions): GetCurrentModeResponse {
  Util.validateModel(request);
  return doRequest('GetCurrentMode', 'HTTPS', 'GET', '2017-04-11', 'AK', request, null, runtime);
}

async function getCurrentMode(request: GetCurrentModeRequest): GetCurrentModeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCurrentModeWithOptions(request, runtime);
}

model GetCoverRateDataRequest = {
  securityToken?: string(name='SecurityToken'),
  version: string(name='Version'),
  domain?: string(name='Domain'),
  region: string(name='Region'),
  ispName: string(name='IspName'),
  platformType: string(name='PlatformType'),
  businessType: string(name='BusinessType'),
  startDate: string(name='StartDate'),
  endDate: string(name='EndDate'),
}

model GetCoverRateDataResponse = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  dataList: {
    usageData: [
      {
        date: string(name='Date'),
        values: {
          values: [ string ](name='Values', description='Values'),
        }(name='Values'),
      }
    ](name='UsageData'),
  }(name='DataList'),
  labels: {
    label: [ string ](name='Label'),
  }(name='Labels'),
}

async function getCoverRateDataWithOptions(request: GetCoverRateDataRequest, runtime: Util.RuntimeOptions): GetCoverRateDataResponse {
  Util.validateModel(request);
  return doRequest('GetCoverRateData', 'HTTPS', 'GET', '2017-04-11', 'AK', request, null, runtime);
}

async function getCoverRateData(request: GetCoverRateDataRequest): GetCoverRateDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCoverRateDataWithOptions(request, runtime);
}

model GetFeeHistoryRequest = {
  securityToken?: string(name='SecurityToken'),
  version: string(name='Version'),
  page: string(name='Page'),
  pageSize: string(name='PageSize'),
}

model GetFeeHistoryResponse = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  feeList: {
    fee: [
      {
        date: string(name='Date'),
        mode: string(name='Mode'),
        totalBandwidth: integer(name='TotalBandwidth'),
        levelTwoBandwidth: integer(name='LevelTwoBandwidth'),
        levelThreeBandwidth: integer(name='LevelThreeBandwidth'),
        totalTraffic: integer(name='TotalTraffic'),
        levelTwoTraffic: integer(name='LevelTwoTraffic'),
        levelThreeTraffic: integer(name='LevelThreeTraffic'),
        timeSpan: string(name='TimeSpan'),
        businessType: string(name='BusinessType'),
        startDate: string(name='StartDate'),
        endDate: string(name='EndDate'),
        resourceId: string(name='ResourceId'),
        flowOut: integer(name='FlowOut'),
      }
    ](name='Fee'),
  }(name='FeeList'),
  pager: {
    page: integer(name='Page'),
    total: integer(name='Total'),
    pageSize: integer(name='PageSize'),
  }(name='Pager'),
}

async function getFeeHistoryWithOptions(request: GetFeeHistoryRequest, runtime: Util.RuntimeOptions): GetFeeHistoryResponse {
  Util.validateModel(request);
  return doRequest('GetFeeHistory', 'HTTPS', 'GET', '2017-04-11', 'AK', request, null, runtime);
}

async function getFeeHistory(request: GetFeeHistoryRequest): GetFeeHistoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFeeHistoryWithOptions(request, runtime);
}

model GetExpenseSummaryRequest = {
  securityToken?: string(name='SecurityToken'),
  version: string(name='Version'),
  startDate?: string(name='StartDate'),
  endDate?: string(name='EndDate'),
  domain?: string(name='Domain'),
  region?: string(name='Region'),
  ispName?: string(name='IspName'),
  platformType?: string(name='PlatformType'),
  businessType?: string(name='BusinessType'),
}

model GetExpenseSummaryResponse = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  data: {
    totalTraffic: long(name='TotalTraffic'),
    totalUV: integer(name='TotalUV'),
    shareRate: float(name='ShareRate'),
    coverRate: float(name='CoverRate'),
    forecastFluency: float(name='ForecastFluency'),
    topBandwidth: long(name='TopBandwidth'),
  }(name='Data'),
}

async function getExpenseSummaryWithOptions(request: GetExpenseSummaryRequest, runtime: Util.RuntimeOptions): GetExpenseSummaryResponse {
  Util.validateModel(request);
  return doRequest('GetExpenseSummary', 'HTTPS', 'GET', '2017-04-11', 'AK', request, null, runtime);
}

async function getExpenseSummary(request: GetExpenseSummaryRequest): GetExpenseSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getExpenseSummaryWithOptions(request, runtime);
}

model GetDomainsRequest = {
  securityToken?: string(name='SecurityToken'),
  version: string(name='Version'),
  page: string(name='Page'),
  pageSize: string(name='PageSize'),
  domain?: string(name='Domain'),
}

model GetDomainsResponse = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  dataList: {
    usageData: [
      {
        resourceId: string(name='ResourceId'),
        domain: string(name='Domain'),
        businessType: string(name='BusinessType'),
        status: boolean(name='Status'),
        createdAt: string(name='CreatedAt'),
        updatedAt: string(name='UpdatedAt'),
        sliceFormat: string(name='SliceFormat'),
      }
    ](name='UsageData'),
  }(name='DataList'),
  pager: {
    page: integer(name='Page'),
    total: integer(name='Total'),
    pageSize: integer(name='PageSize'),
  }(name='Pager'),
}

async function getDomainsWithOptions(request: GetDomainsRequest, runtime: Util.RuntimeOptions): GetDomainsResponse {
  Util.validateModel(request);
  return doRequest('GetDomains', 'HTTPS', 'GET', '2017-04-11', 'AK', request, null, runtime);
}

async function getDomains(request: GetDomainsRequest): GetDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDomainsWithOptions(request, runtime);
}

model GetLogsListRequest = {
  securityToken?: string(name='SecurityToken'),
  version: string(name='Version'),
  domain?: string(name='Domain'),
  date?: string(name='Date'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
}

model GetLogsListResponse = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  logList: {
    log: [
      {
        url: string(name='Url'),
        fileName: string(name='FileName'),
        startDate: string(name='StartDate'),
        endDate: string(name='EndDate'),
      }
    ](name='Log'),
  }(name='LogList'),
}

async function getLogsListWithOptions(request: GetLogsListRequest, runtime: Util.RuntimeOptions): GetLogsListResponse {
  Util.validateModel(request);
  return doRequest('GetLogsList', 'HTTPS', 'GET', '2017-04-11', 'AK', request, null, runtime);
}

async function getLogsList(request: GetLogsListRequest): GetLogsListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLogsListWithOptions(request, runtime);
}

model GetFluencyDataRequest = {
  securityToken?: string(name='SecurityToken'),
  version: string(name='Version'),
  domain?: string(name='Domain'),
  region: string(name='Region'),
  ispName: string(name='IspName'),
  platformType: string(name='PlatformType'),
  businessType: string(name='BusinessType'),
  startDate: string(name='StartDate'),
  endDate: string(name='EndDate'),
}

model GetFluencyDataResponse = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  dataList: {
    usageData: [
      {
        date: string(name='Date'),
        values: {
          values: [ string ](name='Values', description='Values'),
        }(name='Values'),
      }
    ](name='UsageData'),
  }(name='DataList'),
  labels: {
    label: [ string ](name='Label'),
  }(name='Labels'),
}

async function getFluencyDataWithOptions(request: GetFluencyDataRequest, runtime: Util.RuntimeOptions): GetFluencyDataResponse {
  Util.validateModel(request);
  return doRequest('GetFluencyData', 'HTTPS', 'GET', '2017-04-11', 'AK', request, null, runtime);
}

async function getFluencyData(request: GetFluencyDataRequest): GetFluencyDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFluencyDataWithOptions(request, runtime);
}

model GetFirstFrameDelayDataRequest = {
  securityToken?: string(name='SecurityToken'),
  version: string(name='Version'),
  domain?: string(name='Domain'),
  region: string(name='Region'),
  ispName: string(name='IspName'),
  platformType: string(name='PlatformType'),
  businessType: string(name='BusinessType'),
  startDate: string(name='StartDate'),
  endDate: string(name='EndDate'),
}

model GetFirstFrameDelayDataResponse = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  dataList: {
    usageData: [
      {
        date: string(name='Date'),
        values: {
          values: [ string ](name='Values', description='Values'),
        }(name='Values'),
      }
    ](name='UsageData'),
  }(name='DataList'),
  labels: {
    label: [ string ](name='Label'),
  }(name='Labels'),
}

async function getFirstFrameDelayDataWithOptions(request: GetFirstFrameDelayDataRequest, runtime: Util.RuntimeOptions): GetFirstFrameDelayDataResponse {
  Util.validateModel(request);
  return doRequest('GetFirstFrameDelayData', 'HTTPS', 'GET', '2017-04-11', 'AK', request, null, runtime);
}

async function getFirstFrameDelayData(request: GetFirstFrameDelayDataRequest): GetFirstFrameDelayDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFirstFrameDelayDataWithOptions(request, runtime);
}

model GetTokenListRequest = {
  securityToken?: string(name='SecurityToken'),
  version: string(name='Version'),
}

model GetTokenListResponse = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  tokenList: {
    token: [
      {
        clientId: string(name='ClientId'),
        resourceId: string(name='ResourceId'),
        platformName: string(name='PlatformName'),
        platformType: string(name='PlatformType'),
        token: string(name='Token'),
        createdAt: string(name='CreatedAt'),
        updatedAt: string(name='UpdatedAt'),
      }
    ](name='Token'),
  }(name='TokenList'),
}

async function getTokenListWithOptions(request: GetTokenListRequest, runtime: Util.RuntimeOptions): GetTokenListResponse {
  Util.validateModel(request);
  return doRequest('GetTokenList', 'HTTPS', 'GET', '2017-04-11', 'AK', request, null, runtime);
}

async function getTokenList(request: GetTokenListRequest): GetTokenListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTokenListWithOptions(request, runtime);
}

model GetShareRateDataRequest = {
  securityToken?: string(name='SecurityToken'),
  version: string(name='Version'),
  domain?: string(name='Domain'),
  region: string(name='Region'),
  ispName: string(name='IspName'),
  platformType: string(name='PlatformType'),
  businessType: string(name='BusinessType'),
  startDate: string(name='StartDate'),
  endDate: string(name='EndDate'),
}

model GetShareRateDataResponse = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  dataList: {
    usageData: [
      {
        date: string(name='Date'),
        values: {
          values: [ string ](name='Values', description='Values'),
        }(name='Values'),
      }
    ](name='UsageData'),
  }(name='DataList'),
  labels: {
    label: [ string ](name='Label'),
  }(name='Labels'),
}

async function getShareRateDataWithOptions(request: GetShareRateDataRequest, runtime: Util.RuntimeOptions): GetShareRateDataResponse {
  Util.validateModel(request);
  return doRequest('GetShareRateData', 'HTTPS', 'GET', '2017-04-11', 'AK', request, null, runtime);
}

async function getShareRateData(request: GetShareRateDataRequest): GetShareRateDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return getShareRateDataWithOptions(request, runtime);
}

model GetTrafficDataRequest = {
  securityToken?: string(name='SecurityToken'),
  version: string(name='Version'),
  domain?: string(name='Domain'),
  region: string(name='Region'),
  ispName: string(name='IspName'),
  platformType: string(name='PlatformType'),
  businessType: string(name='BusinessType'),
  startDate: string(name='StartDate'),
  endDate: string(name='EndDate'),
}

model GetTrafficDataResponse = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  dataList: {
    usageData: [
      {
        date: string(name='Date'),
        values: {
          values: [ string ](name='Values', description='Values'),
        }(name='Values'),
      }
    ](name='UsageData'),
  }(name='DataList'),
  labels: {
    label: [ string ](name='Label'),
  }(name='Labels'),
}

async function getTrafficDataWithOptions(request: GetTrafficDataRequest, runtime: Util.RuntimeOptions): GetTrafficDataResponse {
  Util.validateModel(request);
  return doRequest('GetTrafficData', 'HTTPS', 'GET', '2017-04-11', 'AK', request, null, runtime);
}

async function getTrafficData(request: GetTrafficDataRequest): GetTrafficDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTrafficDataWithOptions(request, runtime);
}

model GetTrafficByRegionRequest = {
  securityToken?: string(name='SecurityToken'),
  version: string(name='Version'),
}

model GetTrafficByRegionResponse = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  trafficDataList: {
    trafficData: [
      {
        name: string(name='Name'),
        traffic: long(name='Traffic'),
      }
    ](name='TrafficData'),
  }(name='TrafficDataList'),
}

async function getTrafficByRegionWithOptions(request: GetTrafficByRegionRequest, runtime: Util.RuntimeOptions): GetTrafficByRegionResponse {
  Util.validateModel(request);
  return doRequest('GetTrafficByRegion', 'HTTPS', 'GET', '2017-04-11', 'AK', request, null, runtime);
}

async function getTrafficByRegion(request: GetTrafficByRegionRequest): GetTrafficByRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTrafficByRegionWithOptions(request, runtime);
}

model GetAllRegionsRequest = {
  securityToken?: string(name='SecurityToken'),
  version: string(name='Version'),
}

model GetAllRegionsResponse = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  dataList: {
    usageData: [
      {
        code: string(name='Code'),
        name: string(name='Name'),
      }
    ](name='UsageData'),
  }(name='DataList'),
}

async function getAllRegionsWithOptions(request: GetAllRegionsRequest, runtime: Util.RuntimeOptions): GetAllRegionsResponse {
  Util.validateModel(request);
  return doRequest('GetAllRegions', 'HTTPS', 'GET', '2017-04-11', 'AK', request, null, runtime);
}

async function getAllRegions(request: GetAllRegionsRequest): GetAllRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAllRegionsWithOptions(request, runtime);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
