/**
 *
 */
import Util;
import OpenApi;

import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  

  checkConfig(config);
  @endpoint = getEndpoint('cr', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model CancelRepoBuildRecordRequest {
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
  buildRecordId?: string(name='BuildRecordId'),
}

model CancelRepoBuildRecordResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
}

model CancelRepoBuildRecordResponse = {
  headers: map[string]string(name='headers'),
  body: CancelRepoBuildRecordResponseBody(name='body'),
}

async function cancelRepoBuildRecordWithOptions(request: CancelRepoBuildRecordRequest, runtime: Util.RuntimeOptions): CancelRepoBuildRecordResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CancelRepoBuildRecord', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function cancelRepoBuildRecord(request: CancelRepoBuildRecordRequest): CancelRepoBuildRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelRepoBuildRecordWithOptions(request, runtime);
}

model CreateBuildRecordByRuleRequest {
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
  buildRuleId?: string(name='BuildRuleId'),
}

model CreateBuildRecordByRuleResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  buildRecordId?: string(name='BuildRecordId'),
  code?: string(name='Code'),
}

model CreateBuildRecordByRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateBuildRecordByRuleResponseBody(name='body'),
}

async function createBuildRecordByRuleWithOptions(request: CreateBuildRecordByRuleRequest, runtime: Util.RuntimeOptions): CreateBuildRecordByRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateBuildRecordByRule', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createBuildRecordByRule(request: CreateBuildRecordByRuleRequest): CreateBuildRecordByRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBuildRecordByRuleWithOptions(request, runtime);
}

model CreateChartNamespaceRequest {
  instanceId?: string(name='InstanceId'),
  namespaceName?: string(name='NamespaceName'),
  autoCreateRepo?: boolean(name='AutoCreateRepo'),
  defaultRepoType?: string(name='DefaultRepoType'),
}

model CreateChartNamespaceResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
}

model CreateChartNamespaceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateChartNamespaceResponseBody(name='body'),
}

async function createChartNamespaceWithOptions(request: CreateChartNamespaceRequest, runtime: Util.RuntimeOptions): CreateChartNamespaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateChartNamespace', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createChartNamespace(request: CreateChartNamespaceRequest): CreateChartNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createChartNamespaceWithOptions(request, runtime);
}

model CreateChartRepositoryRequest {
  instanceId?: string(name='InstanceId'),
  repoName?: string(name='RepoName'),
  repoNamespaceName?: string(name='RepoNamespaceName'),
  repoType?: string(name='RepoType'),
  summary?: string(name='Summary'),
}

model CreateChartRepositoryResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  repoId?: string(name='RepoId'),
  code?: string(name='Code'),
}

model CreateChartRepositoryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateChartRepositoryResponseBody(name='body'),
}

async function createChartRepositoryWithOptions(request: CreateChartRepositoryRequest, runtime: Util.RuntimeOptions): CreateChartRepositoryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateChartRepository', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createChartRepository(request: CreateChartRepositoryRequest): CreateChartRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createChartRepositoryWithOptions(request, runtime);
}

model CreateInstanceEndpointAclPolicyRequest {
  instanceId?: string(name='InstanceId'),
  endpointType?: string(name='EndpointType'),
  entry?: string(name='Entry'),
  comment?: string(name='Comment'),
  moduleName?: string(name='ModuleName'),
}

model CreateInstanceEndpointAclPolicyResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
}

model CreateInstanceEndpointAclPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: CreateInstanceEndpointAclPolicyResponseBody(name='body'),
}

async function createInstanceEndpointAclPolicyWithOptions(request: CreateInstanceEndpointAclPolicyRequest, runtime: Util.RuntimeOptions): CreateInstanceEndpointAclPolicyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateInstanceEndpointAclPolicy', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createInstanceEndpointAclPolicy(request: CreateInstanceEndpointAclPolicyRequest): CreateInstanceEndpointAclPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createInstanceEndpointAclPolicyWithOptions(request, runtime);
}

model CreateInstanceVpcEndpointLinkedVpcRequest {
  instanceId?: string(name='InstanceId'),
  vpcId?: string(name='VpcId'),
  vswitchId?: string(name='VswitchId'),
  moduleName?: string(name='ModuleName'),
}

model CreateInstanceVpcEndpointLinkedVpcResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
}

model CreateInstanceVpcEndpointLinkedVpcResponse = {
  headers: map[string]string(name='headers'),
  body: CreateInstanceVpcEndpointLinkedVpcResponseBody(name='body'),
}

async function createInstanceVpcEndpointLinkedVpcWithOptions(request: CreateInstanceVpcEndpointLinkedVpcRequest, runtime: Util.RuntimeOptions): CreateInstanceVpcEndpointLinkedVpcResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateInstanceVpcEndpointLinkedVpc', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createInstanceVpcEndpointLinkedVpc(request: CreateInstanceVpcEndpointLinkedVpcRequest): CreateInstanceVpcEndpointLinkedVpcResponse {
  var runtime = new Util.RuntimeOptions{};
  return createInstanceVpcEndpointLinkedVpcWithOptions(request, runtime);
}

model CreateNamespaceRequest {
  instanceId?: string(name='InstanceId'),
  namespaceName?: string(name='NamespaceName'),
  autoCreateRepo?: boolean(name='AutoCreateRepo'),
  defaultRepoType?: string(name='DefaultRepoType'),
}

model CreateNamespaceResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
}

model CreateNamespaceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNamespaceResponseBody(name='body'),
}

async function createNamespaceWithOptions(request: CreateNamespaceRequest, runtime: Util.RuntimeOptions): CreateNamespaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateNamespace', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createNamespace(request: CreateNamespaceRequest): CreateNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNamespaceWithOptions(request, runtime);
}

model CreateRepoBuildRuleRequest {
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
  dockerfileLocation?: string(name='DockerfileLocation'),
  dockerfileName?: string(name='DockerfileName'),
  pushType?: string(name='PushType'),
  pushName?: string(name='PushName'),
  imageTag?: string(name='ImageTag'),
}

model CreateRepoBuildRuleResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  buildRuleId?: string(name='BuildRuleId'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
}

model CreateRepoBuildRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRepoBuildRuleResponseBody(name='body'),
}

async function createRepoBuildRuleWithOptions(request: CreateRepoBuildRuleRequest, runtime: Util.RuntimeOptions): CreateRepoBuildRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateRepoBuildRule', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createRepoBuildRule(request: CreateRepoBuildRuleRequest): CreateRepoBuildRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRepoBuildRuleWithOptions(request, runtime);
}

model CreateRepositoryRequest {
  instanceId?: string(name='InstanceId'),
  repoName?: string(name='RepoName'),
  repoNamespaceName?: string(name='RepoNamespaceName'),
  repoType?: string(name='RepoType'),
  summary?: string(name='Summary'),
  detail?: string(name='Detail'),
  tagImmutability?: boolean(name='TagImmutability'),
}

model CreateRepositoryResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  repoId?: string(name='RepoId'),
  code?: string(name='Code'),
}

model CreateRepositoryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRepositoryResponseBody(name='body'),
}

async function createRepositoryWithOptions(request: CreateRepositoryRequest, runtime: Util.RuntimeOptions): CreateRepositoryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateRepository', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createRepository(request: CreateRepositoryRequest): CreateRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRepositoryWithOptions(request, runtime);
}

model CreateRepoSyncRuleRequest {
  instanceId?: string(name='InstanceId'),
  namespaceName?: string(name='NamespaceName'),
  repoName?: string(name='RepoName'),
  targetRegionId?: string(name='TargetRegionId'),
  targetInstanceId?: string(name='TargetInstanceId'),
  targetNamespaceName?: string(name='TargetNamespaceName'),
  targetRepoName?: string(name='TargetRepoName'),
  tagFilter?: string(name='TagFilter'),
  syncScope?: string(name='SyncScope'),
  syncRuleName?: string(name='SyncRuleName'),
  syncTrigger?: string(name='SyncTrigger'),
}

model CreateRepoSyncRuleResponseBody = {
  syncRuleId?: string(name='SyncRuleId'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
}

model CreateRepoSyncRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRepoSyncRuleResponseBody(name='body'),
}

async function createRepoSyncRuleWithOptions(request: CreateRepoSyncRuleRequest, runtime: Util.RuntimeOptions): CreateRepoSyncRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateRepoSyncRule', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createRepoSyncRule(request: CreateRepoSyncRuleRequest): CreateRepoSyncRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRepoSyncRuleWithOptions(request, runtime);
}

model CreateRepoSyncTaskByRuleRequest {
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
  tag?: string(name='Tag'),
  syncRuleId?: string(name='SyncRuleId'),
}

model CreateRepoSyncTaskByRuleResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  syncTaskId?: string(name='SyncTaskId'),
}

model CreateRepoSyncTaskByRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRepoSyncTaskByRuleResponseBody(name='body'),
}

async function createRepoSyncTaskByRuleWithOptions(request: CreateRepoSyncTaskByRuleRequest, runtime: Util.RuntimeOptions): CreateRepoSyncTaskByRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateRepoSyncTaskByRule', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createRepoSyncTaskByRule(request: CreateRepoSyncTaskByRuleRequest): CreateRepoSyncTaskByRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRepoSyncTaskByRuleWithOptions(request, runtime);
}

model CreateRepoTagScanTaskRequest {
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
  tag?: string(name='Tag'),
}

model CreateRepoTagScanTaskResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
}

model CreateRepoTagScanTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRepoTagScanTaskResponseBody(name='body'),
}

async function createRepoTagScanTaskWithOptions(request: CreateRepoTagScanTaskRequest, runtime: Util.RuntimeOptions): CreateRepoTagScanTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateRepoTagScanTask', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createRepoTagScanTask(request: CreateRepoTagScanTaskRequest): CreateRepoTagScanTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRepoTagScanTaskWithOptions(request, runtime);
}

model CreateRepoTriggerRequest {
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
  triggerName?: string(name='TriggerName'),
  triggerUrl?: string(name='TriggerUrl'),
  triggerType?: string(name='TriggerType'),
  triggerTag?: string(name='TriggerTag'),
}

model CreateRepoTriggerResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  triggerId?: string(name='TriggerId'),
  code?: string(name='Code'),
}

model CreateRepoTriggerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRepoTriggerResponseBody(name='body'),
}

async function createRepoTriggerWithOptions(request: CreateRepoTriggerRequest, runtime: Util.RuntimeOptions): CreateRepoTriggerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateRepoTrigger', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createRepoTrigger(request: CreateRepoTriggerRequest): CreateRepoTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRepoTriggerWithOptions(request, runtime);
}

model DeleteChartNamespaceRequest {
  instanceId?: string(name='InstanceId'),
  namespaceName?: string(name='NamespaceName'),
}

model DeleteChartNamespaceResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
}

model DeleteChartNamespaceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteChartNamespaceResponseBody(name='body'),
}

async function deleteChartNamespaceWithOptions(request: DeleteChartNamespaceRequest, runtime: Util.RuntimeOptions): DeleteChartNamespaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteChartNamespace', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteChartNamespace(request: DeleteChartNamespaceRequest): DeleteChartNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteChartNamespaceWithOptions(request, runtime);
}

model DeleteChartReleaseRequest {
  instanceId?: string(name='InstanceId'),
  chart?: string(name='Chart'),
  release?: string(name='Release'),
  repoName?: string(name='RepoName'),
  repoNamespaceName?: string(name='RepoNamespaceName'),
}

model DeleteChartReleaseResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
}

model DeleteChartReleaseResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteChartReleaseResponseBody(name='body'),
}

async function deleteChartReleaseWithOptions(request: DeleteChartReleaseRequest, runtime: Util.RuntimeOptions): DeleteChartReleaseResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteChartRelease', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteChartRelease(request: DeleteChartReleaseRequest): DeleteChartReleaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteChartReleaseWithOptions(request, runtime);
}

model DeleteChartRepositoryRequest {
  instanceId?: string(name='InstanceId'),
  repoNamespaceName?: string(name='RepoNamespaceName'),
  repoName?: string(name='RepoName'),
}

model DeleteChartRepositoryResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
}

model DeleteChartRepositoryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteChartRepositoryResponseBody(name='body'),
}

async function deleteChartRepositoryWithOptions(request: DeleteChartRepositoryRequest, runtime: Util.RuntimeOptions): DeleteChartRepositoryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteChartRepository', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteChartRepository(request: DeleteChartRepositoryRequest): DeleteChartRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteChartRepositoryWithOptions(request, runtime);
}

model DeleteInstanceEndpointAclPolicyRequest {
  instanceId?: string(name='InstanceId'),
  endpointType?: string(name='EndpointType'),
  entry?: string(name='Entry'),
  moduleName?: string(name='ModuleName'),
}

model DeleteInstanceEndpointAclPolicyResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
}

model DeleteInstanceEndpointAclPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteInstanceEndpointAclPolicyResponseBody(name='body'),
}

async function deleteInstanceEndpointAclPolicyWithOptions(request: DeleteInstanceEndpointAclPolicyRequest, runtime: Util.RuntimeOptions): DeleteInstanceEndpointAclPolicyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteInstanceEndpointAclPolicy', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteInstanceEndpointAclPolicy(request: DeleteInstanceEndpointAclPolicyRequest): DeleteInstanceEndpointAclPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteInstanceEndpointAclPolicyWithOptions(request, runtime);
}

model DeleteInstanceVpcEndpointLinkedVpcRequest {
  instanceId?: string(name='InstanceId'),
  vpcId?: string(name='VpcId'),
  vswitchId?: string(name='VswitchId'),
  moduleName?: string(name='ModuleName'),
}

model DeleteInstanceVpcEndpointLinkedVpcResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
}

model DeleteInstanceVpcEndpointLinkedVpcResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteInstanceVpcEndpointLinkedVpcResponseBody(name='body'),
}

async function deleteInstanceVpcEndpointLinkedVpcWithOptions(request: DeleteInstanceVpcEndpointLinkedVpcRequest, runtime: Util.RuntimeOptions): DeleteInstanceVpcEndpointLinkedVpcResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteInstanceVpcEndpointLinkedVpc', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteInstanceVpcEndpointLinkedVpc(request: DeleteInstanceVpcEndpointLinkedVpcRequest): DeleteInstanceVpcEndpointLinkedVpcResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteInstanceVpcEndpointLinkedVpcWithOptions(request, runtime);
}

model DeleteNamespaceRequest {
  instanceId?: string(name='InstanceId'),
  namespaceName?: string(name='NamespaceName'),
}

model DeleteNamespaceResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
}

model DeleteNamespaceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNamespaceResponseBody(name='body'),
}

async function deleteNamespaceWithOptions(request: DeleteNamespaceRequest, runtime: Util.RuntimeOptions): DeleteNamespaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteNamespace', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteNamespace(request: DeleteNamespaceRequest): DeleteNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNamespaceWithOptions(request, runtime);
}

model DeleteRepoBuildRuleRequest {
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
  buildRuleId?: string(name='BuildRuleId'),
}

model DeleteRepoBuildRuleResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
}

model DeleteRepoBuildRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRepoBuildRuleResponseBody(name='body'),
}

async function deleteRepoBuildRuleWithOptions(request: DeleteRepoBuildRuleRequest, runtime: Util.RuntimeOptions): DeleteRepoBuildRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteRepoBuildRule', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteRepoBuildRule(request: DeleteRepoBuildRuleRequest): DeleteRepoBuildRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRepoBuildRuleWithOptions(request, runtime);
}

model DeleteRepositoryRequest {
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
}

model DeleteRepositoryResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
}

model DeleteRepositoryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRepositoryResponseBody(name='body'),
}

async function deleteRepositoryWithOptions(request: DeleteRepositoryRequest, runtime: Util.RuntimeOptions): DeleteRepositoryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteRepository', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteRepository(request: DeleteRepositoryRequest): DeleteRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRepositoryWithOptions(request, runtime);
}

model DeleteRepoSyncRuleRequest {
  instanceId?: string(name='InstanceId'),
  syncRuleId?: string(name='SyncRuleId'),
}

model DeleteRepoSyncRuleResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
}

model DeleteRepoSyncRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRepoSyncRuleResponseBody(name='body'),
}

async function deleteRepoSyncRuleWithOptions(request: DeleteRepoSyncRuleRequest, runtime: Util.RuntimeOptions): DeleteRepoSyncRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteRepoSyncRule', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteRepoSyncRule(request: DeleteRepoSyncRuleRequest): DeleteRepoSyncRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRepoSyncRuleWithOptions(request, runtime);
}

model DeleteRepoTagRequest {
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
  tag?: string(name='Tag'),
}

model DeleteRepoTagResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
}

model DeleteRepoTagResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRepoTagResponseBody(name='body'),
}

async function deleteRepoTagWithOptions(request: DeleteRepoTagRequest, runtime: Util.RuntimeOptions): DeleteRepoTagResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteRepoTag', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteRepoTag(request: DeleteRepoTagRequest): DeleteRepoTagResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRepoTagWithOptions(request, runtime);
}

model DeleteRepoTriggerRequest {
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
  triggerId?: string(name='TriggerId'),
}

model DeleteRepoTriggerResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
}

model DeleteRepoTriggerResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRepoTriggerResponseBody(name='body'),
}

async function deleteRepoTriggerWithOptions(request: DeleteRepoTriggerRequest, runtime: Util.RuntimeOptions): DeleteRepoTriggerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteRepoTrigger', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteRepoTrigger(request: DeleteRepoTriggerRequest): DeleteRepoTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRepoTriggerWithOptions(request, runtime);
}

model GetAuthorizationTokenRequest {
  instanceId?: string(name='InstanceId'),
}

model GetAuthorizationTokenResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  tempUsername?: string(name='TempUsername'),
  authorizationToken?: string(name='AuthorizationToken'),
  expireTime?: long(name='ExpireTime'),
  code?: string(name='Code'),
}

model GetAuthorizationTokenResponse = {
  headers: map[string]string(name='headers'),
  body: GetAuthorizationTokenResponseBody(name='body'),
}

async function getAuthorizationTokenWithOptions(request: GetAuthorizationTokenRequest, runtime: Util.RuntimeOptions): GetAuthorizationTokenResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetAuthorizationToken', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getAuthorizationToken(request: GetAuthorizationTokenRequest): GetAuthorizationTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAuthorizationTokenWithOptions(request, runtime);
}

model GetChartNamespaceRequest {
  instanceId?: string(name='InstanceId'),
  namespaceName?: string(name='NamespaceName'),
}

model GetChartNamespaceResponseBody = {
  namespaceStatus?: string(name='NamespaceStatus'),
  isSuccess?: boolean(name='IsSuccess'),
  namespaceName?: string(name='NamespaceName'),
  defaultRepoType?: string(name='DefaultRepoType'),
  requestId?: string(name='RequestId'),
  instanceId?: string(name='InstanceId'),
  autoCreateRepo?: boolean(name='AutoCreateRepo'),
  namespaceId?: string(name='NamespaceId'),
  code?: string(name='Code'),
}

model GetChartNamespaceResponse = {
  headers: map[string]string(name='headers'),
  body: GetChartNamespaceResponseBody(name='body'),
}

async function getChartNamespaceWithOptions(request: GetChartNamespaceRequest, runtime: Util.RuntimeOptions): GetChartNamespaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetChartNamespace', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getChartNamespace(request: GetChartNamespaceRequest): GetChartNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getChartNamespaceWithOptions(request, runtime);
}

model GetChartRepositoryRequest {
  instanceId?: string(name='InstanceId'),
  repoNamespaceName?: string(name='RepoNamespaceName'),
  repoName?: string(name='RepoName'),
}

model GetChartRepositoryResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  repoNamespaceName?: string(name='RepoNamespaceName'),
  requestId?: string(name='RequestId'),
  repoStatus?: string(name='RepoStatus'),
  repoType?: string(name='RepoType'),
  modifiedTime?: long(name='ModifiedTime'),
  instanceId?: string(name='InstanceId'),
  createTime?: long(name='CreateTime'),
  repoName?: string(name='RepoName'),
  summary?: string(name='Summary'),
  repoId?: string(name='RepoId'),
  code?: string(name='Code'),
}

model GetChartRepositoryResponse = {
  headers: map[string]string(name='headers'),
  body: GetChartRepositoryResponseBody(name='body'),
}

async function getChartRepositoryWithOptions(request: GetChartRepositoryRequest, runtime: Util.RuntimeOptions): GetChartRepositoryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetChartRepository', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getChartRepository(request: GetChartRepositoryRequest): GetChartRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getChartRepositoryWithOptions(request, runtime);
}

model GetInstanceRequest {
  instanceId?: string(name='InstanceId'),
}

model GetInstanceResponseBody = {
  instanceName?: string(name='InstanceName'),
  isSuccess?: boolean(name='IsSuccess'),
  modifiedTime?: long(name='ModifiedTime'),
  requestId?: string(name='RequestId'),
  instanceSpecification?: string(name='InstanceSpecification'),
  instanceId?: string(name='InstanceId'),
  instanceStatus?: string(name='InstanceStatus'),
  createTime?: long(name='CreateTime'),
  code?: string(name='Code'),
}

model GetInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: GetInstanceResponseBody(name='body'),
}

async function getInstanceWithOptions(request: GetInstanceRequest, runtime: Util.RuntimeOptions): GetInstanceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetInstance', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getInstance(request: GetInstanceRequest): GetInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceWithOptions(request, runtime);
}

model GetInstanceCountResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  count?: int32(name='Count'),
  code?: string(name='Code'),
}

model GetInstanceCountResponse = {
  headers: map[string]string(name='headers'),
  body: GetInstanceCountResponseBody(name='body'),
}

async function getInstanceCountWithOptions(runtime: Util.RuntimeOptions): GetInstanceCountResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('GetInstanceCount', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getInstanceCount(): GetInstanceCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceCountWithOptions(runtime);
}

model GetInstanceEndpointRequest {
  instanceId?: string(name='InstanceId'),
  endpointType?: string(name='EndpointType'),
  moduleName?: string(name='ModuleName'),
}

model GetInstanceEndpointResponseBody = {
  status?: string(name='Status'),
  domains?: [ 
    {
      type?: string(name='Type'),
      domain?: string(name='Domain'),
    }
  ](name='Domains'),
  aclEntries?: [ 
    {
      comment?: string(name='Comment'),
      entry?: string(name='Entry'),
    }
  ](name='AclEntries'),
  isSuccess?: boolean(name='IsSuccess'),
  aclEnable?: boolean(name='AclEnable'),
  requestId?: string(name='RequestId'),
  enable?: boolean(name='Enable'),
  code?: string(name='Code'),
}

model GetInstanceEndpointResponse = {
  headers: map[string]string(name='headers'),
  body: GetInstanceEndpointResponseBody(name='body'),
}

async function getInstanceEndpointWithOptions(request: GetInstanceEndpointRequest, runtime: Util.RuntimeOptions): GetInstanceEndpointResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetInstanceEndpoint', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getInstanceEndpoint(request: GetInstanceEndpointRequest): GetInstanceEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceEndpointWithOptions(request, runtime);
}

model GetInstanceUsageRequest {
  instanceId?: string(name='InstanceId'),
}

model GetInstanceUsageResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  repoQuota?: string(name='RepoQuota'),
  repoUsage?: string(name='RepoUsage'),
  namespaceQuota?: string(name='NamespaceQuota'),
  namespaceUsage?: string(name='NamespaceUsage'),
  code?: string(name='Code'),
}

model GetInstanceUsageResponse = {
  headers: map[string]string(name='headers'),
  body: GetInstanceUsageResponseBody(name='body'),
}

async function getInstanceUsageWithOptions(request: GetInstanceUsageRequest, runtime: Util.RuntimeOptions): GetInstanceUsageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetInstanceUsage', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getInstanceUsage(request: GetInstanceUsageRequest): GetInstanceUsageResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceUsageWithOptions(request, runtime);
}

model GetInstanceVpcEndpointRequest {
  instanceId?: string(name='InstanceId'),
  moduleName?: string(name='ModuleName'),
}

model GetInstanceVpcEndpointResponseBody = {
  domains?: [ string ](name='Domains'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  enable?: boolean(name='Enable'),
  code?: string(name='Code'),
  linkedVpcs?: [ 
    {
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
      defaultAccess?: boolean(name='DefaultAccess'),
      vswitchId?: string(name='VswitchId'),
      ip?: string(name='Ip'),
    }
  ](name='LinkedVpcs'),
}

model GetInstanceVpcEndpointResponse = {
  headers: map[string]string(name='headers'),
  body: GetInstanceVpcEndpointResponseBody(name='body'),
}

async function getInstanceVpcEndpointWithOptions(request: GetInstanceVpcEndpointRequest, runtime: Util.RuntimeOptions): GetInstanceVpcEndpointResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetInstanceVpcEndpoint', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getInstanceVpcEndpoint(request: GetInstanceVpcEndpointRequest): GetInstanceVpcEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceVpcEndpointWithOptions(request, runtime);
}

model GetNamespaceRequest {
  instanceId?: string(name='InstanceId'),
  namespaceName?: string(name='NamespaceName'),
  namespaceId?: string(name='NamespaceId'),
}

model GetNamespaceResponseBody = {
  namespaceStatus?: string(name='NamespaceStatus'),
  isSuccess?: boolean(name='IsSuccess'),
  namespaceName?: string(name='NamespaceName'),
  defaultRepoType?: string(name='DefaultRepoType'),
  requestId?: string(name='RequestId'),
  instanceId?: string(name='InstanceId'),
  autoCreateRepo?: boolean(name='AutoCreateRepo'),
  namespaceId?: string(name='NamespaceId'),
  code?: string(name='Code'),
}

model GetNamespaceResponse = {
  headers: map[string]string(name='headers'),
  body: GetNamespaceResponseBody(name='body'),
}

async function getNamespaceWithOptions(request: GetNamespaceRequest, runtime: Util.RuntimeOptions): GetNamespaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetNamespace', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getNamespace(request: GetNamespaceRequest): GetNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNamespaceWithOptions(request, runtime);
}

model GetRepoBuildRecordRequest {
  instanceId?: string(name='InstanceId'),
  buildRecordId?: string(name='BuildRecordId'),
}

model GetRepoBuildRecordResponseBody = {
  status?: string(name='Status'),
  isSuccess?: boolean(name='IsSuccess'),
  endTime?: long(name='EndTime'),
  requestId?: string(name='RequestId'),
  startTime?: long(name='StartTime'),
  buildRecordId?: string(name='BuildRecordId'),
  image?: {
    repoNamespaceName?: string(name='RepoNamespaceName'),
    imageTag?: string(name='ImageTag'),
    repoName?: string(name='RepoName'),
  }(name='Image'),
  code?: string(name='Code'),
}

model GetRepoBuildRecordResponse = {
  headers: map[string]string(name='headers'),
  body: GetRepoBuildRecordResponseBody(name='body'),
}

async function getRepoBuildRecordWithOptions(request: GetRepoBuildRecordRequest, runtime: Util.RuntimeOptions): GetRepoBuildRecordResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetRepoBuildRecord', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getRepoBuildRecord(request: GetRepoBuildRecordRequest): GetRepoBuildRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRepoBuildRecordWithOptions(request, runtime);
}

model GetRepoBuildRecordStatusRequest {
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
  buildRecordId?: string(name='BuildRecordId'),
}

model GetRepoBuildRecordStatusResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  buildStatus?: string(name='BuildStatus'),
  code?: string(name='Code'),
}

model GetRepoBuildRecordStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetRepoBuildRecordStatusResponseBody(name='body'),
}

async function getRepoBuildRecordStatusWithOptions(request: GetRepoBuildRecordStatusRequest, runtime: Util.RuntimeOptions): GetRepoBuildRecordStatusResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetRepoBuildRecordStatus', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getRepoBuildRecordStatus(request: GetRepoBuildRecordStatusRequest): GetRepoBuildRecordStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRepoBuildRecordStatusWithOptions(request, runtime);
}

model GetRepositoryRequest {
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
  repoNamespaceName?: string(name='RepoNamespaceName'),
  repoName?: string(name='RepoName'),
}

model GetRepositoryResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  repoNamespaceName?: string(name='RepoNamespaceName'),
  requestId?: string(name='RequestId'),
  instanceId?: string(name='InstanceId'),
  createTime?: long(name='CreateTime'),
  repoName?: string(name='RepoName'),
  code?: string(name='Code'),
  tagImmutability?: boolean(name='TagImmutability'),
  repoBuildType?: string(name='RepoBuildType'),
  repoStatus?: string(name='RepoStatus'),
  repoType?: string(name='RepoType'),
  modifiedTime?: long(name='ModifiedTime'),
  summary?: string(name='Summary'),
  repoId?: string(name='RepoId'),
  detail?: string(name='Detail'),
}

model GetRepositoryResponse = {
  headers: map[string]string(name='headers'),
  body: GetRepositoryResponseBody(name='body'),
}

async function getRepositoryWithOptions(request: GetRepositoryRequest, runtime: Util.RuntimeOptions): GetRepositoryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetRepository', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getRepository(request: GetRepositoryRequest): GetRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRepositoryWithOptions(request, runtime);
}

model GetRepoSyncTaskRequest {
  instanceId?: string(name='InstanceId'),
  syncTaskId?: string(name='SyncTaskId'),
}

model GetRepoSyncTaskResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  progress?: long(name='Progress'),
  requestId?: string(name='RequestId'),
  layerTasks?: [ 
    {
      syncedSize?: long(name='SyncedSize'),
      digest?: string(name='Digest'),
      taskStatus?: string(name='TaskStatus'),
      size?: long(name='Size'),
      syncLayerTaskId?: string(name='SyncLayerTaskId'),
    }
  ](name='LayerTasks'),
  taskStatus?: string(name='TaskStatus'),
  syncTaskId?: string(name='SyncTaskId'),
  code?: string(name='Code'),
  syncedSize?: long(name='SyncedSize'),
  syncRuleId?: string(name='SyncRuleId'),
  imageFrom?: {
    repoNamespaceName?: string(name='RepoNamespaceName'),
    instanceId?: string(name='InstanceId'),
    imageTag?: string(name='ImageTag'),
    repoName?: string(name='RepoName'),
    regionId?: string(name='RegionId'),
  }(name='ImageFrom'),
  taskTrigger?: string(name='TaskTrigger'),
  imageTo?: {
    repoNamespaceName?: string(name='RepoNamespaceName'),
    instanceId?: string(name='InstanceId'),
    imageTag?: string(name='ImageTag'),
    repoName?: string(name='RepoName'),
    regionId?: string(name='RegionId'),
  }(name='ImageTo'),
  syncBatchTaskId?: string(name='SyncBatchTaskId'),
}

model GetRepoSyncTaskResponse = {
  headers: map[string]string(name='headers'),
  body: GetRepoSyncTaskResponseBody(name='body'),
}

async function getRepoSyncTaskWithOptions(request: GetRepoSyncTaskRequest, runtime: Util.RuntimeOptions): GetRepoSyncTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetRepoSyncTask', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getRepoSyncTask(request: GetRepoSyncTaskRequest): GetRepoSyncTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRepoSyncTaskWithOptions(request, runtime);
}

model GetRepoTagLayersRequest {
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
  tag?: string(name='Tag'),
}

model GetRepoTagLayersResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  layers?: [ 
    {
      blobDigest?: string(name='BlobDigest'),
      layerIndex?: int32(name='LayerIndex'),
      layerInstruction?: string(name='LayerInstruction'),
      layerCMD?: string(name='LayerCMD'),
      blobSize?: long(name='BlobSize'),
    }
  ](name='Layers'),
}

model GetRepoTagLayersResponse = {
  headers: map[string]string(name='headers'),
  body: GetRepoTagLayersResponseBody(name='body'),
}

async function getRepoTagLayersWithOptions(request: GetRepoTagLayersRequest, runtime: Util.RuntimeOptions): GetRepoTagLayersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetRepoTagLayers', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getRepoTagLayers(request: GetRepoTagLayersRequest): GetRepoTagLayersResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRepoTagLayersWithOptions(request, runtime);
}

model GetRepoTagManifestRequest {
  instanceId?: string(name='InstanceId'),
  tag?: string(name='Tag'),
  schemaVersion?: int32(name='SchemaVersion'),
  repoId?: string(name='RepoId'),
}

model GetRepoTagManifestResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  manifest?: {
    history?: [ 
      {
        v1Compatibility?: map[string]any(name='V1Compatibility'),
      }
    ](name='History'),
    schemaVersion?: int32(name='SchemaVersion'),
    layers?: [ 
      {
        digest?: string(name='Digest'),
        size?: long(name='Size'),
        mediaType?: string(name='MediaType'),
      }
    ](name='Layers'),
    tag?: string(name='Tag'),
    name?: string(name='Name'),
    mediaType?: string(name='MediaType'),
    fsLayers?: [ 
      {
        blobSum?: string(name='BlobSum'),
      }
    ](name='FsLayers'),
    signatures?: [ 
      {
        signature?: string(name='Signature'),
        protected?: string(name='Protected'),
        header?: map[string]any(name='Header'),
      }
    ](name='Signatures'),
    config?: {
      digest?: string(name='Digest'),
      size?: long(name='Size'),
      mediaType?: string(name='MediaType'),
    }(name='Config'),
    architecture?: string(name='Architecture'),
  }(name='Manifest'),
  code?: string(name='Code'),
}

model GetRepoTagManifestResponse = {
  headers: map[string]string(name='headers'),
  body: GetRepoTagManifestResponseBody(name='body'),
}

async function getRepoTagManifestWithOptions(request: GetRepoTagManifestRequest, runtime: Util.RuntimeOptions): GetRepoTagManifestResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetRepoTagManifest', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getRepoTagManifest(request: GetRepoTagManifestRequest): GetRepoTagManifestResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRepoTagManifestWithOptions(request, runtime);
}

model GetRepoTagScanStatusRequest {
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
  tag?: string(name='Tag'),
  scanTaskId?: string(name='ScanTaskId'),
}

model GetRepoTagScanStatusResponseBody = {
  status?: string(name='Status'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
}

model GetRepoTagScanStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetRepoTagScanStatusResponseBody(name='body'),
}

async function getRepoTagScanStatusWithOptions(request: GetRepoTagScanStatusRequest, runtime: Util.RuntimeOptions): GetRepoTagScanStatusResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetRepoTagScanStatus', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getRepoTagScanStatus(request: GetRepoTagScanStatusRequest): GetRepoTagScanStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRepoTagScanStatusWithOptions(request, runtime);
}

model GetRepoTagScanSummaryRequest {
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
  tag?: string(name='Tag'),
  scanTaskId?: string(name='ScanTaskId'),
}

model GetRepoTagScanSummaryResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  lowSeverity?: int32(name='LowSeverity'),
  mediumSeverity?: int32(name='MediumSeverity'),
  highSeverity?: int32(name='HighSeverity'),
  unknownSeverity?: int32(name='UnknownSeverity'),
  code?: string(name='Code'),
  totalSeverity?: int32(name='TotalSeverity'),
}

model GetRepoTagScanSummaryResponse = {
  headers: map[string]string(name='headers'),
  body: GetRepoTagScanSummaryResponseBody(name='body'),
}

async function getRepoTagScanSummaryWithOptions(request: GetRepoTagScanSummaryRequest, runtime: Util.RuntimeOptions): GetRepoTagScanSummaryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetRepoTagScanSummary', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getRepoTagScanSummary(request: GetRepoTagScanSummaryRequest): GetRepoTagScanSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRepoTagScanSummaryWithOptions(request, runtime);
}

model ListChartNamespaceRequest {
  instanceId?: string(name='InstanceId'),
  namespaceStatus?: string(name='NamespaceStatus'),
  namespaceName?: string(name='NamespaceName'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
}

model ListChartNamespaceResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  namespaces?: [ 
    {
      defaultRepoType?: string(name='DefaultRepoType'),
      namespaceStatus?: string(name='NamespaceStatus'),
      namespaceId?: string(name='NamespaceId'),
      autoCreateRepo?: boolean(name='AutoCreateRepo'),
      instanceId?: string(name='InstanceId'),
      namespaceName?: string(name='NamespaceName'),
    }
  ](name='Namespaces'),
  totalCount?: string(name='TotalCount'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNo?: int32(name='PageNo'),
  code?: string(name='Code'),
}

model ListChartNamespaceResponse = {
  headers: map[string]string(name='headers'),
  body: ListChartNamespaceResponseBody(name='body'),
}

async function listChartNamespaceWithOptions(request: ListChartNamespaceRequest, runtime: Util.RuntimeOptions): ListChartNamespaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListChartNamespace', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listChartNamespace(request: ListChartNamespaceRequest): ListChartNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listChartNamespaceWithOptions(request, runtime);
}

model ListChartReleaseRequest {
  instanceId?: string(name='InstanceId'),
  repoName?: string(name='RepoName'),
  repoNamespaceName?: string(name='RepoNamespaceName'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  chart?: string(name='Chart'),
}

model ListChartReleaseResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  totalCount?: string(name='TotalCount'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  chartReleases?: [ 
    {
      status?: string(name='Status'),
      modifiedTime?: long(name='ModifiedTime'),
      repoId?: string(name='RepoId'),
      release?: string(name='Release'),
      size?: string(name='Size'),
      instanceId?: string(name='InstanceId'),
      chart?: string(name='Chart'),
    }
  ](name='ChartReleases'),
  pageNo?: int32(name='PageNo'),
  code?: string(name='Code'),
}

model ListChartReleaseResponse = {
  headers: map[string]string(name='headers'),
  body: ListChartReleaseResponseBody(name='body'),
}

async function listChartReleaseWithOptions(request: ListChartReleaseRequest, runtime: Util.RuntimeOptions): ListChartReleaseResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListChartRelease', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listChartRelease(request: ListChartReleaseRequest): ListChartReleaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return listChartReleaseWithOptions(request, runtime);
}

model ListChartRepositoryRequest {
  instanceId?: string(name='InstanceId'),
  repoStatus?: string(name='RepoStatus'),
  repoName?: string(name='RepoName'),
  repoNamespaceName?: string(name='RepoNamespaceName'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
}

model ListChartRepositoryResponseBody = {
  repositories?: [ 
    {
      summary?: string(name='Summary'),
      modifiedTime?: long(name='ModifiedTime'),
      repoId?: string(name='RepoId'),
      createTime?: long(name='CreateTime'),
      repoNamespaceName?: string(name='RepoNamespaceName'),
      instanceId?: string(name='InstanceId'),
      repoType?: string(name='RepoType'),
      repoStatus?: string(name='RepoStatus'),
      repoName?: string(name='RepoName'),
    }
  ](name='Repositories'),
  isSuccess?: boolean(name='IsSuccess'),
  totalCount?: string(name='TotalCount'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNo?: int32(name='PageNo'),
  code?: string(name='Code'),
}

model ListChartRepositoryResponse = {
  headers: map[string]string(name='headers'),
  body: ListChartRepositoryResponseBody(name='body'),
}

async function listChartRepositoryWithOptions(request: ListChartRepositoryRequest, runtime: Util.RuntimeOptions): ListChartRepositoryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListChartRepository', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listChartRepository(request: ListChartRepositoryRequest): ListChartRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return listChartRepositoryWithOptions(request, runtime);
}

model ListInstanceRequest {
  instanceName?: string(name='InstanceName'),
  instanceStatus?: string(name='InstanceStatus'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
}

model ListInstanceResponseBody = {
  instances?: [ 
    {
      modifiedTime?: string(name='ModifiedTime'),
      instanceName?: string(name='InstanceName'),
      createTime?: string(name='CreateTime'),
      instanceSpecification?: string(name='InstanceSpecification'),
      instanceStatus?: string(name='InstanceStatus'),
      instanceId?: string(name='InstanceId'),
      regionId?: string(name='RegionId'),
    }
  ](name='Instances'),
  isSuccess?: boolean(name='IsSuccess'),
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNo?: int32(name='PageNo'),
  code?: string(name='Code'),
}

model ListInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: ListInstanceResponseBody(name='body'),
}

async function listInstanceWithOptions(request: ListInstanceRequest, runtime: Util.RuntimeOptions): ListInstanceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListInstance', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listInstance(request: ListInstanceRequest): ListInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstanceWithOptions(request, runtime);
}

model ListInstanceEndpointRequest {
  instanceId?: string(name='InstanceId'),
  moduleName?: string(name='ModuleName'),
}

model ListInstanceEndpointResponseBody = {
  endpoints?: [ 
    {
      status?: string(name='Status'),
      domains?: [ 
        {
          type?: string(name='Type'),
          domain?: string(name='Domain'),
        }
      ](name='Domains'),
      endpointType?: string(name='EndpointType'),
      linkedVpcs?: [ 
        {
          vpcId?: string(name='VpcId'),
        }
      ](name='LinkedVpcs'),
      aclEnable?: boolean(name='AclEnable'),
      aclEntries?: [ 
        {
          entry?: string(name='Entry'),
        }
      ](name='AclEntries'),
      enable?: boolean(name='Enable'),
    }
  ](name='Endpoints'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
}

model ListInstanceEndpointResponse = {
  headers: map[string]string(name='headers'),
  body: ListInstanceEndpointResponseBody(name='body'),
}

async function listInstanceEndpointWithOptions(request: ListInstanceEndpointRequest, runtime: Util.RuntimeOptions): ListInstanceEndpointResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListInstanceEndpoint', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listInstanceEndpoint(request: ListInstanceEndpointRequest): ListInstanceEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstanceEndpointWithOptions(request, runtime);
}

model ListInstanceRegionRequest {
  lang?: string(name='Lang'),
}

model ListInstanceRegionResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  regions?: [ 
    {
      localName?: string(name='LocalName'),
      regionId?: string(name='RegionId'),
    }
  ](name='Regions'),
  code?: string(name='Code'),
}

model ListInstanceRegionResponse = {
  headers: map[string]string(name='headers'),
  body: ListInstanceRegionResponseBody(name='body'),
}

async function listInstanceRegionWithOptions(request: ListInstanceRegionRequest, runtime: Util.RuntimeOptions): ListInstanceRegionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListInstanceRegion', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listInstanceRegion(request: ListInstanceRegionRequest): ListInstanceRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstanceRegionWithOptions(request, runtime);
}

model ListNamespaceRequest {
  instanceId?: string(name='InstanceId'),
  namespaceStatus?: string(name='NamespaceStatus'),
  namespaceName?: string(name='NamespaceName'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
}

model ListNamespaceResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  namespaces?: [ 
    {
      defaultRepoType?: string(name='DefaultRepoType'),
      namespaceStatus?: string(name='NamespaceStatus'),
      namespaceId?: string(name='NamespaceId'),
      autoCreateRepo?: boolean(name='AutoCreateRepo'),
      instanceId?: string(name='InstanceId'),
      namespaceName?: string(name='NamespaceName'),
    }
  ](name='Namespaces'),
  totalCount?: string(name='TotalCount'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNo?: int32(name='PageNo'),
  code?: string(name='Code'),
}

model ListNamespaceResponse = {
  headers: map[string]string(name='headers'),
  body: ListNamespaceResponseBody(name='body'),
}

async function listNamespaceWithOptions(request: ListNamespaceRequest, runtime: Util.RuntimeOptions): ListNamespaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListNamespace', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listNamespace(request: ListNamespaceRequest): ListNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNamespaceWithOptions(request, runtime);
}

model ListRepoBuildRecordRequest {
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
}

model ListRepoBuildRecordResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  buildRecords?: [ 
    {
      endTime?: string(name='EndTime'),
      startTime?: string(name='StartTime'),
      image?: {
        repoId?: string(name='RepoId'),
        repoNamespaceName?: string(name='RepoNamespaceName'),
        imageTag?: string(name='ImageTag'),
        repoName?: string(name='RepoName'),
      }(name='Image'),
      buildStatus?: string(name='BuildStatus'),
      buildRecordId?: string(name='BuildRecordId'),
    }
  ](name='BuildRecords'),
  totalCount?: string(name='TotalCount'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNo?: int32(name='PageNo'),
  code?: string(name='Code'),
}

model ListRepoBuildRecordResponse = {
  headers: map[string]string(name='headers'),
  body: ListRepoBuildRecordResponseBody(name='body'),
}

async function listRepoBuildRecordWithOptions(request: ListRepoBuildRecordRequest, runtime: Util.RuntimeOptions): ListRepoBuildRecordResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListRepoBuildRecord', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listRepoBuildRecord(request: ListRepoBuildRecordRequest): ListRepoBuildRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRepoBuildRecordWithOptions(request, runtime);
}

model ListRepoBuildRecordLogRequest {
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
  buildRecordId?: string(name='BuildRecordId'),
  offset?: int32(name='Offset'),
}

model ListRepoBuildRecordLogResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  buildRecordLogs?: [ 
    {
      lineNumber?: int32(name='LineNumber'),
      message?: string(name='Message'),
      buildStage?: string(name='BuildStage'),
    }
  ](name='BuildRecordLogs'),
  totalCount?: string(name='TotalCount'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNo?: int32(name='PageNo'),
  code?: string(name='Code'),
}

model ListRepoBuildRecordLogResponse = {
  headers: map[string]string(name='headers'),
  body: ListRepoBuildRecordLogResponseBody(name='body'),
}

async function listRepoBuildRecordLogWithOptions(request: ListRepoBuildRecordLogRequest, runtime: Util.RuntimeOptions): ListRepoBuildRecordLogResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListRepoBuildRecordLog', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listRepoBuildRecordLog(request: ListRepoBuildRecordLogRequest): ListRepoBuildRecordLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRepoBuildRecordLogWithOptions(request, runtime);
}

model ListRepoBuildRuleRequest {
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
}

model ListRepoBuildRuleResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  totalCount?: string(name='TotalCount'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  buildRules?: [ 
    {
      dockerfileLocation?: string(name='DockerfileLocation'),
      buildRuleId?: string(name='BuildRuleId'),
      pushType?: string(name='PushType'),
      pushName?: string(name='PushName'),
      imageTag?: string(name='ImageTag'),
      dockerfileName?: string(name='DockerfileName'),
    }
  ](name='BuildRules'),
  pageNo?: int32(name='PageNo'),
  code?: string(name='Code'),
}

model ListRepoBuildRuleResponse = {
  headers: map[string]string(name='headers'),
  body: ListRepoBuildRuleResponseBody(name='body'),
}

async function listRepoBuildRuleWithOptions(request: ListRepoBuildRuleRequest, runtime: Util.RuntimeOptions): ListRepoBuildRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListRepoBuildRule', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listRepoBuildRule(request: ListRepoBuildRuleRequest): ListRepoBuildRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRepoBuildRuleWithOptions(request, runtime);
}

model ListRepositoryRequest {
  instanceId?: string(name='InstanceId'),
  repoStatus?: string(name='RepoStatus'),
  repoName?: string(name='RepoName'),
  repoNamespaceName?: string(name='RepoNamespaceName'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
}

model ListRepositoryResponseBody = {
  repositories?: [ 
    {
      summary?: string(name='Summary'),
      repoBuildType?: string(name='RepoBuildType'),
      modifiedTime?: long(name='ModifiedTime'),
      repoId?: string(name='RepoId'),
      createTime?: long(name='CreateTime'),
      repoNamespaceName?: string(name='RepoNamespaceName'),
      tagImmutability?: boolean(name='TagImmutability'),
      instanceId?: string(name='InstanceId'),
      repoType?: string(name='RepoType'),
      repoStatus?: string(name='RepoStatus'),
      repoName?: string(name='RepoName'),
    }
  ](name='Repositories'),
  isSuccess?: boolean(name='IsSuccess'),
  totalCount?: string(name='TotalCount'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNo?: int32(name='PageNo'),
  code?: string(name='Code'),
}

model ListRepositoryResponse = {
  headers: map[string]string(name='headers'),
  body: ListRepositoryResponseBody(name='body'),
}

async function listRepositoryWithOptions(request: ListRepositoryRequest, runtime: Util.RuntimeOptions): ListRepositoryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListRepository', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listRepository(request: ListRepositoryRequest): ListRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRepositoryWithOptions(request, runtime);
}

model ListRepoSyncRuleRequest {
  instanceId?: string(name='InstanceId'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  namespaceName?: string(name='NamespaceName'),
  repoName?: string(name='RepoName'),
  targetInstanceId?: string(name='TargetInstanceId'),
  targetRegionId?: string(name='TargetRegionId'),
}

model ListRepoSyncRuleResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  syncRules?: [ 
    {
      syncTrigger?: string(name='SyncTrigger'),
      createTime?: long(name='CreateTime'),
      localRegionId?: string(name='LocalRegionId'),
      syncScope?: string(name='SyncScope'),
      tagFilter?: string(name='TagFilter'),
      targetNamespaceName?: string(name='TargetNamespaceName'),
      targetRepoName?: string(name='TargetRepoName'),
      targetInstanceId?: string(name='TargetInstanceId'),
      syncRuleId?: string(name='SyncRuleId'),
      modifiedTime?: long(name='ModifiedTime'),
      syncRuleName?: string(name='SyncRuleName'),
      targetRegionId?: string(name='TargetRegionId'),
      localInstanceId?: string(name='LocalInstanceId'),
      localNamespaceName?: string(name='LocalNamespaceName'),
      localRepoName?: string(name='LocalRepoName'),
      syncDirection?: string(name='SyncDirection'),
    }
  ](name='SyncRules'),
  pageNo?: int32(name='PageNo'),
  code?: string(name='Code'),
}

model ListRepoSyncRuleResponse = {
  headers: map[string]string(name='headers'),
  body: ListRepoSyncRuleResponseBody(name='body'),
}

async function listRepoSyncRuleWithOptions(request: ListRepoSyncRuleRequest, runtime: Util.RuntimeOptions): ListRepoSyncRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListRepoSyncRule', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listRepoSyncRule(request: ListRepoSyncRuleRequest): ListRepoSyncRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRepoSyncRuleWithOptions(request, runtime);
}

model ListRepoSyncTaskRequest {
  instanceId?: string(name='InstanceId'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  syncRecordId?: string(name='SyncRecordId'),
}

model ListRepoSyncTaskResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  totalCount?: string(name='TotalCount'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNo?: int32(name='PageNo'),
  syncTasks?: [ 
    {
      modifedTime?: long(name='ModifedTime'),
      syncRuleId?: string(name='SyncRuleId'),
      syncTaskId?: string(name='SyncTaskId'),
      taskStatus?: string(name='TaskStatus'),
      createTime?: long(name='CreateTime'),
      syncBatchTaskId?: string(name='SyncBatchTaskId'),
      taskTrigger?: string(name='TaskTrigger'),
      imageTo?: {
        repoNamespaceName?: string(name='RepoNamespaceName'),
        instanceId?: string(name='InstanceId'),
        imageTag?: string(name='ImageTag'),
        repoName?: string(name='RepoName'),
        regionId?: string(name='RegionId'),
      }(name='ImageTo'),
      imageFrom?: {
        repoNamespaceName?: string(name='RepoNamespaceName'),
        instanceId?: string(name='InstanceId'),
        imageTag?: string(name='ImageTag'),
        repoName?: string(name='RepoName'),
        regionId?: string(name='RegionId'),
      }(name='ImageFrom'),
    }
  ](name='SyncTasks'),
  code?: string(name='Code'),
}

model ListRepoSyncTaskResponse = {
  headers: map[string]string(name='headers'),
  body: ListRepoSyncTaskResponseBody(name='body'),
}

async function listRepoSyncTaskWithOptions(request: ListRepoSyncTaskRequest, runtime: Util.RuntimeOptions): ListRepoSyncTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListRepoSyncTask', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listRepoSyncTask(request: ListRepoSyncTaskRequest): ListRepoSyncTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRepoSyncTaskWithOptions(request, runtime);
}

model ListRepoTagRequest {
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
}

model ListRepoTagResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  totalCount?: string(name='TotalCount'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  images?: [ 
    {
      status?: string(name='Status'),
      imageSize?: long(name='ImageSize'),
      imageCreate?: string(name='ImageCreate'),
      digest?: string(name='Digest'),
      imageUpdate?: string(name='ImageUpdate'),
      tag?: string(name='Tag'),
      imageId?: string(name='ImageId'),
    }
  ](name='Images'),
  pageNo?: int32(name='PageNo'),
  code?: string(name='Code'),
}

model ListRepoTagResponse = {
  headers: map[string]string(name='headers'),
  body: ListRepoTagResponseBody(name='body'),
}

async function listRepoTagWithOptions(request: ListRepoTagRequest, runtime: Util.RuntimeOptions): ListRepoTagResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListRepoTag', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listRepoTag(request: ListRepoTagRequest): ListRepoTagResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRepoTagWithOptions(request, runtime);
}

model ListRepoTagScanResultRequest {
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
  tag?: string(name='Tag'),
  scanTaskId?: string(name='ScanTaskId'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  severity?: string(name='Severity'),
}

model ListRepoTagScanResultResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNo?: int32(name='PageNo'),
  vulnerabilities?: [ 
    {
      severity?: string(name='Severity'),
      addedBy?: string(name='AddedBy'),
      cveName?: string(name='CveName'),
      description?: string(name='Description'),
      feature?: string(name='Feature'),
      version?: string(name='Version'),
      versionFormat?: string(name='VersionFormat'),
      cveLink?: string(name='CveLink'),
      versionFixed?: string(name='VersionFixed'),
    }
  ](name='Vulnerabilities'),
  code?: string(name='Code'),
}

model ListRepoTagScanResultResponse = {
  headers: map[string]string(name='headers'),
  body: ListRepoTagScanResultResponseBody(name='body'),
}

async function listRepoTagScanResultWithOptions(request: ListRepoTagScanResultRequest, runtime: Util.RuntimeOptions): ListRepoTagScanResultResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListRepoTagScanResult', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listRepoTagScanResult(request: ListRepoTagScanResultRequest): ListRepoTagScanResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRepoTagScanResultWithOptions(request, runtime);
}

model ListRepoTriggerRequest {
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
}

model ListRepoTriggerResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  triggers?: [ 
    {
      triggerName?: string(name='TriggerName'),
      repoEvent?: string(name='RepoEvent'),
      triggerId?: string(name='TriggerId'),
      triggerUrl?: string(name='TriggerUrl'),
      triggerType?: string(name='TriggerType'),
      triggerTag?: string(name='TriggerTag'),
    }
  ](name='Triggers'),
  code?: string(name='Code'),
}

model ListRepoTriggerResponse = {
  headers: map[string]string(name='headers'),
  body: ListRepoTriggerResponseBody(name='body'),
}

async function listRepoTriggerWithOptions(request: ListRepoTriggerRequest, runtime: Util.RuntimeOptions): ListRepoTriggerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListRepoTrigger', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listRepoTrigger(request: ListRepoTriggerRequest): ListRepoTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRepoTriggerWithOptions(request, runtime);
}

model ListRepoTriggerRecordRequest {
  instanceId?: string(name='InstanceId'),
  triggerRecordId?: string(name='TriggerRecordId'),
}

model ListRepoTriggerRecordResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  repoTriggerRecords?: [ 
    {
      requestHeaders?: string(name='RequestHeaders'),
      responseHeaders?: string(name='ResponseHeaders'),
      triggerName?: string(name='TriggerName'),
      triggerLogId?: string(name='TriggerLogId'),
      requestBody?: string(name='RequestBody'),
      triggerUrl?: string(name='TriggerUrl'),
      responseBody?: string(name='ResponseBody'),
      triggerTag?: string(name='TriggerTag'),
      triggerType?: string(name='TriggerType'),
      statusCode?: string(name='StatusCode'),
      repoEvent?: string(name='RepoEvent'),
      triggerId?: string(name='TriggerId'),
      requestTime?: long(name='RequestTime'),
    }
  ](name='RepoTriggerRecords'),
  code?: string(name='Code'),
}

model ListRepoTriggerRecordResponse = {
  headers: map[string]string(name='headers'),
  body: ListRepoTriggerRecordResponseBody(name='body'),
}

async function listRepoTriggerRecordWithOptions(request: ListRepoTriggerRecordRequest, runtime: Util.RuntimeOptions): ListRepoTriggerRecordResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListRepoTriggerRecord', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listRepoTriggerRecord(request: ListRepoTriggerRecordRequest): ListRepoTriggerRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRepoTriggerRecordWithOptions(request, runtime);
}

model ResetLoginPasswordRequest {
  instanceId?: string(name='InstanceId'),
  password?: string(name='Password'),
}

model ResetLoginPasswordResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
}

model ResetLoginPasswordResponse = {
  headers: map[string]string(name='headers'),
  body: ResetLoginPasswordResponseBody(name='body'),
}

async function resetLoginPasswordWithOptions(request: ResetLoginPasswordRequest, runtime: Util.RuntimeOptions): ResetLoginPasswordResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ResetLoginPassword', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function resetLoginPassword(request: ResetLoginPasswordRequest): ResetLoginPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetLoginPasswordWithOptions(request, runtime);
}

model UpdateChartNamespaceRequest {
  instanceId?: string(name='InstanceId'),
  namespaceName?: string(name='NamespaceName'),
  autoCreateRepo?: boolean(name='AutoCreateRepo'),
  defaultRepoType?: string(name='DefaultRepoType'),
}

model UpdateChartNamespaceResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
}

model UpdateChartNamespaceResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateChartNamespaceResponseBody(name='body'),
}

async function updateChartNamespaceWithOptions(request: UpdateChartNamespaceRequest, runtime: Util.RuntimeOptions): UpdateChartNamespaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateChartNamespace', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateChartNamespace(request: UpdateChartNamespaceRequest): UpdateChartNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateChartNamespaceWithOptions(request, runtime);
}

model UpdateChartRepositoryRequest {
  instanceId?: string(name='InstanceId'),
  repoType?: string(name='RepoType'),
  summary?: string(name='Summary'),
  repoNamespaceName?: string(name='RepoNamespaceName'),
  repoName?: string(name='RepoName'),
}

model UpdateChartRepositoryResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
}

model UpdateChartRepositoryResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateChartRepositoryResponseBody(name='body'),
}

async function updateChartRepositoryWithOptions(request: UpdateChartRepositoryRequest, runtime: Util.RuntimeOptions): UpdateChartRepositoryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateChartRepository', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateChartRepository(request: UpdateChartRepositoryRequest): UpdateChartRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateChartRepositoryWithOptions(request, runtime);
}

model UpdateInstanceEndpointStatusRequest {
  instanceId?: string(name='InstanceId'),
  endpointType?: string(name='EndpointType'),
  enable?: boolean(name='Enable'),
  moduleName?: string(name='ModuleName'),
}

model UpdateInstanceEndpointStatusResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
}

model UpdateInstanceEndpointStatusResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateInstanceEndpointStatusResponseBody(name='body'),
}

async function updateInstanceEndpointStatusWithOptions(request: UpdateInstanceEndpointStatusRequest, runtime: Util.RuntimeOptions): UpdateInstanceEndpointStatusResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateInstanceEndpointStatus', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateInstanceEndpointStatus(request: UpdateInstanceEndpointStatusRequest): UpdateInstanceEndpointStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateInstanceEndpointStatusWithOptions(request, runtime);
}

model UpdateNamespaceRequest {
  instanceId?: string(name='InstanceId'),
  namespaceName?: string(name='NamespaceName'),
  autoCreateRepo?: boolean(name='AutoCreateRepo'),
  defaultRepoType?: string(name='DefaultRepoType'),
}

model UpdateNamespaceResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
}

model UpdateNamespaceResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateNamespaceResponseBody(name='body'),
}

async function updateNamespaceWithOptions(request: UpdateNamespaceRequest, runtime: Util.RuntimeOptions): UpdateNamespaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateNamespace', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateNamespace(request: UpdateNamespaceRequest): UpdateNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateNamespaceWithOptions(request, runtime);
}

model UpdateRepoBuildRuleRequest {
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
  dockerfileLocation?: string(name='DockerfileLocation'),
  dockerfileName?: string(name='DockerfileName'),
  pushType?: string(name='PushType'),
  pushName?: string(name='PushName'),
  imageTag?: string(name='ImageTag'),
  buildRuleId?: string(name='BuildRuleId'),
}

model UpdateRepoBuildRuleResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  buildRuleId?: string(name='BuildRuleId'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
}

model UpdateRepoBuildRuleResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateRepoBuildRuleResponseBody(name='body'),
}

async function updateRepoBuildRuleWithOptions(request: UpdateRepoBuildRuleRequest, runtime: Util.RuntimeOptions): UpdateRepoBuildRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateRepoBuildRule', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateRepoBuildRule(request: UpdateRepoBuildRuleRequest): UpdateRepoBuildRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateRepoBuildRuleWithOptions(request, runtime);
}

model UpdateRepositoryRequest {
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
  repoType?: string(name='RepoType'),
  summary?: string(name='Summary'),
  detail?: string(name='Detail'),
  tagImmutability?: boolean(name='TagImmutability'),
}

model UpdateRepositoryResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
}

model UpdateRepositoryResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateRepositoryResponseBody(name='body'),
}

async function updateRepositoryWithOptions(request: UpdateRepositoryRequest, runtime: Util.RuntimeOptions): UpdateRepositoryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateRepository', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateRepository(request: UpdateRepositoryRequest): UpdateRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateRepositoryWithOptions(request, runtime);
}

model UpdateRepoTriggerRequest {
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
  triggerName?: string(name='TriggerName'),
  triggerUrl?: string(name='TriggerUrl'),
  triggerType?: string(name='TriggerType'),
  triggerTag?: string(name='TriggerTag'),
  triggerId?: string(name='TriggerId'),
}

model UpdateRepoTriggerResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
}

model UpdateRepoTriggerResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateRepoTriggerResponseBody(name='body'),
}

async function updateRepoTriggerWithOptions(request: UpdateRepoTriggerRequest, runtime: Util.RuntimeOptions): UpdateRepoTriggerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateRepoTrigger', '2018-12-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateRepoTrigger(request: UpdateRepoTriggerRequest): UpdateRepoTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateRepoTriggerWithOptions(request, runtime);
}

