import Util;
import ROA;
import ROAUtil;
import EndpointUtil;

extends ROA;

const version = '2017-08-01';

init(config: ROA.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-2-pop = 'edas.ap-northeast-1.aliyuncs.com',
    ap-south-1 = 'edas.ap-northeast-1.aliyuncs.com',
    ap-southeast-3 = 'edas.ap-northeast-1.aliyuncs.com',
    ap-southeast-5 = 'edas.ap-northeast-1.aliyuncs.com',
    cn-beijing-finance-1 = 'edas.aliyuncs.com',
    cn-beijing-finance-pop = 'edas.aliyuncs.com',
    cn-beijing-gov-1 = 'edas.aliyuncs.com',
    cn-beijing-nu16-b01 = 'edas.aliyuncs.com',
    cn-chengdu = 'edas.aliyuncs.com',
    cn-edge-1 = 'edas.aliyuncs.com',
    cn-fujian = 'edas.aliyuncs.com',
    cn-haidian-cm12-c01 = 'edas.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'edas.aliyuncs.com',
    cn-hangzhou-finance = 'edas.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'edas.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'edas.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'edas.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'edas.aliyuncs.com',
    cn-hangzhou-test-306 = 'edas.aliyuncs.com',
    cn-hongkong-finance-pop = 'edas.aliyuncs.com',
    cn-huhehaote = 'edas.aliyuncs.com',
    cn-qingdao-nebula = 'edas.aliyuncs.com',
    cn-shanghai-et15-b01 = 'edas.aliyuncs.com',
    cn-shanghai-et2-b01 = 'edas.aliyuncs.com',
    cn-shanghai-finance-1 = 'edas.aliyuncs.com',
    cn-shanghai-inner = 'edas.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'edas.aliyuncs.com',
    cn-shenzhen-finance-1 = 'edas.aliyuncs.com',
    cn-shenzhen-inner = 'edas.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'edas.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'edas.aliyuncs.com',
    cn-wuhan = 'edas.aliyuncs.com',
    cn-yushanfang = 'edas.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'edas.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'edas.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'edas.aliyuncs.com',
    eu-west-1 = 'edas.ap-northeast-1.aliyuncs.com',
    eu-west-1-oxs = 'edas.ap-northeast-1.aliyuncs.com',
    me-east-1 = 'edas.ap-northeast-1.aliyuncs.com',
    rus-west-1-pop = 'edas.ap-northeast-1.aliyuncs.com',
    us-west-1 = 'edas.ap-northeast-1.aliyuncs.com',
  };

  checkConfig(config);
  @endpointHost = getEndpoint('edas', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpointHost);
}


model CreateModuleQuery = {
  clusterId: string(name='ClusterId'),
  moduleName: string(name='ModuleName'),
}

model CreateModuleBody = {
  values?: string(name='Values'),
}

model CreateModuleRequest = {
  headers?: map[string]string(name='headers'),
  query: CreateModuleQuery(name='query'),
  body?: CreateModuleBody(name='body'),
}

model CreateModuleResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  result: string(name='Result'),
}

model CreateModuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateModuleResponseBody(name='body'),
}

async function createModuleWithOptions(request: CreateModuleRequest, runtime: Util.RuntimeOptions): CreateModuleResponse {
  Util.validateModel(request);
  return doRequestWithAction('CreateModule', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/oam/feature/module_actions`, Util.stringifyMapValue(request.query), request.headers, request.body, runtime);
}

async function createModule(request: CreateModuleRequest): CreateModuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createModuleWithOptions(request, runtime);
}

model UpdateK8sApplicationBaseInfoQuery = {
  appId: string(name='AppId'),
  description?: string(name='Description'),
  owner?: string(name='Owner'),
}

model UpdateK8sApplicationBaseInfoRequest = {
  headers?: map[string]string(name='headers'),
  query: UpdateK8sApplicationBaseInfoQuery(name='query'),
}

model UpdateK8sApplicationBaseInfoResponseBody = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  message: string(name='Message'),
  result: string(name='Result'),
}

model UpdateK8sApplicationBaseInfoResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateK8sApplicationBaseInfoResponseBody(name='body'),
}

async function updateK8sApplicationBaseInfoWithOptions(request: UpdateK8sApplicationBaseInfoRequest, runtime: Util.RuntimeOptions): UpdateK8sApplicationBaseInfoResponse {
  Util.validateModel(request);
  return doRequestWithAction('UpdateK8sApplicationBaseInfo', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/oam/update_app_basic_info`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function updateK8sApplicationBaseInfo(request: UpdateK8sApplicationBaseInfoRequest): UpdateK8sApplicationBaseInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateK8sApplicationBaseInfoWithOptions(request, runtime);
}

model ScaleoutApplicationWithNewInstancesQuery = {
  appId: string(name='AppId'),
  groupId: string(name='GroupId'),
  scalingNum: integer(name='ScalingNum'),
  templateId?: string(name='TemplateId'),
  templateVersion?: string(name='TemplateVersion'),
  scalingPolicy?: string(name='ScalingPolicy'),
  templateInstanceId?: string(name='TemplateInstanceId'),
  clusterId?: string(name='ClusterId'),
  instanceChargeType?: string(name='InstanceChargeType'),
  instanceChargePeriodUnit?: string(name='InstanceChargePeriodUnit'),
  instanceChargePeriod?: integer(name='InstanceChargePeriod'),
  autoRenew?: boolean(name='AutoRenew'),
  autoRenewPeriod?: integer(name='AutoRenewPeriod'),
}

model ScaleoutApplicationWithNewInstancesRequest = {
  headers?: map[string]string(name='headers'),
  query: ScaleoutApplicationWithNewInstancesQuery(name='query'),
}

model ScaleoutApplicationWithNewInstancesResponseBody = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  message: string(name='Message'),
  changeOrderId: string(name='ChangeOrderId'),
  instanceIds: [ string ](name='InstanceIds'),
}

model ScaleoutApplicationWithNewInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ScaleoutApplicationWithNewInstancesResponseBody(name='body'),
}

async function scaleoutApplicationWithNewInstancesWithOptions(request: ScaleoutApplicationWithNewInstancesRequest, runtime: Util.RuntimeOptions): ScaleoutApplicationWithNewInstancesResponse {
  Util.validateModel(request);
  return doRequestWithAction('ScaleoutApplicationWithNewInstances', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/scaling/scale_out`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function scaleoutApplicationWithNewInstances(request: ScaleoutApplicationWithNewInstancesRequest): ScaleoutApplicationWithNewInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return scaleoutApplicationWithNewInstancesWithOptions(request, runtime);
}

model GetK8sClusterQuery = {
  regionTag: string(name='RegionTag'),
  currentPage?: integer(name='CurrentPage'),
  pageSize?: integer(name='PageSize'),
  clusterType?: integer(name='ClusterType'),
}

model GetK8sClusterRequest = {
  headers?: map[string]string(name='headers'),
  query: GetK8sClusterQuery(name='query'),
}

model GetK8sClusterResponseBody = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  message: string(name='Message'),
  clusterPage: {
    currentPage: integer(name='CurrentPage'),
    pageSize: integer(name='PageSize'),
    totalSize: integer(name='TotalSize'),
    clusterList: {
      cluster: [
        {
          clusterId: string(name='ClusterId'),
          clusterImportStatus: integer(name='ClusterImportStatus'),
          clusterName: string(name='ClusterName'),
          clusterStatus: integer(name='ClusterStatus'),
          clusterType: integer(name='ClusterType'),
          regionId: string(name='RegionId'),
          vpcId: string(name='VpcId'),
          vswitchId: string(name='VswitchId'),
          subNetCidr: string(name='SubNetCidr'),
          csClusterStatus: string(name='CsClusterStatus'),
          csClusterId: string(name='CsClusterId'),
          description: string(name='Description'),
          nodeNum: integer(name='NodeNum'),
          cpu: integer(name='Cpu'),
          mem: integer(name='Mem'),
          networkMode: integer(name='NetworkMode'),
        }
      ](name='Cluster'),
    }(name='ClusterList'),
  }(name='ClusterPage'),
}

model GetK8sClusterResponse = {
  headers: map[string]string(name='headers'),
  body: GetK8sClusterResponseBody(name='body'),
}

async function getK8sClusterWithOptions(request: GetK8sClusterRequest, runtime: Util.RuntimeOptions): GetK8sClusterResponse {
  Util.validateModel(request);
  return doRequestWithAction('GetK8sCluster', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/k8s_clusters`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function getK8sCluster(request: GetK8sClusterRequest): GetK8sClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return getK8sClusterWithOptions(request, runtime);
}

model CreateIDCImportCommandBody = {
  clusterId: string(name='ClusterId'),
}

model CreateIDCImportCommandRequest = {
  headers?: map[string]string(name='headers'),
  body: CreateIDCImportCommandBody(name='body'),
}

model CreateIDCImportCommandResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: string(name='Data'),
}

model CreateIDCImportCommandResponse = {
  headers: map[string]string(name='headers'),
  body: CreateIDCImportCommandResponseBody(name='body'),
}

async function createIDCImportCommandWithOptions(request: CreateIDCImportCommandRequest, runtime: Util.RuntimeOptions): CreateIDCImportCommandResponse {
  Util.validateModel(request);
  return doRequestWithAction('CreateIDCImportCommand', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/create_idc_import_command`, null, request.headers, request.body, runtime);
}

async function createIDCImportCommand(request: CreateIDCImportCommandRequest): CreateIDCImportCommandResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIDCImportCommandWithOptions(request, runtime);
}

model ListOperationLogsQuery = {
  appId?: string(name='AppId'),
  beginTime?: long(name='BeginTime'),
  endTime?: long(name='EndTime'),
  userId?: string(name='UserId'),
  currentPage?: integer(name='CurrentPage'),
  pageSize?: integer(name='PageSize'),
}

model ListOperationLogsRequest = {
  headers?: map[string]string(name='headers'),
  query?: ListOperationLogsQuery(name='query'),
}

model ListOperationLogsResponseBody = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  message: string(name='Message'),
  totalSize: integer(name='TotalSize'),
  currentPage: integer(name='CurrentPage'),
  pageSize: integer(name='PageSize'),
  logList: [
    {
      actionGroup: string(name='ActionGroup'),
      actionName: string(name='ActionName'),
      beginTime: long(name='BeginTime'),
      endTime: long(name='EndTime'),
      operatorName: string(name='OperatorName'),
      operatorId: string(name='OperatorId'),
      source: string(name='Source'),
      status: string(name='Status'),
      message: string(name='Message'),
      extraParameters: string(name='ExtraParameters'),
      appId: string(name='AppId'),
    }
  ](name='LogList'),
}

model ListOperationLogsResponse = {
  headers: map[string]string(name='headers'),
  body: ListOperationLogsResponseBody(name='body'),
}

async function listOperationLogsWithOptions(request: ListOperationLogsRequest, runtime: Util.RuntimeOptions): ListOperationLogsResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListOperationLogs', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/operationlog/log_list`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function listOperationLogs(request: ListOperationLogsRequest): ListOperationLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listOperationLogsWithOptions(request, runtime);
}

model ListRootStacksQuery = {
  currentPage?: integer(name='CurrentPage'),
  pageSize?: integer(name='PageSize'),
}

model ListRootStacksRequest = {
  headers?: map[string]string(name='headers'),
  query?: ListRootStacksQuery(name='query'),
}

model ListRootStacksResponseBody = {
  requestId: string(name='RequestId'),
  message: string(name='Message'),
  code: integer(name='Code'),
  data: {
    currentPage: integer(name='CurrentPage'),
    pageSize: integer(name='PageSize'),
    totalSize: integer(name='TotalSize'),
    result: [
      {
        children: [
          {
            id: long(name='Id'),
            name: string(name='Name'),
            icon: string(name='Icon'),
            comment: string(name='Comment'),
          }
        ](name='Children'),
        root: {
          id: long(name='Id'),
          name: string(name='Name'),
        }(name='Root'),
      }
    ](name='Result'),
  }(name='Data'),
}

model ListRootStacksResponse = {
  headers: map[string]string(name='headers'),
  body: ListRootStacksResponseBody(name='body'),
}

async function listRootStacksWithOptions(request: ListRootStacksRequest, runtime: Util.RuntimeOptions): ListRootStacksResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListRootStacks', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/s2i/list_root_stack`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function listRootStacks(request: ListRootStacksRequest): ListRootStacksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRootStacksWithOptions(request, runtime);
}

model ListChildrenStacksQuery = {
  stackId: long(name='StackId'),
  currentPage?: integer(name='CurrentPage'),
  pageSize?: integer(name='PageSize'),
}

model ListChildrenStacksRequest = {
  headers?: map[string]string(name='headers'),
  query: ListChildrenStacksQuery(name='query'),
}

model ListChildrenStacksResponseBody = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  message: string(name='Message'),
  data: {
    pageSize: integer(name='PageSize'),
    totalSize: integer(name='TotalSize'),
    currentPage: integer(name='CurrentPage'),
    result: [
      {
        id: long(name='Id'),
        name: string(name='Name'),
        comment: string(name='Comment'),
        preferred: boolean(name='Preferred'),
        latest: boolean(name='Latest'),
        buildTypes: [ string ](name='BuildTypes'),
      }
    ](name='Result'),
  }(name='Data'),
}

model ListChildrenStacksResponse = {
  headers: map[string]string(name='headers'),
  body: ListChildrenStacksResponseBody(name='body'),
}

async function listChildrenStacksWithOptions(request: ListChildrenStacksRequest, runtime: Util.RuntimeOptions): ListChildrenStacksResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListChildrenStacks', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/s2i/list_children_stack`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function listChildrenStacks(request: ListChildrenStacksRequest): ListChildrenStacksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listChildrenStacksWithOptions(request, runtime);
}

model StartK8sApplicationQuery = {
  replicas?: integer(name='Replicas'),
  timeout?: integer(name='Timeout'),
  appId: string(name='AppId'),
}

model StartK8sApplicationRequest = {
  headers?: map[string]string(name='headers'),
  query: StartK8sApplicationQuery(name='query'),
}

model StartK8sApplicationResponseBody = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  message: string(name='Message'),
  changeOrderId: string(name='ChangeOrderId'),
}

model StartK8sApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: StartK8sApplicationResponseBody(name='body'),
}

async function startK8sApplicationWithOptions(request: StartK8sApplicationRequest, runtime: Util.RuntimeOptions): StartK8sApplicationResponse {
  Util.validateModel(request);
  return doRequestWithAction('StartK8sApplication', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/k8s/acs/start_k8s_app`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function startK8sApplication(request: StartK8sApplicationRequest): StartK8sApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return startK8sApplicationWithOptions(request, runtime);
}

model RestartK8sApplicationQuery = {
  appId: string(name='AppId'),
  timeout?: integer(name='Timeout'),
}

model RestartK8sApplicationRequest = {
  headers?: map[string]string(name='headers'),
  query: RestartK8sApplicationQuery(name='query'),
}

model RestartK8sApplicationResponseBody = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  message: string(name='Message'),
  changeOrderId: string(name='ChangeOrderId'),
}

model RestartK8sApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: RestartK8sApplicationResponseBody(name='body'),
}

async function restartK8sApplicationWithOptions(request: RestartK8sApplicationRequest, runtime: Util.RuntimeOptions): RestartK8sApplicationResponse {
  Util.validateModel(request);
  return doRequestWithAction('RestartK8sApplication', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/k8s/acs/restart_k8s_app`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function restartK8sApplication(request: RestartK8sApplicationRequest): RestartK8sApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return restartK8sApplicationWithOptions(request, runtime);
}

model BindEcsSlbQuery = {
  appId: string(name='AppId'),
  slbId: string(name='SlbId'),
  listenerPort: integer(name='ListenerPort'),
  VServerGroupId?: string(name='VServerGroupId'),
  listenerProtocol: string(name='ListenerProtocol'),
  deployGroupId?: string(name='DeployGroupId'),
  VServerGroupName?: string(name='VServerGroupName'),
  listenerHealthCheckUrl?: string(name='ListenerHealthCheckUrl'),
  VForwardingUrlRule?: string(name='VForwardingUrlRule'),
}

model BindEcsSlbRequest = {
  headers?: map[string]string(name='headers'),
  query: BindEcsSlbQuery(name='query'),
}

model BindEcsSlbResponseBody = {
  requestId: string(name='RequestId'),
  message: string(name='Message'),
  code: integer(name='Code'),
  changeOrderId: string(name='ChangeOrderId'),
}

model BindEcsSlbResponse = {
  headers: map[string]string(name='headers'),
  body: BindEcsSlbResponseBody(name='body'),
}

async function bindEcsSlbWithOptions(request: BindEcsSlbRequest, runtime: Util.RuntimeOptions): BindEcsSlbResponse {
  Util.validateModel(request);
  return doRequestWithAction('BindEcsSlb', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/app/slb/bind_slb`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function bindEcsSlb(request: BindEcsSlbRequest): BindEcsSlbResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindEcsSlbWithOptions(request, runtime);
}

model StopK8sApplicationQuery = {
  appId: string(name='AppId'),
  timeout?: integer(name='Timeout'),
}

model StopK8sApplicationRequest = {
  headers?: map[string]string(name='headers'),
  query: StopK8sApplicationQuery(name='query'),
}

model StopK8sApplicationResponseBody = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  message: string(name='Message'),
  changeOrderId: string(name='ChangeOrderId'),
}

model StopK8sApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: StopK8sApplicationResponseBody(name='body'),
}

async function stopK8sApplicationWithOptions(request: StopK8sApplicationRequest, runtime: Util.RuntimeOptions): StopK8sApplicationResponse {
  Util.validateModel(request);
  return doRequestWithAction('StopK8sApplication', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/k8s/acs/stop_k8s_app`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function stopK8sApplication(request: StopK8sApplicationRequest): StopK8sApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopK8sApplicationWithOptions(request, runtime);
}

model ConvertK8sResourceQuery = {
  resourceType: string(name='ResourceType'),
  resourceName: string(name='ResourceName'),
  namespace: string(name='Namespace'),
  clusterId: string(name='ClusterId'),
}

model ConvertK8sResourceRequest = {
  headers?: map[string]string(name='headers'),
  query: ConvertK8sResourceQuery(name='query'),
}

model ConvertK8sResourceResponseBody = {
  requestId: string(name='RequestId'),
  message: string(name='Message'),
  code: integer(name='Code'),
}

model ConvertK8sResourceResponse = {
  headers: map[string]string(name='headers'),
  body: ConvertK8sResourceResponseBody(name='body'),
}

async function convertK8sResourceWithOptions(request: ConvertK8sResourceRequest, runtime: Util.RuntimeOptions): ConvertK8sResourceResponse {
  Util.validateModel(request);
  return doRequestWithAction('ConvertK8sResource', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/oam/k8s_resource_convert`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function convertK8sResource(request: ConvertK8sResourceRequest): ConvertK8sResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return convertK8sResourceWithOptions(request, runtime);
}

model UpdateSlsLogStoreBody = {
  appId: string(name='AppId'),
  configs: string(name='Configs'),
}

model UpdateSlsLogStoreRequest = {
  headers?: map[string]string(name='headers'),
  body: UpdateSlsLogStoreBody(name='body'),
}

model UpdateSlsLogStoreResponseBody = {
  requestId: string(name='RequestId'),
  message: string(name='Message'),
  code: integer(name='Code'),
}

model UpdateSlsLogStoreResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateSlsLogStoreResponseBody(name='body'),
}

async function updateSlsLogStoreWithOptions(request: UpdateSlsLogStoreRequest, runtime: Util.RuntimeOptions): UpdateSlsLogStoreResponse {
  Util.validateModel(request);
  return doRequestWithAction('UpdateSlsLogStore', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/k8s/sls/update_sls_log_store`, null, request.headers, request.body, runtime);
}

async function updateSlsLogStore(request: UpdateSlsLogStoreRequest): UpdateSlsLogStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSlsLogStoreWithOptions(request, runtime);
}

model QueryK8sClusterLogProjectInfoQuery = {
  clusterId: string(name='ClusterId'),
}

model QueryK8sClusterLogProjectInfoRequest = {
  headers?: map[string]string(name='headers'),
  query: QueryK8sClusterLogProjectInfoQuery(name='query'),
}

model QueryK8sClusterLogProjectInfoResponseBody = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  message: string(name='Message'),
  projectInfo: {
    projectName: string(name='ProjectName'),
  }(name='ProjectInfo'),
}

model QueryK8sClusterLogProjectInfoResponse = {
  headers: map[string]string(name='headers'),
  body: QueryK8sClusterLogProjectInfoResponseBody(name='body'),
}

async function queryK8sClusterLogProjectInfoWithOptions(request: QueryK8sClusterLogProjectInfoRequest, runtime: Util.RuntimeOptions): QueryK8sClusterLogProjectInfoResponse {
  Util.validateModel(request);
  return doRequestWithAction('QueryK8sClusterLogProjectInfo', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/k8s/sls/project`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function queryK8sClusterLogProjectInfo(request: QueryK8sClusterLogProjectInfoRequest): QueryK8sClusterLogProjectInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryK8sClusterLogProjectInfoWithOptions(request, runtime);
}

model QuerySlsLogStoreListQuery = {
  appId: string(name='AppId'),
  type: string(name='Type'),
  pageSize?: integer(name='PageSize'),
  currentPage?: integer(name='CurrentPage'),
}

model QuerySlsLogStoreListRequest = {
  headers?: map[string]string(name='headers'),
  query: QuerySlsLogStoreListQuery(name='query'),
}

model QuerySlsLogStoreListResponseBody = {
  totalSize: integer(name='TotalSize'),
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  message: string(name='Message'),
  result: [
    {
      logstore: string(name='Logstore'),
      project: string(name='Project'),
      link: string(name='Link'),
      consumerSide: string(name='ConsumerSide'),
      createTime: string(name='CreateTime'),
      source: string(name='Source'),
    }
  ](name='Result'),
}

model QuerySlsLogStoreListResponse = {
  headers: map[string]string(name='headers'),
  body: QuerySlsLogStoreListResponseBody(name='body'),
}

async function querySlsLogStoreListWithOptions(request: QuerySlsLogStoreListRequest, runtime: Util.RuntimeOptions): QuerySlsLogStoreListResponse {
  Util.validateModel(request);
  return doRequestWithAction('QuerySlsLogStoreList', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/k8s/sls/query_sls_log_store_list`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function querySlsLogStoreList(request: QuerySlsLogStoreListRequest): QuerySlsLogStoreListResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySlsLogStoreListWithOptions(request, runtime);
}

model GetSubAccountInfoQuery = {
  targetUserId: string(name='TargetUserId'),
}

model GetSubAccountInfoRequest = {
  headers?: map[string]string(name='headers'),
  query: GetSubAccountInfoQuery(name='query'),
}

model GetSubAccountInfoResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  authorization: {
    adminUserId: string(name='AdminUserId'),
    adminEdasId: string(name='AdminEdasId'),
    userId: string(name='UserId'),
    edasId: string(name='EdasId'),
    appIdData: string(name='AppIdData'),
    roleIdData: string(name='RoleIdData'),
    createTime: long(name='CreateTime'),
    updateTime: long(name='UpdateTime'),
    resGroupId: long(name='ResGroupId'),
    resGroupIdData: string(name='ResGroupIdData'),
    isRamSlave: boolean(name='IsRamSlave'),
    isRamDel: boolean(name='IsRamDel'),
    subUserKp: string(name='SubUserKp'),
    ramOperation: boolean(name='RamOperation'),
    delegateAdmin: boolean(name='DelegateAdmin'),
    sts: boolean(name='Sts'),
  }(name='Authorization'),
}

model GetSubAccountInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetSubAccountInfoResponseBody(name='body'),
}

async function getSubAccountInfoWithOptions(request: GetSubAccountInfoRequest, runtime: Util.RuntimeOptions): GetSubAccountInfoResponse {
  Util.validateModel(request);
  return doRequestWithAction('GetSubAccountInfo', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/account/sub_account_info`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function getSubAccountInfo(request: GetSubAccountInfoRequest): GetSubAccountInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSubAccountInfoWithOptions(request, runtime);
}

model DelegateAdminRoleQuery = {
  targetUserId: string(name='TargetUserId'),
}

model DelegateAdminRoleRequest = {
  headers?: map[string]string(name='headers'),
  query: DelegateAdminRoleQuery(name='query'),
}

model DelegateAdminRoleResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

model DelegateAdminRoleResponse = {
  headers: map[string]string(name='headers'),
  body: DelegateAdminRoleResponseBody(name='body'),
}

async function delegateAdminRoleWithOptions(request: DelegateAdminRoleRequest, runtime: Util.RuntimeOptions): DelegateAdminRoleResponse {
  Util.validateModel(request);
  return doRequestWithAction('DelegateAdminRole', '2017-08-01', 'HTTPS', 'PUT', 'AK', `/pop/v5/account/delegate_admin_role`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function delegateAdminRole(request: DelegateAdminRoleRequest): DelegateAdminRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return delegateAdminRoleWithOptions(request, runtime);
}

model RestartApplicationQuery = {
  appId: string(name='AppId'),
  eccInfo?: string(name='EccInfo'),
}

model RestartApplicationRequest = {
  headers?: map[string]string(name='headers'),
  query: RestartApplicationQuery(name='query'),
}

model RestartApplicationResponseBody = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  message: string(name='Message'),
  changeOrderId: string(name='ChangeOrderId'),
}

model RestartApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: RestartApplicationResponseBody(name='body'),
}

async function restartApplicationWithOptions(request: RestartApplicationRequest, runtime: Util.RuntimeOptions): RestartApplicationResponse {
  Util.validateModel(request);
  return doRequestWithAction('RestartApplication', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/changeorder/co_restart`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function restartApplication(request: RestartApplicationRequest): RestartApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return restartApplicationWithOptions(request, runtime);
}

model DeleteLogPathQuery = {
  appId: string(name='AppId'),
  path?: string(name='Path'),
}

model DeleteLogPathRequest = {
  headers?: map[string]string(name='headers'),
  query: DeleteLogPathQuery(name='query'),
}

model DeleteLogPathResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
}

model DeleteLogPathResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteLogPathResponseBody(name='body'),
}

async function deleteLogPathWithOptions(request: DeleteLogPathRequest, runtime: Util.RuntimeOptions): DeleteLogPathResponse {
  Util.validateModel(request);
  return doRequestWithAction('DeleteLogPath', '2017-08-01', 'HTTPS', 'DELETE', 'AK', `/pop/v5/log/popListLogDirs`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function deleteLogPath(request: DeleteLogPathRequest): DeleteLogPathResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLogPathWithOptions(request, runtime);
}

model AddLogPathBody = {
  appId: string(name='AppId'),
  path: string(name='Path'),
}

model AddLogPathRequest = {
  headers?: map[string]string(name='headers'),
  body: AddLogPathBody(name='body'),
}

model AddLogPathResponseBody = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  message: string(name='Message'),
}

model AddLogPathResponse = {
  headers: map[string]string(name='headers'),
  body: AddLogPathResponseBody(name='body'),
}

async function addLogPathWithOptions(request: AddLogPathRequest, runtime: Util.RuntimeOptions): AddLogPathResponse {
  Util.validateModel(request);
  return doRequestWithAction('AddLogPath', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/log/popListLogDirs`, null, request.headers, request.body, runtime);
}

async function addLogPath(request: AddLogPathRequest): AddLogPathResponse {
  var runtime = new Util.RuntimeOptions{};
  return addLogPathWithOptions(request, runtime);
}

model UpdateK8sResourceBody = {
  clusterId?: string(name='ClusterId'),
  namespace?: string(name='Namespace'),
  resourceContent?: string(name='ResourceContent'),
}

model UpdateK8sResourceRequest = {
  headers?: map[string]string(name='headers'),
  body?: UpdateK8sResourceBody(name='body'),
}

model UpdateK8sResourceResponseBody = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  message: string(name='Message'),
}

model UpdateK8sResourceResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateK8sResourceResponseBody(name='body'),
}

async function updateK8sResourceWithOptions(request: UpdateK8sResourceRequest, runtime: Util.RuntimeOptions): UpdateK8sResourceResponse {
  Util.validateModel(request);
  return doRequestWithAction('UpdateK8sResource', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/oam/update_k8s_resource_config`, null, request.headers, request.body, runtime);
}

async function updateK8sResource(request: UpdateK8sResourceRequest): UpdateK8sResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateK8sResourceWithOptions(request, runtime);
}

model AbortChangeOrderQuery = {
  changeOrderId: string(name='ChangeOrderId'),
}

model AbortChangeOrderRequest = {
  headers?: map[string]string(name='headers'),
  query: AbortChangeOrderQuery(name='query'),
}

model AbortChangeOrderResponseBody = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  errorCode: string(name='ErrorCode'),
  message: string(name='Message'),
  traceId: string(name='TraceId'),
  data: {
    changeOrderId: string(name='ChangeOrderId'),
  }(name='Data'),
}

model AbortChangeOrderResponse = {
  headers: map[string]string(name='headers'),
  body: AbortChangeOrderResponseBody(name='body'),
}

async function abortChangeOrderWithOptions(request: AbortChangeOrderRequest, runtime: Util.RuntimeOptions): AbortChangeOrderResponse {
  Util.validateModel(request);
  return doRequestWithAction('AbortChangeOrder', '2017-08-01', 'HTTPS', 'PUT', 'AK', `/pop/v5/changeorder/change_order_abort`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function abortChangeOrder(request: AbortChangeOrderRequest): AbortChangeOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return abortChangeOrderWithOptions(request, runtime);
}

model RollbackChangeOrderQuery = {
  changeOrderId: string(name='ChangeOrderId'),
}

model RollbackChangeOrderRequest = {
  headers?: map[string]string(name='headers'),
  query: RollbackChangeOrderQuery(name='query'),
}

model RollbackChangeOrderResponseBody = {
  code: integer(name='Code'),
  errorCode: string(name='ErrorCode'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  traceId: string(name='TraceId'),
  data: {
    changeOrderId: string(name='ChangeOrderId'),
  }(name='Data'),
}

model RollbackChangeOrderResponse = {
  headers: map[string]string(name='headers'),
  body: RollbackChangeOrderResponseBody(name='body'),
}

async function rollbackChangeOrderWithOptions(request: RollbackChangeOrderRequest, runtime: Util.RuntimeOptions): RollbackChangeOrderResponse {
  Util.validateModel(request);
  return doRequestWithAction('RollbackChangeOrder', '2017-08-01', 'HTTPS', 'PUT', 'AK', `/pop/v5/oam/changeorder/rollback`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function rollbackChangeOrder(request: RollbackChangeOrderRequest): RollbackChangeOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return rollbackChangeOrderWithOptions(request, runtime);
}

model AbortAndRollbackChangeOrderQuery = {
  changeOrderId: string(name='ChangeOrderId'),
}

model AbortAndRollbackChangeOrderRequest = {
  headers?: map[string]string(name='headers'),
  query: AbortAndRollbackChangeOrderQuery(name='query'),
}

model AbortAndRollbackChangeOrderResponseBody = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  errorCode: string(name='ErrorCode'),
  message: string(name='Message'),
  traceId: string(name='TraceId'),
  data: {
    changeOrderId: string(name='ChangeOrderId'),
  }(name='Data'),
}

model AbortAndRollbackChangeOrderResponse = {
  headers: map[string]string(name='headers'),
  body: AbortAndRollbackChangeOrderResponseBody(name='body'),
}

async function abortAndRollbackChangeOrderWithOptions(request: AbortAndRollbackChangeOrderRequest, runtime: Util.RuntimeOptions): AbortAndRollbackChangeOrderResponse {
  Util.validateModel(request);
  return doRequestWithAction('AbortAndRollbackChangeOrder', '2017-08-01', 'HTTPS', 'PUT', 'AK', `/pop/v5/changeorder/change_order_abort_and_rollback`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function abortAndRollbackChangeOrder(request: AbortAndRollbackChangeOrderRequest): AbortAndRollbackChangeOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return abortAndRollbackChangeOrderWithOptions(request, runtime);
}

model GetScalingRulesQuery = {
  appId: string(name='AppId'),
  groupId: string(name='GroupId'),
  mode?: string(name='Mode'),
}

model GetScalingRulesRequest = {
  headers?: map[string]string(name='headers'),
  query: GetScalingRulesQuery(name='query'),
}

model GetScalingRulesResponseBody = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  message: string(name='Message'),
  updateTime: long(name='UpdateTime'),
  data: {
    clusterType: integer(name='ClusterType'),
    oversoldFactor: integer(name='OversoldFactor'),
    vpcId: string(name='VpcId'),
    updateTime: long(name='UpdateTime'),
    ruleList: {
      rule: [
        {
          appId: string(name='AppId'),
          groupId: string(name='GroupId'),
          enable: boolean(name='Enable'),
          mode: string(name='Mode'),
          cond: string(name='Cond'),
          cpu: integer(name='Cpu'),
          rt: integer(name='Rt'),
          resourceFrom: string(name='ResourceFrom'),
          step: integer(name='Step'),
          instNum: integer(name='InstNum'),
          loadNum: integer(name='LoadNum'),
          templateId: string(name='TemplateId'),
          templateVersion: integer(name='TemplateVersion'),
          vpcId: string(name='VpcId'),
          metricType: string(name='MetricType'),
          vSwitchIds: string(name='VSwitchIds'),
          multiAzPolicy: string(name='MultiAzPolicy'),
          specId: string(name='SpecId'),
          duration: integer(name='Duration'),
          createTime: long(name='CreateTime'),
          updateTime: long(name='UpdateTime'),
        }
      ](name='Rule'),
    }(name='RuleList'),
  }(name='Data'),
}

model GetScalingRulesResponse = {
  headers: map[string]string(name='headers'),
  body: GetScalingRulesResponseBody(name='body'),
}

async function getScalingRulesWithOptions(request: GetScalingRulesRequest, runtime: Util.RuntimeOptions): GetScalingRulesResponse {
  Util.validateModel(request);
  return doRequestWithAction('GetScalingRules', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/app/scalingRules`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function getScalingRules(request: GetScalingRulesRequest): GetScalingRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return getScalingRulesWithOptions(request, runtime);
}

model ModifyScalingRuleQuery = {
  appId: string(name='AppId'),
  groupId: string(name='GroupId'),
  inCondition?: string(name='InCondition'),
  inEnable?: boolean(name='InEnable'),
  inCpu?: integer(name='InCpu'),
  inDuration?: integer(name='InDuration'),
  inInstanceNum?: integer(name='InInstanceNum'),
  inLoad?: integer(name='InLoad'),
  inRT?: integer(name='InRT'),
  inStep?: integer(name='InStep'),
  outCondition?: string(name='OutCondition'),
  outCPU?: integer(name='OutCPU'),
  outDuration?: integer(name='OutDuration'),
  outEnable?: boolean(name='OutEnable'),
  outInstanceNum?: integer(name='OutInstanceNum'),
  outLoad?: integer(name='OutLoad'),
  outRT?: integer(name='OutRT'),
  outStep?: integer(name='OutStep'),
  resourceFrom?: string(name='ResourceFrom'),
  multiAzPolicy?: string(name='MultiAzPolicy'),
  vpcId?: string(name='VpcId'),
  vSwitchIds?: string(name='VSwitchIds'),
  scalingPolicy?: string(name='ScalingPolicy'),
  templateInstanceId?: string(name='TemplateInstanceId'),
  templateInstanceName?: string(name='TemplateInstanceName'),
  password?: string(name='Password'),
  keyPairName?: string(name='KeyPairName'),
  acceptEULA?: boolean(name='AcceptEULA'),
  templateId?: string(name='TemplateId'),
  templateVersion?: integer(name='TemplateVersion'),
}

model ModifyScalingRuleRequest = {
  headers?: map[string]string(name='headers'),
  query: ModifyScalingRuleQuery(name='query'),
}

model ModifyScalingRuleResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

model ModifyScalingRuleResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyScalingRuleResponseBody(name='body'),
}

async function modifyScalingRuleWithOptions(request: ModifyScalingRuleRequest, runtime: Util.RuntimeOptions): ModifyScalingRuleResponse {
  Util.validateModel(request);
  return doRequestWithAction('ModifyScalingRule', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/app/scaling_rules`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function modifyScalingRule(request: ModifyScalingRuleRequest): ModifyScalingRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyScalingRuleWithOptions(request, runtime);
}

model ListMethodsQuery = {
  appId: string(name='AppId'),
  serviceName: string(name='ServiceName'),
}

model ListMethodsRequest = {
  headers?: map[string]string(name='headers'),
  query: ListMethodsQuery(name='query'),
}

model ListMethodsResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  serviceMethodList: {
    serviceMethod: [
      {
        appName: string(name='AppName'),
        serviceName: string(name='ServiceName'),
        methodName: string(name='MethodName'),
        output: string(name='Output'),
        inputParams: {
          inputParam: [ string ](name='InputParam'),
        }(name='InputParams'),
        paramTypes: {
          paramType: [ string ](name='ParamType'),
        }(name='ParamTypes'),
      }
    ](name='ServiceMethod'),
  }(name='ServiceMethodList'),
}

model ListMethodsResponse = {
  headers: map[string]string(name='headers'),
  body: ListMethodsResponseBody(name='body'),
}

async function listMethodsWithOptions(request: ListMethodsRequest, runtime: Util.RuntimeOptions): ListMethodsResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListMethods', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/service/list_methods`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function listMethods(request: ListMethodsRequest): ListMethodsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMethodsWithOptions(request, runtime);
}

model GetK8sApplicationQuery = {
  appId: string(name='AppId'),
  from?: string(name='From'),
}

model GetK8sApplicationRequest = {
  headers?: map[string]string(name='headers'),
  query: GetK8sApplicationQuery(name='query'),
}

model GetK8sApplicationResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  applcation: {
    appId: string(name='AppId'),
    deployGroups: {
      deployGroup: [
        {
          components: {
            components: [
              {
                componentId: string(name='ComponentId'),
                componentKey: string(name='ComponentKey'),
              }
            ](name='Components'),
          }(name='Components'),
        }
      ](name='DeployGroup'),
    }(name='DeployGroups'),
    imageInfo: {
      imageUrl: string(name='ImageUrl'),
      repoName: string(name='RepoName'),
      regionId: string(name='RegionId'),
      repoId: string(name='RepoId'),
      repoNamespace: string(name='RepoNamespace'),
      repoOriginType: string(name='RepoOriginType'),
      tag: string(name='Tag'),
    }(name='ImageInfo'),
    app: {
      applicationType: string(name='ApplicationType'),
      cmd: string(name='Cmd'),
      deployType: string(name='DeployType'),
      edasContainerVersion: string(name='EdasContainerVersion'),
      buildpackId: integer(name='BuildpackId'),
      tomcatVersion: string(name='TomcatVersion'),
      instancesBeforeScaling: integer(name='InstancesBeforeScaling'),
      appId: string(name='AppId'),
      applicationName: string(name='ApplicationName'),
      clusterId: string(name='ClusterId'),
      instances: integer(name='Instances'),
      csClusterId: string(name='CsClusterId'),
      envList: {
        env: [
          {
            name: string(name='Name'),
            value: string(name='Value'),
          }
        ](name='Env'),
      }(name='EnvList'),
      cmdArgs: {
        cmdArg: [ string ](name='CmdArg'),
      }(name='CmdArgs'),
    }(name='App'),
    conf: {
      jarStartArgs: string(name='JarStartArgs'),
      jarStartOptions: string(name='JarStartOptions'),
      k8sCmd: string(name='K8sCmd'),
      k8sCmdArgs: string(name='K8sCmdArgs'),
      k8sLocalvolumeInfo: string(name='K8sLocalvolumeInfo'),
      k8sNasInfo: string(name='K8sNasInfo'),
      k8sVolumeInfo: string(name='K8sVolumeInfo'),
      liveness: string(name='Liveness'),
      postStart: string(name='PostStart'),
      preStop: string(name='PreStop'),
      readiness: string(name='Readiness'),
      runtimeClassName: string(name='RuntimeClassName'),
      deployAcrossZones: string(name='DeployAcrossZones'),
      ahasEnabled: boolean(name='AhasEnabled'),
      deployAcrossNodes: string(name='DeployAcrossNodes'),
    }(name='Conf'),
  }(name='Applcation'),
}

model GetK8sApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: GetK8sApplicationResponseBody(name='body'),
}

async function getK8sApplicationWithOptions(request: GetK8sApplicationRequest, runtime: Util.RuntimeOptions): GetK8sApplicationResponse {
  Util.validateModel(request);
  return doRequestWithAction('GetK8sApplication', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/changeorder/co_application`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function getK8sApplication(request: GetK8sApplicationRequest): GetK8sApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return getK8sApplicationWithOptions(request, runtime);
}

model QueryEccInfoQuery = {
  eccId: string(name='EccId'),
}

model QueryEccInfoRequest = {
  headers?: map[string]string(name='headers'),
  query: QueryEccInfoQuery(name='query'),
}

model QueryEccInfoResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  eccInfo: {
    appId: string(name='AppId'),
    eccId: string(name='EccId'),
    ecuId: string(name='EcuId'),
    groupId: string(name='GroupId'),
    groupName: string(name='GroupName'),
    packageMd5: string(name='PackageMd5'),
    packageVersion: string(name='PackageVersion'),
    vpcId: string(name='VpcId'),
  }(name='EccInfo'),
}

model QueryEccInfoResponse = {
  headers: map[string]string(name='headers'),
  body: QueryEccInfoResponseBody(name='body'),
}

async function queryEccInfoWithOptions(request: QueryEccInfoRequest, runtime: Util.RuntimeOptions): QueryEccInfoResponse {
  Util.validateModel(request);
  return doRequestWithAction('QueryEccInfo', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/ecc`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function queryEccInfo(request: QueryEccInfoRequest): QueryEccInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryEccInfoWithOptions(request, runtime);
}

model ContinuePipelineQuery = {
  pipelineId: string(name='PipelineId'),
  confirm?: boolean(name='Confirm'),
}

model ContinuePipelineRequest = {
  headers?: map[string]string(name='headers'),
  query: ContinuePipelineQuery(name='query'),
}

model ContinuePipelineResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

model ContinuePipelineResponse = {
  headers: map[string]string(name='headers'),
  body: ContinuePipelineResponseBody(name='body'),
}

async function continuePipelineWithOptions(request: ContinuePipelineRequest, runtime: Util.RuntimeOptions): ContinuePipelineResponse {
  Util.validateModel(request);
  return doRequestWithAction('ContinuePipeline', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/changeorder/pipeline_batch_confirm`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function continuePipeline(request: ContinuePipelineRequest): ContinuePipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return continuePipelineWithOptions(request, runtime);
}

model ChangeDeployGroupQuery = {
  appId: string(name='AppId'),
  eccInfo: string(name='EccInfo'),
  groupName: string(name='GroupName'),
  forceStatus?: boolean(name='ForceStatus'),
}

model ChangeDeployGroupRequest = {
  headers?: map[string]string(name='headers'),
  query: ChangeDeployGroupQuery(name='query'),
}

model ChangeDeployGroupResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  changeOrderId: string(name='ChangeOrderId'),
  requestId: string(name='RequestId'),
}

model ChangeDeployGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ChangeDeployGroupResponseBody(name='body'),
}

async function changeDeployGroupWithOptions(request: ChangeDeployGroupRequest, runtime: Util.RuntimeOptions): ChangeDeployGroupResponse {
  Util.validateModel(request);
  return doRequestWithAction('ChangeDeployGroup', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/changeorder/co_change_group`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function changeDeployGroup(request: ChangeDeployGroupRequest): ChangeDeployGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return changeDeployGroupWithOptions(request, runtime);
}

model GetClusterQuery = {
  clusterId: string(name='ClusterId'),
}

model GetClusterRequest = {
  headers?: map[string]string(name='headers'),
  query: GetClusterQuery(name='query'),
}

model GetClusterResponseBody = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  message: string(name='Message'),
  cluster: {
    clusterId: string(name='ClusterId'),
    regionId: string(name='RegionId'),
    description: string(name='Description'),
    clusterName: string(name='ClusterName'),
    clusterType: integer(name='ClusterType'),
    oversoldFactor: integer(name='OversoldFactor'),
    networkMode: integer(name='NetworkMode'),
    vpcId: string(name='VpcId'),
    nodeNum: integer(name='NodeNum'),
    cpu: integer(name='Cpu'),
    mem: integer(name='Mem'),
    cpuUsed: integer(name='CpuUsed'),
    memUsed: integer(name='MemUsed'),
    createTime: long(name='CreateTime'),
    updateTime: long(name='UpdateTime'),
    iaasProvider: string(name='IaasProvider'),
    csClusterId: string(name='CsClusterId'),
    clusterImportStatus: integer(name='ClusterImportStatus'),
  }(name='Cluster'),
}

model GetClusterResponse = {
  headers: map[string]string(name='headers'),
  body: GetClusterResponseBody(name='body'),
}

async function getClusterWithOptions(request: GetClusterRequest, runtime: Util.RuntimeOptions): GetClusterResponse {
  Util.validateModel(request);
  return doRequestWithAction('GetCluster', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/resource/cluster`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function getCluster(request: GetClusterRequest): GetClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return getClusterWithOptions(request, runtime);
}

model QueryRegionConfigRequest = {
  headers?: map[string]string(name='headers'),
}

model QueryRegionConfigResponseBody = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  message: string(name='Message'),
  regionConfig: {
    addressServerHost: string(name='AddressServerHost'),
    agentInstallScript: string(name='AgentInstallScript'),
    fileServerType: string(name='FileServerType'),
    id: string(name='Id'),
    imageId: string(name='ImageId'),
    name: string(name='Name'),
    no: integer(name='No'),
    tag: string(name='Tag'),
    fileServerConfig: {
      bucket: string(name='Bucket'),
      internalUrl: string(name='InternalUrl'),
      publicUrl: string(name='PublicUrl'),
      vpcUrl: string(name='VpcUrl'),
    }(name='FileServerConfig'),
  }(name='RegionConfig'),
}

model QueryRegionConfigResponse = {
  headers: map[string]string(name='headers'),
  body: QueryRegionConfigResponseBody(name='body'),
}

async function queryRegionConfigWithOptions(request: QueryRegionConfigRequest, runtime: Util.RuntimeOptions): QueryRegionConfigResponse {
  Util.validateModel(request);
  return doRequestWithAction('QueryRegionConfig', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/region_config`, null, request.headers, null, runtime);
}

async function queryRegionConfig(request: QueryRegionConfigRequest): QueryRegionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryRegionConfigWithOptions(request, runtime);
}

model SynchronizeResourceQuery = {
  type: string(name='Type'),
}

model SynchronizeResourceRequest = {
  headers?: map[string]string(name='headers'),
  query: SynchronizeResourceQuery(name='query'),
}

model SynchronizeResourceResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  data: string(name='Data'),
  requestId: string(name='RequestId'),
}

model SynchronizeResourceResponse = {
  headers: map[string]string(name='headers'),
  body: SynchronizeResourceResponseBody(name='body'),
}

async function synchronizeResourceWithOptions(request: SynchronizeResourceRequest, runtime: Util.RuntimeOptions): SynchronizeResourceResponse {
  Util.validateModel(request);
  return doRequestWithAction('SynchronizeResource', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/resource/pop_sync_resource`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function synchronizeResource(request: SynchronizeResourceRequest): SynchronizeResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return synchronizeResourceWithOptions(request, runtime);
}

model InstallAgentQuery = {
  clusterId: string(name='ClusterId'),
  instanceIds: string(name='InstanceIds'),
  doAsync?: boolean(name='DoAsync'),
}

model InstallAgentRequest = {
  headers?: map[string]string(name='headers'),
  query: InstallAgentQuery(name='query'),
}

model InstallAgentResponseBody = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  message: string(name='Message'),
  executionResultList: {
    executionResult: [
      {
        instanceId: string(name='InstanceId'),
        status: string(name='Status'),
        finishedTime: string(name='FinishedTime'),
        invokeRecordStatus: string(name='InvokeRecordStatus'),
        success: boolean(name='Success'),
      }
    ](name='ExecutionResult'),
  }(name='ExecutionResultList'),
}

model InstallAgentResponse = {
  headers: map[string]string(name='headers'),
  body: InstallAgentResponseBody(name='body'),
}

async function installAgentWithOptions(request: InstallAgentRequest, runtime: Util.RuntimeOptions): InstallAgentResponse {
  Util.validateModel(request);
  return doRequestWithAction('InstallAgent', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/ecss/install_agent`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function installAgent(request: InstallAgentRequest): InstallAgentResponse {
  var runtime = new Util.RuntimeOptions{};
  return installAgentWithOptions(request, runtime);
}

model ListComponentsRequest = {
  headers?: map[string]string(name='headers'),
}

model ListComponentsResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  componentList: {
    component: [
      {
        componentId: string(name='ComponentId'),
        type: string(name='Type'),
        version: string(name='Version'),
        expired: boolean(name='Expired'),
        componentKey: string(name='ComponentKey'),
        desc: string(name='Desc'),
      }
    ](name='Component'),
  }(name='ComponentList'),
}

model ListComponentsResponse = {
  headers: map[string]string(name='headers'),
  body: ListComponentsResponseBody(name='body'),
}

async function listComponentsWithOptions(request: ListComponentsRequest, runtime: Util.RuntimeOptions): ListComponentsResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListComponents', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/resource/components`, null, request.headers, null, runtime);
}

async function listComponents(request: ListComponentsRequest): ListComponentsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listComponentsWithOptions(request, runtime);
}

model GetPackageStorageCredentialRequest = {
  headers?: map[string]string(name='headers'),
}

model GetPackageStorageCredentialResponseBody = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  message: string(name='Message'),
  credential: {
    accessKeyId: string(name='AccessKeyId'),
    accessKeySecret: string(name='AccessKeySecret'),
    bucket: string(name='Bucket'),
    expiration: string(name='Expiration'),
    keyPrefix: string(name='KeyPrefix'),
    regionId: string(name='RegionId'),
    securityToken: string(name='SecurityToken'),
  }(name='Credential'),
}

model GetPackageStorageCredentialResponse = {
  headers: map[string]string(name='headers'),
  body: GetPackageStorageCredentialResponseBody(name='body'),
}

async function getPackageStorageCredentialWithOptions(request: GetPackageStorageCredentialRequest, runtime: Util.RuntimeOptions): GetPackageStorageCredentialResponse {
  Util.validateModel(request);
  return doRequestWithAction('GetPackageStorageCredential', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/package_storage_credential`, null, request.headers, null, runtime);
}

async function getPackageStorageCredential(request: GetPackageStorageCredentialRequest): GetPackageStorageCredentialResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPackageStorageCredentialWithOptions(request, runtime);
}

model ListEcsNotInClusterQuery = {
  networkMode: integer(name='NetworkMode'),
  vpcId?: string(name='VpcId'),
}

model ListEcsNotInClusterRequest = {
  headers?: map[string]string(name='headers'),
  query: ListEcsNotInClusterQuery(name='query'),
}

model ListEcsNotInClusterResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  ecsEntityList: {
    ecsEntity: [
      {
        instanceId: string(name='InstanceId'),
        instanceName: string(name='InstanceName'),
        vpcId: string(name='VpcId'),
        vpcName: string(name='VpcName'),
        expired: boolean(name='Expired'),
        status: string(name='Status'),
        regionId: string(name='RegionId'),
        cpu: integer(name='Cpu'),
        mem: integer(name='Mem'),
        publicIp: string(name='PublicIp'),
        innerIp: string(name='InnerIp'),
        privateIp: string(name='PrivateIp'),
        eip: string(name='Eip'),
      }
    ](name='EcsEntity'),
  }(name='EcsEntityList'),
}

model ListEcsNotInClusterResponse = {
  headers: map[string]string(name='headers'),
  body: ListEcsNotInClusterResponseBody(name='body'),
}

async function listEcsNotInClusterWithOptions(request: ListEcsNotInClusterRequest, runtime: Util.RuntimeOptions): ListEcsNotInClusterResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListEcsNotInCluster', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/resource/ecs_not_in_cluster`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function listEcsNotInCluster(request: ListEcsNotInClusterRequest): ListEcsNotInClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEcsNotInClusterWithOptions(request, runtime);
}

model InsertK8sApplicationQuery = {
  intranetTargetPort?: integer(name='IntranetTargetPort'),
  intranetSlbPort?: integer(name='IntranetSlbPort'),
  imageUrl?: string(name='ImageUrl'),
  applicationDescription?: string(name='ApplicationDescription'),
  repoId?: string(name='RepoId'),
  replicas?: integer(name='Replicas'),
  limitCpu?: integer(name='LimitCpu'),
  limitMem?: integer(name='LimitMem'),
  requestsCpu?: integer(name='RequestsCpu'),
  requestsMem?: integer(name='RequestsMem'),
  command?: string(name='Command'),
  commandArgs?: string(name='CommandArgs'),
  appName: string(name='AppName'),
  intranetSlbProtocol?: string(name='IntranetSlbProtocol'),
  intranetSlbId?: string(name='IntranetSlbId'),
  clusterId: string(name='ClusterId'),
  internetSlbId?: string(name='InternetSlbId'),
  internetSlbProtocol?: string(name='InternetSlbProtocol'),
  internetSlbPort?: integer(name='InternetSlbPort'),
  internetTargetPort?: integer(name='InternetTargetPort'),
  envs?: string(name='Envs'),
  preStop?: string(name='PreStop'),
  postStart?: string(name='PostStart'),
  liveness?: string(name='Liveness'),
  readiness?: string(name='Readiness'),
  nasId?: string(name='NasId'),
  mountDescs?: string(name='MountDescs'),
  storageType?: string(name='StorageType'),
  localVolume?: string(name='LocalVolume'),
  namespace?: string(name='Namespace'),
  logicalRegionId?: string(name='LogicalRegionId'),
  packageType?: string(name='PackageType'),
  packageUrl?: string(name='PackageUrl'),
  packageVersion?: string(name='PackageVersion'),
  JDK?: string(name='JDK'),
  webContainer?: string(name='WebContainer'),
  edasContainerVersion?: string(name='EdasContainerVersion'),
  uriEncoding?: string(name='UriEncoding'),
  useBodyEncoding?: boolean(name='UseBodyEncoding'),
  requestsmCpu?: integer(name='RequestsmCpu'),
  limitmCpu?: integer(name='LimitmCpu'),
  runtimeClassName?: string(name='RuntimeClassName'),
  deployAcrossZones?: string(name='DeployAcrossZones'),
  timeout?: integer(name='Timeout'),
  enableAhas?: boolean(name='EnableAhas'),
  webContainerConfig?: string(name='WebContainerConfig'),
  javaStartUpConfig?: string(name='JavaStartUpConfig'),
  slsConfigs?: string(name='SlsConfigs'),
  isMultilingualApp?: boolean(name='IsMultilingualApp'),
  deployAcrossNodes?: string(name='DeployAcrossNodes'),
}

model InsertK8sApplicationRequest = {
  headers?: map[string]string(name='headers'),
  query: InsertK8sApplicationQuery(name='query'),
}

model InsertK8sApplicationResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  applicationInfo: {
    appName: string(name='AppName'),
    appId: string(name='AppId'),
    userId: string(name='UserId'),
    edasId: string(name='EdasId'),
    owner: string(name='Owner'),
    dockerize: boolean(name='Dockerize'),
    clusterType: integer(name='ClusterType'),
    regionId: string(name='RegionId'),
    changeOrderId: string(name='ChangeOrderId'),
  }(name='ApplicationInfo'),
}

model InsertK8sApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: InsertK8sApplicationResponseBody(name='body'),
}

async function insertK8sApplicationWithOptions(request: InsertK8sApplicationRequest, runtime: Util.RuntimeOptions): InsertK8sApplicationResponse {
  Util.validateModel(request);
  return doRequestWithAction('InsertK8sApplication', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/k8s/acs/create_k8s_app`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function insertK8sApplication(request: InsertK8sApplicationRequest): InsertK8sApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return insertK8sApplicationWithOptions(request, runtime);
}

model ImportK8sClusterQuery = {
  clusterId: string(name='ClusterId'),
  namespaceId?: string(name='NamespaceId'),
  mode?: integer(name='Mode'),
  enableAsm?: boolean(name='EnableAsm'),
}

model ImportK8sClusterRequest = {
  headers?: map[string]string(name='headers'),
  query: ImportK8sClusterQuery(name='query'),
}

model ImportK8sClusterResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  data: string(name='Data'),
  requestId: string(name='RequestId'),
}

model ImportK8sClusterResponse = {
  headers: map[string]string(name='headers'),
  body: ImportK8sClusterResponseBody(name='body'),
}

async function importK8sClusterWithOptions(request: ImportK8sClusterRequest, runtime: Util.RuntimeOptions): ImportK8sClusterResponse {
  Util.validateModel(request);
  return doRequestWithAction('ImportK8sCluster', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/import_k8s_cluster`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function importK8sCluster(request: ImportK8sClusterRequest): ImportK8sClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return importK8sClusterWithOptions(request, runtime);
}

model UpdateK8sApplicationConfigQuery = {
  appId: string(name='AppId'),
  clusterId: string(name='ClusterId'),
  cpuLimit: string(name='CpuLimit'),
  memoryLimit: string(name='MemoryLimit'),
  mcpuLimit?: string(name='McpuLimit'),
  cpuRequest?: string(name='CpuRequest'),
  mcpuRequest?: string(name='McpuRequest'),
  memoryRequest?: string(name='MemoryRequest'),
  timeout?: integer(name='Timeout'),
}

model UpdateK8sApplicationConfigRequest = {
  headers?: map[string]string(name='headers'),
  query: UpdateK8sApplicationConfigQuery(name='query'),
}

model UpdateK8sApplicationConfigResponseBody = {
  changeOrderId: string(name='ChangeOrderId'),
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

model UpdateK8sApplicationConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateK8sApplicationConfigResponseBody(name='body'),
}

async function updateK8sApplicationConfigWithOptions(request: UpdateK8sApplicationConfigRequest, runtime: Util.RuntimeOptions): UpdateK8sApplicationConfigResponse {
  Util.validateModel(request);
  return doRequestWithAction('UpdateK8sApplicationConfig', '2017-08-01', 'HTTPS', 'PUT', 'AK', `/pop/v5/k8s/acs/k8s_app_configuration`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function updateK8sApplicationConfig(request: UpdateK8sApplicationConfigRequest): UpdateK8sApplicationConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateK8sApplicationConfigWithOptions(request, runtime);
}

model DeployK8sApplicationQuery = {
  preStop?: string(name='PreStop'),
  envs?: string(name='Envs'),
  imageTag?: string(name='ImageTag'),
  batchWaitTime?: integer(name='BatchWaitTime'),
  command?: string(name='Command'),
  appId: string(name='AppId'),
  postStart?: string(name='PostStart'),
  readiness?: string(name='Readiness'),
  liveness?: string(name='Liveness'),
  args?: string(name='Args'),
  replicas?: integer(name='Replicas'),
  image?: string(name='Image'),
  cpuLimit?: integer(name='CpuLimit'),
  memoryLimit?: integer(name='MemoryLimit'),
  cpuRequest?: integer(name='CpuRequest'),
  memoryRequest?: integer(name='MemoryRequest'),
  nasId?: string(name='NasId'),
  mountDescs?: string(name='MountDescs'),
  storageType?: string(name='StorageType'),
  localVolume?: string(name='LocalVolume'),
  packageUrl?: string(name='PackageUrl'),
  packageVersion?: string(name='PackageVersion'),
  JDK?: string(name='JDK'),
  webContainer?: string(name='WebContainer'),
  edasContainerVersion?: string(name='EdasContainerVersion'),
  uriEncoding?: string(name='UriEncoding'),
  useBodyEncoding?: boolean(name='UseBodyEncoding'),
  updateStrategy?: string(name='UpdateStrategy'),
  mcpuRequest?: integer(name='McpuRequest'),
  mcpuLimit?: integer(name='McpuLimit'),
  volumesStr?: string(name='VolumesStr'),
  packageVersionId?: string(name='PackageVersionId'),
  changeOrderDesc?: string(name='ChangeOrderDesc'),
  runtimeClassName?: string(name='RuntimeClassName'),
  deployAcrossZones?: string(name='DeployAcrossZones'),
  batchTimeout?: integer(name='BatchTimeout'),
  enableAhas?: boolean(name='EnableAhas'),
  webContainerConfig?: string(name='WebContainerConfig'),
  javaStartUpConfig?: string(name='JavaStartUpConfig'),
  slsConfigs?: string(name='SlsConfigs'),
  deployAcrossNodes?: string(name='DeployAcrossNodes'),
  trafficControlStrategy?: string(name='TrafficControlStrategy'),
}

model DeployK8sApplicationRequest = {
  headers?: map[string]string(name='headers'),
  query: DeployK8sApplicationQuery(name='query'),
}

model DeployK8sApplicationResponseBody = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  message: string(name='Message'),
  changeOrderId: string(name='ChangeOrderId'),
}

model DeployK8sApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: DeployK8sApplicationResponseBody(name='body'),
}

async function deployK8sApplicationWithOptions(request: DeployK8sApplicationRequest, runtime: Util.RuntimeOptions): DeployK8sApplicationResponse {
  Util.validateModel(request);
  return doRequestWithAction('DeployK8sApplication', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/k8s/acs/k8s_apps`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function deployK8sApplication(request: DeployK8sApplicationRequest): DeployK8sApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deployK8sApplicationWithOptions(request, runtime);
}

model ScaleK8sApplicationQuery = {
  appId: string(name='AppId'),
  replicas: integer(name='Replicas'),
  timeout?: integer(name='Timeout'),
}

model ScaleK8sApplicationRequest = {
  headers?: map[string]string(name='headers'),
  query: ScaleK8sApplicationQuery(name='query'),
}

model ScaleK8sApplicationResponseBody = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  message: string(name='Message'),
  changeOrderId: string(name='ChangeOrderId'),
}

model ScaleK8sApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: ScaleK8sApplicationResponseBody(name='body'),
}

async function scaleK8sApplicationWithOptions(request: ScaleK8sApplicationRequest, runtime: Util.RuntimeOptions): ScaleK8sApplicationResponse {
  Util.validateModel(request);
  return doRequestWithAction('ScaleK8sApplication', '2017-08-01', 'HTTPS', 'PUT', 'AK', `/pop/v5/k8s/acs/k8s_apps`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function scaleK8sApplication(request: ScaleK8sApplicationRequest): ScaleK8sApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return scaleK8sApplicationWithOptions(request, runtime);
}

model DeleteK8sApplicationQuery = {
  appId: string(name='AppId'),
}

model DeleteK8sApplicationRequest = {
  headers?: map[string]string(name='headers'),
  query: DeleteK8sApplicationQuery(name='query'),
}

model DeleteK8sApplicationResponseBody = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  message: string(name='Message'),
  changeOrderId: string(name='ChangeOrderId'),
}

model DeleteK8sApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteK8sApplicationResponseBody(name='body'),
}

async function deleteK8sApplicationWithOptions(request: DeleteK8sApplicationRequest, runtime: Util.RuntimeOptions): DeleteK8sApplicationResponse {
  Util.validateModel(request);
  return doRequestWithAction('DeleteK8sApplication', '2017-08-01', 'HTTPS', 'DELETE', 'AK', `/pop/v5/k8s/acs/k8s_apps`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function deleteK8sApplication(request: DeleteK8sApplicationRequest): DeleteK8sApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteK8sApplicationWithOptions(request, runtime);
}

model UnbindK8sSlbQuery = {
  appId: string(name='AppId'),
  clusterId: string(name='ClusterId'),
  type: string(name='Type'),
}

model UnbindK8sSlbRequest = {
  headers?: map[string]string(name='headers'),
  query: UnbindK8sSlbQuery(name='query'),
}

model UnbindK8sSlbResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  changeOrderId: string(name='ChangeOrderId'),
  requestId: string(name='RequestId'),
}

model UnbindK8sSlbResponse = {
  headers: map[string]string(name='headers'),
  body: UnbindK8sSlbResponseBody(name='body'),
}

async function unbindK8sSlbWithOptions(request: UnbindK8sSlbRequest, runtime: Util.RuntimeOptions): UnbindK8sSlbResponse {
  Util.validateModel(request);
  return doRequestWithAction('UnbindK8sSlb', '2017-08-01', 'HTTPS', 'DELETE', 'AK', `/pop/v5/k8s/acs/k8s_slb_binding`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function unbindK8sSlb(request: UnbindK8sSlbRequest): UnbindK8sSlbResponse {
  var runtime = new Util.RuntimeOptions{};
  return unbindK8sSlbWithOptions(request, runtime);
}

model BindK8sSlbQuery = {
  appId: string(name='AppId'),
  clusterId: string(name='ClusterId'),
  type: string(name='Type'),
  slbId?: string(name='SlbId'),
  slbProtocol?: string(name='SlbProtocol'),
  targetPort?: string(name='TargetPort'),
  port?: string(name='Port'),
  servicePortInfos?: string(name='ServicePortInfos'),
  specification?: string(name='Specification'),
  scheduler?: string(name='Scheduler'),
}

model BindK8sSlbRequest = {
  headers?: map[string]string(name='headers'),
  query: BindK8sSlbQuery(name='query'),
}

model BindK8sSlbResponseBody = {
  changeOrderId: string(name='ChangeOrderId'),
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

model BindK8sSlbResponse = {
  headers: map[string]string(name='headers'),
  body: BindK8sSlbResponseBody(name='body'),
}

async function bindK8sSlbWithOptions(request: BindK8sSlbRequest, runtime: Util.RuntimeOptions): BindK8sSlbResponse {
  Util.validateModel(request);
  return doRequestWithAction('BindK8sSlb', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/k8s/acs/k8s_slb_binding`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function bindK8sSlb(request: BindK8sSlbRequest): BindK8sSlbResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindK8sSlbWithOptions(request, runtime);
}

model UpdateK8sSlbQuery = {
  appId: string(name='AppId'),
  clusterId: string(name='ClusterId'),
  type: string(name='Type'),
  slbProtocol?: string(name='SlbProtocol'),
  targetPort?: string(name='TargetPort'),
  port?: string(name='Port'),
  servicePortInfos?: string(name='ServicePortInfos'),
  specification?: string(name='Specification'),
  scheduler?: string(name='Scheduler'),
}

model UpdateK8sSlbRequest = {
  headers?: map[string]string(name='headers'),
  query: UpdateK8sSlbQuery(name='query'),
}

model UpdateK8sSlbResponseBody = {
  changeOrderId: string(name='ChangeOrderId'),
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

model UpdateK8sSlbResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateK8sSlbResponseBody(name='body'),
}

async function updateK8sSlbWithOptions(request: UpdateK8sSlbRequest, runtime: Util.RuntimeOptions): UpdateK8sSlbResponse {
  Util.validateModel(request);
  return doRequestWithAction('UpdateK8sSlb', '2017-08-01', 'HTTPS', 'PUT', 'AK', `/pop/v5/k8s/acs/k8s_slb_binding`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function updateK8sSlb(request: UpdateK8sSlbRequest): UpdateK8sSlbResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateK8sSlbWithOptions(request, runtime);
}

model GetSecureTokenQuery = {
  namespaceId: string(name='NamespaceId'),
}

model GetSecureTokenRequest = {
  headers?: map[string]string(name='headers'),
  query: GetSecureTokenQuery(name='query'),
}

model GetSecureTokenResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  secureToken: {
    id: long(name='Id'),
    userId: string(name='UserId'),
    edasId: string(name='EdasId'),
    regionId: string(name='RegionId'),
    regionName: string(name='RegionName'),
    description: string(name='Description'),
    belongRegion: string(name='BelongRegion'),
    accessKey: string(name='AccessKey'),
    secretKey: string(name='SecretKey'),
    tenantId: string(name='TenantId'),
    addressServerHost: string(name='AddressServerHost'),
  }(name='SecureToken'),
}

model GetSecureTokenResponse = {
  headers: map[string]string(name='headers'),
  body: GetSecureTokenResponseBody(name='body'),
}

async function getSecureTokenWithOptions(request: GetSecureTokenRequest, runtime: Util.RuntimeOptions): GetSecureTokenResponse {
  Util.validateModel(request);
  return doRequestWithAction('GetSecureToken', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/secure_token`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function getSecureToken(request: GetSecureTokenRequest): GetSecureTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSecureTokenWithOptions(request, runtime);
}

model TransformClusterMemberQuery = {
  instanceIds: string(name='InstanceIds'),
  targetClusterId: string(name='TargetClusterId'),
  password: string(name='Password'),
}

model TransformClusterMemberRequest = {
  headers?: map[string]string(name='headers'),
  query: TransformClusterMemberQuery(name='query'),
}

model TransformClusterMemberResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  data: string(name='Data'),
  requestId: string(name='RequestId'),
}

model TransformClusterMemberResponse = {
  headers: map[string]string(name='headers'),
  body: TransformClusterMemberResponseBody(name='body'),
}

async function transformClusterMemberWithOptions(request: TransformClusterMemberRequest, runtime: Util.RuntimeOptions): TransformClusterMemberResponse {
  Util.validateModel(request);
  return doRequestWithAction('TransformClusterMember', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/resource/transform_cluster_member`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function transformClusterMember(request: TransformClusterMemberRequest): TransformClusterMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  return transformClusterMemberWithOptions(request, runtime);
}

model ListConvertableEcuQuery = {
  clusterId: string(name='clusterId'),
}

model ListConvertableEcuRequest = {
  headers?: map[string]string(name='headers'),
  query: ListConvertableEcuQuery(name='query'),
}

model ListConvertableEcuResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  instanceList: {
    instance: [
      {
        instanceId: string(name='InstanceId'),
        instanceName: string(name='InstanceName'),
        ecuId: string(name='EcuId'),
        vpcId: string(name='VpcId'),
        vpcName: string(name='VpcName'),
        expired: boolean(name='Expired'),
        status: string(name='Status'),
        regionId: string(name='RegionId'),
        cpu: integer(name='Cpu'),
        mem: integer(name='Mem'),
        publicIp: string(name='PublicIp'),
        innerIp: string(name='InnerIp'),
        privateIp: string(name='PrivateIp'),
        eip: string(name='Eip'),
      }
    ](name='Instance'),
  }(name='InstanceList'),
}

model ListConvertableEcuResponse = {
  headers: map[string]string(name='headers'),
  body: ListConvertableEcuResponseBody(name='body'),
}

async function listConvertableEcuWithOptions(request: ListConvertableEcuRequest, runtime: Util.RuntimeOptions): ListConvertableEcuResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListConvertableEcu', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/resource/convertable_ecu_list`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function listConvertableEcu(request: ListConvertableEcuRequest): ListConvertableEcuResponse {
  var runtime = new Util.RuntimeOptions{};
  return listConvertableEcuWithOptions(request, runtime);
}

model InsertClusterMemberQuery = {
  clusterId: string(name='clusterId'),
  instanceIds: string(name='instanceIds'),
  password: string(name='password'),
}

model InsertClusterMemberRequest = {
  headers?: map[string]string(name='headers'),
  query: InsertClusterMemberQuery(name='query'),
}

model InsertClusterMemberResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  data: string(name='Data'),
  requestId: string(name='RequestId'),
}

model InsertClusterMemberResponse = {
  headers: map[string]string(name='headers'),
  body: InsertClusterMemberResponseBody(name='body'),
}

async function insertClusterMemberWithOptions(request: InsertClusterMemberRequest, runtime: Util.RuntimeOptions): InsertClusterMemberResponse {
  Util.validateModel(request);
  return doRequestWithAction('InsertClusterMember', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/resource/cluster_member`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function insertClusterMember(request: InsertClusterMemberRequest): InsertClusterMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  return insertClusterMemberWithOptions(request, runtime);
}

model UpdateRoleQuery = {
  roleId: integer(name='RoleId'),
  actionData: string(name='ActionData'),
}

model UpdateRoleRequest = {
  headers?: map[string]string(name='headers'),
  query: UpdateRoleQuery(name='query'),
}

model UpdateRoleResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

model UpdateRoleResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateRoleResponseBody(name='body'),
}

async function updateRoleWithOptions(request: UpdateRoleRequest, runtime: Util.RuntimeOptions): UpdateRoleResponse {
  Util.validateModel(request);
  return doRequestWithAction('UpdateRole', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/account/edit_role`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function updateRole(request: UpdateRoleRequest): UpdateRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateRoleWithOptions(request, runtime);
}

model UpdateJvmConfigurationQuery = {
  appId: string(name='AppId'),
  groupId?: string(name='GroupId'),
  options?: string(name='Options'),
  minHeapSize?: integer(name='MinHeapSize'),
  maxPermSize?: integer(name='MaxPermSize'),
  maxHeapSize?: integer(name='MaxHeapSize'),
}

model UpdateJvmConfigurationRequest = {
  headers?: map[string]string(name='headers'),
  query: UpdateJvmConfigurationQuery(name='query'),
}

model UpdateJvmConfigurationResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  jvmConfiguration: {
    maxHeapSize: integer(name='MaxHeapSize'),
    maxPermSize: integer(name='MaxPermSize'),
    minHeapSize: integer(name='MinHeapSize'),
    options: string(name='Options'),
  }(name='JvmConfiguration'),
}

model UpdateJvmConfigurationResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateJvmConfigurationResponseBody(name='body'),
}

async function updateJvmConfigurationWithOptions(request: UpdateJvmConfigurationRequest, runtime: Util.RuntimeOptions): UpdateJvmConfigurationResponse {
  Util.validateModel(request);
  return doRequestWithAction('UpdateJvmConfiguration', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/app/app_jvm_config`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function updateJvmConfiguration(request: UpdateJvmConfigurationRequest): UpdateJvmConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateJvmConfigurationWithOptions(request, runtime);
}

model UpdateHealthCheckUrlQuery = {
  appId: string(name='AppId'),
  hcURL?: string(name='hcURL'),
}

model UpdateHealthCheckUrlRequest = {
  headers?: map[string]string(name='headers'),
  query: UpdateHealthCheckUrlQuery(name='query'),
}

model UpdateHealthCheckUrlResponseBody = {
  code: integer(name='Code'),
  healthCheckURL: string(name='HealthCheckURL'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

model UpdateHealthCheckUrlResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateHealthCheckUrlResponseBody(name='body'),
}

async function updateHealthCheckUrlWithOptions(request: UpdateHealthCheckUrlRequest, runtime: Util.RuntimeOptions): UpdateHealthCheckUrlResponse {
  Util.validateModel(request);
  return doRequestWithAction('UpdateHealthCheckUrl', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/app/modify_hc_url`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function updateHealthCheckUrl(request: UpdateHealthCheckUrlRequest): UpdateHealthCheckUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateHealthCheckUrlWithOptions(request, runtime);
}

model UpdateFlowControlQuery = {
  appId: string(name='AppId'),
  ruleId: string(name='RuleId'),
  consumerAppId?: string(name='ConsumerAppId'),
  granularity: string(name='Granularity'),
  methodName?: string(name='MethodName'),
  ruleType: string(name='RuleType'),
  serviceName?: string(name='ServiceName'),
  strategy?: string(name='Strategy'),
  threshold: integer(name='Threshold'),
  urlVar?: string(name='UrlVar'),
}

model UpdateFlowControlRequest = {
  headers?: map[string]string(name='headers'),
  query: UpdateFlowControlQuery(name='query'),
}

model UpdateFlowControlResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

model UpdateFlowControlResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateFlowControlResponseBody(name='body'),
}

async function updateFlowControlWithOptions(request: UpdateFlowControlRequest, runtime: Util.RuntimeOptions): UpdateFlowControlResponse {
  Util.validateModel(request);
  return doRequestWithAction('UpdateFlowControl', '2017-08-01', 'HTTPS', 'PUT', 'AK', `/pop/v5/flowControl`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function updateFlowControl(request: UpdateFlowControlRequest): UpdateFlowControlResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateFlowControlWithOptions(request, runtime);
}

model UpdateDegradeControlQuery = {
  appId: string(name='AppId'),
  ruleId: string(name='RuleId'),
  duration: integer(name='Duration'),
  methodName?: string(name='MethodName'),
  rtThreshold: integer(name='RtThreshold'),
  serviceName?: string(name='ServiceName'),
  urlVar?: string(name='UrlVar'),
  ruleType: string(name='RuleType'),
}

model UpdateDegradeControlRequest = {
  headers?: map[string]string(name='headers'),
  query: UpdateDegradeControlQuery(name='query'),
}

model UpdateDegradeControlResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

model UpdateDegradeControlResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDegradeControlResponseBody(name='body'),
}

async function updateDegradeControlWithOptions(request: UpdateDegradeControlRequest, runtime: Util.RuntimeOptions): UpdateDegradeControlResponse {
  Util.validateModel(request);
  return doRequestWithAction('UpdateDegradeControl', '2017-08-01', 'HTTPS', 'PUT', 'AK', `/pop/v5/degradeControl`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function updateDegradeControl(request: UpdateDegradeControlRequest): UpdateDegradeControlResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDegradeControlWithOptions(request, runtime);
}

model UpdateContainerConfigurationQuery = {
  appId: string(name='AppId'),
  groupId?: string(name='GroupId'),
  contextPath?: string(name='ContextPath'),
  httpPort?: integer(name='HttpPort'),
  maxThreads?: integer(name='MaxThreads'),
  URIEncoding?: string(name='URIEncoding'),
  useBodyEncoding?: boolean(name='UseBodyEncoding'),
}

model UpdateContainerConfigurationRequest = {
  headers?: map[string]string(name='headers'),
  query: UpdateContainerConfigurationQuery(name='query'),
}

model UpdateContainerConfigurationResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  containerConfiguration: {
    contextPath: string(name='ContextPath'),
    httpPort: integer(name='HttpPort'),
    maxThreads: integer(name='MaxThreads'),
    URIEncoding: string(name='URIEncoding'),
    useBodyEncoding: boolean(name='UseBodyEncoding'),
  }(name='ContainerConfiguration'),
}

model UpdateContainerConfigurationResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateContainerConfigurationResponseBody(name='body'),
}

async function updateContainerConfigurationWithOptions(request: UpdateContainerConfigurationRequest, runtime: Util.RuntimeOptions): UpdateContainerConfigurationResponse {
  Util.validateModel(request);
  return doRequestWithAction('UpdateContainerConfiguration', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/app/container_config`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function updateContainerConfiguration(request: UpdateContainerConfigurationRequest): UpdateContainerConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateContainerConfigurationWithOptions(request, runtime);
}

model UpdateApplicationBaseInfoQuery = {
  appId: string(name='AppId'),
  appName?: string(name='AppName'),
  desc?: string(name='Desc'),
  owner?: string(name='Owner'),
}

model UpdateApplicationBaseInfoRequest = {
  headers?: map[string]string(name='headers'),
  query: UpdateApplicationBaseInfoQuery(name='query'),
}

model UpdateApplicationBaseInfoResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  applcation: {
    appId: string(name='AppId'),
    name: string(name='Name'),
    regionId: string(name='RegionId'),
    description: string(name='Description'),
    owner: string(name='Owner'),
    instanceCount: integer(name='InstanceCount'),
    runningInstanceCount: integer(name='RunningInstanceCount'),
    port: integer(name='Port'),
    userId: string(name='UserId'),
    slbId: string(name='SlbId'),
    slbIp: string(name='SlbIp'),
    slbPort: integer(name='SlbPort'),
    extSlbId: string(name='ExtSlbId'),
    extSlbIp: string(name='ExtSlbIp'),
    slbName: string(name='SlbName'),
    extSlbName: string(name='ExtSlbName'),
    applicationType: string(name='ApplicationType'),
    clusterType: integer(name='ClusterType'),
    clusterId: string(name='ClusterId'),
    dockerize: boolean(name='Dockerize'),
    cpu: integer(name='Cpu'),
    memory: integer(name='Memory'),
    healthCheckUrl: string(name='HealthCheckUrl'),
    buildPackageId: long(name='BuildPackageId'),
    createTime: long(name='CreateTime'),
  }(name='Applcation'),
}

model UpdateApplicationBaseInfoResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateApplicationBaseInfoResponseBody(name='body'),
}

async function updateApplicationBaseInfoWithOptions(request: UpdateApplicationBaseInfoRequest, runtime: Util.RuntimeOptions): UpdateApplicationBaseInfoResponse {
  Util.validateModel(request);
  return doRequestWithAction('UpdateApplicationBaseInfo', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/app/update_app_info`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function updateApplicationBaseInfo(request: UpdateApplicationBaseInfoRequest): UpdateApplicationBaseInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateApplicationBaseInfoWithOptions(request, runtime);
}

model UpdateAccountInfoQuery = {
  name?: string(name='Name'),
  telephone?: string(name='Telephone'),
  email?: string(name='Email'),
}

model UpdateAccountInfoRequest = {
  headers?: map[string]string(name='headers'),
  query?: UpdateAccountInfoQuery(name='query'),
}

model UpdateAccountInfoResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

model UpdateAccountInfoResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAccountInfoResponseBody(name='body'),
}

async function updateAccountInfoWithOptions(request: UpdateAccountInfoRequest, runtime: Util.RuntimeOptions): UpdateAccountInfoResponse {
  Util.validateModel(request);
  return doRequestWithAction('UpdateAccountInfo', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/account/edit_account_info`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function updateAccountInfo(request: UpdateAccountInfoRequest): UpdateAccountInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAccountInfoWithOptions(request, runtime);
}

model UnbindSlbQuery = {
  appId: string(name='AppId'),
  slbId: string(name='SlbId'),
  type: string(name='Type'),
}

model UnbindSlbRequest = {
  headers?: map[string]string(name='headers'),
  query: UnbindSlbQuery(name='query'),
}

model UnbindSlbResponseBody = {
  code: integer(name='Code'),
  data: string(name='Data'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

model UnbindSlbResponse = {
  headers: map[string]string(name='headers'),
  body: UnbindSlbResponseBody(name='body'),
}

async function unbindSlbWithOptions(request: UnbindSlbRequest, runtime: Util.RuntimeOptions): UnbindSlbResponse {
  Util.validateModel(request);
  return doRequestWithAction('UnbindSlb', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/app/unbind_slb_json`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function unbindSlb(request: UnbindSlbRequest): UnbindSlbResponse {
  var runtime = new Util.RuntimeOptions{};
  return unbindSlbWithOptions(request, runtime);
}

model RollbackApplicationQuery = {
  appId: string(name='AppId'),
  historyVersion: string(name='HistoryVersion'),
  groupId: string(name='GroupId'),
  batch?: integer(name='Batch'),
  batchWaitTime?: integer(name='BatchWaitTime'),
}

model RollbackApplicationRequest = {
  headers?: map[string]string(name='headers'),
  query: RollbackApplicationQuery(name='query'),
}

model RollbackApplicationResponseBody = {
  changeOrderId: string(name='ChangeOrderId'),
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

model RollbackApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: RollbackApplicationResponseBody(name='body'),
}

async function rollbackApplicationWithOptions(request: RollbackApplicationRequest, runtime: Util.RuntimeOptions): RollbackApplicationResponse {
  Util.validateModel(request);
  return doRequestWithAction('RollbackApplication', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/changeorder/co_rollback`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function rollbackApplication(request: RollbackApplicationRequest): RollbackApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return rollbackApplicationWithOptions(request, runtime);
}

model QueryMonitorInfoQuery = {
  start: long(name='Start'),
  end: long(name='End'),
  metric: string(name='Metric'),
  tags: map[string]any(name='Tags'),
  aggregator: string(name='Aggregator'),
  interval?: string(name='Interval'),
}

model QueryMonitorInfoShrinkQuery = {
  start: long(name='Start'),
  end: long(name='End'),
  metric: string(name='Metric'),
  tagsShrink: string(name='Tags'),
  aggregator: string(name='Aggregator'),
  interval?: string(name='Interval'),
}

model QueryMonitorInfoRequest = {
  headers?: map[string]string(name='headers'),
  query: QueryMonitorInfoQuery(name='query'),
}

model QueryMonitorInfoShrinkRequest = {
  headers?: map[string]string(name='headers'),
  query: QueryMonitorInfoShrinkQuery(name='query'),
}

model QueryMonitorInfoResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  monitorInfo: string(name='MonitorInfo'),
  requestId: string(name='RequestId'),
}

model QueryMonitorInfoResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMonitorInfoResponseBody(name='body'),
}

async function queryMonitorInfoWithOptions(tmp: QueryMonitorInfoRequest, runtime: Util.RuntimeOptions): QueryMonitorInfoResponse {
  Util.validateModel(tmp);
  var request = new QueryMonitorInfoShrinkRequest{};
  ROAUtil.convert(tmp, request);
  if (!Util.isUnset(tmp.query)) {
    var query = new QueryMonitorInfoShrinkQuery{};
    ROAUtil.convert(tmp.query, query);
    if (!Util.isUnset(tmp.query.tags)) {
      query.tagsShrink = Util.toJSONString(tmp.query.tags);
    }
    request.query = query;
  }
  return doRequestWithAction('QueryMonitorInfo', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/monitor/queryMonitorInfo`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function queryMonitorInfo(request: QueryMonitorInfoRequest): QueryMonitorInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMonitorInfoWithOptions(request, runtime);
}

model QueryMigrateRegionListQuery = {
  logicalRegionId?: string(name='LogicalRegionId'),
}

model QueryMigrateRegionListRequest = {
  headers?: map[string]string(name='headers'),
  query?: QueryMigrateRegionListQuery(name='query'),
}

model QueryMigrateRegionListResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  regionEntityList: {
    regionEntity: [
      {
        regionNo: string(name='RegionNo'),
        regionName: string(name='RegionName'),
      }
    ](name='RegionEntity'),
  }(name='RegionEntityList'),
}

model QueryMigrateRegionListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMigrateRegionListResponseBody(name='body'),
}

async function queryMigrateRegionListWithOptions(request: QueryMigrateRegionListRequest, runtime: Util.RuntimeOptions): QueryMigrateRegionListResponse {
  Util.validateModel(request);
  return doRequestWithAction('QueryMigrateRegionList', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/resource/migrate_region_select`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function queryMigrateRegionList(request: QueryMigrateRegionListRequest): QueryMigrateRegionListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMigrateRegionListWithOptions(request, runtime);
}

model QueryMigrateEcuListQuery = {
  logicalRegionId?: string(name='LogicalRegionId'),
}

model QueryMigrateEcuListRequest = {
  headers?: map[string]string(name='headers'),
  query?: QueryMigrateEcuListQuery(name='query'),
}

model QueryMigrateEcuListResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  ecuEntityList: {
    ecuEntity: [
      {
        ecuId: string(name='EcuId'),
        online: boolean(name='Online'),
        dockerEnv: boolean(name='DockerEnv'),
        createTime: long(name='CreateTime'),
        updateTime: long(name='UpdateTime'),
        ipAddr: string(name='IpAddr'),
        heartbeatTime: long(name='HeartbeatTime'),
        userId: string(name='UserId'),
        name: string(name='Name'),
        zoneId: string(name='ZoneId'),
        regionId: string(name='RegionId'),
        instanceId: string(name='InstanceId'),
        vpcId: string(name='VpcId'),
        availableCpu: integer(name='AvailableCpu'),
        availableMem: integer(name='AvailableMem'),
        cpu: integer(name='Cpu'),
        mem: integer(name='Mem'),
      }
    ](name='EcuEntity'),
  }(name='EcuEntityList'),
}

model QueryMigrateEcuListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMigrateEcuListResponseBody(name='body'),
}

async function queryMigrateEcuListWithOptions(request: QueryMigrateEcuListRequest, runtime: Util.RuntimeOptions): QueryMigrateEcuListResponse {
  Util.validateModel(request);
  return doRequestWithAction('QueryMigrateEcuList', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/resource/migrate_ecu_list`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function queryMigrateEcuList(request: QueryMigrateEcuListRequest): QueryMigrateEcuListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMigrateEcuListWithOptions(request, runtime);
}

model QueryConfigCenterQuery = {
  dataId: string(name='DataId'),
  group: string(name='Group'),
  logicalRegionId: string(name='LogicalRegionId'),
}

model QueryConfigCenterRequest = {
  headers?: map[string]string(name='headers'),
  query: QueryConfigCenterQuery(name='query'),
}

model QueryConfigCenterResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  configCenterInfo: {
    appName: string(name='AppName'),
    content: string(name='Content'),
    dataId: string(name='DataId'),
    group: string(name='Group'),
    id: string(name='Id'),
  }(name='configCenterInfo'),
}

model QueryConfigCenterResponse = {
  headers: map[string]string(name='headers'),
  body: QueryConfigCenterResponseBody(name='body'),
}

async function queryConfigCenterWithOptions(request: QueryConfigCenterRequest, runtime: Util.RuntimeOptions): QueryConfigCenterResponse {
  Util.validateModel(request);
  return doRequestWithAction('QueryConfigCenter', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/configCenter`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function queryConfigCenter(request: QueryConfigCenterRequest): QueryConfigCenterResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryConfigCenterWithOptions(request, runtime);
}

model QueryApplicationStatusQuery = {
  appId: string(name='AppId'),
}

model QueryApplicationStatusRequest = {
  headers?: map[string]string(name='headers'),
  query: QueryApplicationStatusQuery(name='query'),
}

model QueryApplicationStatusResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  appInfo: {
    ecuList: {
      ecu: [
        {
          ecuId: string(name='EcuId'),
          online: boolean(name='Online'),
          dockerEnv: boolean(name='DockerEnv'),
          createTime: long(name='CreateTime'),
          updateTime: long(name='UpdateTime'),
          ipAddr: string(name='IpAddr'),
          heartbeatTime: long(name='HeartbeatTime'),
          userId: string(name='UserId'),
          groupId: string(name='GroupId'),
          name: string(name='Name'),
          zoneId: string(name='ZoneId'),
          regionId: string(name='RegionId'),
          instanceId: string(name='InstanceId'),
          vpcId: string(name='VpcId'),
          availableCpu: integer(name='AvailableCpu'),
          availableMem: integer(name='AvailableMem'),
        }
      ](name='Ecu'),
    }(name='EcuList'),
    eccList: {
      ecc: [
        {
          eccId: string(name='EccId'),
          ecuId: string(name='EcuId'),
          appId: string(name='AppId'),
          appState: integer(name='AppState'),
          taskState: integer(name='TaskState'),
          createTime: long(name='CreateTime'),
          updateTime: long(name='UpdateTime'),
          ip: string(name='Ip'),
          vpcId: string(name='VpcId'),
          groupId: string(name='GroupId'),
          containerStatus: string(name='ContainerStatus'),
        }
      ](name='Ecc'),
    }(name='EccList'),
    groupList: {
      group: [
        {
          groupId: string(name='GroupId'),
          groupName: string(name='GroupName'),
          appId: string(name='AppId'),
          packageVersionId: string(name='PackageVersionId'),
          appVersionId: string(name='AppVersionId'),
          groupType: integer(name='GroupType'),
          clusterId: string(name='ClusterId'),
          createTime: long(name='CreateTime'),
          updateTime: long(name='UpdateTime'),
        }
      ](name='Group'),
    }(name='GroupList'),
    deployRecordList: {
      deployRecord: [
        {
          deployRecordId: string(name='DeployRecordId'),
          eccId: string(name='EccId'),
          ecuId: string(name='EcuId'),
          packageVersionId: string(name='PackageVersionId'),
          packageMd5: string(name='PackageMd5'),
          createTime: long(name='CreateTime'),
        }
      ](name='DeployRecord'),
    }(name='DeployRecordList'),
    application: {
      applicationId: string(name='ApplicationId'),
      buildPackageId: integer(name='BuildPackageId'),
      clusterId: string(name='ClusterId'),
      cpu: integer(name='Cpu'),
      createTime: long(name='CreateTime'),
      dockerize: boolean(name='Dockerize'),
      email: string(name='Email'),
      healthCheckUrl: string(name='HealthCheckUrl'),
      instanceCount: integer(name='InstanceCount'),
      launchTime: long(name='LaunchTime'),
      memory: integer(name='Memory'),
      name: string(name='Name'),
      owner: string(name='Owner'),
      phone: string(name='Phone'),
      port: integer(name='Port'),
      regionId: string(name='RegionId'),
      runningInstanceCount: integer(name='RunningInstanceCount'),
      userId: string(name='UserId'),
    }(name='Application'),
  }(name='AppInfo'),
}

model QueryApplicationStatusResponse = {
  headers: map[string]string(name='headers'),
  body: QueryApplicationStatusResponseBody(name='body'),
}

async function queryApplicationStatusWithOptions(request: QueryApplicationStatusRequest, runtime: Util.RuntimeOptions): QueryApplicationStatusResponse {
  Util.validateModel(request);
  return doRequestWithAction('QueryApplicationStatus', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/app/app_status`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function queryApplicationStatus(request: QueryApplicationStatusRequest): QueryApplicationStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryApplicationStatusWithOptions(request, runtime);
}

model MigrateEcuQuery = {
  instanceIds: string(name='InstanceIds'),
  logicalRegionId?: string(name='LogicalRegionId'),
}

model MigrateEcuRequest = {
  headers?: map[string]string(name='headers'),
  query: MigrateEcuQuery(name='query'),
}

model MigrateEcuResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  data: string(name='Data'),
  requestId: string(name='RequestId'),
}

model MigrateEcuResponse = {
  headers: map[string]string(name='headers'),
  body: MigrateEcuResponseBody(name='body'),
}

async function migrateEcuWithOptions(request: MigrateEcuRequest, runtime: Util.RuntimeOptions): MigrateEcuResponse {
  Util.validateModel(request);
  return doRequestWithAction('MigrateEcu', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/resource/migrate_ecu`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function migrateEcu(request: MigrateEcuRequest): MigrateEcuResponse {
  var runtime = new Util.RuntimeOptions{};
  return migrateEcuWithOptions(request, runtime);
}

model ListUserDefineRegionQuery = {
  debugEnable?: boolean(name='DebugEnable'),
}

model ListUserDefineRegionRequest = {
  headers?: map[string]string(name='headers'),
  query?: ListUserDefineRegionQuery(name='query'),
}

model ListUserDefineRegionResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  userDefineRegionList: {
    userDefineRegionEntity: [
      {
        id: long(name='Id'),
        userId: string(name='UserId'),
        regionId: string(name='RegionId'),
        regionName: string(name='RegionName'),
        description: string(name='Description'),
        belongRegion: string(name='BelongRegion'),
        debugEnable: boolean(name='DebugEnable'),
      }
    ](name='UserDefineRegionEntity'),
  }(name='UserDefineRegionList'),
}

model ListUserDefineRegionResponse = {
  headers: map[string]string(name='headers'),
  body: ListUserDefineRegionResponseBody(name='body'),
}

async function listUserDefineRegionWithOptions(request: ListUserDefineRegionRequest, runtime: Util.RuntimeOptions): ListUserDefineRegionResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListUserDefineRegion', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/user_region_defs`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function listUserDefineRegion(request: ListUserDefineRegionRequest): ListUserDefineRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUserDefineRegionWithOptions(request, runtime);
}

model ListSubAccountRequest = {
  headers?: map[string]string(name='headers'),
}

model ListSubAccountResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  subAccountList: {
    subAccount: [
      {
        adminUserId: string(name='AdminUserId'),
        subUserId: string(name='SubUserId'),
        email: string(name='Email'),
        phone: string(name='Phone'),
        adminUserKp: string(name='AdminUserKp'),
        subUserKp: string(name='SubUserKp'),
        adminEdasId: string(name='AdminEdasId'),
        subEdasId: string(name='SubEdasId'),
      }
    ](name='SubAccount'),
  }(name='SubAccountList'),
}

model ListSubAccountResponse = {
  headers: map[string]string(name='headers'),
  body: ListSubAccountResponseBody(name='body'),
}

async function listSubAccountWithOptions(request: ListSubAccountRequest, runtime: Util.RuntimeOptions): ListSubAccountResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListSubAccount', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/account/sub_account_list`, null, request.headers, null, runtime);
}

async function listSubAccount(request: ListSubAccountRequest): ListSubAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSubAccountWithOptions(request, runtime);
}

model ListSlbRequest = {
  headers?: map[string]string(name='headers'),
}

model ListSlbResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  slbList: {
    slbEntity: [
      {
        slbId: string(name='SlbId'),
        slbName: string(name='SlbName'),
        regionId: string(name='RegionId'),
        userId: string(name='UserId'),
        address: string(name='Address'),
        slbStatus: string(name='SlbStatus'),
        addressType: string(name='AddressType'),
        vswitchId: string(name='VswitchId'),
        vpcId: string(name='VpcId'),
        networkType: string(name='NetworkType'),
        groupId: integer(name='GroupId'),
        expired: boolean(name='Expired'),
      }
    ](name='SlbEntity'),
  }(name='SlbList'),
}

model ListSlbResponse = {
  headers: map[string]string(name='headers'),
  body: ListSlbResponseBody(name='body'),
}

async function listSlbWithOptions(request: ListSlbRequest, runtime: Util.RuntimeOptions): ListSlbResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListSlb', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/slb_list`, null, request.headers, null, runtime);
}

async function listSlb(request: ListSlbRequest): ListSlbResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSlbWithOptions(request, runtime);
}

model ListServiceGroupsRequest = {
  headers?: map[string]string(name='headers'),
}

model ListServiceGroupsResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  serviceGroupsList: {
    listServiceGroups: [
      {
        createTime: string(name='CreateTime'),
        groupId: string(name='GroupId'),
        groupName: string(name='GroupName'),
      }
    ](name='ListServiceGroups'),
  }(name='ServiceGroupsList'),
}

model ListServiceGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListServiceGroupsResponseBody(name='body'),
}

async function listServiceGroupsWithOptions(request: ListServiceGroupsRequest, runtime: Util.RuntimeOptions): ListServiceGroupsResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListServiceGroups', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/service/serviceGroups`, null, request.headers, null, runtime);
}

async function listServiceGroups(request: ListServiceGroupsRequest): ListServiceGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listServiceGroupsWithOptions(request, runtime);
}

model ListScaleOutEcuQuery = {
  logicalRegionId?: string(name='LogicalRegionId'),
  clusterId?: string(name='ClusterId'),
  appId?: string(name='AppId'),
  groupId?: string(name='GroupId'),
  cpu?: integer(name='Cpu'),
  mem?: integer(name='Mem'),
  instanceNum?: integer(name='InstanceNum'),
}

model ListScaleOutEcuRequest = {
  headers?: map[string]string(name='headers'),
  query?: ListScaleOutEcuQuery(name='query'),
}

model ListScaleOutEcuResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  ecuInfoList: {
    ecuInfo: [
      {
        ecuId: string(name='EcuId'),
        online: boolean(name='Online'),
        dockerEnv: boolean(name='DockerEnv'),
        createTime: long(name='CreateTime'),
        updateTime: long(name='UpdateTime'),
        ipAddr: string(name='IpAddr'),
        heartbeatTime: long(name='HeartbeatTime'),
        userId: string(name='UserId'),
        name: string(name='Name'),
        zoneId: string(name='ZoneId'),
        regionId: string(name='RegionId'),
        instanceId: string(name='InstanceId'),
        vpcId: string(name='VpcId'),
        availableCpu: integer(name='AvailableCpu'),
        availableMem: integer(name='AvailableMem'),
      }
    ](name='EcuInfo'),
  }(name='EcuInfoList'),
}

model ListScaleOutEcuResponse = {
  headers: map[string]string(name='headers'),
  body: ListScaleOutEcuResponseBody(name='body'),
}

async function listScaleOutEcuWithOptions(request: ListScaleOutEcuRequest, runtime: Util.RuntimeOptions): ListScaleOutEcuResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListScaleOutEcu', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/resource/scale_out_ecu_list`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function listScaleOutEcu(request: ListScaleOutEcuRequest): ListScaleOutEcuResponse {
  var runtime = new Util.RuntimeOptions{};
  return listScaleOutEcuWithOptions(request, runtime);
}

model ListRoleRequest = {
  headers?: map[string]string(name='headers'),
}

model ListRoleResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  roleList: {
    roleItem: [
      {
        actionList: {
          action: [
            {
              groupId: string(name='GroupId'),
              code: string(name='Code'),
              name: string(name='Name'),
              description: string(name='Description'),
            }
          ](name='Action'),
        }(name='ActionList'),
        role: {
          id: integer(name='Id'),
          adminUserId: string(name='AdminUserId'),
          name: string(name='Name'),
          createTime: long(name='CreateTime'),
          updateTime: long(name='UpdateTime'),
          isDefault: boolean(name='IsDefault'),
        }(name='Role'),
      }
    ](name='RoleItem'),
  }(name='RoleList'),
}

model ListRoleResponse = {
  headers: map[string]string(name='headers'),
  body: ListRoleResponseBody(name='body'),
}

async function listRoleWithOptions(request: ListRoleRequest, runtime: Util.RuntimeOptions): ListRoleResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListRole', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/account/role_list`, null, request.headers, null, runtime);
}

async function listRole(request: ListRoleRequest): ListRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRoleWithOptions(request, runtime);
}

model ListResourceGroupRequest = {
  headers?: map[string]string(name='headers'),
}

model ListResourceGroupResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  resourceGroupList: {
    resGroupEntity: [
      {
        id: long(name='Id'),
        name: string(name='Name'),
        description: string(name='Description'),
        adminUserId: string(name='AdminUserId'),
        createTime: long(name='CreateTime'),
        updateTime: long(name='UpdateTime'),
        regionId: string(name='RegionId'),
        ecsList: {
          ecsEntity: [
            {
              instanceId: string(name='InstanceId'),
              instanceName: string(name='InstanceName'),
              hostName: string(name='HostName'),
              description: string(name='Description'),
              status: string(name='Status'),
              publicIp: string(name='PublicIp'),
              innerIp: string(name='InnerIp'),
              privateIp: string(name='PrivateIp'),
              eip: string(name='Eip'),
              serialNum: string(name='SerialNum'),
              userId: string(name='UserId'),
              zoneId: string(name='ZoneId'),
              regionId: string(name='RegionId'),
              expired: boolean(name='Expired'),
              sgId: string(name='SgId'),
              vpcId: string(name='VpcId'),
              groupId: string(name='GroupId'),
              cpu: integer(name='Cpu'),
              mem: integer(name='Mem'),
              ecuEntity: {
                ecuId: string(name='EcuId'),
                online: boolean(name='Online'),
                dockerEnv: boolean(name='DockerEnv'),
                createTime: long(name='CreateTime'),
                updateTime: long(name='UpdateTime'),
                ipAddr: string(name='IpAddr'),
                heartbeatTime: long(name='HeartbeatTime'),
                userId: string(name='UserId'),
                name: string(name='Name'),
                zoneId: string(name='ZoneId'),
                regionId: string(name='RegionId'),
                instanceId: string(name='InstanceId'),
                vpcId: string(name='VpcId'),
                availableCpu: integer(name='AvailableCpu'),
                availableMem: integer(name='AvailableMem'),
                cpu: integer(name='Cpu'),
                mem: integer(name='Mem'),
              }(name='EcuEntity'),
              vpcEntity: {
                vpcId: string(name='VpcId'),
                vpcName: string(name='VpcName'),
                regionId: string(name='RegionId'),
                userId: string(name='UserId'),
                cidrblock: string(name='Cidrblock'),
                status: string(name='Status'),
                description: string(name='Description'),
                expired: boolean(name='Expired'),
                ecsNum: integer(name='EcsNum'),
              }(name='VpcEntity'),
            }
          ](name='EcsEntity'),
        }(name='ecsList'),
        slbList: {
          slbEntity: [
            {
              slbId: string(name='SlbId'),
              slbName: string(name='SlbName'),
              regionId: string(name='RegionId'),
              userId: string(name='UserId'),
              address: string(name='Address'),
              slbStatus: string(name='SlbStatus'),
              addressType: string(name='AddressType'),
              vswitchId: string(name='VswitchId'),
              vpcId: string(name='VpcId'),
              networkType: string(name='NetworkType'),
              groupId: integer(name='GroupId'),
              expired: boolean(name='Expired'),
            }
          ](name='SlbEntity'),
        }(name='SlbList'),
      }
    ](name='ResGroupEntity'),
  }(name='ResourceGroupList'),
}

model ListResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ListResourceGroupResponseBody(name='body'),
}

async function listResourceGroupWithOptions(request: ListResourceGroupRequest, runtime: Util.RuntimeOptions): ListResourceGroupResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListResourceGroup', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/resource/reg_group_list`, null, request.headers, null, runtime);
}

async function listResourceGroup(request: ListResourceGroupRequest): ListResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return listResourceGroupWithOptions(request, runtime);
}

model ListRecentChangeOrderQuery = {
  appId: string(name='AppId'),
}

model ListRecentChangeOrderRequest = {
  headers?: map[string]string(name='headers'),
  query: ListRecentChangeOrderQuery(name='query'),
}

model ListRecentChangeOrderResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  changeOrderList: {
    changeOrder: [
      {
        changeOrderId: string(name='ChangeOrderId'),
        userId: string(name='UserId'),
        batchType: string(name='BatchType'),
        batchCount: integer(name='BatchCount'),
        appId: string(name='AppId'),
        groupId: string(name='GroupId'),
        status: integer(name='Status'),
        createTime: string(name='CreateTime'),
        finishTime: string(name='FinishTime'),
        coType: string(name='CoType'),
        createUserId: string(name='CreateUserId'),
        coTypeCode: string(name='CoTypeCode'),
        source: string(name='Source'),
        changeOrderDescription: string(name='ChangeOrderDescription'),
      }
    ](name='ChangeOrder'),
  }(name='ChangeOrderList'),
}

model ListRecentChangeOrderResponse = {
  headers: map[string]string(name='headers'),
  body: ListRecentChangeOrderResponseBody(name='body'),
}

async function listRecentChangeOrderWithOptions(request: ListRecentChangeOrderRequest, runtime: Util.RuntimeOptions): ListRecentChangeOrderResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListRecentChangeOrder', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/changeorder/change_order_list`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function listRecentChangeOrder(request: ListRecentChangeOrderRequest): ListRecentChangeOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRecentChangeOrderWithOptions(request, runtime);
}

model ListPublishedServicesQuery = {
  appId: string(name='AppId'),
}

model ListPublishedServicesRequest = {
  headers?: map[string]string(name='headers'),
  query: ListPublishedServicesQuery(name='query'),
}

model ListPublishedServicesResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  publishedServicesList: {
    listPublishedServices: [
      {
        appId: string(name='AppId'),
        dockerApplication: boolean(name='DockerApplication'),
        group2Ip: string(name='Group2Ip'),
        name: string(name='Name'),
        type: string(name='Type'),
        version: string(name='Version'),
        groups: {
          group: [ string ](name='group'),
        }(name='Groups'),
        ips: {
          ip: [ string ](name='ip'),
        }(name='Ips'),
      }
    ](name='ListPublishedServices'),
  }(name='PublishedServicesList'),
}

model ListPublishedServicesResponse = {
  headers: map[string]string(name='headers'),
  body: ListPublishedServicesResponseBody(name='body'),
}

async function listPublishedServicesWithOptions(request: ListPublishedServicesRequest, runtime: Util.RuntimeOptions): ListPublishedServicesResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListPublishedServices', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/service/listPublishedServices`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function listPublishedServices(request: ListPublishedServicesRequest): ListPublishedServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPublishedServicesWithOptions(request, runtime);
}

model ListHistoryDeployVersionQuery = {
  appId: string(name='AppId'),
}

model ListHistoryDeployVersionRequest = {
  headers?: map[string]string(name='headers'),
  query: ListHistoryDeployVersionQuery(name='query'),
}

model ListHistoryDeployVersionResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  packageVersionList: {
    packageVersion: [
      {
        id: string(name='Id'),
        packageVersion: string(name='PackageVersion'),
        appId: string(name='AppId'),
        description: string(name='Description'),
        warUrl: string(name='WarUrl'),
        createTime: long(name='CreateTime'),
        updateTime: long(name='UpdateTime'),
        type: string(name='Type'),
        publicUrl: string(name='PublicUrl'),
      }
    ](name='PackageVersion'),
  }(name='PackageVersionList'),
}

model ListHistoryDeployVersionResponse = {
  headers: map[string]string(name='headers'),
  body: ListHistoryDeployVersionResponseBody(name='body'),
}

async function listHistoryDeployVersionWithOptions(request: ListHistoryDeployVersionRequest, runtime: Util.RuntimeOptions): ListHistoryDeployVersionResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListHistoryDeployVersion', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/app/deploy_history_version_list`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function listHistoryDeployVersion(request: ListHistoryDeployVersionRequest): ListHistoryDeployVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHistoryDeployVersionWithOptions(request, runtime);
}

model ListFlowControlsQuery = {
  appId: string(name='AppId'),
}

model ListFlowControlsRequest = {
  headers?: map[string]string(name='headers'),
  query: ListFlowControlsQuery(name='query'),
}

model ListFlowControlsResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  flowControlsMap: {
    appId: string(name='AppId'),
    appName: string(name='AppName'),
    interfaceMethods: {
      interfaceMethod: [
        {
          name: string(name='name'),
          version: string(name='Version'),
          methods: {
            method: [ string ](name='Method'),
          }(name='Methods'),
        }
      ](name='InterfaceMethod'),
    }(name='InterfaceMethods'),
    appList: {
      app: [
        {
          appId: string(name='AppId'),
          name: string(name='Name'),
          regionId: string(name='RegionId'),
          description: string(name='Description'),
          owner: string(name='Owner'),
          instanceCount: integer(name='InstanceCount'),
          runningInstanceCount: integer(name='RunningInstanceCount'),
          port: integer(name='Port'),
          userId: string(name='UserId'),
          slbId: string(name='SlbId'),
          slbIp: string(name='SlbIp'),
          slbPort: integer(name='SlbPort'),
          extSlbId: string(name='ExtSlbId'),
          extSlbIp: string(name='ExtSlbIp'),
          applicationType: string(name='ApplicationType'),
          clusterType: integer(name='ClusterType'),
          clusterId: string(name='ClusterId'),
          dockerize: boolean(name='Dockerize'),
          cpu: integer(name='Cpu'),
          memory: integer(name='Memory'),
          healthCheckUrl: string(name='HealthCheckUrl'),
          buildPackageId: long(name='BuildPackageId'),
          createTime: long(name='CreateTime'),
        }
      ](name='App'),
    }(name='AppList'),
    ruleList: {
      currentPage: integer(name='CurrentPage'),
      pageSize: integer(name='pageSize'),
      totalSize: integer(name='TotalSize'),
      ruleResultList: {
        rule: [
          {
            appId: string(name='AppId'),
            consumerAppId: string(name='ConsumerAppId'),
            createTime: long(name='CreateTime'),
            granularity: string(name='Granularity'),
            id: string(name='Id'),
            resource: string(name='Resource'),
            ruleId: string(name='RuleId'),
            ruleType: string(name='RuleType'),
            state: integer(name='State'),
            strategy: string(name='Strategy'),
            threshold: integer(name='Threshold'),
            updateTime: long(name='UpdateTime'),
          }
        ](name='Rule'),
      }(name='RuleResultList'),
    }(name='RuleList'),
  }(name='FlowControlsMap'),
}

model ListFlowControlsResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowControlsResponseBody(name='body'),
}

async function listFlowControlsWithOptions(request: ListFlowControlsRequest, runtime: Util.RuntimeOptions): ListFlowControlsResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListFlowControls', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/app/flowControls`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function listFlowControls(request: ListFlowControlsRequest): ListFlowControlsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowControlsWithOptions(request, runtime);
}

model ListEcuByRegionQuery = {
  logicalRegionId?: string(name='LogicalRegionId'),
  act: string(name='Act'),
}

model ListEcuByRegionRequest = {
  headers?: map[string]string(name='headers'),
  query: ListEcuByRegionQuery(name='query'),
}

model ListEcuByRegionResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  ecuEntityList: {
    ecuEntity: [
      {
        ecuId: string(name='EcuId'),
        online: boolean(name='Online'),
        dockerEnv: boolean(name='DockerEnv'),
        createTime: long(name='CreateTime'),
        updateTime: long(name='UpdateTime'),
        ipAddr: string(name='IpAddr'),
        heartbeatTime: long(name='HeartbeatTime'),
        userId: string(name='UserId'),
        name: string(name='Name'),
        zoneId: string(name='ZoneId'),
        regionId: string(name='RegionId'),
        instanceId: string(name='InstanceId'),
        vpcId: string(name='VpcId'),
        availableCpu: integer(name='AvailableCpu'),
        availableMem: integer(name='AvailableMem'),
        cpu: integer(name='Cpu'),
        mem: integer(name='Mem'),
      }
    ](name='EcuEntity'),
  }(name='EcuEntityList'),
}

model ListEcuByRegionResponse = {
  headers: map[string]string(name='headers'),
  body: ListEcuByRegionResponseBody(name='body'),
}

async function listEcuByRegionWithOptions(request: ListEcuByRegionRequest, runtime: Util.RuntimeOptions): ListEcuByRegionResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListEcuByRegion', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/resource/ecu_list`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function listEcuByRegion(request: ListEcuByRegionRequest): ListEcuByRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEcuByRegionWithOptions(request, runtime);
}

model ListDegradeControlsQuery = {
  appId: string(name='AppId'),
}

model ListDegradeControlsRequest = {
  headers?: map[string]string(name='headers'),
  query: ListDegradeControlsQuery(name='query'),
}

model ListDegradeControlsResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  flowControlsMap: {
    appId: string(name='AppId'),
    appName: string(name='AppName'),
    interfaceMethods: {
      interfaceMethod: [
        {
          name: string(name='name'),
          version: string(name='Version'),
          methods: {
            method: [ string ](name='Method'),
          }(name='Methods'),
        }
      ](name='InterfaceMethod'),
    }(name='InterfaceMethods'),
    ruleList: {
      currentPage: integer(name='CurrentPage'),
      pageSize: integer(name='pageSize'),
      totalSize: integer(name='TotalSize'),
      ruleResultList: {
        rule: [
          {
            appId: string(name='AppId'),
            ruleId: string(name='RuleId'),
            createTime: long(name='CreateTime'),
            updateTime: long(name='UpdateTime'),
            resource: string(name='Resource'),
            rtThreshold: integer(name='RtThreshold'),
            duration: integer(name='Duration'),
            state: integer(name='State'),
            ruleType: string(name='RuleType'),
          }
        ](name='Rule'),
      }(name='RuleResultList'),
    }(name='RuleList'),
  }(name='FlowControlsMap'),
}

model ListDegradeControlsResponse = {
  headers: map[string]string(name='headers'),
  body: ListDegradeControlsResponseBody(name='body'),
}

async function listDegradeControlsWithOptions(request: ListDegradeControlsRequest, runtime: Util.RuntimeOptions): ListDegradeControlsResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListDegradeControls', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/app/degradeControls`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function listDegradeControls(request: ListDegradeControlsRequest): ListDegradeControlsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDegradeControlsWithOptions(request, runtime);
}

model ListConsumedServicesQuery = {
  appId: string(name='AppId'),
}

model ListConsumedServicesRequest = {
  headers?: map[string]string(name='headers'),
  query: ListConsumedServicesQuery(name='query'),
}

model ListConsumedServicesResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  consumedServicesList: {
    listConsumedServices: [
      {
        appId: string(name='AppId'),
        dockerApplication: boolean(name='DockerApplication'),
        group2Ip: string(name='Group2Ip'),
        name: string(name='Name'),
        type: string(name='Type'),
        version: string(name='Version'),
        groups: {
          group: [ string ](name='group'),
        }(name='Groups'),
        ips: {
          ip: [ string ](name='ip'),
        }(name='Ips'),
      }
    ](name='ListConsumedServices'),
  }(name='ConsumedServicesList'),
}

model ListConsumedServicesResponse = {
  headers: map[string]string(name='headers'),
  body: ListConsumedServicesResponseBody(name='body'),
}

async function listConsumedServicesWithOptions(request: ListConsumedServicesRequest, runtime: Util.RuntimeOptions): ListConsumedServicesResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListConsumedServices', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/service/listConsumedServices`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function listConsumedServices(request: ListConsumedServicesRequest): ListConsumedServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listConsumedServicesWithOptions(request, runtime);
}

model ListConfigCentersQuery = {
  dataIdPattern?: string(name='DataIdPattern'),
  group: string(name='Group'),
  logicalRegionId: string(name='LogicalRegionId'),
  appName?: string(name='AppName'),
}

model ListConfigCentersRequest = {
  headers?: map[string]string(name='headers'),
  query: ListConfigCentersQuery(name='query'),
}

model ListConfigCentersResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  configCentersList: {
    listConfigCenters: [
      {
        appName: string(name='AppName'),
        dataId: string(name='DataId'),
        group: string(name='Group'),
        id: string(name='Id'),
      }
    ](name='ListConfigCenters'),
  }(name='ConfigCentersList'),
}

model ListConfigCentersResponse = {
  headers: map[string]string(name='headers'),
  body: ListConfigCentersResponseBody(name='body'),
}

async function listConfigCentersWithOptions(request: ListConfigCentersRequest, runtime: Util.RuntimeOptions): ListConfigCentersResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListConfigCenters', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/configCenters`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function listConfigCenters(request: ListConfigCentersRequest): ListConfigCentersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listConfigCentersWithOptions(request, runtime);
}

model ListClusterMembersQuery = {
  clusterId: string(name='ClusterId'),
  currentPage?: integer(name='CurrentPage'),
  pageSize?: integer(name='PageSize'),
  ecsList?: string(name='EcsList'),
}

model ListClusterMembersRequest = {
  headers?: map[string]string(name='headers'),
  query: ListClusterMembersQuery(name='query'),
}

model ListClusterMembersResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  clusterMemberPage: {
    currentPage: integer(name='CurrentPage'),
    pageSize: integer(name='PageSize'),
    totalSize: integer(name='TotalSize'),
    clusterMemberList: {
      clusterMember: [
        {
          clusterMemberId: string(name='ClusterMemberId'),
          clusterId: string(name='ClusterId'),
          ecuId: string(name='EcuId'),
          ecsId: string(name='EcsId'),
          status: integer(name='Status'),
          createTime: long(name='CreateTime'),
          updateTime: long(name='UpdateTime'),
        }
      ](name='ClusterMember'),
    }(name='ClusterMemberList'),
  }(name='ClusterMemberPage'),
}

model ListClusterMembersResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterMembersResponseBody(name='body'),
}

async function listClusterMembersWithOptions(request: ListClusterMembersRequest, runtime: Util.RuntimeOptions): ListClusterMembersResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListClusterMembers', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/resource/cluster_member_list`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function listClusterMembers(request: ListClusterMembersRequest): ListClusterMembersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterMembersWithOptions(request, runtime);
}

model ListAuthorityRequest = {
  headers?: map[string]string(name='headers'),
}

model ListAuthorityResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  authorityList: {
    authority: [
      {
        groupId: string(name='GroupId'),
        name: string(name='Name'),
        description: string(name='Description'),
        actionList: {
          action: [
            {
              groupId: string(name='GroupId'),
              code: string(name='Code'),
              name: string(name='Name'),
              description: string(name='Description'),
            }
          ](name='Action'),
        }(name='ActionList'),
      }
    ](name='Authority'),
  }(name='AuthorityList'),
}

model ListAuthorityResponse = {
  headers: map[string]string(name='headers'),
  body: ListAuthorityResponseBody(name='body'),
}

async function listAuthorityWithOptions(request: ListAuthorityRequest, runtime: Util.RuntimeOptions): ListAuthorityResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListAuthority', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/account/authority_list`, null, request.headers, null, runtime);
}

async function listAuthority(request: ListAuthorityRequest): ListAuthorityResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAuthorityWithOptions(request, runtime);
}

model ListAliyunRegionRequest = {
  headers?: map[string]string(name='headers'),
}

model ListAliyunRegionResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  regionEntityList: {
    regionEntity: [
      {
        id: string(name='Id'),
        name: string(name='Name'),
      }
    ](name='RegionEntity'),
  }(name='RegionEntityList'),
}

model ListAliyunRegionResponse = {
  headers: map[string]string(name='headers'),
  body: ListAliyunRegionResponseBody(name='body'),
}

async function listAliyunRegionWithOptions(request: ListAliyunRegionRequest, runtime: Util.RuntimeOptions): ListAliyunRegionResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListAliyunRegion', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/resource/region_list`, null, request.headers, null, runtime);
}

async function listAliyunRegion(request: ListAliyunRegionRequest): ListAliyunRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAliyunRegionWithOptions(request, runtime);
}

model InsertServiceGroupQuery = {
  groupName: string(name='GroupName'),
}

model InsertServiceGroupRequest = {
  headers?: map[string]string(name='headers'),
  query: InsertServiceGroupQuery(name='query'),
}

model InsertServiceGroupResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

model InsertServiceGroupResponse = {
  headers: map[string]string(name='headers'),
  body: InsertServiceGroupResponseBody(name='body'),
}

async function insertServiceGroupWithOptions(request: InsertServiceGroupRequest, runtime: Util.RuntimeOptions): InsertServiceGroupResponse {
  Util.validateModel(request);
  return doRequestWithAction('InsertServiceGroup', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/service/serviceGroups`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function insertServiceGroup(request: InsertServiceGroupRequest): InsertServiceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return insertServiceGroupWithOptions(request, runtime);
}

model InsertRoleQuery = {
  roleName: string(name='RoleName'),
  actionData: string(name='ActionData'),
}

model InsertRoleRequest = {
  headers?: map[string]string(name='headers'),
  query: InsertRoleQuery(name='query'),
}

model InsertRoleResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  roleId: integer(name='RoleId'),
  requestId: string(name='RequestId'),
}

model InsertRoleResponse = {
  headers: map[string]string(name='headers'),
  body: InsertRoleResponseBody(name='body'),
}

async function insertRoleWithOptions(request: InsertRoleRequest, runtime: Util.RuntimeOptions): InsertRoleResponse {
  Util.validateModel(request);
  return doRequestWithAction('InsertRole', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/account/create_role`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function insertRole(request: InsertRoleRequest): InsertRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return insertRoleWithOptions(request, runtime);
}

model InsertOrUpdateRegionQuery = {
  regionTag: string(name='RegionTag'),
  regionName: string(name='RegionName'),
  description?: string(name='Description'),
  id?: long(name='Id'),
  debugEnable?: boolean(name='DebugEnable'),
}

model InsertOrUpdateRegionRequest = {
  headers?: map[string]string(name='headers'),
  query: InsertOrUpdateRegionQuery(name='query'),
}

model InsertOrUpdateRegionResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  userDefineRegionEntity: {
    id: long(name='Id'),
    userId: string(name='UserId'),
    regionId: string(name='RegionId'),
    regionName: string(name='RegionName'),
    description: string(name='Description'),
    belongRegion: string(name='BelongRegion'),
    debugEnable: boolean(name='DebugEnable'),
  }(name='UserDefineRegionEntity'),
}

model InsertOrUpdateRegionResponse = {
  headers: map[string]string(name='headers'),
  body: InsertOrUpdateRegionResponseBody(name='body'),
}

async function insertOrUpdateRegionWithOptions(request: InsertOrUpdateRegionRequest, runtime: Util.RuntimeOptions): InsertOrUpdateRegionResponse {
  Util.validateModel(request);
  return doRequestWithAction('InsertOrUpdateRegion', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/user_region_def`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function insertOrUpdateRegion(request: InsertOrUpdateRegionRequest): InsertOrUpdateRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  return insertOrUpdateRegionWithOptions(request, runtime);
}

model InsertConfigCenterQuery = {
  dataId: string(name='DataId'),
  group: string(name='Group'),
  data: string(name='Data'),
  logicalRegionId: string(name='LogicalRegionId'),
  appName?: string(name='AppName'),
}

model InsertConfigCenterRequest = {
  headers?: map[string]string(name='headers'),
  query: InsertConfigCenterQuery(name='query'),
}

model InsertConfigCenterResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

model InsertConfigCenterResponse = {
  headers: map[string]string(name='headers'),
  body: InsertConfigCenterResponseBody(name='body'),
}

async function insertConfigCenterWithOptions(request: InsertConfigCenterRequest, runtime: Util.RuntimeOptions): InsertConfigCenterResponse {
  Util.validateModel(request);
  return doRequestWithAction('InsertConfigCenter', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/configCenter`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function insertConfigCenter(request: InsertConfigCenterRequest): InsertConfigCenterResponse {
  var runtime = new Util.RuntimeOptions{};
  return insertConfigCenterWithOptions(request, runtime);
}

model InsertFlowControlQuery = {
  appId: string(name='AppId'),
  consumerAppId?: string(name='ConsumerAppId'),
  granularity: string(name='Granularity'),
  methodName?: string(name='MethodName'),
  ruleType: string(name='RuleType'),
  serviceName?: string(name='ServiceName'),
  strategy?: string(name='Strategy'),
  threshold: integer(name='Threshold'),
  urlVar?: string(name='UrlVar'),
}

model InsertFlowControlRequest = {
  headers?: map[string]string(name='headers'),
  query: InsertFlowControlQuery(name='query'),
}

model InsertFlowControlResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

model InsertFlowControlResponse = {
  headers: map[string]string(name='headers'),
  body: InsertFlowControlResponseBody(name='body'),
}

async function insertFlowControlWithOptions(request: InsertFlowControlRequest, runtime: Util.RuntimeOptions): InsertFlowControlResponse {
  Util.validateModel(request);
  return doRequestWithAction('InsertFlowControl', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/flowControl`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function insertFlowControl(request: InsertFlowControlRequest): InsertFlowControlResponse {
  var runtime = new Util.RuntimeOptions{};
  return insertFlowControlWithOptions(request, runtime);
}

model InsertDeployGroupQuery = {
  appId: string(name='AppId'),
  groupName: string(name='GroupName'),
  initPackageVersionId?: string(name='InitPackageVersionId'),
}

model InsertDeployGroupRequest = {
  headers?: map[string]string(name='headers'),
  query: InsertDeployGroupQuery(name='query'),
}

model InsertDeployGroupResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  deployGroupEntity: {
    id: string(name='Id'),
    groupName: string(name='GroupName'),
    groupType: integer(name='GroupType'),
    appId: string(name='AppId'),
    clusterId: string(name='ClusterId'),
    packageVersionId: string(name='PackageVersionId'),
    appVersionId: string(name='AppVersionId'),
    createTime: long(name='CreateTime'),
    updateTime: long(name='UpdateTime'),
  }(name='DeployGroupEntity'),
}

model InsertDeployGroupResponse = {
  headers: map[string]string(name='headers'),
  body: InsertDeployGroupResponseBody(name='body'),
}

async function insertDeployGroupWithOptions(request: InsertDeployGroupRequest, runtime: Util.RuntimeOptions): InsertDeployGroupResponse {
  Util.validateModel(request);
  return doRequestWithAction('InsertDeployGroup', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/deploy_group`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function insertDeployGroup(request: InsertDeployGroupRequest): InsertDeployGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return insertDeployGroupWithOptions(request, runtime);
}

model InsertDegradeControlQuery = {
  appId: string(name='AppId'),
  duration: integer(name='Duration'),
  methodName?: string(name='MethodName'),
  rtThreshold: integer(name='RtThreshold'),
  serviceName?: string(name='ServiceName'),
  urlVar?: string(name='UrlVar'),
  ruleType: string(name='RuleType'),
}

model InsertDegradeControlRequest = {
  headers?: map[string]string(name='headers'),
  query: InsertDegradeControlQuery(name='query'),
}

model InsertDegradeControlResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

model InsertDegradeControlResponse = {
  headers: map[string]string(name='headers'),
  body: InsertDegradeControlResponseBody(name='body'),
}

async function insertDegradeControlWithOptions(request: InsertDegradeControlRequest, runtime: Util.RuntimeOptions): InsertDegradeControlResponse {
  Util.validateModel(request);
  return doRequestWithAction('InsertDegradeControl', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/degradeControl`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function insertDegradeControl(request: InsertDegradeControlRequest): InsertDegradeControlResponse {
  var runtime = new Util.RuntimeOptions{};
  return insertDegradeControlWithOptions(request, runtime);
}

model InsertClusterQuery = {
  logicalRegionId?: string(name='LogicalRegionId'),
  clusterName: string(name='ClusterName'),
  clusterType: integer(name='ClusterType'),
  networkMode: integer(name='NetworkMode'),
  vpcId?: string(name='VpcId'),
  oversoldFactor?: integer(name='OversoldFactor'),
  iaasProvider?: string(name='IaasProvider'),
}

model InsertClusterRequest = {
  headers?: map[string]string(name='headers'),
  query: InsertClusterQuery(name='query'),
}

model InsertClusterResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  cluster: {
    clusterId: string(name='ClusterId'),
    regionId: string(name='RegionId'),
    clusterName: string(name='ClusterName'),
    clusterType: integer(name='ClusterType'),
    oversoldFactor: integer(name='OversoldFactor'),
    networkMode: integer(name='NetworkMode'),
    vpcId: string(name='VpcId'),
    iaasProvider: string(name='IaasProvider'),
  }(name='Cluster'),
}

model InsertClusterResponse = {
  headers: map[string]string(name='headers'),
  body: InsertClusterResponseBody(name='body'),
}

async function insertClusterWithOptions(request: InsertClusterRequest, runtime: Util.RuntimeOptions): InsertClusterResponse {
  Util.validateModel(request);
  return doRequestWithAction('InsertCluster', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/resource/cluster`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function insertCluster(request: InsertClusterRequest): InsertClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return insertClusterWithOptions(request, runtime);
}

model GetJvmConfigurationQuery = {
  appId: string(name='AppId'),
  groupId?: string(name='GroupId'),
}

model GetJvmConfigurationRequest = {
  headers?: map[string]string(name='headers'),
  query: GetJvmConfigurationQuery(name='query'),
}

model GetJvmConfigurationResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  jvmConfiguration: {
    options: string(name='Options'),
    minHeapSize: integer(name='MinHeapSize'),
    maxPermSize: integer(name='MaxPermSize'),
    maxHeapSize: integer(name='MaxHeapSize'),
  }(name='JvmConfiguration'),
}

model GetJvmConfigurationResponse = {
  headers: map[string]string(name='headers'),
  body: GetJvmConfigurationResponseBody(name='body'),
}

async function getJvmConfigurationWithOptions(request: GetJvmConfigurationRequest, runtime: Util.RuntimeOptions): GetJvmConfigurationResponse {
  Util.validateModel(request);
  return doRequestWithAction('GetJvmConfiguration', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/app/app_jvm_config`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function getJvmConfiguration(request: GetJvmConfigurationRequest): GetJvmConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return getJvmConfigurationWithOptions(request, runtime);
}

model GetContainerConfigurationQuery = {
  appId: string(name='AppId'),
  groupId?: string(name='GroupId'),
}

model GetContainerConfigurationRequest = {
  headers?: map[string]string(name='headers'),
  query: GetContainerConfigurationQuery(name='query'),
}

model GetContainerConfigurationResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  containerConfiguration: {
    contextPath: string(name='ContextPath'),
    httpPort: integer(name='HttpPort'),
    maxThreads: integer(name='MaxThreads'),
    URIEncoding: string(name='URIEncoding'),
    useBodyEncoding: boolean(name='UseBodyEncoding'),
  }(name='ContainerConfiguration'),
}

model GetContainerConfigurationResponse = {
  headers: map[string]string(name='headers'),
  body: GetContainerConfigurationResponseBody(name='body'),
}

async function getContainerConfigurationWithOptions(request: GetContainerConfigurationRequest, runtime: Util.RuntimeOptions): GetContainerConfigurationResponse {
  Util.validateModel(request);
  return doRequestWithAction('GetContainerConfiguration', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/app/container_config`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function getContainerConfiguration(request: GetContainerConfigurationRequest): GetContainerConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return getContainerConfigurationWithOptions(request, runtime);
}

model GetApplicationQuery = {
  appId: string(name='AppId'),
}

model GetApplicationRequest = {
  headers?: map[string]string(name='headers'),
  query: GetApplicationQuery(name='query'),
}

model GetApplicationResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  applcation: {
    appId: string(name='AppId'),
    name: string(name='Name'),
    regionId: string(name='RegionId'),
    description: string(name='Description'),
    owner: string(name='Owner'),
    instanceCount: integer(name='InstanceCount'),
    runningInstanceCount: integer(name='RunningInstanceCount'),
    port: integer(name='Port'),
    userId: string(name='UserId'),
    slbId: string(name='SlbId'),
    slbIp: string(name='SlbIp'),
    slbPort: integer(name='SlbPort'),
    extSlbId: string(name='ExtSlbId'),
    extSlbIp: string(name='ExtSlbIp'),
    slbName: string(name='SlbName'),
    extSlbName: string(name='ExtSlbName'),
    applicationType: string(name='ApplicationType'),
    clusterType: integer(name='ClusterType'),
    clusterId: string(name='ClusterId'),
    dockerize: boolean(name='Dockerize'),
    cpu: integer(name='Cpu'),
    memory: integer(name='Memory'),
    healthCheckUrl: string(name='HealthCheckUrl'),
    buildPackageId: long(name='BuildPackageId'),
    createTime: long(name='CreateTime'),
    nameSpace: string(name='NameSpace'),
    slbInfo: string(name='SlbInfo'),
    email: string(name='Email'),
  }(name='Applcation'),
}

model GetApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: GetApplicationResponseBody(name='body'),
}

async function getApplicationWithOptions(request: GetApplicationRequest, runtime: Util.RuntimeOptions): GetApplicationResponse {
  Util.validateModel(request);
  return doRequestWithAction('GetApplication', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/app/app_info`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function getApplication(request: GetApplicationRequest): GetApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return getApplicationWithOptions(request, runtime);
}

model EnableFlowControlQuery = {
  appId: string(name='AppId'),
  ruleId: string(name='RuleId'),
}

model EnableFlowControlRequest = {
  headers?: map[string]string(name='headers'),
  query: EnableFlowControlQuery(name='query'),
}

model EnableFlowControlResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

model EnableFlowControlResponse = {
  headers: map[string]string(name='headers'),
  body: EnableFlowControlResponseBody(name='body'),
}

async function enableFlowControlWithOptions(request: EnableFlowControlRequest, runtime: Util.RuntimeOptions): EnableFlowControlResponse {
  Util.validateModel(request);
  return doRequestWithAction('EnableFlowControl', '2017-08-01', 'HTTPS', 'PUT', 'AK', `/pop/v5/flowcontrol/enable`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function enableFlowControl(request: EnableFlowControlRequest): EnableFlowControlResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableFlowControlWithOptions(request, runtime);
}

model EnableDegradeControlQuery = {
  appId: string(name='AppId'),
  ruleId: string(name='RuleId'),
}

model EnableDegradeControlRequest = {
  headers?: map[string]string(name='headers'),
  query: EnableDegradeControlQuery(name='query'),
}

model EnableDegradeControlResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

model EnableDegradeControlResponse = {
  headers: map[string]string(name='headers'),
  body: EnableDegradeControlResponseBody(name='body'),
}

async function enableDegradeControlWithOptions(request: EnableDegradeControlRequest, runtime: Util.RuntimeOptions): EnableDegradeControlResponse {
  Util.validateModel(request);
  return doRequestWithAction('EnableDegradeControl', '2017-08-01', 'HTTPS', 'PUT', 'AK', `/pop/v5/degradecontrol/enable`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function enableDegradeControl(request: EnableDegradeControlRequest): EnableDegradeControlResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableDegradeControlWithOptions(request, runtime);
}

model DisableFlowControlQuery = {
  appId: string(name='AppId'),
  ruleId: string(name='RuleId'),
}

model DisableFlowControlRequest = {
  headers?: map[string]string(name='headers'),
  query: DisableFlowControlQuery(name='query'),
}

model DisableFlowControlResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

model DisableFlowControlResponse = {
  headers: map[string]string(name='headers'),
  body: DisableFlowControlResponseBody(name='body'),
}

async function disableFlowControlWithOptions(request: DisableFlowControlRequest, runtime: Util.RuntimeOptions): DisableFlowControlResponse {
  Util.validateModel(request);
  return doRequestWithAction('DisableFlowControl', '2017-08-01', 'HTTPS', 'PUT', 'AK', `/pop/v5/flowcontrol/disable`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function disableFlowControl(request: DisableFlowControlRequest): DisableFlowControlResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableFlowControlWithOptions(request, runtime);
}

model DisableDegradeControlQuery = {
  appId: string(name='AppId'),
  ruleId: string(name='RuleId'),
}

model DisableDegradeControlRequest = {
  headers?: map[string]string(name='headers'),
  query: DisableDegradeControlQuery(name='query'),
}

model DisableDegradeControlResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

model DisableDegradeControlResponse = {
  headers: map[string]string(name='headers'),
  body: DisableDegradeControlResponseBody(name='body'),
}

async function disableDegradeControlWithOptions(request: DisableDegradeControlRequest, runtime: Util.RuntimeOptions): DisableDegradeControlResponse {
  Util.validateModel(request);
  return doRequestWithAction('DisableDegradeControl', '2017-08-01', 'HTTPS', 'PUT', 'AK', `/pop/v5/degradecontrol/disable`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function disableDegradeControl(request: DisableDegradeControlRequest): DisableDegradeControlResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableDegradeControlWithOptions(request, runtime);
}

model DeleteUserDefineRegionQuery = {
  id: long(name='Id'),
  regionTag?: string(name='RegionTag'),
}

model DeleteUserDefineRegionRequest = {
  headers?: map[string]string(name='headers'),
  query: DeleteUserDefineRegionQuery(name='query'),
}

model DeleteUserDefineRegionResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  regionDefine: {
    id: long(name='Id'),
    userId: string(name='UserId'),
    regionId: string(name='RegionId'),
    regionName: string(name='RegionName'),
    description: string(name='Description'),
    belongRegion: string(name='BelongRegion'),
  }(name='RegionDefine'),
}

model DeleteUserDefineRegionResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteUserDefineRegionResponseBody(name='body'),
}

async function deleteUserDefineRegionWithOptions(request: DeleteUserDefineRegionRequest, runtime: Util.RuntimeOptions): DeleteUserDefineRegionResponse {
  Util.validateModel(request);
  return doRequestWithAction('DeleteUserDefineRegion', '2017-08-01', 'HTTPS', 'DELETE', 'AK', `/pop/v5/user_region_def`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function deleteUserDefineRegion(request: DeleteUserDefineRegionRequest): DeleteUserDefineRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUserDefineRegionWithOptions(request, runtime);
}

model DeleteServiceGroupQuery = {
  groupId: string(name='GroupId'),
}

model DeleteServiceGroupRequest = {
  headers?: map[string]string(name='headers'),
  query: DeleteServiceGroupQuery(name='query'),
}

model DeleteServiceGroupResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

model DeleteServiceGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteServiceGroupResponseBody(name='body'),
}

async function deleteServiceGroupWithOptions(request: DeleteServiceGroupRequest, runtime: Util.RuntimeOptions): DeleteServiceGroupResponse {
  Util.validateModel(request);
  return doRequestWithAction('DeleteServiceGroup', '2017-08-01', 'HTTPS', 'DELETE', 'AK', `/pop/v5/service/serviceGroups`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function deleteServiceGroup(request: DeleteServiceGroupRequest): DeleteServiceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteServiceGroupWithOptions(request, runtime);
}

model DeleteRoleQuery = {
  roleId: integer(name='RoleId'),
}

model DeleteRoleRequest = {
  headers?: map[string]string(name='headers'),
  query: DeleteRoleQuery(name='query'),
}

model DeleteRoleResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

model DeleteRoleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRoleResponseBody(name='body'),
}

async function deleteRoleWithOptions(request: DeleteRoleRequest, runtime: Util.RuntimeOptions): DeleteRoleResponse {
  Util.validateModel(request);
  return doRequestWithAction('DeleteRole', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/account/delete_role`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function deleteRole(request: DeleteRoleRequest): DeleteRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRoleWithOptions(request, runtime);
}

model DeleteFlowControlQuery = {
  appId: string(name='AppId'),
  ruleId: string(name='RuleId'),
}

model DeleteFlowControlRequest = {
  headers?: map[string]string(name='headers'),
  query: DeleteFlowControlQuery(name='query'),
}

model DeleteFlowControlResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

model DeleteFlowControlResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFlowControlResponseBody(name='body'),
}

async function deleteFlowControlWithOptions(request: DeleteFlowControlRequest, runtime: Util.RuntimeOptions): DeleteFlowControlResponse {
  Util.validateModel(request);
  return doRequestWithAction('DeleteFlowControl', '2017-08-01', 'HTTPS', 'DELETE', 'AK', `/pop/v5/flowControl`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function deleteFlowControl(request: DeleteFlowControlRequest): DeleteFlowControlResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFlowControlWithOptions(request, runtime);
}

model DeleteEcuQuery = {
  ecuId: string(name='EcuId'),
}

model DeleteEcuRequest = {
  headers?: map[string]string(name='headers'),
  query: DeleteEcuQuery(name='query'),
}

model DeleteEcuResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  data: string(name='Data'),
  requestId: string(name='RequestId'),
}

model DeleteEcuResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteEcuResponseBody(name='body'),
}

async function deleteEcuWithOptions(request: DeleteEcuRequest, runtime: Util.RuntimeOptions): DeleteEcuResponse {
  Util.validateModel(request);
  return doRequestWithAction('DeleteEcu', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/resource/delete_ecu`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function deleteEcu(request: DeleteEcuRequest): DeleteEcuResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEcuWithOptions(request, runtime);
}

model DeleteDeployGroupQuery = {
  appId: string(name='AppId'),
  groupName: string(name='GroupName'),
}

model DeleteDeployGroupRequest = {
  headers?: map[string]string(name='headers'),
  query: DeleteDeployGroupQuery(name='query'),
}

model DeleteDeployGroupResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  data: string(name='Data'),
  requestId: string(name='RequestId'),
}

model DeleteDeployGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDeployGroupResponseBody(name='body'),
}

async function deleteDeployGroupWithOptions(request: DeleteDeployGroupRequest, runtime: Util.RuntimeOptions): DeleteDeployGroupResponse {
  Util.validateModel(request);
  return doRequestWithAction('DeleteDeployGroup', '2017-08-01', 'HTTPS', 'DELETE', 'AK', `/pop/v5/deploy_group`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function deleteDeployGroup(request: DeleteDeployGroupRequest): DeleteDeployGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDeployGroupWithOptions(request, runtime);
}

model DeleteDegradeControlQuery = {
  appId: string(name='AppId'),
  ruleId: string(name='RuleId'),
}

model DeleteDegradeControlRequest = {
  headers?: map[string]string(name='headers'),
  query: DeleteDegradeControlQuery(name='query'),
}

model DeleteDegradeControlResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

model DeleteDegradeControlResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDegradeControlResponseBody(name='body'),
}

async function deleteDegradeControlWithOptions(request: DeleteDegradeControlRequest, runtime: Util.RuntimeOptions): DeleteDegradeControlResponse {
  Util.validateModel(request);
  return doRequestWithAction('DeleteDegradeControl', '2017-08-01', 'HTTPS', 'DELETE', 'AK', `/pop/v5/degradeControl`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function deleteDegradeControl(request: DeleteDegradeControlRequest): DeleteDegradeControlResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDegradeControlWithOptions(request, runtime);
}

model DeleteConfigCenterQuery = {
  dataId: string(name='DataId'),
  group: string(name='Group'),
  logicalRegionId: string(name='LogicalRegionId'),
}

model DeleteConfigCenterRequest = {
  headers?: map[string]string(name='headers'),
  query: DeleteConfigCenterQuery(name='query'),
}

model DeleteConfigCenterResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

model DeleteConfigCenterResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteConfigCenterResponseBody(name='body'),
}

async function deleteConfigCenterWithOptions(request: DeleteConfigCenterRequest, runtime: Util.RuntimeOptions): DeleteConfigCenterResponse {
  Util.validateModel(request);
  return doRequestWithAction('DeleteConfigCenter', '2017-08-01', 'HTTPS', 'DELETE', 'AK', `/pop/v5/configCenter`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function deleteConfigCenter(request: DeleteConfigCenterRequest): DeleteConfigCenterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteConfigCenterWithOptions(request, runtime);
}

model DeleteClusterMemberQuery = {
  clusterId: string(name='ClusterId'),
  clusterMemberId: string(name='ClusterMemberId'),
}

model DeleteClusterMemberRequest = {
  headers?: map[string]string(name='headers'),
  query: DeleteClusterMemberQuery(name='query'),
}

model DeleteClusterMemberResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  data: boolean(name='Data'),
  requestId: string(name='RequestId'),
}

model DeleteClusterMemberResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteClusterMemberResponseBody(name='body'),
}

async function deleteClusterMemberWithOptions(request: DeleteClusterMemberRequest, runtime: Util.RuntimeOptions): DeleteClusterMemberResponse {
  Util.validateModel(request);
  return doRequestWithAction('DeleteClusterMember', '2017-08-01', 'HTTPS', 'DELETE', 'AK', `/pop/v5/resource/cluster_member`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function deleteClusterMember(request: DeleteClusterMemberRequest): DeleteClusterMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteClusterMemberWithOptions(request, runtime);
}

model DeleteClusterQuery = {
  clusterId: string(name='ClusterId'),
  mode?: integer(name='Mode'),
}

model DeleteClusterRequest = {
  headers?: map[string]string(name='headers'),
  query: DeleteClusterQuery(name='query'),
}

model DeleteClusterResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  data: boolean(name='Data'),
  requestId: string(name='RequestId'),
}

model DeleteClusterResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteClusterResponseBody(name='body'),
}

async function deleteClusterWithOptions(request: DeleteClusterRequest, runtime: Util.RuntimeOptions): DeleteClusterResponse {
  Util.validateModel(request);
  return doRequestWithAction('DeleteCluster', '2017-08-01', 'HTTPS', 'DELETE', 'AK', `/pop/v5/resource/cluster`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function deleteCluster(request: DeleteClusterRequest): DeleteClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteClusterWithOptions(request, runtime);
}

model BindSlbQuery = {
  appId: string(name='AppId'),
  slbId: string(name='SlbId'),
  slbIp: string(name='SlbIp'),
  type: string(name='Type'),
  listenerPort?: integer(name='ListenerPort'),
  VServerGroupId?: string(name='VServerGroupId'),
}

model BindSlbRequest = {
  headers?: map[string]string(name='headers'),
  query: BindSlbQuery(name='query'),
}

model BindSlbResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  data: {
    extSlbId: string(name='ExtSlbId'),
    extSlbIp: string(name='ExtSlbIp'),
    extSlbName: string(name='ExtSlbName'),
    extVServerGroupId: string(name='ExtVServerGroupId'),
    slbId: string(name='SlbId'),
    slbIp: string(name='SlbIp'),
    slbName: string(name='SlbName'),
    slbPort: integer(name='SlbPort'),
    VServerGroupId: string(name='VServerGroupId'),
  }(name='Data'),
}

model BindSlbResponse = {
  headers: map[string]string(name='headers'),
  body: BindSlbResponseBody(name='body'),
}

async function bindSlbWithOptions(request: BindSlbRequest, runtime: Util.RuntimeOptions): BindSlbResponse {
  Util.validateModel(request);
  return doRequestWithAction('BindSlb', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/app/bind_slb_json`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function bindSlb(request: BindSlbRequest): BindSlbResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindSlbWithOptions(request, runtime);
}

model AuthorizeRoleQuery = {
  targetUserId: string(name='TargetUserId'),
  roleIds: string(name='RoleIds'),
}

model AuthorizeRoleRequest = {
  headers?: map[string]string(name='headers'),
  query: AuthorizeRoleQuery(name='query'),
}

model AuthorizeRoleResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

model AuthorizeRoleResponse = {
  headers: map[string]string(name='headers'),
  body: AuthorizeRoleResponseBody(name='body'),
}

async function authorizeRoleWithOptions(request: AuthorizeRoleRequest, runtime: Util.RuntimeOptions): AuthorizeRoleResponse {
  Util.validateModel(request);
  return doRequestWithAction('AuthorizeRole', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/account/authorize_role`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function authorizeRole(request: AuthorizeRoleRequest): AuthorizeRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return authorizeRoleWithOptions(request, runtime);
}

model AuthorizeResourceGroupQuery = {
  targetUserId: string(name='TargetUserId'),
  resourceGroupIds: string(name='ResourceGroupIds'),
}

model AuthorizeResourceGroupRequest = {
  headers?: map[string]string(name='headers'),
  query: AuthorizeResourceGroupQuery(name='query'),
}

model AuthorizeResourceGroupResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

model AuthorizeResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  body: AuthorizeResourceGroupResponseBody(name='body'),
}

async function authorizeResourceGroupWithOptions(request: AuthorizeResourceGroupRequest, runtime: Util.RuntimeOptions): AuthorizeResourceGroupResponse {
  Util.validateModel(request);
  return doRequestWithAction('AuthorizeResourceGroup', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/account/authorize_res_group`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function authorizeResourceGroup(request: AuthorizeResourceGroupRequest): AuthorizeResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return authorizeResourceGroupWithOptions(request, runtime);
}

model AuthorizeApplicationQuery = {
  targetUserId: string(name='TargetUserId'),
  appIds: string(name='AppIds'),
}

model AuthorizeApplicationRequest = {
  headers?: map[string]string(name='headers'),
  query: AuthorizeApplicationQuery(name='query'),
}

model AuthorizeApplicationResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

model AuthorizeApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: AuthorizeApplicationResponseBody(name='body'),
}

async function authorizeApplicationWithOptions(request: AuthorizeApplicationRequest, runtime: Util.RuntimeOptions): AuthorizeApplicationResponse {
  Util.validateModel(request);
  return doRequestWithAction('AuthorizeApplication', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/account/authorize_app`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function authorizeApplication(request: AuthorizeApplicationRequest): AuthorizeApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return authorizeApplicationWithOptions(request, runtime);
}

model ListVpcRequest = {
  headers?: map[string]string(name='headers'),
}

model ListVpcResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  vpcList: {
    vpcEntity: [
      {
        vpcId: string(name='VpcId'),
        vpcName: string(name='VpcName'),
        regionId: string(name='RegionId'),
        userId: string(name='UserId'),
        expired: boolean(name='Expired'),
        ecsNum: integer(name='EcsNum'),
      }
    ](name='VpcEntity'),
  }(name='VpcList'),
}

model ListVpcResponse = {
  headers: map[string]string(name='headers'),
  body: ListVpcResponseBody(name='body'),
}

async function listVpcWithOptions(request: ListVpcRequest, runtime: Util.RuntimeOptions): ListVpcResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListVpc', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/vpc_list`, null, request.headers, null, runtime);
}

async function listVpc(request: ListVpcRequest): ListVpcResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVpcWithOptions(request, runtime);
}

model ScaleOutApplicationQuery = {
  appId: string(name='AppId'),
  ecuInfo: string(name='EcuInfo'),
  deployGroup: string(name='DeployGroup'),
}

model ScaleOutApplicationRequest = {
  headers?: map[string]string(name='headers'),
  query: ScaleOutApplicationQuery(name='query'),
}

model ScaleOutApplicationResponseBody = {
  changeOrderId: string(name='ChangeOrderId'),
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

model ScaleOutApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: ScaleOutApplicationResponseBody(name='body'),
}

async function scaleOutApplicationWithOptions(request: ScaleOutApplicationRequest, runtime: Util.RuntimeOptions): ScaleOutApplicationResponse {
  Util.validateModel(request);
  return doRequestWithAction('ScaleOutApplication', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/changeorder/co_scale_out`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function scaleOutApplication(request: ScaleOutApplicationRequest): ScaleOutApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return scaleOutApplicationWithOptions(request, runtime);
}

model ScaleInApplicationQuery = {
  appId: string(name='AppId'),
  eccInfo: string(name='EccInfo'),
  forceStatus?: boolean(name='ForceStatus'),
}

model ScaleInApplicationRequest = {
  headers?: map[string]string(name='headers'),
  query: ScaleInApplicationQuery(name='query'),
}

model ScaleInApplicationResponseBody = {
  changeOrderId: string(name='ChangeOrderId'),
  code: integer(name='Code'),
  message: string(name='Message'),
}

model ScaleInApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: ScaleInApplicationResponseBody(name='body'),
}

async function scaleInApplicationWithOptions(request: ScaleInApplicationRequest, runtime: Util.RuntimeOptions): ScaleInApplicationResponse {
  Util.validateModel(request);
  return doRequestWithAction('ScaleInApplication', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/changeorder/co_scale_in`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function scaleInApplication(request: ScaleInApplicationRequest): ScaleInApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return scaleInApplicationWithOptions(request, runtime);
}

model DeployApplicationQuery = {
  appId: string(name='AppId'),
  packageVersion: string(name='PackageVersion'),
  desc?: string(name='Desc'),
  deployType: string(name='DeployType'),
  warUrl?: string(name='WarUrl'),
  imageUrl?: string(name='ImageUrl'),
  groupId: string(name='GroupId'),
  batch?: integer(name='Batch'),
  batchWaitTime?: integer(name='BatchWaitTime'),
  appEnv?: string(name='AppEnv'),
  buildPackId?: long(name='BuildPackId'),
  componentIds?: string(name='ComponentIds'),
  releaseType?: long(name='ReleaseType'),
  gray?: boolean(name='Gray'),
  trafficControlStrategy?: string(name='TrafficControlStrategy'),
}

model DeployApplicationRequest = {
  headers?: map[string]string(name='headers'),
  query: DeployApplicationQuery(name='query'),
}

model DeployApplicationResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  changeOrderId: string(name='ChangeOrderId'),
  requestId: string(name='RequestId'),
}

model DeployApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: DeployApplicationResponseBody(name='body'),
}

async function deployApplicationWithOptions(request: DeployApplicationRequest, runtime: Util.RuntimeOptions): DeployApplicationResponse {
  Util.validateModel(request);
  return doRequestWithAction('DeployApplication', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/changeorder/co_deploy`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function deployApplication(request: DeployApplicationRequest): DeployApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deployApplicationWithOptions(request, runtime);
}

model InsertApplicationQuery = {
  clusterId?: string(name='ClusterId'),
  buildPackId?: integer(name='BuildPackId'),
  description?: string(name='Description'),
  applicationName: string(name='ApplicationName'),
  reservedPortStr?: string(name='ReservedPortStr'),
  ecuInfo?: string(name='EcuInfo'),
  cpu?: integer(name='Cpu'),
  mem?: integer(name='Mem'),
  healthCheckURL?: string(name='HealthCheckURL'),
  logicalRegionId?: string(name='LogicalRegionId'),
  jdk?: string(name='Jdk'),
  webContainer?: string(name='WebContainer'),
  packageType?: string(name='PackageType'),
  componentIds?: string(name='ComponentIds'),
}

model InsertApplicationRequest = {
  headers?: map[string]string(name='headers'),
  query: InsertApplicationQuery(name='query'),
}

model InsertApplicationResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  applicationInfo: {
    appName: string(name='AppName'),
    appId: string(name='AppId'),
    userId: string(name='UserId'),
    owner: string(name='Owner'),
    dockerize: boolean(name='Dockerize'),
    port: integer(name='Port'),
    regionName: string(name='RegionName'),
    changeOrderId: string(name='ChangeOrderId'),
  }(name='ApplicationInfo'),
}

model InsertApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: InsertApplicationResponseBody(name='body'),
}

async function insertApplicationWithOptions(request: InsertApplicationRequest, runtime: Util.RuntimeOptions): InsertApplicationResponse {
  Util.validateModel(request);
  return doRequestWithAction('InsertApplication', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/changeorder/co_create_app`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function insertApplication(request: InsertApplicationRequest): InsertApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return insertApplicationWithOptions(request, runtime);
}

model DeleteApplicationQuery = {
  appId: string(name='AppId'),
}

model DeleteApplicationRequest = {
  headers?: map[string]string(name='headers'),
  query: DeleteApplicationQuery(name='query'),
}

model DeleteApplicationResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  changeOrderId: string(name='ChangeOrderId'),
  requestId: string(name='RequestId'),
}

model DeleteApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteApplicationResponseBody(name='body'),
}

async function deleteApplicationWithOptions(request: DeleteApplicationRequest, runtime: Util.RuntimeOptions): DeleteApplicationResponse {
  Util.validateModel(request);
  return doRequestWithAction('DeleteApplication', '2017-08-01', 'HTTPS', 'DELETE', 'AK', `/pop/v5/changeorder/co_delete_app`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function deleteApplication(request: DeleteApplicationRequest): DeleteApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteApplicationWithOptions(request, runtime);
}

model UpdateContainerQuery = {
  appId: string(name='AppId'),
  buildPackId: integer(name='BuildPackId'),
}

model UpdateContainerRequest = {
  headers?: map[string]string(name='headers'),
  query: UpdateContainerQuery(name='query'),
}

model UpdateContainerResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  changeOrderId: string(name='ChangeOrderId'),
  requestId: string(name='RequestId'),
}

model UpdateContainerResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateContainerResponseBody(name='body'),
}

async function updateContainerWithOptions(request: UpdateContainerRequest, runtime: Util.RuntimeOptions): UpdateContainerResponse {
  Util.validateModel(request);
  return doRequestWithAction('UpdateContainer', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/changeorder/co_update_container`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function updateContainer(request: UpdateContainerRequest): UpdateContainerResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateContainerWithOptions(request, runtime);
}

model StopApplicationQuery = {
  appId: string(name='AppId'),
  eccInfo?: string(name='EccInfo'),
}

model StopApplicationRequest = {
  headers?: map[string]string(name='headers'),
  query: StopApplicationQuery(name='query'),
}

model StopApplicationResponseBody = {
  changeOrderId: string(name='ChangeOrderId'),
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

model StopApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: StopApplicationResponseBody(name='body'),
}

async function stopApplicationWithOptions(request: StopApplicationRequest, runtime: Util.RuntimeOptions): StopApplicationResponse {
  Util.validateModel(request);
  return doRequestWithAction('StopApplication', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/changeorder/co_stop`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function stopApplication(request: StopApplicationRequest): StopApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopApplicationWithOptions(request, runtime);
}

model StartApplicationQuery = {
  appId: string(name='AppId'),
  eccInfo?: string(name='EccInfo'),
}

model StartApplicationRequest = {
  headers?: map[string]string(name='headers'),
  query: StartApplicationQuery(name='query'),
}

model StartApplicationResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  changeOrderId: string(name='ChangeOrderId'),
  requestId: string(name='RequestId'),
}

model StartApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: StartApplicationResponseBody(name='body'),
}

async function startApplicationWithOptions(request: StartApplicationRequest, runtime: Util.RuntimeOptions): StartApplicationResponse {
  Util.validateModel(request);
  return doRequestWithAction('StartApplication', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/changeorder/co_start`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function startApplication(request: StartApplicationRequest): StartApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return startApplicationWithOptions(request, runtime);
}

model ResetApplicationQuery = {
  appId: string(name='AppId'),
  eccInfo: string(name='EccInfo'),
}

model ResetApplicationRequest = {
  headers?: map[string]string(name='headers'),
  query: ResetApplicationQuery(name='query'),
}

model ResetApplicationResponseBody = {
  changeOrderId: string(name='ChangeOrderId'),
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

model ResetApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: ResetApplicationResponseBody(name='body'),
}

async function resetApplicationWithOptions(request: ResetApplicationRequest, runtime: Util.RuntimeOptions): ResetApplicationResponse {
  Util.validateModel(request);
  return doRequestWithAction('ResetApplication', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/changeorder/co_reset`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function resetApplication(request: ResetApplicationRequest): ResetApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetApplicationWithOptions(request, runtime);
}

model ListDeployGroupQuery = {
  appId: string(name='AppId'),
}

model ListDeployGroupRequest = {
  headers?: map[string]string(name='headers'),
  query: ListDeployGroupQuery(name='query'),
}

model ListDeployGroupResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  deployGroupList: {
    deployGroup: [
      {
        groupId: string(name='GroupId'),
        groupName: string(name='GroupName'),
        appId: string(name='AppId'),
        packageVersionId: string(name='PackageVersionId'),
        appVersionId: string(name='AppVersionId'),
        groupType: integer(name='GroupType'),
        clusterId: string(name='ClusterId'),
        createTime: long(name='CreateTime'),
        updateTime: long(name='UpdateTime'),
        nameSpace: string(name='NameSpace'),
        clusterName: string(name='ClusterName'),
        lastUpdateTime: long(name='LastUpdateTime'),
        preStop: string(name='PreStop'),
        postStart: string(name='PostStart'),
        packageUrl: string(name='PackageUrl'),
        env: string(name='Env'),
        labels: string(name='Labels'),
        selector: string(name='Selector'),
        strategy: string(name='Strategy'),
        status: string(name='Status'),
        reversion: string(name='Reversion'),
        csClusterId: string(name='CsClusterId'),
        baseComponentMetaName: string(name='BaseComponentMetaName'),
        deploymentName: string(name='DeploymentName'),
        cpuLimit: string(name='CpuLimit'),
        memoryLimit: string(name='MemoryLimit'),
        packagePublicUrl: string(name='PackagePublicUrl'),
        packageVersion: string(name='PackageVersion'),
        cpuRequest: string(name='CpuRequest'),
        memoryRequest: string(name='MemoryRequest'),
        VServerGroupId: string(name='VServerGroupId'),
        VExtServerGroupId: string(name='VExtServerGroupId'),
      }
    ](name='DeployGroup'),
  }(name='DeployGroupList'),
}

model ListDeployGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ListDeployGroupResponseBody(name='body'),
}

async function listDeployGroupWithOptions(request: ListDeployGroupRequest, runtime: Util.RuntimeOptions): ListDeployGroupResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListDeployGroup', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/app/deploy_group_list`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function listDeployGroup(request: ListDeployGroupRequest): ListDeployGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDeployGroupWithOptions(request, runtime);
}

model ListBuildPackRequest = {
  headers?: map[string]string(name='headers'),
}

model ListBuildPackResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  buildPackList: {
    buildPack: [
      {
        configId: long(name='ConfigId'),
        packVersion: string(name='PackVersion'),
        tomcatDesc: string(name='TomcatDesc'),
        tomcatVersion: string(name='TomcatVersion'),
        tomcatDownloadUrl: string(name='TomcatDownloadUrl'),
        pandoraVersion: string(name='PandoraVersion'),
        pandoraDownloadUrl: string(name='PandoraDownloadUrl'),
        pandoraDesc: string(name='PandoraDesc'),
        pluginInfo: string(name='PluginInfo'),
        tomcatPath: string(name='TomcatPath'),
        imageId: string(name='ImageId'),
        tengineImageId: string(name='TengineImageId'),
        multipleTenant: boolean(name='MultipleTenant'),
        withTengine: boolean(name='WithTengine'),
        tengineDownloadUrl: string(name='TengineDownloadUrl'),
        scriptName: string(name='ScriptName'),
        scriptVersion: string(name='ScriptVersion'),
        feature: string(name='Feature'),
        supportFeatures: string(name='SupportFeatures'),
        disabled: boolean(name='Disabled'),
      }
    ](name='BuildPack'),
  }(name='BuildPackList'),
}

model ListBuildPackResponse = {
  headers: map[string]string(name='headers'),
  body: ListBuildPackResponseBody(name='body'),
}

async function listBuildPackWithOptions(request: ListBuildPackRequest, runtime: Util.RuntimeOptions): ListBuildPackResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListBuildPack', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/app/build_pack_list`, null, request.headers, null, runtime);
}

async function listBuildPack(request: ListBuildPackRequest): ListBuildPackResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBuildPackWithOptions(request, runtime);
}

model ListApplicationEcuRequest = {
  headers?: map[string]string(name='headers'),
}

model ListApplicationEcuResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  ecuInfoList: {
    ecuEntity: [
      {
        ecuId: string(name='EcuId'),
        online: boolean(name='Online'),
        dockerEnv: boolean(name='DockerEnv'),
        createTime: long(name='CreateTime'),
        updateTime: long(name='UpdateTime'),
        ipAddr: string(name='IpAddr'),
        heartbeatTime: long(name='HeartbeatTime'),
        userId: string(name='UserId'),
        name: string(name='Name'),
        zoneId: string(name='ZoneId'),
        regionId: string(name='RegionId'),
        instanceId: string(name='InstanceId'),
        vpcId: string(name='VpcId'),
        availableCpu: integer(name='AvailableCpu'),
        availableMem: integer(name='AvailableMem'),
        cpu: integer(name='Cpu'),
        mem: integer(name='Mem'),
      }
    ](name='EcuEntity'),
  }(name='EcuInfoList'),
}

model ListApplicationEcuResponse = {
  headers: map[string]string(name='headers'),
  body: ListApplicationEcuResponseBody(name='body'),
}

async function listApplicationEcuWithOptions(request: ListApplicationEcuRequest, runtime: Util.RuntimeOptions): ListApplicationEcuResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListApplicationEcu', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/resource/ecu_list`, null, request.headers, null, runtime);
}

async function listApplicationEcu(request: ListApplicationEcuRequest): ListApplicationEcuResponse {
  var runtime = new Util.RuntimeOptions{};
  return listApplicationEcuWithOptions(request, runtime);
}

model GetChangeOrderInfoQuery = {
  changeOrderId: string(name='ChangeOrderId'),
}

model GetChangeOrderInfoRequest = {
  headers?: map[string]string(name='headers'),
  query: GetChangeOrderInfoQuery(name='query'),
}

model GetChangeOrderInfoResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  changeOrderInfo: {
    changeOrderId: string(name='ChangeOrderId'),
    createUserId: string(name='CreateUserId'),
    desc: string(name='Desc'),
    batchCount: integer(name='BatchCount'),
    batchType: string(name='BatchType'),
    status: integer(name='Status'),
    coType: string(name='CoType'),
    createTime: string(name='CreateTime'),
    supportRollback: boolean(name='SupportRollback'),
    changeOrderDescription: string(name='ChangeOrderDescription'),
    pipelineInfoList: {
      pipelineInfo: [
        {
          pipelineId: string(name='PipelineId'),
          pipelineName: string(name='PipelineName'),
          pipelineStatus: integer(name='PipelineStatus'),
          startTime: string(name='StartTime'),
          updateTime: string(name='UpdateTime'),
          stageList: {
            stageInfoDTO: [
              {
                stageId: string(name='StageId'),
                stageName: string(name='StageName'),
                status: integer(name='Status'),
                stageResultDTO: {
                  instanceDTOList: {
                    instanceDTO: [
                      {
                        instanceName: string(name='InstanceName'),
                        instanceIp: string(name='InstanceIp'),
                        status: integer(name='Status'),
                        podName: string(name='PodName'),
                        podStatus: string(name='PodStatus'),
                        instanceStageDTOList: {
                          instanceStageDTO: [
                            {
                              stageId: string(name='StageId'),
                              stageName: string(name='StageName'),
                              status: integer(name='Status'),
                              stageMessage: string(name='StageMessage'),
                              startTime: string(name='StartTime'),
                              finishTime: string(name='FinishTime'),
                            }
                          ](name='InstanceStageDTO'),
                        }(name='InstanceStageDTOList'),
                      }
                    ](name='InstanceDTO'),
                  }(name='InstanceDTOList'),
                  serviceStage: {
                    stageId: string(name='StageId'),
                    stageName: string(name='StageName'),
                    status: integer(name='Status'),
                    message: string(name='Message'),
                  }(name='ServiceStage'),
                }(name='StageResultDTO'),
              }
            ](name='StageInfoDTO'),
          }(name='StageList'),
          stageDetailList: {
            stageDetailDTO: [
              {
                stageId: string(name='StageId'),
                stageName: string(name='StageName'),
                stageStatus: integer(name='StageStatus'),
                taskList: {
                  taskInfoDTO: [
                    {
                      taskName: string(name='TaskName'),
                      taskStatus: string(name='TaskStatus'),
                      taskMessage: string(name='TaskMessage'),
                      taskId: string(name='TaskId'),
                      taskErrorCode: string(name='TaskErrorCode'),
                      taskErrorMessage: string(name='TaskErrorMessage'),
                      showManualIgnorance: boolean(name='ShowManualIgnorance'),
                      taskErrorIgnorance: integer(name='TaskErrorIgnorance'),
                    }
                  ](name='TaskInfoDTO'),
                }(name='TaskList'),
              }
            ](name='StageDetailDTO'),
          }(name='StageDetailList'),
        }
      ](name='PipelineInfo'),
    }(name='PipelineInfoList'),
    trafficControl: {
      rules: string(name='Rules'),
      routes: string(name='Routes'),
      tips: string(name='Tips'),
    }(name='TrafficControl'),
  }(name='changeOrderInfo'),
}

model GetChangeOrderInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetChangeOrderInfoResponseBody(name='body'),
}

async function getChangeOrderInfoWithOptions(request: GetChangeOrderInfoRequest, runtime: Util.RuntimeOptions): GetChangeOrderInfoResponse {
  Util.validateModel(request);
  return doRequestWithAction('GetChangeOrderInfo', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/changeorder/change_order_info`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function getChangeOrderInfo(request: GetChangeOrderInfoRequest): GetChangeOrderInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getChangeOrderInfoWithOptions(request, runtime);
}

model ListClusterQuery = {
  logicalRegionId?: string(name='LogicalRegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ListClusterRequest = {
  headers?: map[string]string(name='headers'),
  query?: ListClusterQuery(name='query'),
}

model ListClusterResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  clusterList: {
    cluster: [
      {
        clusterId: string(name='ClusterId'),
        regionId: string(name='RegionId'),
        description: string(name='Description'),
        clusterName: string(name='ClusterName'),
        clusterType: integer(name='ClusterType'),
        oversoldFactor: integer(name='OversoldFactor'),
        networkMode: integer(name='NetworkMode'),
        vpcId: string(name='VpcId'),
        nodeNum: integer(name='NodeNum'),
        cpu: integer(name='Cpu'),
        mem: integer(name='Mem'),
        cpuUsed: integer(name='CpuUsed'),
        memUsed: integer(name='MemUsed'),
        createTime: long(name='CreateTime'),
        updateTime: long(name='UpdateTime'),
        iaasProvider: string(name='IaasProvider'),
        csClusterId: string(name='CsClusterId'),
        resourceGroupId: string(name='ResourceGroupId'),
      }
    ](name='Cluster'),
  }(name='ClusterList'),
}

model ListClusterResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterResponseBody(name='body'),
}

async function listClusterWithOptions(request: ListClusterRequest, runtime: Util.RuntimeOptions): ListClusterResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListCluster', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/resource/cluster_list`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function listCluster(request: ListClusterRequest): ListClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterWithOptions(request, runtime);
}

model ListApplicationQuery = {
  clusterId?: string(name='ClusterId'),
  logicalRegionId?: string(name='LogicalRegionId'),
  appName?: string(name='AppName'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ListApplicationRequest = {
  headers?: map[string]string(name='headers'),
  query?: ListApplicationQuery(name='query'),
}

model ListApplicationResponseBody = {
  code: integer(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  applicationList: {
    application: [
      {
        appId: string(name='AppId'),
        name: string(name='Name'),
        regionId: string(name='RegionId'),
        applicationType: string(name='ApplicationType'),
        clusterType: integer(name='ClusterType'),
        clusterId: string(name='ClusterId'),
        buildPackageId: long(name='BuildPackageId'),
        runningInstanceCount: integer(name='RunningInstanceCount'),
        resourceGroupId: string(name='ResourceGroupId'),
      }
    ](name='Application'),
  }(name='ApplicationList'),
}

model ListApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: ListApplicationResponseBody(name='body'),
}

async function listApplicationWithOptions(request: ListApplicationRequest, runtime: Util.RuntimeOptions): ListApplicationResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListApplication', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/app/app_list`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function listApplication(request: ListApplicationRequest): ListApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return listApplicationWithOptions(request, runtime);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
