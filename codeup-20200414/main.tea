/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  

  checkConfig(config);
  @endpoint = getEndpoint('codeup', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model AddGroupMemberRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
  clientToken?: string(name='ClientToken'),
}

model AddGroupMemberResponseBody = {
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  result?: [ 
    {
      externUserId?: string(name='ExternUserId'),
      email?: string(name='Email'),
      avatarUrl?: string(name='AvatarUrl'),
      state?: string(name='State'),
      accessLevel?: int32(name='AccessLevel'),
      id?: long(name='Id'),
    }
  ](name='Result'),
}

model AddGroupMemberResponse = {
  headers: map[string]string(name='headers'),
  body: AddGroupMemberResponseBody(name='body'),
}

async function addGroupMember(GroupId: string, request: AddGroupMemberRequest): AddGroupMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addGroupMemberWithOptions(GroupId, request, headers, runtime);
}

async function addGroupMemberWithOptions(GroupId: string, request: AddGroupMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddGroupMemberResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('AddGroupMember', '2020-04-14', 'HTTPS', 'POST', 'AK', `/api/v4/groups/${GroupId}/members`, 'json', req, runtime);
}

model AddRepositoryMemberRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
  clientToken?: string(name='ClientToken'),
}

model AddRepositoryMemberResponseBody = {
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  result?: [ 
    {
      externUserId?: string(name='ExternUserId'),
      email?: string(name='Email'),
      avatarUrl?: string(name='AvatarUrl'),
      state?: string(name='State'),
      accessLevel?: int32(name='AccessLevel'),
      id?: long(name='Id'),
    }
  ](name='Result'),
}

model AddRepositoryMemberResponse = {
  headers: map[string]string(name='headers'),
  body: AddRepositoryMemberResponseBody(name='body'),
}

async function addRepositoryMember(ProjectId: string, request: AddRepositoryMemberRequest): AddRepositoryMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addRepositoryMemberWithOptions(ProjectId, request, headers, runtime);
}

async function addRepositoryMemberWithOptions(ProjectId: string, request: AddRepositoryMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddRepositoryMemberResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('AddRepositoryMember', '2020-04-14', 'HTTPS', 'POST', 'AK', `/api/v4/projects/${ProjectId}/members`, 'json', req, runtime);
}

model AddWebhookRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model AddWebhookResponseBody = {
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  result?: {
    pushEvents?: boolean(name='PushEvents'),
    buildEvents?: boolean(name='BuildEvents'),
    projectId?: long(name='ProjectId'),
    createdAt?: string(name='CreatedAt'),
    tagPushEvents?: boolean(name='TagPushEvents'),
    issuesEvents?: boolean(name='IssuesEvents'),
    url?: string(name='Url'),
    lastTestResult?: string(name='LastTestResult'),
    mergeRequestsEvents?: boolean(name='MergeRequestsEvents'),
    description?: string(name='Description'),
    noteEvents?: boolean(name='NoteEvents'),
    secretToken?: string(name='SecretToken'),
    id?: long(name='Id'),
    enableSslVerification?: boolean(name='EnableSslVerification'),
  }(name='Result'),
}

model AddWebhookResponse = {
  headers: map[string]string(name='headers'),
  body: AddWebhookResponseBody(name='body'),
}

async function addWebhook(ProjectId: string, request: AddWebhookRequest): AddWebhookResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addWebhookWithOptions(ProjectId, request, headers, runtime);
}

async function addWebhookWithOptions(ProjectId: string, request: AddWebhookRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddWebhookResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('AddWebhook', '2020-04-14', 'HTTPS', 'POST', 'AK', `/api/v3/projects/${ProjectId}/hooks`, 'json', req, runtime);
}

model CreateBranchRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model CreateBranchResponseBody = {
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  result?: {
    protectedBranch?: boolean(name='ProtectedBranch'),
    commitInfo?: {
      shortId?: string(name='ShortId'),
      authorDate?: string(name='AuthorDate'),
      createdAt?: string(name='CreatedAt'),
      message?: string(name='Message'),
      parentIds?: [ string ](name='ParentIds'),
      authorName?: string(name='AuthorName'),
      committerName?: string(name='CommitterName'),
      title?: string(name='Title'),
      authorEmail?: string(name='AuthorEmail'),
      committerEmail?: string(name='CommitterEmail'),
      id?: string(name='Id'),
      committedDate?: string(name='CommittedDate'),
    }(name='CommitInfo'),
    branchName?: string(name='BranchName'),
  }(name='Result'),
}

model CreateBranchResponse = {
  headers: map[string]string(name='headers'),
  body: CreateBranchResponseBody(name='body'),
}

async function createBranch(ProjectId: string, request: CreateBranchRequest): CreateBranchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createBranchWithOptions(ProjectId, request, headers, runtime);
}

async function createBranchWithOptions(ProjectId: string, request: CreateBranchRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateBranchResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('CreateBranch', '2020-04-14', 'HTTPS', 'POST', 'AK', `/api/v3/projects/${ProjectId}/repository/branches`, 'json', req, runtime);
}

model CreateFileRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
  clientToken?: string(name='ClientToken'),
}

model CreateFileResponseBody = {
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  result?: {
    filePath?: string(name='FilePath'),
    branchName?: string(name='BranchName'),
  }(name='Result'),
}

model CreateFileResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFileResponseBody(name='body'),
}

async function createFile(ProjectId: string, request: CreateFileRequest): CreateFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createFileWithOptions(ProjectId, request, headers, runtime);
}

async function createFileWithOptions(ProjectId: string, request: CreateFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateFileResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('CreateFile', '2020-04-14', 'HTTPS', 'POST', 'AK', `/api/v3/projects/${ProjectId}/repository/files`, 'json', req, runtime);
}

model CreateMergeRequestRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model CreateMergeRequestResponseBody = {
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  result?: {
    state?: string(name='State'),
    behindCommitCount?: int32(name='BehindCommitCount'),
    projectId?: long(name='ProjectId'),
    assigneeList?: [ 
      {
        externUserId?: string(name='ExternUserId'),
        avatarUrl?: string(name='AvatarUrl'),
        name?: string(name='Name'),
        id?: string(name='Id'),
      }
    ](name='AssigneeList'),
    createdAt?: string(name='CreatedAt'),
    author?: {
      externUserId?: string(name='ExternUserId'),
      avatarUrl?: string(name='AvatarUrl'),
      name?: string(name='Name'),
      id?: long(name='Id'),
    }(name='Author'),
    acceptedRevision?: string(name='AcceptedRevision'),
    approveCheckResult?: {
      totalCheckResult?: string(name='TotalCheckResult'),
      unsatisfiedCheckResults?: [ 
        {
          satisfiedItems?: [ string ](name='SatisfiedItems'),
          checkStatus?: string(name='CheckStatus'),
          checkType?: string(name='CheckType'),
          unsatisfiedItems?: [ string ](name='UnsatisfiedItems'),
          extraUsers?: [ 
            {
              externUserId?: string(name='ExternUserId'),
              avatarUrl?: string(name='AvatarUrl'),
              name?: string(name='Name'),
              id?: long(name='Id'),
            }
          ](name='ExtraUsers'),
          checkName?: string(name='CheckName'),
        }
      ](name='UnsatisfiedCheckResults'),
      satisfiedCheckResults?: [ 
        {
          satisfiedItems?: [ string ](name='SatisfiedItems'),
          checkStatus?: string(name='CheckStatus'),
          checkType?: string(name='CheckType'),
          unsatisfiedItems?: [ string ](name='UnsatisfiedItems'),
          extraUsers?: [ 
            {
              externUserId?: string(name='ExternUserId'),
              avatarUrl?: string(name='AvatarUrl'),
              name?: string(name='Name'),
              id?: long(name='Id'),
            }
          ](name='ExtraUsers'),
          checkName?: string(name='CheckName'),
        }
      ](name='SatisfiedCheckResults'),
    }(name='ApproveCheckResult'),
    sourceBranch?: string(name='SourceBranch'),
    webUrl?: string(name='WebUrl'),
    description?: string(name='Description'),
    mergeType?: string(name='MergeType'),
    nameWithNamespace?: string(name='NameWithNamespace'),
    targetBranch?: string(name='TargetBranch'),
    aheadCommitCount?: int32(name='AheadCommitCount'),
    updatedAt?: string(name='UpdatedAt'),
    title?: string(name='Title'),
    mergeError?: string(name='MergeError'),
    mergedRevision?: string(name='MergedRevision'),
    id?: long(name='Id'),
    mergeStatus?: string(name='MergeStatus'),
  }(name='Result'),
}

model CreateMergeRequestResponse = {
  headers: map[string]string(name='headers'),
  body: CreateMergeRequestResponseBody(name='body'),
}

async function createMergeRequest(ProjectId: string, request: CreateMergeRequestRequest): CreateMergeRequestResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createMergeRequestWithOptions(ProjectId, request, headers, runtime);
}

async function createMergeRequestWithOptions(ProjectId: string, request: CreateMergeRequestRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateMergeRequestResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('CreateMergeRequest', '2020-04-14', 'HTTPS', 'POST', 'AK', `/api/v4/projects/${ProjectId}/merge_requests`, 'json', req, runtime);
}

model CreateRepositoryRequest {
  accessToken?: string(name='AccessToken'),
  sync?: boolean(name='Sync'),
  createParentPath?: boolean(name='CreateParentPath'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
  clientToken?: string(name='ClientToken'),
}

model CreateRepositoryResponseBody = {
  requestId?: string(name='RequestId'),
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  result?: {
    defaultBranch?: string(name='DefaultBranch'),
    snippetsEnableStatus?: boolean(name='SnippetsEnableStatus'),
    createdAt?: string(name='CreatedAt'),
    buildsEnableStatus?: boolean(name='BuildsEnableStatus'),
    webUrl?: string(name='WebUrl'),
    description?: string(name='Description'),
    tagList?: [ string ](name='TagList'),
    public?: boolean(name='Public'),
    pathWithNamespace?: string(name='PathWithNamespace'),
    visibilityLevel?: string(name='VisibilityLevel'),
    wikiEnableStatus?: boolean(name='WikiEnableStatus'),
    name?: string(name='Name'),
    lastActivityAt?: string(name='LastActivityAt'),
    avatarUrl?: string(name='AvatarUrl'),
    archive?: boolean(name='Archive'),
    namespace?: {
      avatar?: string(name='Avatar'),
      description?: string(name='Description'),
      state?: string(name='State'),
      public?: boolean(name='Public'),
      visibilityLevel?: string(name='VisibilityLevel'),
      createdAt?: string(name='CreatedAt'),
      path?: string(name='Path'),
      updatedAt?: string(name='UpdatedAt'),
      name?: string(name='Name'),
      ownerId?: long(name='OwnerId'),
      id?: long(name='Id'),
    }(name='Namespace'),
    issuesEnableStatus?: boolean(name='IssuesEnableStatus'),
    demoProjectStatus?: boolean(name='DemoProjectStatus'),
    creatorId?: long(name='CreatorId'),
    httpUrlToRepo?: string(name='HttpUrlToRepo'),
    nameWithNamespace?: string(name='NameWithNamespace'),
    mergeRequestEnableStatus?: boolean(name='MergeRequestEnableStatus'),
    path?: string(name='Path'),
    sshUrlToRepo?: string(name='SshUrlToRepo'),
    id?: long(name='Id'),
  }(name='Result'),
}

model CreateRepositoryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRepositoryResponseBody(name='body'),
}

async function createRepository(request: CreateRepositoryRequest): CreateRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createRepositoryWithOptions(request, headers, runtime);
}

async function createRepositoryWithOptions(request: CreateRepositoryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateRepositoryResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.sync)) {
    query.Sync = request.sync;
  }
  if (!Util.isUnset(request.createParentPath)) {
    query.CreateParentPath = request.createParentPath;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('CreateRepository', '2020-04-14', 'HTTPS', 'POST', 'AK', `/api/v3/projects`, 'json', req, runtime);
}

model CreateRepositoryGroupRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
  clientToken?: string(name='ClientToken'),
}

model CreateRepositoryGroupResponseBody = {
  requestId?: string(name='RequestId'),
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  result?: {
    type?: string(name='Type'),
    avatarUrl?: string(name='AvatarUrl'),
    ownerId?: long(name='OwnerId'),
    parentId?: long(name='ParentId'),
    webUrl?: string(name='WebUrl'),
    description?: string(name='Description'),
    nameWithNamespace?: string(name='NameWithNamespace'),
    pathWithNamespace?: string(name='PathWithNamespace'),
    path?: string(name='Path'),
    visibilityLevel?: string(name='VisibilityLevel'),
    name?: string(name='Name'),
    id?: long(name='Id'),
  }(name='Result'),
}

model CreateRepositoryGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRepositoryGroupResponseBody(name='body'),
}

async function createRepositoryGroup(request: CreateRepositoryGroupRequest): CreateRepositoryGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createRepositoryGroupWithOptions(request, headers, runtime);
}

async function createRepositoryGroupWithOptions(request: CreateRepositoryGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateRepositoryGroupResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('CreateRepositoryGroup', '2020-04-14', 'HTTPS', 'POST', 'AK', `/api/v3/groups`, 'json', req, runtime);
}

model CreateTagRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model CreateTagResponseBody = {
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  result?: {
    release?: {
      description?: string(name='Description'),
      tagName?: string(name='TagName'),
    }(name='Release'),
    message?: string(name='Message'),
    commitInfo?: {
      shortId?: string(name='ShortId'),
      createdAt?: string(name='CreatedAt'),
      message?: string(name='Message'),
      authoredDate?: string(name='AuthoredDate'),
      parentIds?: [ string ](name='ParentIds'),
      authorName?: string(name='AuthorName'),
      committerName?: string(name='CommitterName'),
      title?: string(name='Title'),
      authorEmail?: string(name='AuthorEmail'),
      committerEmail?: string(name='CommitterEmail'),
      id?: string(name='Id'),
      committedDate?: string(name='CommittedDate'),
    }(name='CommitInfo'),
    name?: string(name='Name'),
  }(name='Result'),
}

model CreateTagResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTagResponseBody(name='body'),
}

async function createTag(ProjectId: string, request: CreateTagRequest): CreateTagResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createTagWithOptions(ProjectId, request, headers, runtime);
}

async function createTagWithOptions(ProjectId: string, request: CreateTagRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateTagResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('CreateTag', '2020-04-14', 'HTTPS', 'POST', 'AK', `/api/v3/projects/${ProjectId}/repository/tags`, 'json', req, runtime);
}

model DeleteBranchRequest {
  accessToken?: string(name='AccessToken'),
  branchName?: string(name='BranchName'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model DeleteBranchResponseBody = {
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  result?: {
    branchName?: string(name='BranchName'),
  }(name='Result'),
}

model DeleteBranchResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteBranchResponseBody(name='body'),
}

async function deleteBranch(ProjectId: string, request: DeleteBranchRequest): DeleteBranchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteBranchWithOptions(ProjectId, request, headers, runtime);
}

async function deleteBranchWithOptions(ProjectId: string, request: DeleteBranchRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteBranchResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.branchName)) {
    query.BranchName = request.branchName;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteBranch', '2020-04-14', 'HTTPS', 'DELETE', 'AK', `/api/v3/projects/${ProjectId}/repository/branches/delete`, 'json', req, runtime);
}

model DeleteFileRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  branchName?: string(name='BranchName'),
  filePath?: string(name='FilePath'),
  commitMessage?: string(name='CommitMessage'),
  subUserId?: string(name='SubUserId'),
}

model DeleteFileResponseBody = {
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  result?: {
    filePath?: string(name='FilePath'),
    branchName?: string(name='BranchName'),
  }(name='Result'),
}

model DeleteFileResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFileResponseBody(name='body'),
}

async function deleteFile(ProjectId: string, request: DeleteFileRequest): DeleteFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteFileWithOptions(ProjectId, request, headers, runtime);
}

async function deleteFileWithOptions(ProjectId: string, request: DeleteFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteFileResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.branchName)) {
    query.BranchName = request.branchName;
  }
  if (!Util.isUnset(request.filePath)) {
    query.FilePath = request.filePath;
  }
  if (!Util.isUnset(request.commitMessage)) {
    query.CommitMessage = request.commitMessage;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteFile', '2020-04-14', 'HTTPS', 'DELETE', 'AK', `/api/v3/projects/${ProjectId}/repository/files`, 'json', req, runtime);
}

model DeleteGroupMemberRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model DeleteGroupMemberResponseBody = {
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  result?: {
    externUserId?: string(name='ExternUserId'),
    email?: string(name='Email'),
    avatarUrl?: string(name='AvatarUrl'),
    state?: string(name='State'),
    accessLevel?: int32(name='AccessLevel'),
    id?: long(name='Id'),
  }(name='Result'),
}

model DeleteGroupMemberResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteGroupMemberResponseBody(name='body'),
}

async function deleteGroupMember(GroupId: string, UserId: string, request: DeleteGroupMemberRequest): DeleteGroupMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteGroupMemberWithOptions(GroupId, UserId, request, headers, runtime);
}

async function deleteGroupMemberWithOptions(GroupId: string, UserId: string, request: DeleteGroupMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteGroupMemberResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteGroupMember', '2020-04-14', 'HTTPS', 'DELETE', 'AK', `/api/v3/groups/${GroupId}/members/{UserId}`, 'json', req, runtime);
}

model DeleteRepositoryRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model DeleteRepositoryResponseBody = {
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  result?: {
    result?: boolean(name='Result'),
  }(name='Result'),
}

model DeleteRepositoryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRepositoryResponseBody(name='body'),
}

async function deleteRepository(ProjectId: string, request: DeleteRepositoryRequest): DeleteRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRepositoryWithOptions(ProjectId, request, headers, runtime);
}

async function deleteRepositoryWithOptions(ProjectId: string, request: DeleteRepositoryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteRepositoryResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteRepository', '2020-04-14', 'HTTPS', 'POST', 'AK', `/api/v3/projects/${ProjectId}/remove`, 'json', req, runtime);
}

model DeleteRepositoryGroupRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model DeleteRepositoryGroupResponseBody = {
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  result?: {
    result?: boolean(name='Result'),
  }(name='Result'),
}

model DeleteRepositoryGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRepositoryGroupResponseBody(name='body'),
}

async function deleteRepositoryGroup(GroupId: string, request: DeleteRepositoryGroupRequest): DeleteRepositoryGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRepositoryGroupWithOptions(GroupId, request, headers, runtime);
}

async function deleteRepositoryGroupWithOptions(GroupId: string, request: DeleteRepositoryGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteRepositoryGroupResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteRepositoryGroup', '2020-04-14', 'HTTPS', 'POST', 'AK', `/api/v3/groups/${GroupId}/remove`, 'json', req, runtime);
}

model DeleteRepositoryMemberRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model DeleteRepositoryMemberResponseBody = {
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  result?: {
    userId?: long(name='UserId'),
    sourceType?: string(name='SourceType'),
    createdAt?: string(name='CreatedAt'),
    message?: string(name='Message'),
    accessLevel?: int32(name='AccessLevel'),
    updatedAt?: string(name='UpdatedAt'),
    sourceId?: long(name='SourceId'),
    notificationLevel?: int32(name='NotificationLevel'),
    id?: long(name='Id'),
  }(name='Result'),
}

model DeleteRepositoryMemberResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRepositoryMemberResponseBody(name='body'),
}

async function deleteRepositoryMember(ProjectId: string, UserId: string, request: DeleteRepositoryMemberRequest): DeleteRepositoryMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRepositoryMemberWithOptions(ProjectId, UserId, request, headers, runtime);
}

async function deleteRepositoryMemberWithOptions(ProjectId: string, UserId: string, request: DeleteRepositoryMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteRepositoryMemberResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteRepositoryMember', '2020-04-14', 'HTTPS', 'DELETE', 'AK', `/api/v3/projects/${ProjectId}/members/{UserId}`, 'json', req, runtime);
}

model DeleteRepositoryTagRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model DeleteRepositoryTagResponseBody = {
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  result?: {
    tagName?: string(name='TagName'),
  }(name='Result'),
}

model DeleteRepositoryTagResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRepositoryTagResponseBody(name='body'),
}

async function deleteRepositoryTag(ProjectId: string, TagName: string, request: DeleteRepositoryTagRequest): DeleteRepositoryTagResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRepositoryTagWithOptions(ProjectId, TagName, request, headers, runtime);
}

async function deleteRepositoryTagWithOptions(ProjectId: string, TagName: string, request: DeleteRepositoryTagRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteRepositoryTagResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteRepositoryTag', '2020-04-14', 'HTTPS', 'DELETE', 'AK', `/api/v3/projects/${ProjectId}/repository/tags/{TagName}`, 'json', req, runtime);
}

model DeleteRepositoryWebhookRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model DeleteRepositoryWebhookResponseBody = {
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  result?: {
    pushEvents?: boolean(name='PushEvents'),
    projectId?: long(name='ProjectId'),
    createdAt?: string(name='CreatedAt'),
    tagPushEvents?: boolean(name='TagPushEvents'),
    url?: string(name='Url'),
    lastTestResult?: string(name='LastTestResult'),
    description?: string(name='Description'),
    mergeRequestsEvents?: boolean(name='MergeRequestsEvents'),
    secretToken?: string(name='SecretToken'),
    noteEvents?: boolean(name='NoteEvents'),
    enableSslVerification?: boolean(name='EnableSslVerification'),
    id?: long(name='Id'),
  }(name='Result'),
}

model DeleteRepositoryWebhookResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRepositoryWebhookResponseBody(name='body'),
}

async function deleteRepositoryWebhook(ProjectId: string, WebhookId: string, request: DeleteRepositoryWebhookRequest): DeleteRepositoryWebhookResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRepositoryWebhookWithOptions(ProjectId, WebhookId, request, headers, runtime);
}

async function deleteRepositoryWebhookWithOptions(ProjectId: string, WebhookId: string, request: DeleteRepositoryWebhookRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteRepositoryWebhookResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteRepositoryWebhook', '2020-04-14', 'HTTPS', 'DELETE', 'AK', `/api/v3/projects/${ProjectId}/hooks/{WebhookId}`, 'json', req, runtime);
}

model GetBranchInfoRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
  branchName?: string(name='BranchName'),
}

model GetBranchInfoResponseBody = {
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  result?: {
    protectedBranch?: boolean(name='ProtectedBranch'),
    commitInfo?: {
      shortId?: string(name='ShortId'),
      authorDate?: string(name='AuthorDate'),
      createdAt?: string(name='CreatedAt'),
      message?: string(name='Message'),
      parentIds?: [ string ](name='ParentIds'),
      authorName?: string(name='AuthorName'),
      committerName?: string(name='CommitterName'),
      title?: string(name='Title'),
      authorEmail?: string(name='AuthorEmail'),
      committerEmail?: string(name='CommitterEmail'),
      id?: string(name='Id'),
      committedDate?: string(name='CommittedDate'),
    }(name='CommitInfo'),
    branchName?: string(name='BranchName'),
  }(name='Result'),
}

model GetBranchInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetBranchInfoResponseBody(name='body'),
}

async function getBranchInfo(ProjectId: string, request: GetBranchInfoRequest): GetBranchInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getBranchInfoWithOptions(ProjectId, request, headers, runtime);
}

async function getBranchInfoWithOptions(ProjectId: string, request: GetBranchInfoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetBranchInfoResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }
  if (!Util.isUnset(request.branchName)) {
    query.BranchName = request.branchName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetBranchInfo', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v3/projects/${ProjectId}/repository/branches/detail`, 'json', req, runtime);
}

model GetCodeupOrganizationRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model GetCodeupOrganizationResponseBody = {
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  result?: {
    namespaceId?: long(name='NamespaceId'),
    userRole?: string(name='UserRole'),
    path?: string(name='Path'),
    createdAt?: string(name='CreatedAt'),
    updatedAt?: string(name='UpdatedAt'),
    id?: long(name='Id'),
    organizationId?: string(name='OrganizationId'),
  }(name='Result'),
}

model GetCodeupOrganizationResponse = {
  headers: map[string]string(name='headers'),
  body: GetCodeupOrganizationResponseBody(name='body'),
}

async function getCodeupOrganization(OrganizationIdentity: string, request: GetCodeupOrganizationRequest): GetCodeupOrganizationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getCodeupOrganizationWithOptions(OrganizationIdentity, request, headers, runtime);
}

async function getCodeupOrganizationWithOptions(OrganizationIdentity: string, request: GetCodeupOrganizationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetCodeupOrganizationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetCodeupOrganization', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v4/organization/${OrganizationIdentity}`, 'json', req, runtime);
}

model GetFileBlobsRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  filePath?: string(name='FilePath'),
  ref?: string(name='Ref'),
  from?: long(name='From'),
  to?: long(name='To'),
  subUserId?: string(name='SubUserId'),
}

model GetFileBlobsResponseBody = {
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  result?: {
    totalLines?: int32(name='TotalLines'),
    content?: string(name='Content'),
  }(name='Result'),
}

model GetFileBlobsResponse = {
  headers: map[string]string(name='headers'),
  body: GetFileBlobsResponseBody(name='body'),
}

async function getFileBlobs(ProjectId: string, request: GetFileBlobsRequest): GetFileBlobsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFileBlobsWithOptions(ProjectId, request, headers, runtime);
}

async function getFileBlobsWithOptions(ProjectId: string, request: GetFileBlobsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetFileBlobsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.filePath)) {
    query.FilePath = request.filePath;
  }
  if (!Util.isUnset(request.ref)) {
    query.Ref = request.ref;
  }
  if (!Util.isUnset(request.from)) {
    query.From = request.from;
  }
  if (!Util.isUnset(request.to)) {
    query.To = request.to;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetFileBlobs', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v4/projects/${ProjectId}/repository/blobs`, 'json', req, runtime);
}

model GetGroupDetailRequest {
  accessToken?: string(name='AccessToken'),
  groupId?: long(name='GroupId'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model GetGroupDetailResponseBody = {
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  result?: {
    type?: string(name='Type'),
    avatarUrl?: string(name='AvatarUrl'),
    ownerId?: long(name='OwnerId'),
    parentId?: long(name='ParentId'),
    webUrl?: string(name='WebUrl'),
    description?: string(name='Description'),
    nameWithNamespace?: string(name='NameWithNamespace'),
    pathWithNamespace?: string(name='PathWithNamespace'),
    visibilityLevel?: string(name='VisibilityLevel'),
    path?: string(name='Path'),
    name?: string(name='Name'),
    id?: long(name='Id'),
  }(name='Result'),
}

model GetGroupDetailResponse = {
  headers: map[string]string(name='headers'),
  body: GetGroupDetailResponseBody(name='body'),
}

async function getGroupDetail(request: GetGroupDetailRequest): GetGroupDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getGroupDetailWithOptions(request, headers, runtime);
}

async function getGroupDetailWithOptions(request: GetGroupDetailRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetGroupDetailResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.groupId)) {
    query.GroupId = request.groupId;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetGroupDetail', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v3/groups/detail`, 'json', req, runtime);
}

model GetProjectMemberRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model GetProjectMemberResponseBody = {
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  result?: {
    externUserId?: string(name='ExternUserId'),
    avatarUrl?: string(name='AvatarUrl'),
    accessLevel?: int32(name='AccessLevel'),
    name?: string(name='Name'),
    id?: long(name='Id'),
  }(name='Result'),
}

model GetProjectMemberResponse = {
  headers: map[string]string(name='headers'),
  body: GetProjectMemberResponseBody(name='body'),
}

async function getProjectMember(ProjectId: string, UserId: string, request: GetProjectMemberRequest): GetProjectMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProjectMemberWithOptions(ProjectId, UserId, request, headers, runtime);
}

async function getProjectMemberWithOptions(ProjectId: string, UserId: string, request: GetProjectMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetProjectMemberResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetProjectMember', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v3/projects/${ProjectId}/members/{UserId}`, 'json', req, runtime);
}

model GetRepositoryInfoRequest {
  accessToken?: string(name='AccessToken'),
  identity?: string(name='Identity'),
  organizationId?: string(name='OrganizationId'),
}

model GetRepositoryInfoResponseBody = {
  requestId?: string(name='RequestId'),
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  result?: {
    defaultBranch?: string(name='DefaultBranch'),
    importUrl?: string(name='ImportUrl'),
    createdAt?: string(name='CreatedAt'),
    webUrl?: string(name='WebUrl'),
    tagList?: [ string ](name='TagList'),
    description?: string(name='Description'),
    public?: boolean(name='Public'),
    pathWithNamespace?: string(name='PathWithNamespace'),
    visibilityLevel?: string(name='VisibilityLevel'),
    name?: string(name='Name'),
    lastActivityAt?: string(name='LastActivityAt'),
    avatarUrl?: string(name='AvatarUrl'),
    archive?: boolean(name='Archive'),
    namespace?: {
      avatar?: string(name='Avatar'),
      description?: string(name='Description'),
      state?: string(name='State'),
      public?: boolean(name='Public'),
      visibilityLevel?: string(name='VisibilityLevel'),
      createdAt?: string(name='CreatedAt'),
      path?: string(name='Path'),
      updatedAt?: string(name='UpdatedAt'),
      name?: string(name='Name'),
      ownerId?: long(name='OwnerId'),
      id?: long(name='Id'),
    }(name='Namespace'),
    demoProjectStatus?: boolean(name='DemoProjectStatus'),
    creatorId?: long(name='CreatorId'),
    importStatus?: string(name='ImportStatus'),
    httpUrlToRepo?: string(name='HttpUrlToRepo'),
    permissions?: {
      projectAccess?: {
        accessLevel?: int32(name='AccessLevel'),
      }(name='ProjectAccess'),
      groupAccess?: {
        accessLevel?: int32(name='AccessLevel'),
      }(name='GroupAccess'),
    }(name='Permissions'),
    nameWithNamespace?: string(name='NameWithNamespace'),
    path?: string(name='Path'),
    accessLevel?: int32(name='AccessLevel'),
    importFromSubversion?: boolean(name='ImportFromSubversion'),
    sshUrlToRepo?: string(name='SshUrlToRepo'),
    id?: long(name='Id'),
  }(name='Result'),
}

model GetRepositoryInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetRepositoryInfoResponseBody(name='body'),
}

async function getRepositoryInfo(request: GetRepositoryInfoRequest): GetRepositoryInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRepositoryInfoWithOptions(request, headers, runtime);
}

async function getRepositoryInfoWithOptions(request: GetRepositoryInfoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetRepositoryInfoResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.identity)) {
    query.Identity = request.identity;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetRepositoryInfo', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v3/projects/info`, 'json', req, runtime);
}

model GetRepositoryTagRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model GetRepositoryTagResponseBody = {
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  result?: {
    signature?: {
      gpgKeyId?: string(name='GpgKeyId'),
      verificationStatus?: string(name='VerificationStatus'),
    }(name='Signature'),
    commit?: {
      shortId?: string(name='ShortId'),
      createdAt?: string(name='CreatedAt'),
      message?: string(name='Message'),
      authoredDate?: string(name='AuthoredDate'),
      signature?: {
        gpgKeyId?: string(name='GpgKeyId'),
        verificationStatus?: string(name='VerificationStatus'),
      }(name='Signature'),
      parentIds?: [ string ](name='ParentIds'),
      authorName?: string(name='AuthorName'),
      committerName?: string(name='CommitterName'),
      title?: string(name='Title'),
      authorEmail?: string(name='AuthorEmail'),
      committerEmail?: string(name='CommitterEmail'),
      id?: string(name='Id'),
      committedDate?: string(name='CommittedDate'),
    }(name='Commit'),
    message?: string(name='Message'),
    name?: string(name='Name'),
    id?: string(name='Id'),
  }(name='Result'),
}

model GetRepositoryTagResponse = {
  headers: map[string]string(name='headers'),
  body: GetRepositoryTagResponseBody(name='body'),
}

async function getRepositoryTag(ProjectId: string, TagName: string, request: GetRepositoryTagRequest): GetRepositoryTagResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRepositoryTagWithOptions(ProjectId, TagName, request, headers, runtime);
}

async function getRepositoryTagWithOptions(ProjectId: string, TagName: string, request: GetRepositoryTagRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetRepositoryTagResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetRepositoryTag', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v3/projects/${ProjectId}/repository/tags/{TagName}`, 'json', req, runtime);
}

model GetUserInfoRequest {
  accessToken?: string(name='AccessToken'),
}

model GetUserInfoResponseBody = {
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  result?: {
    email?: string(name='Email'),
    avatarUrl?: string(name='AvatarUrl'),
    externalUserId?: string(name='ExternalUserId'),
    name?: string(name='Name'),
    id?: long(name='Id'),
    username?: string(name='Username'),
  }(name='Result'),
}

model GetUserInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetUserInfoResponseBody(name='body'),
}

async function getUserInfo(request: GetUserInfoRequest): GetUserInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getUserInfoWithOptions(request, headers, runtime);
}

async function getUserInfoWithOptions(request: GetUserInfoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetUserInfoResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetUserInfo', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v3/user/current`, 'json', req, runtime);
}

model ListGroupMemberRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  page?: long(name='Page'),
  pageSize?: long(name='PageSize'),
  subUserId?: string(name='SubUserId'),
}

model ListGroupMemberResponseBody = {
  requestId?: string(name='RequestId'),
  total?: long(name='Total'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  result?: [ 
    {
      externUserId?: string(name='ExternUserId'),
      email?: string(name='Email'),
      avatarUrl?: string(name='AvatarUrl'),
      state?: string(name='State'),
      accessLevel?: int32(name='AccessLevel'),
      id?: long(name='Id'),
    }
  ](name='Result'),
}

model ListGroupMemberResponse = {
  headers: map[string]string(name='headers'),
  body: ListGroupMemberResponseBody(name='body'),
}

async function listGroupMember(GroupId: string, request: ListGroupMemberRequest): ListGroupMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listGroupMemberWithOptions(GroupId, request, headers, runtime);
}

async function listGroupMemberWithOptions(GroupId: string, request: ListGroupMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListGroupMemberResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.page)) {
    query.Page = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListGroupMember', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v3/groups/${GroupId}/members`, 'json', req, runtime);
}

model ListGroupRepositoriesRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  isMember?: boolean(name='IsMember'),
  subUserId?: string(name='SubUserId'),
  search?: string(name='Search'),
  page?: long(name='Page'),
  pageSize?: long(name='PageSize'),
}

model ListGroupRepositoriesResponseBody = {
  requestId?: string(name='RequestId'),
  total?: long(name='Total'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  result?: [ 
    {
      lastActivityAt?: string(name='LastActivityAt'),
      namespaceId?: long(name='NamespaceId'),
      httpCloneUrl?: string(name='HttpCloneUrl'),
      archive?: boolean(name='Archive'),
      createdAt?: string(name='CreatedAt'),
      sshCloneUrl?: string(name='SshCloneUrl'),
      creatorId?: long(name='CreatorId'),
      importStatus?: string(name='ImportStatus'),
      webUrl?: string(name='WebUrl'),
      nameWithNamespace?: string(name='NameWithNamespace'),
      pathWithNamespace?: string(name='PathWithNamespace'),
      visibilityLevel?: int32(name='VisibilityLevel'),
      path?: string(name='Path'),
      updatedAt?: string(name='UpdatedAt'),
      name?: string(name='Name'),
      id?: long(name='Id'),
    }
  ](name='Result'),
}

model ListGroupRepositoriesResponse = {
  headers: map[string]string(name='headers'),
  body: ListGroupRepositoriesResponseBody(name='body'),
}

async function listGroupRepositories(Identity: string, request: ListGroupRepositoriesRequest): ListGroupRepositoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listGroupRepositoriesWithOptions(Identity, request, headers, runtime);
}

async function listGroupRepositoriesWithOptions(Identity: string, request: ListGroupRepositoriesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListGroupRepositoriesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.isMember)) {
    query.IsMember = request.isMember;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }
  if (!Util.isUnset(request.search)) {
    query.Search = request.search;
  }
  if (!Util.isUnset(request.page)) {
    query.Page = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListGroupRepositories', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v3/groups/${Identity}/projects`, 'json', req, runtime);
}

model ListGroupsRequest {
  accessToken?: string(name='AccessToken'),
  search?: string(name='Search'),
  organizationId?: string(name='OrganizationId'),
  page?: long(name='Page'),
  pageSize?: long(name='PageSize'),
  subUserId?: string(name='SubUserId'),
  includePersonal?: boolean(name='IncludePersonal'),
}

model ListGroupsResponseBody = {
  requestId?: string(name='RequestId'),
  total?: long(name='Total'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  result?: [ 
    {
      type?: string(name='Type'),
      createdAt?: string(name='CreatedAt'),
      ownerId?: long(name='OwnerId'),
      parentId?: long(name='ParentId'),
      webUrl?: string(name='WebUrl'),
      description?: string(name='Description'),
      nameWithNamespace?: string(name='NameWithNamespace'),
      pathWithNamespace?: string(name='PathWithNamespace'),
      path?: string(name='Path'),
      visibilityLevel?: string(name='VisibilityLevel'),
      accessLevel?: int32(name='AccessLevel'),
      updatedAt?: string(name='UpdatedAt'),
      name?: string(name='Name'),
      id?: long(name='Id'),
    }
  ](name='Result'),
}

model ListGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListGroupsResponseBody(name='body'),
}

async function listGroups(request: ListGroupsRequest): ListGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listGroupsWithOptions(request, headers, runtime);
}

async function listGroupsWithOptions(request: ListGroupsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListGroupsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.search)) {
    query.Search = request.search;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.page)) {
    query.Page = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }
  if (!Util.isUnset(request.includePersonal)) {
    query.IncludePersonal = request.includePersonal;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListGroups', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v3/groups/all`, 'json', req, runtime);
}

model ListOrganizationsRequest {
  accessToken?: string(name='AccessToken'),
  accessLevel?: int32(name='AccessLevel'),
  minAccessLevel?: int32(name='MinAccessLevel'),
}

model ListOrganizationsResponseBody = {
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  result?: [ 
    {
      organizationRole?: string(name='OrganizationRole'),
      accessLevel?: int32(name='AccessLevel'),
      organizationName?: string(name='OrganizationName'),
      organizationId?: string(name='OrganizationId'),
    }
  ](name='Result'),
}

model ListOrganizationsResponse = {
  headers: map[string]string(name='headers'),
  body: ListOrganizationsResponseBody(name='body'),
}

async function listOrganizations(request: ListOrganizationsRequest): ListOrganizationsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listOrganizationsWithOptions(request, headers, runtime);
}

async function listOrganizationsWithOptions(request: ListOrganizationsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListOrganizationsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.accessLevel)) {
    query.AccessLevel = request.accessLevel;
  }
  if (!Util.isUnset(request.minAccessLevel)) {
    query.MinAccessLevel = request.minAccessLevel;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListOrganizations', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v4/organization`, 'json', req, runtime);
}

model ListRepositoriesRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  page?: long(name='Page'),
  pageSize?: long(name='PageSize'),
  order?: string(name='Order'),
  sort?: string(name='Sort'),
  search?: string(name='Search'),
  archive?: boolean(name='Archive'),
}

model ListRepositoriesResponseBody = {
  requestId?: string(name='RequestId'),
  total?: long(name='Total'),
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  result?: [ 
    {
      lastActivityAt?: string(name='LastActivityAt'),
      namespaceId?: long(name='NamespaceId'),
      avatarUrl?: string(name='AvatarUrl'),
      starCount?: long(name='StarCount'),
      archive?: boolean(name='Archive'),
      createdAt?: string(name='CreatedAt'),
      demoProjectStatus?: boolean(name='DemoProjectStatus'),
      star?: boolean(name='Star'),
      importStatus?: string(name='ImportStatus'),
      webUrl?: string(name='WebUrl'),
      description?: string(name='Description'),
      nameWithNamespace?: string(name='NameWithNamespace'),
      pathWithNamespace?: string(name='PathWithNamespace'),
      path?: string(name='Path'),
      visibilityLevel?: string(name='VisibilityLevel'),
      accessLevel?: int32(name='AccessLevel'),
      updatedAt?: string(name='UpdatedAt'),
      name?: string(name='Name'),
      id?: long(name='Id'),
    }
  ](name='Result'),
}

model ListRepositoriesResponse = {
  headers: map[string]string(name='headers'),
  body: ListRepositoriesResponseBody(name='body'),
}

async function listRepositories(request: ListRepositoriesRequest): ListRepositoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRepositoriesWithOptions(request, headers, runtime);
}

async function listRepositoriesWithOptions(request: ListRepositoriesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRepositoriesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.page)) {
    query.Page = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }
  if (!Util.isUnset(request.order)) {
    query.Order = request.order;
  }
  if (!Util.isUnset(request.sort)) {
    query.Sort = request.sort;
  }
  if (!Util.isUnset(request.search)) {
    query.Search = request.search;
  }
  if (!Util.isUnset(request.archive)) {
    query.Archive = request.archive;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListRepositories', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v3/projects/all`, 'json', req, runtime);
}

model ListRepositoryBranchesRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
  page?: long(name='Page'),
  pageSize?: long(name='PageSize'),
  search?: string(name='Search'),
}

model ListRepositoryBranchesResponseBody = {
  requestId?: string(name='RequestId'),
  total?: long(name='Total'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  result?: [ 
    {
      protectedBranch?: boolean(name='ProtectedBranch'),
      commitInfo?: {
        shortId?: string(name='ShortId'),
        authorDate?: string(name='AuthorDate'),
        createdAt?: string(name='CreatedAt'),
        message?: string(name='Message'),
        parentIds?: [ string ](name='ParentIds'),
        authorName?: string(name='AuthorName'),
        committerName?: string(name='CommitterName'),
        title?: string(name='Title'),
        authorEmail?: string(name='AuthorEmail'),
        committerEmail?: string(name='CommitterEmail'),
        id?: string(name='Id'),
        committedDate?: string(name='CommittedDate'),
      }(name='CommitInfo'),
      branchName?: string(name='BranchName'),
    }
  ](name='Result'),
}

model ListRepositoryBranchesResponse = {
  headers: map[string]string(name='headers'),
  body: ListRepositoryBranchesResponseBody(name='body'),
}

async function listRepositoryBranches(ProjectId: string, request: ListRepositoryBranchesRequest): ListRepositoryBranchesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRepositoryBranchesWithOptions(ProjectId, request, headers, runtime);
}

async function listRepositoryBranchesWithOptions(ProjectId: string, request: ListRepositoryBranchesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRepositoryBranchesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }
  if (!Util.isUnset(request.page)) {
    query.Page = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }
  if (!Util.isUnset(request.search)) {
    query.Search = request.search;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListRepositoryBranches', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v3/projects/${ProjectId}/repository/branches`, 'json', req, runtime);
}

model ListRepositoryMemberRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  query?: string(name='Query'),
  page?: long(name='Page'),
  pageSize?: long(name='PageSize'),
  subUserId?: string(name='SubUserId'),
}

model ListRepositoryMemberResponseBody = {
  requestId?: string(name='RequestId'),
  total?: long(name='Total'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  result?: [ 
    {
      externUserId?: string(name='ExternUserId'),
      email?: string(name='Email'),
      avatarUrl?: string(name='AvatarUrl'),
      state?: string(name='State'),
      accessLevel?: int32(name='AccessLevel'),
      id?: long(name='Id'),
    }
  ](name='Result'),
}

model ListRepositoryMemberResponse = {
  headers: map[string]string(name='headers'),
  body: ListRepositoryMemberResponseBody(name='body'),
}

async function listRepositoryMember(ProjectId: string, request: ListRepositoryMemberRequest): ListRepositoryMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRepositoryMemberWithOptions(ProjectId, request, headers, runtime);
}

async function listRepositoryMemberWithOptions(ProjectId: string, request: ListRepositoryMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRepositoryMemberResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.query)) {
    query.Query = request.query;
  }
  if (!Util.isUnset(request.page)) {
    query.Page = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListRepositoryMember', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v3/projects/${ProjectId}/members`, 'json', req, runtime);
}

model ListRepositoryTagsRequest {
  accessToken?: string(name='AccessToken'),
  search?: string(name='Search'),
  organizationId?: string(name='OrganizationId'),
  page?: long(name='Page'),
  pageSize?: long(name='PageSize'),
  sort?: string(name='Sort'),
  showSignature?: boolean(name='ShowSignature'),
}

model ListRepositoryTagsResponseBody = {
  requestId?: string(name='RequestId'),
  total?: long(name='Total'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  result?: [ 
    {
      signature?: {
        gpgKeyId?: string(name='GpgKeyId'),
        verificationStatus?: string(name='VerificationStatus'),
      }(name='Signature'),
      commit?: {
        shortId?: string(name='ShortId'),
        createdAt?: string(name='CreatedAt'),
        message?: string(name='Message'),
        authoredDate?: string(name='AuthoredDate'),
        signature?: {
          gpgKeyId?: string(name='GpgKeyId'),
          verificationStatus?: string(name='VerificationStatus'),
        }(name='Signature'),
        parentIds?: [ string ](name='ParentIds'),
        authorName?: string(name='AuthorName'),
        committerName?: string(name='CommitterName'),
        title?: string(name='Title'),
        authorEmail?: string(name='AuthorEmail'),
        committerEmail?: string(name='CommitterEmail'),
        id?: string(name='Id'),
        committedDate?: string(name='CommittedDate'),
      }(name='Commit'),
      message?: string(name='Message'),
      name?: string(name='Name'),
      id?: string(name='Id'),
    }
  ](name='Result'),
}

model ListRepositoryTagsResponse = {
  headers: map[string]string(name='headers'),
  body: ListRepositoryTagsResponseBody(name='body'),
}

async function listRepositoryTags(ProjectId: string, request: ListRepositoryTagsRequest): ListRepositoryTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRepositoryTagsWithOptions(ProjectId, request, headers, runtime);
}

async function listRepositoryTagsWithOptions(ProjectId: string, request: ListRepositoryTagsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRepositoryTagsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.search)) {
    query.Search = request.search;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.page)) {
    query.Page = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }
  if (!Util.isUnset(request.sort)) {
    query.Sort = request.sort;
  }
  if (!Util.isUnset(request.showSignature)) {
    query.ShowSignature = request.showSignature;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListRepositoryTags', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v4/projects/${ProjectId}/repository/tags`, 'json', req, runtime);
}

model ListRepositoryTreeRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  path?: string(name='Path'),
  type?: string(name='Type'),
  refName?: string(name='RefName'),
  subUserId?: string(name='SubUserId'),
}

model ListRepositoryTreeResponseBody = {
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  result?: [ 
    {
      type?: string(name='Type'),
      path?: string(name='Path'),
      mode?: string(name='Mode'),
      name?: string(name='Name'),
      id?: string(name='Id'),
    }
  ](name='Result'),
}

model ListRepositoryTreeResponse = {
  headers: map[string]string(name='headers'),
  body: ListRepositoryTreeResponseBody(name='body'),
}

async function listRepositoryTree(ProjectId: string, request: ListRepositoryTreeRequest): ListRepositoryTreeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRepositoryTreeWithOptions(ProjectId, request, headers, runtime);
}

async function listRepositoryTreeWithOptions(ProjectId: string, request: ListRepositoryTreeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRepositoryTreeResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.path)) {
    query.Path = request.path;
  }
  if (!Util.isUnset(request.type)) {
    query.Type = request.type;
  }
  if (!Util.isUnset(request.refName)) {
    query.RefName = request.refName;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListRepositoryTree', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v4/projects/${ProjectId}/repository/tree`, 'json', req, runtime);
}

model ListRepositoryWebhookRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  page?: long(name='Page'),
  pageSize?: long(name='PageSize'),
}

model ListRepositoryWebhookResponseBody = {
  requestId?: string(name='RequestId'),
  total?: long(name='Total'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  result?: [ 
    {
      pushEvents?: boolean(name='PushEvents'),
      projectId?: long(name='ProjectId'),
      createdAt?: string(name='CreatedAt'),
      tagPushEvents?: boolean(name='TagPushEvents'),
      url?: string(name='Url'),
      lastTestResult?: string(name='LastTestResult'),
      description?: string(name='Description'),
      mergeRequestsEvents?: boolean(name='MergeRequestsEvents'),
      secretToken?: string(name='SecretToken'),
      noteEvents?: boolean(name='NoteEvents'),
      enableSslVerification?: boolean(name='EnableSslVerification'),
      id?: long(name='Id'),
    }
  ](name='Result'),
}

model ListRepositoryWebhookResponse = {
  headers: map[string]string(name='headers'),
  body: ListRepositoryWebhookResponseBody(name='body'),
}

async function listRepositoryWebhook(ProjectId: string, request: ListRepositoryWebhookRequest): ListRepositoryWebhookResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRepositoryWebhookWithOptions(ProjectId, request, headers, runtime);
}

async function listRepositoryWebhookWithOptions(ProjectId: string, request: ListRepositoryWebhookRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRepositoryWebhookResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.page)) {
    query.Page = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListRepositoryWebhook', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v3/projects/${ProjectId}/hooks`, 'json', req, runtime);
}

model MergeMergeRequestRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model MergeMergeRequestResponseBody = {
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  result?: {
    state?: string(name='State'),
    behindCommitCount?: int32(name='BehindCommitCount'),
    projectId?: long(name='ProjectId'),
    assigneeList?: [ 
      {
        externUserId?: string(name='ExternUserId'),
        avatarUrl?: string(name='AvatarUrl'),
        name?: string(name='Name'),
        id?: string(name='Id'),
      }
    ](name='AssigneeList'),
    createdAt?: string(name='CreatedAt'),
    author?: {
      externUserId?: string(name='ExternUserId'),
      avatarUrl?: string(name='AvatarUrl'),
      name?: string(name='Name'),
      id?: long(name='Id'),
    }(name='Author'),
    acceptedRevision?: string(name='AcceptedRevision'),
    approveCheckResult?: {
      totalCheckResult?: string(name='TotalCheckResult'),
      unsatisfiedCheckResults?: [ 
        {
          satisfiedItems?: [ string ](name='SatisfiedItems'),
          checkStatus?: string(name='CheckStatus'),
          checkType?: string(name='CheckType'),
          unsatisfiedItems?: [ string ](name='UnsatisfiedItems'),
          extraUsers?: [ 
            {
              externUserId?: string(name='ExternUserId'),
              avatarUrl?: string(name='AvatarUrl'),
              name?: string(name='Name'),
              id?: long(name='Id'),
            }
          ](name='ExtraUsers'),
          checkName?: string(name='CheckName'),
        }
      ](name='UnsatisfiedCheckResults'),
      satisfiedCheckResults?: [ 
        {
          satisfiedItems?: [ string ](name='SatisfiedItems'),
          checkStatus?: string(name='CheckStatus'),
          checkType?: string(name='CheckType'),
          unsatisfiedItems?: [ string ](name='UnsatisfiedItems'),
          extraUsers?: [ 
            {
              externUserId?: string(name='ExternUserId'),
              avatarUrl?: string(name='AvatarUrl'),
              name?: string(name='Name'),
              id?: long(name='Id'),
            }
          ](name='ExtraUsers'),
          checkName?: string(name='CheckName'),
        }
      ](name='SatisfiedCheckResults'),
    }(name='ApproveCheckResult'),
    sourceBranch?: string(name='SourceBranch'),
    webUrl?: string(name='WebUrl'),
    description?: string(name='Description'),
    mergeType?: string(name='MergeType'),
    nameWithNamespace?: string(name='NameWithNamespace'),
    targetBranch?: string(name='TargetBranch'),
    aheadCommitCount?: int32(name='AheadCommitCount'),
    updatedAt?: string(name='UpdatedAt'),
    title?: string(name='Title'),
    mergeError?: string(name='MergeError'),
    mergedRevision?: string(name='MergedRevision'),
    id?: long(name='Id'),
    mergeStatus?: string(name='MergeStatus'),
  }(name='Result'),
}

model MergeMergeRequestResponse = {
  headers: map[string]string(name='headers'),
  body: MergeMergeRequestResponseBody(name='body'),
}

async function mergeMergeRequest(ProjectId: string, MergeRequestId: string, request: MergeMergeRequestRequest): MergeMergeRequestResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return mergeMergeRequestWithOptions(ProjectId, MergeRequestId, request, headers, runtime);
}

async function mergeMergeRequestWithOptions(ProjectId: string, MergeRequestId: string, request: MergeMergeRequestRequest, headers: map[string]string, runtime: Util.RuntimeOptions): MergeMergeRequestResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('MergeMergeRequest', '2020-04-14', 'HTTPS', 'PUT', 'AK', `/api/v3/projects/${ProjectId}/mergeRequest/{MergeRequestId}/merge`, 'json', req, runtime);
}

model UpdateFileRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model UpdateFileResponseBody = {
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  result?: {
    filePath?: string(name='FilePath'),
    branchName?: string(name='BranchName'),
  }(name='Result'),
}

model UpdateFileResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateFileResponseBody(name='body'),
}

async function updateFile(ProjectId: string, request: UpdateFileRequest): UpdateFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateFileWithOptions(ProjectId, request, headers, runtime);
}

async function updateFileWithOptions(ProjectId: string, request: UpdateFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateFileResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateFile', '2020-04-14', 'HTTPS', 'PUT', 'AK', `/api/v4/projects/${ProjectId}/repository/files`, 'json', req, runtime);
}

model UpdateGroupMemberRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model UpdateGroupMemberResponseBody = {
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  result?: {
    externUserId?: string(name='ExternUserId'),
    email?: string(name='Email'),
    avatarUrl?: string(name='AvatarUrl'),
    state?: string(name='State'),
    accessLevel?: int32(name='AccessLevel'),
    id?: long(name='Id'),
  }(name='Result'),
}

model UpdateGroupMemberResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateGroupMemberResponseBody(name='body'),
}

async function updateGroupMember(GroupId: string, UserId: string, request: UpdateGroupMemberRequest): UpdateGroupMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateGroupMemberWithOptions(GroupId, UserId, request, headers, runtime);
}

async function updateGroupMemberWithOptions(GroupId: string, UserId: string, request: UpdateGroupMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateGroupMemberResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateGroupMember', '2020-04-14', 'HTTPS', 'PUT', 'AK', `/api/v3/groups/${GroupId}/members/{UserId}`, 'json', req, runtime);
}

model UpdateRepositoryMemberRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model UpdateRepositoryMemberResponseBody = {
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  success?: boolean(name='Success'),
  result?: {
    externUserId?: string(name='ExternUserId'),
    email?: string(name='Email'),
    avatarUrl?: string(name='AvatarUrl'),
    state?: string(name='State'),
    accessLevel?: int32(name='AccessLevel'),
    id?: long(name='Id'),
  }(name='Result'),
}

model UpdateRepositoryMemberResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateRepositoryMemberResponseBody(name='body'),
}

async function updateRepositoryMember(ProjectId: string, UserId: string, request: UpdateRepositoryMemberRequest): UpdateRepositoryMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateRepositoryMemberWithOptions(ProjectId, UserId, request, headers, runtime);
}

async function updateRepositoryMemberWithOptions(ProjectId: string, UserId: string, request: UpdateRepositoryMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateRepositoryMemberResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateRepositoryMember', '2020-04-14', 'HTTPS', 'PUT', 'AK', `/api/v3/projects/${ProjectId}/members/{UserId}`, 'json', req, runtime);
}

