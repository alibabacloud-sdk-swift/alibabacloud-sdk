import Util;

import RPC;
import EndpointUtil;

extends RPC;

init(config: RPC.Config){
  super(config);
  @endpointRule = 'central';
  
  checkConfig(config);
  @endpoint = getEndpoint('servicemesh', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

model GetAutoInjectionLabelSyncStatusRequest = {
  serviceMeshId: string(name='ServiceMeshId'),
}

model GetAutoInjectionLabelSyncStatusResponse = {
  requestId: string(name='RequestId'),
  status: string(name='Status'),
}

async function getAutoInjectionLabelSyncStatusWithOptions(request: GetAutoInjectionLabelSyncStatusRequest, runtime: Util.RuntimeOptions): GetAutoInjectionLabelSyncStatusResponse {
  Util.validateModel(request);
  return doRequest('GetAutoInjectionLabelSyncStatus', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function getAutoInjectionLabelSyncStatus(request: GetAutoInjectionLabelSyncStatusRequest): GetAutoInjectionLabelSyncStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAutoInjectionLabelSyncStatusWithOptions(request, runtime);
}

model AddVmAppToMeshRequest = {
  serviceMeshId: string(name='ServiceMeshId'),
  namespace: string(name='Namespace'),
  serviceName: string(name='ServiceName'),
  ips: string(name='Ips'),
  ports: string(name='Ports'),
  labels: string(name='Labels'),
  annotations?: string(name='Annotations'),
  serviceAccount?: string(name='ServiceAccount'),
  force?: boolean(name='Force'),
}

model AddVmAppToMeshResponse = {
  requestId: string(name='RequestId'),
  data: string(name='Data'),
}

async function addVmAppToMeshWithOptions(request: AddVmAppToMeshRequest, runtime: Util.RuntimeOptions): AddVmAppToMeshResponse {
  Util.validateModel(request);
  return doRequest('AddVmAppToMesh', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function addVmAppToMesh(request: AddVmAppToMeshRequest): AddVmAppToMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return addVmAppToMeshWithOptions(request, runtime);
}

model GetVmAppMeshInfoRequest = {
  serviceMeshId: string(name='ServiceMeshId'),
}

model GetVmAppMeshInfoResponse = {
  requestId: string(name='RequestId'),
  data: string(name='Data'),
}

async function getVmAppMeshInfoWithOptions(request: GetVmAppMeshInfoRequest, runtime: Util.RuntimeOptions): GetVmAppMeshInfoResponse {
  Util.validateModel(request);
  return doRequest('GetVmAppMeshInfo', 'HTTPS', 'GET', '2020-01-11', 'AK', request, null, runtime);
}

async function getVmAppMeshInfo(request: GetVmAppMeshInfoRequest): GetVmAppMeshInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVmAppMeshInfoWithOptions(request, runtime);
}

model GetVmMetaRequest = {
  serviceMeshId: string(name='ServiceMeshId'),
  trustDomain?: string(name='TrustDomain'),
  namespace?: string(name='Namespace'),
  serviceAccount?: string(name='ServiceAccount'),
}

model GetVmMetaResponse = {
  requestId: string(name='RequestId'),
  vmMetaInfo: {
    rootCertPath: string(name='RootCertPath'),
    rootCertContent: string(name='RootCertContent'),
    keyPath: string(name='KeyPath'),
    keyContent: string(name='KeyContent'),
    certChainPath: string(name='CertChainPath'),
    certChainContent: string(name='CertChainContent'),
    envoyEnvPath: string(name='EnvoyEnvPath'),
    envoyEnvContent: string(name='EnvoyEnvContent'),
    hostsPath: string(name='HostsPath'),
    hostsContent: string(name='HostsContent'),
    tokenPath: string(name='TokenPath'),
    tokenContent: string(name='TokenContent'),
  }(name='VmMetaInfo'),
}

async function getVmMetaWithOptions(request: GetVmMetaRequest, runtime: Util.RuntimeOptions): GetVmMetaResponse {
  Util.validateModel(request);
  return doRequest('GetVmMeta', 'HTTPS', 'GET', '2020-01-11', 'AK', request, null, runtime);
}

async function getVmMeta(request: GetVmMetaRequest): GetVmMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVmMetaWithOptions(request, runtime);
}

model RemoveVmAppFromMeshRequest = {
  serviceMeshId: string(name='ServiceMeshId'),
  namespace: string(name='Namespace'),
  serviceName: string(name='ServiceName'),
}

model RemoveVmAppFromMeshResponse = {
  requestId: string(name='RequestId'),
  data: string(name='Data'),
}

async function removeVmAppFromMeshWithOptions(request: RemoveVmAppFromMeshRequest, runtime: Util.RuntimeOptions): RemoveVmAppFromMeshResponse {
  Util.validateModel(request);
  return doRequest('RemoveVmAppFromMesh', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function removeVmAppFromMesh(request: RemoveVmAppFromMeshRequest): RemoveVmAppFromMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeVmAppFromMeshWithOptions(request, runtime);
}

model GetRegisteredServiceEndpointsRequest = {
  serviceMeshId: string(name='ServiceMeshId'),
  namespace: string(name='Namespace'),
  name: string(name='Name'),
}

model GetRegisteredServiceEndpointsResponse = {
  requestId: string(name='RequestId'),
  serviceEndpoints: [
    {
      address: string(name='Address'),
      clusterId: string(name='ClusterId'),
    }
  ](name='ServiceEndpoints'),
}

async function getRegisteredServiceEndpointsWithOptions(request: GetRegisteredServiceEndpointsRequest, runtime: Util.RuntimeOptions): GetRegisteredServiceEndpointsResponse {
  Util.validateModel(request);
  return doRequest('GetRegisteredServiceEndpoints', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function getRegisteredServiceEndpoints(request: GetRegisteredServiceEndpointsRequest): GetRegisteredServiceEndpointsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRegisteredServiceEndpointsWithOptions(request, runtime);
}

model GetServiceMeshSlbRequest = {
  serviceMeshId: string(name='ServiceMeshId'),
}

model GetServiceMeshSlbResponse = {
  requestId: string(name='RequestId'),
  data: [
    {
      loadBalancerId: string(name='LoadBalancerId'),
      status: string(name='Status'),
      serverHealthStatus: string(name='ServerHealthStatus'),
    }
  ](name='Data'),
}

async function getServiceMeshSlbWithOptions(request: GetServiceMeshSlbRequest, runtime: Util.RuntimeOptions): GetServiceMeshSlbResponse {
  Util.validateModel(request);
  return doRequest('GetServiceMeshSlb', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function getServiceMeshSlb(request: GetServiceMeshSlbRequest): GetServiceMeshSlbResponse {
  var runtime = new Util.RuntimeOptions{};
  return getServiceMeshSlbWithOptions(request, runtime);
}

model GetRegisteredServicesRequest = {
  serviceMeshId: string(name='ServiceMeshId'),
  namespace: string(name='Namespace'),
}

model GetRegisteredServicesResponse = {
  requestId: string(name='RequestId'),
  services: [ string ] (name='Services'),
}

async function getRegisteredServicesWithOptions(request: GetRegisteredServicesRequest, runtime: Util.RuntimeOptions): GetRegisteredServicesResponse {
  Util.validateModel(request);
  return doRequest('GetRegisteredServices', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function getRegisteredServices(request: GetRegisteredServicesRequest): GetRegisteredServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRegisteredServicesWithOptions(request, runtime);
}

model GetDiagnosisRequest = {
  serviceMeshId: string(name='ServiceMeshId'),
}

model GetDiagnosisResponse = {
  requestId: string(name='RequestId'),
  result: string(name='Result'),
  runAt: string(name='RunAt'),
}

async function getDiagnosisWithOptions(request: GetDiagnosisRequest, runtime: Util.RuntimeOptions): GetDiagnosisResponse {
  Util.validateModel(request);
  return doRequest('GetDiagnosis', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function getDiagnosis(request: GetDiagnosisRequest): GetDiagnosisResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDiagnosisWithOptions(request, runtime);
}

model GetRegisteredServiceNamespacesRequest = {
  serviceMeshId: string(name='ServiceMeshId'),
}

model GetRegisteredServiceNamespacesResponse = {
  requestId: string(name='RequestId'),
  namespaces: [ string ] (name='Namespaces'),
}

async function getRegisteredServiceNamespacesWithOptions(request: GetRegisteredServiceNamespacesRequest, runtime: Util.RuntimeOptions): GetRegisteredServiceNamespacesResponse {
  Util.validateModel(request);
  return doRequest('GetRegisteredServiceNamespaces', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function getRegisteredServiceNamespaces(request: GetRegisteredServiceNamespacesRequest): GetRegisteredServiceNamespacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRegisteredServiceNamespacesWithOptions(request, runtime);
}

model RunDiagnosisRequest = {
  serviceMeshId: string(name='ServiceMeshId'),
}

model RunDiagnosisResponse = {
  requestId: string(name='RequestId'),
  result: string(name='Result'),
}

async function runDiagnosisWithOptions(request: RunDiagnosisRequest, runtime: Util.RuntimeOptions): RunDiagnosisResponse {
  Util.validateModel(request);
  return doRequest('RunDiagnosis', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function runDiagnosis(request: RunDiagnosisRequest): RunDiagnosisResponse {
  var runtime = new Util.RuntimeOptions{};
  return runDiagnosisWithOptions(request, runtime);
}

model RemoveClusterFromServiceMeshRequest = {
  serviceMeshId: string(name='ServiceMeshId'),
  clusterId: string(name='ClusterId'),
}

model RemoveClusterFromServiceMeshResponse = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
}

async function removeClusterFromServiceMeshWithOptions(request: RemoveClusterFromServiceMeshRequest, runtime: Util.RuntimeOptions): RemoveClusterFromServiceMeshResponse {
  Util.validateModel(request);
  return doRequest('RemoveClusterFromServiceMesh', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function removeClusterFromServiceMesh(request: RemoveClusterFromServiceMeshRequest): RemoveClusterFromServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeClusterFromServiceMeshWithOptions(request, runtime);
}

model AddClusterIntoServiceMeshRequest = {
  serviceMeshId: string(name='ServiceMeshId'),
  clusterId: string(name='ClusterId'),
}

model AddClusterIntoServiceMeshResponse = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
}

async function addClusterIntoServiceMeshWithOptions(request: AddClusterIntoServiceMeshRequest, runtime: Util.RuntimeOptions): AddClusterIntoServiceMeshResponse {
  Util.validateModel(request);
  return doRequest('AddClusterIntoServiceMesh', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function addClusterIntoServiceMesh(request: AddClusterIntoServiceMeshRequest): AddClusterIntoServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return addClusterIntoServiceMeshWithOptions(request, runtime);
}

model UpdateIstioInjectionConfigRequest = {
  serviceMeshId: string(name='ServiceMeshId'),
  namespace: string(name='Namespace'),
  enableIstioInjection: boolean(name='EnableIstioInjection'),
}

model UpdateIstioInjectionConfigResponse = {
  requestId: string(name='RequestId'),
}

async function updateIstioInjectionConfigWithOptions(request: UpdateIstioInjectionConfigRequest, runtime: Util.RuntimeOptions): UpdateIstioInjectionConfigResponse {
  Util.validateModel(request);
  return doRequest('UpdateIstioInjectionConfig', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function updateIstioInjectionConfig(request: UpdateIstioInjectionConfigRequest): UpdateIstioInjectionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateIstioInjectionConfigWithOptions(request, runtime);
}

model DescribeGuestClusterAccessLogDashboardsRequest = {
  k8sClusterId: string(name='K8sClusterId'),
}

model DescribeGuestClusterAccessLogDashboardsResponse = {
  requestId: string(name='RequestId'),
  k8sClusterId: string(name='K8sClusterId'),
  dashboards: [
    {
      title: string(name='Title'),
      url: string(name='Url'),
    }
  ](name='Dashboards'),
}

async function describeGuestClusterAccessLogDashboardsWithOptions(request: DescribeGuestClusterAccessLogDashboardsRequest, runtime: Util.RuntimeOptions): DescribeGuestClusterAccessLogDashboardsResponse {
  Util.validateModel(request);
  return doRequest('DescribeGuestClusterAccessLogDashboards', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function describeGuestClusterAccessLogDashboards(request: DescribeGuestClusterAccessLogDashboardsRequest): DescribeGuestClusterAccessLogDashboardsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGuestClusterAccessLogDashboardsWithOptions(request, runtime);
}

model DescribeClusterPrometheusRequest = {
  serviceMeshId?: string(name='ServiceMeshId'),
  k8sClusterId?: string(name='K8sClusterId'),
  k8sClusterRegionId?: string(name='K8sClusterRegionId'),
}

model DescribeClusterPrometheusResponse = {
  requestId: string(name='RequestId'),
  prometheus: string(name='Prometheus'),
}

async function describeClusterPrometheusWithOptions(request: DescribeClusterPrometheusRequest, runtime: Util.RuntimeOptions): DescribeClusterPrometheusResponse {
  Util.validateModel(request);
  return doRequest('DescribeClusterPrometheus', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function describeClusterPrometheus(request: DescribeClusterPrometheusRequest): DescribeClusterPrometheusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterPrometheusWithOptions(request, runtime);
}

model DescribeClusterGrafanaRequest = {
  serviceMeshId: string(name='ServiceMeshId'),
  k8sClusterId: string(name='K8sClusterId'),
}

model DescribeClusterGrafanaResponse = {
  requestId: string(name='RequestId'),
  dashboards: [
    {
      url: string(name='Url'),
      title: string(name='Title'),
    }
  ](name='Dashboards'),
}

async function describeClusterGrafanaWithOptions(request: DescribeClusterGrafanaRequest, runtime: Util.RuntimeOptions): DescribeClusterGrafanaResponse {
  Util.validateModel(request);
  return doRequest('DescribeClusterGrafana', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function describeClusterGrafana(request: DescribeClusterGrafanaRequest): DescribeClusterGrafanaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterGrafanaWithOptions(request, runtime);
}

model DescribeCensRequest = {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeCensResponse = {
  requestId: string(name='RequestId'),
  clusters: [ string ] (name='Clusters'),
}

async function describeCensWithOptions(request: DescribeCensRequest, runtime: Util.RuntimeOptions): DescribeCensResponse {
  Util.validateModel(request);
  return doRequest('DescribeCens', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function describeCens(request: DescribeCensRequest): DescribeCensResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCensWithOptions(request, runtime);
}

model DescribeClustersInServiceMeshRequest = {
  serviceMeshId: string(name='ServiceMeshId'),
}

model DescribeClustersInServiceMeshResponse = {
  requestId: string(name='RequestId'),
  clusters: [
    {
      clusterId: string(name='ClusterId'),
      clusterType: string(name='ClusterType'),
      creationTime: string(name='CreationTime'),
      errorMessage: string(name='ErrorMessage'),
      name: string(name='Name'),
      regionId: string(name='RegionId'),
      state: string(name='State'),
      updateTime: string(name='UpdateTime'),
      version: string(name='Version'),
      vpcId: string(name='VpcId'),
      sgId: string(name='SgId'),
      clusterDomain: string(name='ClusterDomain'),
      accessLogDashboards: [
        {
          title: string(name='Title'),
          url: string(name='Url'),
        }
      ](name='AccessLogDashboards'),
    }
  ](name='Clusters'),
}

async function describeClustersInServiceMeshWithOptions(request: DescribeClustersInServiceMeshRequest, runtime: Util.RuntimeOptions): DescribeClustersInServiceMeshResponse {
  Util.validateModel(request);
  return doRequest('DescribeClustersInServiceMesh', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function describeClustersInServiceMesh(request: DescribeClustersInServiceMeshRequest): DescribeClustersInServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClustersInServiceMeshWithOptions(request, runtime);
}

model DescribeIngressGatewaysRequest = {
  serviceMeshId?: string(name='ServiceMeshId'),
}

model DescribeIngressGatewaysResponse = {
  requestId: string(name='RequestId'),
  ingressGateways: [ map[string]any ] (name='IngressGateways'),
}

async function describeIngressGatewaysWithOptions(request: DescribeIngressGatewaysRequest, runtime: Util.RuntimeOptions): DescribeIngressGatewaysResponse {
  Util.validateModel(request);
  return doRequest('DescribeIngressGateways', 'HTTPS', 'GET', '2020-01-11', 'AK', request, null, runtime);
}

async function describeIngressGateways(request: DescribeIngressGatewaysRequest): DescribeIngressGatewaysResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIngressGatewaysWithOptions(request, runtime);
}

model DescribeUpgradeVersionRequest = {
  serviceMeshId: string(name='ServiceMeshId'),
}

model DescribeUpgradeVersionResponse = {
  requestId: string(name='RequestId'),
  version: {
    istioVersion: string(name='IstioVersion'),
    istioOperatorVersion: string(name='IstioOperatorVersion'),
    kubernetesVersion: string(name='KubernetesVersion'),
  }(name='Version'),
}

async function describeUpgradeVersionWithOptions(request: DescribeUpgradeVersionRequest, runtime: Util.RuntimeOptions): DescribeUpgradeVersionResponse {
  Util.validateModel(request);
  return doRequest('DescribeUpgradeVersion', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function describeUpgradeVersion(request: DescribeUpgradeVersionRequest): DescribeUpgradeVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUpgradeVersionWithOptions(request, runtime);
}

model UpdateMeshFeatureRequest = {
  serviceMeshId: string(name='ServiceMeshId'),
  tracing?: boolean(name='Tracing'),
  traceSampling?: float(name='TraceSampling'),
  localityLoadBalancing?: boolean(name='LocalityLoadBalancing'),
  telemetry?: boolean(name='Telemetry'),
  openAgentPolicy?: boolean(name='OpenAgentPolicy'),
  OPALogLevel?: string(name='OPALogLevel'),
  OPARequestCPU?: string(name='OPARequestCPU'),
  OPARequestMemory?: string(name='OPARequestMemory'),
  OPALimitCPU?: string(name='OPALimitCPU'),
  OPALimitMemory?: string(name='OPALimitMemory'),
  enableAudit?: boolean(name='EnableAudit'),
  auditProject?: string(name='AuditProject'),
  clusterDomain?: string(name='ClusterDomain'),
  customizedZipkin?: boolean(name='CustomizedZipkin'),
  outboundTrafficPolicy?: string(name='OutboundTrafficPolicy'),
  proxyRequestCPU?: string(name='ProxyRequestCPU'),
  proxyRequestMemory?: string(name='ProxyRequestMemory'),
  proxyLimitCPU?: string(name='ProxyLimitCPU'),
  proxyLimitMemory?: string(name='ProxyLimitMemory'),
  includeIPRanges?: string(name='IncludeIPRanges'),
  enableNamespacesByDefault?: boolean(name='EnableNamespacesByDefault'),
  autoInjectionPolicyEnabled?: boolean(name='AutoInjectionPolicyEnabled'),
  sidecarInjectorRequestCPU?: string(name='SidecarInjectorRequestCPU'),
  sidecarInjectorRequestMemory?: string(name='SidecarInjectorRequestMemory'),
  sidecarInjectorLimitCPU?: string(name='SidecarInjectorLimitCPU'),
  sidecarInjectorLimitMemory?: string(name='SidecarInjectorLimitMemory'),
  sidecarInjectorWebhookAsYaml?: string(name='SidecarInjectorWebhookAsYaml'),
  cniEnabled?: boolean(name='CniEnabled'),
  cniExcludeNamespaces?: string(name='CniExcludeNamespaces'),
  opaEnabled?: boolean(name='OpaEnabled'),
  http10Enabled?: boolean(name='Http10Enabled'),
  kialiEnabled?: boolean(name='KialiEnabled'),
  customizedPrometheus?: boolean(name='CustomizedPrometheus'),
  prometheusUrl?: string(name='PrometheusUrl'),
  accessLogEnabled?: boolean(name='AccessLogEnabled'),
}

model UpdateMeshFeatureResponse = {
  requestId: string(name='RequestId'),
}

async function updateMeshFeatureWithOptions(request: UpdateMeshFeatureRequest, runtime: Util.RuntimeOptions): UpdateMeshFeatureResponse {
  Util.validateModel(request);
  return doRequest('UpdateMeshFeature', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function updateMeshFeature(request: UpdateMeshFeatureRequest): UpdateMeshFeatureResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMeshFeatureWithOptions(request, runtime);
}

model UpgradeMeshVersionRequest = {
  serviceMeshId: string(name='ServiceMeshId'),
}

model UpgradeMeshVersionResponse = {
  requestId: string(name='RequestId'),
}

async function upgradeMeshVersionWithOptions(request: UpgradeMeshVersionRequest, runtime: Util.RuntimeOptions): UpgradeMeshVersionResponse {
  Util.validateModel(request);
  return doRequest('UpgradeMeshVersion', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function upgradeMeshVersion(request: UpgradeMeshVersionRequest): UpgradeMeshVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeMeshVersionWithOptions(request, runtime);
}

model DescribeServiceMeshesRequest = {
}

model DescribeServiceMeshesResponse = {
  requestId: string(name='RequestId'),
  serviceMeshes: [
    {
      endpoints: {
        intranetApiServerEndpoint: string(name='IntranetApiServerEndpoint'),
        intranetPilotEndpoint: string(name='IntranetPilotEndpoint'),
        publicApiServerEndpoint: string(name='PublicApiServerEndpoint'),
        publicPilotEndpoint: string(name='PublicPilotEndpoint'),
        reverseTunnelEndpoint: string(name='ReverseTunnelEndpoint'),
      }(name='Endpoints'),
      serviceMeshInfo: {
        creationTime: string(name='CreationTime'),
        errorMessage: string(name='ErrorMessage'),
        name: string(name='Name'),
        regionId: string(name='RegionId'),
        serviceMeshId: string(name='ServiceMeshId'),
        state: string(name='State'),
        updateTime: string(name='UpdateTime'),
        version: string(name='Version'),
      }(name='ServiceMeshInfo'),
      spec: {
        loadBalancer: {
          apiServerLoadbalancerId: string(name='ApiServerLoadbalancerId'),
          apiServerPublicEip: boolean(name='ApiServerPublicEip'),
          pilotPublicEip: boolean(name='PilotPublicEip'),
          pilotPublicLoadbalancerId: string(name='PilotPublicLoadbalancerId'),
        }(name='LoadBalancer'),
        meshConfig: {
          mtls: boolean(name='Mtls'),
          outboundTrafficPolicy: string(name='OutboundTrafficPolicy'),
          strictMtls: boolean(name='StrictMtls'),
          tracing: boolean(name='Tracing'),
          telemetry: boolean(name='Telemetry'),
          pilot: {
            traceSampling: float(name='TraceSampling'),
            http10Enabled: boolean(name='Http10Enabled'),
          }(name='Pilot'),
          sidecarInjector: {
            enableNamespacesByDefault: boolean(name='EnableNamespacesByDefault'),
            autoInjectionPolicyEnabled: boolean(name='AutoInjectionPolicyEnabled'),
            initCNIConfiguration: {
              enabled: boolean(name='Enabled'),
              excludeNamespaces: string(name='ExcludeNamespaces'),
            }(name='InitCNIConfiguration'),
          }(name='SidecarInjector'),
        }(name='MeshConfig'),
        network: {
          securityGroupId: string(name='SecurityGroupId'),
          vpcId: string(name='VpcId'),
          vSwitches: [ string ](name='VSwitches'),
        }(name='Network'),
      }(name='Spec'),
      clusters: [ string ](name='Clusters'),
    }
  ](name='ServiceMeshes'),
}

async function describeServiceMeshesWithOptions(request: DescribeServiceMeshesRequest, runtime: Util.RuntimeOptions): DescribeServiceMeshesResponse {
  Util.validateModel(request);
  return doRequest('DescribeServiceMeshes', 'HTTPS', 'GET', '2020-01-11', 'AK', request, null, runtime);
}

async function describeServiceMeshes(request: DescribeServiceMeshesRequest): DescribeServiceMeshesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceMeshesWithOptions(request, runtime);
}

model DescribeServiceMeshDetailRequest = {
  serviceMeshId: string(name='ServiceMeshId'),
}

model DescribeServiceMeshDetailResponse = {
  requestId: string(name='RequestId'),
  serviceMesh: {
    endpoints: {
      intranetApiServerEndpoint: string(name='IntranetApiServerEndpoint'),
      intranetPilotEndpoint: string(name='IntranetPilotEndpoint'),
      publicApiServerEndpoint: string(name='PublicApiServerEndpoint'),
      publicPilotEndpoint: string(name='PublicPilotEndpoint'),
    }(name='Endpoints'),
    serviceMeshInfo: {
      creationTime: string(name='CreationTime'),
      errorMessage: string(name='ErrorMessage'),
      name: string(name='Name'),
      regionId: string(name='RegionId'),
      serviceMeshId: string(name='ServiceMeshId'),
      state: string(name='State'),
      updateTime: string(name='UpdateTime'),
      version: string(name='Version'),
    }(name='ServiceMeshInfo'),
    spec: {
      loadBalancer: {
        apiServerLoadbalancerId: string(name='ApiServerLoadbalancerId'),
        apiServerPublicEip: boolean(name='ApiServerPublicEip'),
        pilotPublicEip: boolean(name='PilotPublicEip'),
        pilotPublicLoadbalancerId: string(name='PilotPublicLoadbalancerId'),
      }(name='LoadBalancer'),
      meshConfig: {
        enableLocalityLB: boolean(name='EnableLocalityLB'),
        telemetry: boolean(name='Telemetry'),
        tracing: boolean(name='Tracing'),
        customizedZipkin: boolean(name='CustomizedZipkin'),
        outboundTrafficPolicy: string(name='OutboundTrafficPolicy'),
        includeIPRanges: string(name='IncludeIPRanges'),
        edition: string(name='Edition'),
        pilot: {
          traceSampling: float(name='TraceSampling'),
          http10Enabled: boolean(name='Http10Enabled'),
        }(name='Pilot'),
        OPA: {
          enabled: boolean(name='Enabled'),
          logLevel: string(name='LogLevel'),
          requestCPU: string(name='RequestCPU'),
          requestMemory: string(name='RequestMemory'),
          limitCPU: string(name='LimitCPU'),
          limitMemory: string(name='LimitMemory'),
        }(name='OPA'),
        audit: {
          enabled: boolean(name='Enabled'),
          project: string(name='Project'),
        }(name='Audit'),
        proxy: {
          clusterDomain: string(name='ClusterDomain'),
          requestCPU: string(name='RequestCPU'),
          requestMemory: string(name='RequestMemory'),
          limitCPU: string(name='LimitCPU'),
          limitMemory: string(name='LimitMemory'),
        }(name='Proxy'),
        sidecarInjector: {
          enableNamespacesByDefault: boolean(name='EnableNamespacesByDefault'),
          autoInjectionPolicyEnabled: boolean(name='AutoInjectionPolicyEnabled'),
          requestCPU: string(name='RequestCPU'),
          requestMemory: string(name='RequestMemory'),
          limitCPU: string(name='LimitCPU'),
          limitMemory: string(name='LimitMemory'),
          sidecarInjectorWebhookAsYaml: string(name='SidecarInjectorWebhookAsYaml'),
          initCNIConfiguration: {
            enabled: boolean(name='Enabled'),
            excludeNamespaces: string(name='ExcludeNamespaces'),
          }(name='InitCNIConfiguration'),
        }(name='SidecarInjector'),
        kiali: {
          enabled: boolean(name='Enabled'),
        }(name='Kiali'),
        prometheus: {
          useExternal: boolean(name='UseExternal'),
          externalUrl: string(name='ExternalUrl'),
        }(name='Prometheus'),
        accessLog: {
          enabled: boolean(name='Enabled'),
        }(name='AccessLog'),
      }(name='MeshConfig'),
      network: {
        securityGroupId: string(name='SecurityGroupId'),
        vpcId: string(name='VpcId'),
        vSwitches: [ string ](name='VSwitches'),
      }(name='Network'),
    }(name='Spec'),
    clusters: [ string ](name='Clusters'),
  }(name='ServiceMesh'),
}

async function describeServiceMeshDetailWithOptions(request: DescribeServiceMeshDetailRequest, runtime: Util.RuntimeOptions): DescribeServiceMeshDetailResponse {
  Util.validateModel(request);
  return doRequest('DescribeServiceMeshDetail', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function describeServiceMeshDetail(request: DescribeServiceMeshDetailRequest): DescribeServiceMeshDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceMeshDetailWithOptions(request, runtime);
}

model DescribeServiceMeshKubeconfigRequest = {
  serviceMeshId: string(name='ServiceMeshId'),
  privateIpAddress?: boolean(name='PrivateIpAddress'),
}

model DescribeServiceMeshKubeconfigResponse = {
  kubeconfig: string(name='Kubeconfig'),
  requestId: string(name='RequestId'),
}

async function describeServiceMeshKubeconfigWithOptions(request: DescribeServiceMeshKubeconfigRequest, runtime: Util.RuntimeOptions): DescribeServiceMeshKubeconfigResponse {
  Util.validateModel(request);
  return doRequest('DescribeServiceMeshKubeconfig', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function describeServiceMeshKubeconfig(request: DescribeServiceMeshKubeconfigRequest): DescribeServiceMeshKubeconfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceMeshKubeconfigWithOptions(request, runtime);
}

model CreateServiceMeshRequest = {
  regionId: string(name='RegionId'),
  istioVersion?: string(name='IstioVersion'),
  vpcId: string(name='VpcId'),
  apiServerPublicEip?: boolean(name='ApiServerPublicEip'),
  pilotPublicEip?: boolean(name='PilotPublicEip'),
  tracing?: boolean(name='Tracing'),
  name?: string(name='Name'),
  vSwitches: string(name='VSwitches'),
  traceSampling?: float(name='TraceSampling'),
  localityLoadBalancing?: boolean(name='LocalityLoadBalancing'),
  telemetry?: boolean(name='Telemetry'),
  openAgentPolicy?: boolean(name='OpenAgentPolicy'),
  OPALogLevel?: string(name='OPALogLevel'),
  OPARequestCPU?: string(name='OPARequestCPU'),
  OPARequestMemory?: string(name='OPARequestMemory'),
  OPALimitCPU?: string(name='OPALimitCPU'),
  OPALimitMemory?: string(name='OPALimitMemory'),
  enableAudit?: boolean(name='EnableAudit'),
  auditProject?: string(name='AuditProject'),
  proxyRequestCPU?: string(name='ProxyRequestCPU'),
  proxyRequestMemory?: string(name='ProxyRequestMemory'),
  proxyLimitCPU?: string(name='ProxyLimitCPU'),
  proxyLimitMemory?: string(name='ProxyLimitMemory'),
  includeIPRanges?: string(name='IncludeIPRanges'),
  excludeIPRanges?: string(name='ExcludeIPRanges'),
  excludeOutboundPorts?: string(name='ExcludeOutboundPorts'),
  excludeInboundPorts?: string(name='ExcludeInboundPorts'),
  opaEnabled?: boolean(name='OpaEnabled'),
  kialiEnabled?: boolean(name='KialiEnabled'),
  accessLogEnabled?: boolean(name='AccessLogEnabled'),
  customizedPrometheus?: boolean(name='CustomizedPrometheus'),
  prometheusUrl?: string(name='PrometheusUrl'),
}

model CreateServiceMeshResponse = {
  requestId: string(name='RequestId'),
  serviceMeshId: string(name='ServiceMeshId'),
}

async function createServiceMeshWithOptions(request: CreateServiceMeshRequest, runtime: Util.RuntimeOptions): CreateServiceMeshResponse {
  Util.validateModel(request);
  return doRequest('CreateServiceMesh', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function createServiceMesh(request: CreateServiceMeshRequest): CreateServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return createServiceMeshWithOptions(request, runtime);
}

model DeleteServiceMeshRequest = {
  serviceMeshId: string(name='ServiceMeshId'),
  force?: boolean(name='Force'),
}

model DeleteServiceMeshResponse = {
  requestId: string(name='RequestId'),
}

async function deleteServiceMeshWithOptions(request: DeleteServiceMeshRequest, runtime: Util.RuntimeOptions): DeleteServiceMeshResponse {
  Util.validateModel(request);
  return doRequest('DeleteServiceMesh', 'HTTPS', 'POST', '2020-01-11', 'AK', null, request, runtime);
}

async function deleteServiceMesh(request: DeleteServiceMeshRequest): DeleteServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteServiceMeshWithOptions(request, runtime);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
