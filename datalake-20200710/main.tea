/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  

  checkConfig(config);
  @endpoint = getEndpoint('datalake', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model LockObj {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  partitionName?: string(name='PartitionName', description='PartitionName'),
  tableName?: string(name='TableName', description='TableName'),
}

model FieldSchema {
  comment?: string(name='Comment', description='Comment'),
  name?: string(name='Name', description='Name'),
  parameters?: map[string]string(name='Parameters'),
  type?: string(name='Type', description='Type'),
}

model StorageDescriptor {
  bucketCols?: [ string ](name='BucketCols'),
  cols?: [
    FieldSchema
  ](name='Cols', description='Cols'),
  compressed?: boolean(name='Compressed', description='Compressed'),
  inputFormat?: string(name='InputFormat', description='InputFormat'),
  location?: string(name='Location', description='Location'),
  numBuckets?: int32(name='NumBuckets', description='NumBuckets'),
  outputFormat?: string(name='OutputFormat', description='OutputFormat'),
  parameters?: map[string]string(name='Parameters', description='Parameters'),
  serDeInfo?: SerDeInfo(name='SerDeInfo'),
  skewedInfo?: SkewedInfo(name='SkewedInfo'),
  sortCols?: [
    Order
  ](name='SortCols', description='SortCols'),
  storedAsSubDirectories?: boolean(name='StoredAsSubDirectories', description='StoredAsSubDirectories'),
}

model UpdateTablePartitionColumnStatisticsRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  columnStatisticsList?: [
    ColumnStatistics
  ](name='ColumnStatisticsList', description='ColumnStatisticsList'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  engine?: string(name='Engine', description='Engine'),
  tableName?: string(name='TableName', description='TableName'),
  validWriteIdList?: string(name='ValidWriteIdList', description='ValidWriteIdList, optional'),
  writeId?: string(name='WriteId', description='WriteId, optional'),
  isStatsCompliant?: boolean(name='IsStatsCompliant', description='IsStatsCompliant'),
}

model TableError {
  errorDetail?: ErrorDetail(name='ErrorDetail'),
  tableName?: string(name='TableName', description='TableName'),
}

model PartitionInput {
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  lastAccessTime?: int32(name='LastAccessTime', description='LastAccessTime'),
  lastAnalyzedTime?: int32(name='LastAnalyzedTime', description='LastAnalyzedTime'),
  parameters?: map[string]string(name='Parameters', description='Parameters'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
  sd?: StorageDescriptor(name='Sd'),
  tableName?: string(name='TableName', description='TableName'),
  values?: [ string ](name='Values', description='Values'),
}

model ErrorDetail {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
}

model Function {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  className?: string(name='ClassName', description='ClassName'),
  createTime?: int32(name='CreateTime', description='CreateTime'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  functionName?: string(name='FunctionName', description='FunctionName'),
  functionType?: string(name='FunctionType', description='FunctionType'),
  ownerName?: string(name='OwnerName', description='OwnerName'),
  ownerType?: string(name='OwnerType', description='OwnerType'),
  resourceUri?: [
    ResourceUri
  ](name='ResourceUri', description='ResourceUri'),
  updateTime?: int32(name='UpdateTime', description='UpdateTime'),
}

model TableInput {
  cascade?: boolean(name='Cascade', description='Cascade'),
  createdBy?: string(name='CreatedBy', description='CreatedBy'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  lastAccessTime?: int32(name='LastAccessTime', description='LastAccessTime'),
  lastAnalyzedTime?: int32(name='LastAnalyzedTime', description='LastAnalyzedTime'),
  owner?: string(name='Owner', description='Owner'),
  ownerType?: string(name='OwnerType', description='OwnerType'),
  parameters?: map[string]string(name='Parameters'),
  partitionKeys?: [
FieldSchema
](name='PartitionKeys'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
  retention?: int32(name='Retention', description='Retention'),
  rewriteEnabled?: boolean(name='RewriteEnabled', description='RewriteEnabled'),
  sd?: StorageDescriptor(name='Sd'),
  tableName?: string(name='TableName', description='TableName'),
  tableType?: string(name='TableType', description='TableType'),
  temporary?: boolean(name='Temporary', description='Temporary'),
  viewExpandedText?: string(name='ViewExpandedText', description='ViewExpandedText'),
  viewOriginalText?: string(name='ViewOriginalText', description='ViewOriginalText'),
}

model ColumnStatisticsObj {
  columnName?: string(name='ColumnName', description='ColumnName of the table'),
  columnType?: string(name='ColumnType', description='ColumnType'),
  columnStatisticsData?: {
    statisticsData?: string(name='StatisticsData', description='StatisticsData'),
    statisticsType?: string(name='StatisticsType', description='StatisticsType'),
  }(name='ColumnStatisticsData', description='ColumnStatisticsData'),
}

model StorageSummary {
  databaseNum?: long(name='DatabaseNum', description='database num of this catalog'),
  partitionNum?: long(name='PartitionNum', description='partition num of this catalog'),
  tableNum?: long(name='TableNum', description='table num of this catalog'),
}

model SkewedInfo {
  skewedColNames?: [ string ](name='SkewedColNames', description='SkewedColNames'),
  skewedColValueLocationMaps?: map[string]string(name='SkewedColValueLocationMaps', description='SkewedColValueLocationMaps'),
  skewedColValues?: [[ string ]  ](name='SkewedColValues', description='SkewedColValueLocationMaps'),
}

model ColumnStatisticsDesc {
  lastAnalyzedTime?: long(name='LastAnalyzedTime', description='optional'),
  partitionName?: string(name='PartitionName', description='required'),
}

model Database {
  createTime?: int32(name='CreateTime', description='createTime'),
  description?: string(name='Description', description='description'),
  locationUri?: string(name='LocationUri', description='locationUri'),
  name?: string(name='Name', description='name'),
  ownerName?: string(name='OwnerName', description='ownerName'),
  ownerType?: string(name='OwnerType', description='ownerType'),
  parameters?: map[string]string(name='Parameters'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
  updateTime?: int32(name='UpdateTime', description='updateTime'),
}

model Order {
  col?: string(name='Col', description='Col'),
  order?: int32(name='Order', description='Order'),
}

model ColumnStatistics {
  columnStatisticsDesc?: ColumnStatisticsDesc(name='ColumnStatisticsDesc'),
  columnStatisticsObjList?: [
    ColumnStatisticsObj
  ](name='ColumnStatisticsObjList', description='ColumnStatisticsObjList'),
  engine?: string(name='Engine', description='Engine for hive3+'),
  isStatsCompliant?: boolean(name='IsStatsCompliant', description='IsStatsCompliant for hive3+'),
}

model Partition {
  createTime?: int32(name='CreateTime', description='CreateTime'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  lastAccessTime?: int32(name='LastAccessTime', description='LastAccessTime'),
  lastAnalyzedTime?: int32(name='LastAnalyzedTime', description='LastAnalyzedTime'),
  parameters?: map[string]string(name='Parameters', description='Parameters'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
  sd?: StorageDescriptor(name='Sd'),
  tableName?: string(name='TableName', description='TableName'),
  values?: [ string ](name='Values', description='Values'),
}

model ResourceUri {
  resourceType?: string(name='ResourceType', description='ResourceType'),
  uri?: string(name='Uri', description='Uri'),
}

model Table {
  cascade?: boolean(name='Cascade', description='Cascade'),
  createTime?: int32(name='CreateTime', description='CreateTime'),
  createdBy?: string(name='CreatedBy', description='CreatedBy'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  lastAccessTime?: int32(name='LastAccessTime', description='LastAccessTime'),
  lastAnalyzedTime?: int32(name='LastAnalyzedTime', description='LastAnalyzedTime'),
  owner?: string(name='Owner', description='Owner'),
  ownerType?: string(name='OwnerType', description='OwnerType'),
  parameters?: map[string]string(name='Parameters'),
  partitionKeys?: [
FieldSchema
](name='PartitionKeys'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
  retention?: int32(name='Retention', description='Retention'),
  rewriteEnabled?: boolean(name='RewriteEnabled', description='RewriteEnabled'),
  sd?: StorageDescriptor(name='Sd'),
  tableName?: string(name='TableName', description='TableName'),
  tableType?: string(name='TableType', description='TableType'),
  temporary?: boolean(name='Temporary', description='Temporary'),
  updateTime?: int32(name='UpdateTime', description='UpdateTime'),
  viewExpandedText?: string(name='ViewExpandedText', description='ViewExpandedText'),
  viewOriginalText?: string(name='ViewOriginalText', description='ViewOriginalText'),
}

model PrivilegeGrantInfo {
  createTime?: int32(name='CreateTime', description='createTime'),
  grantOption?: boolean(name='GrantOption', description='grantOption'),
  grantor?: string(name='Grantor', description='grantor'),
  grantorType?: string(name='GrantorType', description='grantorType'),
  privilege?: string(name='Privilege', description='privilege'),
}

model PrincipalPrivilegeSet {
  groupPrivileges?: map[string][
    PrivilegeGrantInfo
  ](name='GroupPrivileges'),
  rolePrivileges?: map[string][
    PrivilegeGrantInfo
  ](name='RolePrivileges'),
  userPrivileges?: map[string][
    PrivilegeGrantInfo
  ](name='UserPrivileges'),
}

model PartitionError {
  errorDetail?: ErrorDetail(name='ErrorDetail'),
  partitionValues?: [ string ](name='PartitionValues'),
}

model LockStatus {
  lockId?: long(name='LockId', description='LockId'),
  lockState?: string(name='LockState', description='ACQUIRED/NOT_ACQUIRED'),
}

model SerDeInfo {
  name?: string(name='Name', description='Name'),
  parameters?: map[string]string(name='Parameters'),
  serializationLib?: string(name='SerializationLib', description='SerializationLib'),
}

model Catalog {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  createTime?: int32(name='CreateTime', description='CreateTime'),
}

model TablePartitionColumnStatisticsRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  columnNames?: [ string ](name='ColumnNames'),
  databaseName?: string(name='DatabaseName', description='DatabaseName of this catalog, required'),
  partitionNames?: [ string ](name='PartitionNames'),
  tableName?: string(name='TableName', description='TableName of this catalog, required'),
}

model TableVersion {
  table?: Table(name='Table'),
  versionId?: int32(name='VersionId', description='table version'),
}

model DatabaseInput {
  description?: string(name='Description', description='description'),
  locationUri?: string(name='LocationUri', description='locationUri'),
  name?: string(name='Name', description='name'),
  ownerName?: string(name='OwnerName', description='ownerName'),
  ownerType?: string(name='OwnerType', description='ownerType'),
  parameters?: map[string]string(name='Parameters'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
}

model FunctionInput {
  className?: string(name='ClassName', description='ClassName'),
  functionName?: string(name='FunctionName', description='FunctionName'),
  functionType?: string(name='FunctionType', description='FunctionType'),
  ownerName?: string(name='OwnerName', description='OwnerName'),
  ownerType?: string(name='OwnerType', description='OwnerType'),
  resourceUri?: [
    ResourceUri
  ](name='ResourceUri', description='ResourceUri'),
}

model BatchCreatePartitionsRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  ifNotExists?: boolean(name='IfNotExists', description='IfNotExists'),
  needResult?: boolean(name='NeedResult', description='NeedResult'),
  partitionInputs?: [
    PartitionInput
  ](name='PartitionInputs', description='PartitionInputs'),
  tableName?: string(name='TableName', description='TableName'),
}

model BatchCreatePartitionsResponseBody = {
  code?: string(name='Code', description='响应代码'),
  message?: string(name='Message', description='响应消息'),
  partitionErrors?: [
    PartitionError
  ](name='PartitionErrors', description='分区出错信息'),
  partitions?: [
    Partition
  ](name='Partitions', description='Partitions'),
  requestId?: string(name='RequestId', description='请求ID'),
  success?: boolean(name='Success', description='是否成功'),
}

model BatchCreatePartitionsResponse = {
  headers: map[string]string(name='headers'),
  body: BatchCreatePartitionsResponseBody(name='body'),
}

async function batchCreatePartitions(request: BatchCreatePartitionsRequest): BatchCreatePartitionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchCreatePartitionsWithOptions(request, headers, runtime);
}

async function batchCreatePartitionsWithOptions(request: BatchCreatePartitionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchCreatePartitionsResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body.DatabaseName = request.databaseName;
  }
  if (!Util.isUnset(request.ifNotExists)) {
    body.IfNotExists = request.ifNotExists;
  }
  if (!Util.isUnset(request.needResult)) {
    body.NeedResult = request.needResult;
  }
  if (!Util.isUnset(request.partitionInputs)) {
    body.PartitionInputs = request.partitionInputs;
  }
  if (!Util.isUnset(request.tableName)) {
    body.TableName = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('BatchCreatePartitions', '2020-07-10', 'HTTPS', 'POST', 'AK', `/api/metastore/catalogs/databases/tables/partitions/batchcreate`, 'json', req, runtime);
}

model ListPartitionNamesRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  pageSize?: int32(name='PageSize', description='PageSize'),
  partialPartValues?: [ string ](name='PartialPartValues'),
  tableName?: string(name='TableName', description='TableName'),
}

model ListPartitionNamesResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  partitionNames?: [ string ](name='PartitionNames', description='PartitionNames'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model ListPartitionNamesResponse = {
  headers: map[string]string(name='headers'),
  body: ListPartitionNamesResponseBody(name='body'),
}

async function listPartitionNames(request: ListPartitionNamesRequest): ListPartitionNamesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPartitionNamesWithOptions(request, headers, runtime);
}

async function listPartitionNamesWithOptions(request: ListPartitionNamesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPartitionNamesResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body.DatabaseName = request.databaseName;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    body.NextPageToken = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    body.PageSize = request.pageSize;
  }
  if (!Util.isUnset(request.partialPartValues)) {
    body.PartialPartValues = request.partialPartValues;
  }
  if (!Util.isUnset(request.tableName)) {
    body.TableName = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('ListPartitionNames', '2020-07-10', 'HTTPS', 'POST', 'AK', `/api/metastore/catalogs/databases/tables/partitions/names`, 'json', req, runtime);
}

model RenamePartitionRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  partitionInput?: PartitionInput(name='PartitionInput'),
  partitionValues?: [ string ](name='PartitionValues'),
  tableName?: string(name='TableName', description='TableName'),
}

model RenamePartitionResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model RenamePartitionResponse = {
  headers: map[string]string(name='headers'),
  body: RenamePartitionResponseBody(name='body'),
}

async function renamePartition(request: RenamePartitionRequest): RenamePartitionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return renamePartitionWithOptions(request, headers, runtime);
}

async function renamePartitionWithOptions(request: RenamePartitionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RenamePartitionResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body.DatabaseName = request.databaseName;
  }
  if (!Util.isUnset(request.partitionInput)) {
    body.PartitionInput = request.partitionInput;
  }
  if (!Util.isUnset(request.partitionValues)) {
    body.PartitionValues = request.partitionValues;
  }
  if (!Util.isUnset(request.tableName)) {
    body.TableName = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('RenamePartition', '2020-07-10', 'HTTPS', 'POST', 'AK', `/api/metastore/catalogs/databases/tables/partitions/rename`, 'json', req, runtime);
}

model CreateFunctionRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  functionInput?: FunctionInput(name='FunctionInput'),
}

model CreateFunctionResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model CreateFunctionResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFunctionResponseBody(name='body'),
}

async function createFunction(request: CreateFunctionRequest): CreateFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createFunctionWithOptions(request, headers, runtime);
}

async function createFunctionWithOptions(request: CreateFunctionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateFunctionResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body.DatabaseName = request.databaseName;
  }
  if (!Util.isUnset(request.functionInput)) {
    body.FunctionInput = request.functionInput;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('CreateFunction', '2020-07-10', 'HTTPS', 'POST', 'AK', `/api/metastore/catalogs/databases/functions`, 'json', req, runtime);
}

model CreateTableRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  tableInput?: TableInput(name='TableInput'),
}

model CreateTableResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model CreateTableResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTableResponseBody(name='body'),
}

async function createTable(request: CreateTableRequest): CreateTableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createTableWithOptions(request, headers, runtime);
}

async function createTableWithOptions(request: CreateTableRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateTableResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body.DatabaseName = request.databaseName;
  }
  if (!Util.isUnset(request.tableInput)) {
    body.TableInput = request.tableInput;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('CreateTable', '2020-07-10', 'HTTPS', 'POST', 'AK', `/api/metastore/catalogs/databases/tables`, 'json', req, runtime);
}

model BatchCreateTablesRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  ifNotExists?: boolean(name='IfNotExists', description='IfNotExists'),
  tableInputs?: [
    TableInput
  ](name='TableInputs', description='TableInputs'),
}

model BatchCreateTablesResponseBody = {
  code?: string(name='Code', description='响应代码'),
  message?: string(name='Message', description='响应消息'),
  requestId?: string(name='RequestId', description='请求ID'),
  success?: boolean(name='Success', description='是否成功'),
  tableErrors?: [
    TableError
  ](name='TableErrors', description='表出错信息'),
}

model BatchCreateTablesResponse = {
  headers: map[string]string(name='headers'),
  body: BatchCreateTablesResponseBody(name='body'),
}

async function batchCreateTables(request: BatchCreateTablesRequest): BatchCreateTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchCreateTablesWithOptions(request, headers, runtime);
}

async function batchCreateTablesWithOptions(request: BatchCreateTablesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchCreateTablesResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body.DatabaseName = request.databaseName;
  }
  if (!Util.isUnset(request.ifNotExists)) {
    body.IfNotExists = request.ifNotExists;
  }
  if (!Util.isUnset(request.tableInputs)) {
    body.TableInputs = request.tableInputs;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('BatchCreateTables', '2020-07-10', 'HTTPS', 'POST', 'AK', `/api/metastore/catalogs/databases/tables/batchcreate`, 'json', req, runtime);
}

model UpdateTableColumnStatisticsRequest {
  updateTablePartitionColumnStatisticsRequest?: UpdateTablePartitionColumnStatisticsRequest(name='UpdateTablePartitionColumnStatisticsRequest'),
}

model UpdateTableColumnStatisticsResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model UpdateTableColumnStatisticsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTableColumnStatisticsResponseBody(name='body'),
}

async function updateTableColumnStatistics(request: UpdateTableColumnStatisticsRequest): UpdateTableColumnStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateTableColumnStatisticsWithOptions(request, headers, runtime);
}

async function updateTableColumnStatisticsWithOptions(request: UpdateTableColumnStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateTableColumnStatisticsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.updateTablePartitionColumnStatisticsRequest),
  };
  return doROARequest('UpdateTableColumnStatistics', '2020-07-10', 'HTTPS', 'PUT', 'AK', `/api/metastore/catalogs/databases/tables/columnstatistics`, 'json', req, runtime);
}

model ListTableNamesRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  tableNamePattern?: string(name='TableNamePattern', description='TableNamePattern'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  pageSize?: int32(name='PageSize', description='PageSize'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  tableType?: string(name='TableType', description='TableType filter'),
}

model ListTableNamesResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
  tableNames?: [ string ](name='TableNames', description='TableNames'),
}

model ListTableNamesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTableNamesResponseBody(name='body'),
}

async function listTableNames(request: ListTableNamesRequest): ListTableNamesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTableNamesWithOptions(request, headers, runtime);
}

async function listTableNamesWithOptions(request: ListTableNamesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTableNamesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    query.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.tableNamePattern)) {
    query.TableNamePattern = request.tableNamePattern;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query.NextPageToken = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }
  if (!Util.isUnset(request.databaseName)) {
    query.DatabaseName = request.databaseName;
  }
  if (!Util.isUnset(request.tableType)) {
    query.TableType = request.tableType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListTableNames', '2020-07-10', 'HTTPS', 'GET', 'AK', `/api/metastore/catalogs/databases/tables/names`, 'json', req, runtime);
}

model UpdateDatabaseRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseInput?: DatabaseInput(name='DatabaseInput'),
  name?: string(name='Name', description='Name'),
}

model UpdateDatabaseResponseBody = {
  code?: string(name='Code', description='Response Code'),
  message?: string(name='Message', description='Response Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Request is success or not'),
}

model UpdateDatabaseResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDatabaseResponseBody(name='body'),
}

async function updateDatabase(request: UpdateDatabaseRequest): UpdateDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDatabaseWithOptions(request, headers, runtime);
}

async function updateDatabaseWithOptions(request: UpdateDatabaseRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateDatabaseResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.databaseInput)) {
    body.DatabaseInput = request.databaseInput;
  }
  if (!Util.isUnset(request.name)) {
    body.Name = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('UpdateDatabase', '2020-07-10', 'HTTPS', 'PUT', 'AK', `/api/metastore/catalogs/databases`, 'json', req, runtime);
}

model BatchGetPartitionsRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  partitionValueList?: [ 
{
values?: [ string ](name='Values'),
}
](name='PartitionValueList'),
  tableName?: string(name='TableName', description='TableName'),
}

model BatchGetPartitionsResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  partitionErrors?: [
    PartitionError
  ](name='PartitionErrors', description='PartitionErrors'),
  partitions?: [
    Partition
  ](name='Partitions', description='Partitions'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model BatchGetPartitionsResponse = {
  headers: map[string]string(name='headers'),
  body: BatchGetPartitionsResponseBody(name='body'),
}

async function batchGetPartitions(request: BatchGetPartitionsRequest): BatchGetPartitionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchGetPartitionsWithOptions(request, headers, runtime);
}

async function batchGetPartitionsWithOptions(request: BatchGetPartitionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchGetPartitionsResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body.DatabaseName = request.databaseName;
  }
  if (!Util.isUnset(request.partitionValueList)) {
    body.PartitionValueList = request.partitionValueList;
  }
  if (!Util.isUnset(request.tableName)) {
    body.TableName = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('BatchGetPartitions', '2020-07-10', 'HTTPS', 'POST', 'AK', `/api/metastore/catalogs/databases/tables/partitions/batchget`, 'json', req, runtime);
}

model ListDatabasesRequest {
  catalogId?: string(name='CatalogId', description='catalogId'),
  namePattern?: string(name='NamePattern', description='namePattern'),
  nextPageToken?: string(name='NextPageToken', description='namePattern'),
  pageSize?: int32(name='PageSize', description='pageSize'),
}

model ListDatabasesResponseBody = {
  code?: string(name='Code', description='Code'),
  databases?: [
    Database
  ](name='Databases', description='Database List'),
  message?: string(name='Message', description='Message'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model ListDatabasesResponse = {
  headers: map[string]string(name='headers'),
  body: ListDatabasesResponseBody(name='body'),
}

async function listDatabases(request: ListDatabasesRequest): ListDatabasesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDatabasesWithOptions(request, headers, runtime);
}

async function listDatabasesWithOptions(request: ListDatabasesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDatabasesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    query.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.namePattern)) {
    query.NamePattern = request.namePattern;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query.NextPageToken = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListDatabases', '2020-07-10', 'HTTPS', 'GET', 'AK', `/api/metastore/catalogs/databases/list`, 'json', req, runtime);
}

model GetTableColumnStatisticsRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  tableName?: string(name='TableName', description='TableName'),
  columnNames?: [ string ](name='ColumnNames'),
}

model GetTableColumnStatisticsShrinkRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  tableName?: string(name='TableName', description='TableName'),
  columnNamesShrink?: string(name='ColumnNames'),
}

model GetTableColumnStatisticsResponseBody = {
  code?: string(name='Code', description='Code'),
  columnStatisticsObjList?: [
    ColumnStatisticsObj
  ](name='ColumnStatisticsObjList', description='ColumnStatisticsObjList'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model GetTableColumnStatisticsResponse = {
  headers: map[string]string(name='headers'),
  body: GetTableColumnStatisticsResponseBody(name='body'),
}

async function getTableColumnStatistics(request: GetTableColumnStatisticsRequest): GetTableColumnStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTableColumnStatisticsWithOptions(request, headers, runtime);
}

async function getTableColumnStatisticsWithOptions(tmpReq: GetTableColumnStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetTableColumnStatisticsResponse {
  Util.validateModel(tmpReq);
  var request = new GetTableColumnStatisticsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.columnNames)) {
    request.columnNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.columnNames, 'ColumnNames', 'json');
  }
  var query : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    query.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query.DatabaseName = request.databaseName;
  }
  if (!Util.isUnset(request.tableName)) {
    query.TableName = request.tableName;
  }
  if (!Util.isUnset(request.columnNamesShrink)) {
    query.ColumnNames = request.columnNamesShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetTableColumnStatistics', '2020-07-10', 'HTTPS', 'GET', 'AK', `/api/metastore/catalogs/databases/tables/columnstatistics`, 'json', req, runtime);
}

model BatchGetPartitionColumnStatisticsRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  tableName?: string(name='TableName', description='TableName'),
  partitionNames?: [ string ](name='PartitionNames'),
  columnNames?: [ string ](name='ColumnNames'),
}

model BatchGetPartitionColumnStatisticsResponseBody = {
  code?: string(name='Code', description='Code'),
  partitionStatisticsMap?: map[string][
    ColumnStatisticsObj
  ](name='PartitionStatisticsMap', description='PartitionStatisticsMap'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model BatchGetPartitionColumnStatisticsResponse = {
  headers: map[string]string(name='headers'),
  body: BatchGetPartitionColumnStatisticsResponseBody(name='body'),
}

async function batchGetPartitionColumnStatistics(request: BatchGetPartitionColumnStatisticsRequest): BatchGetPartitionColumnStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchGetPartitionColumnStatisticsWithOptions(request, headers, runtime);
}

async function batchGetPartitionColumnStatisticsWithOptions(request: BatchGetPartitionColumnStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchGetPartitionColumnStatisticsResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body.DatabaseName = request.databaseName;
  }
  if (!Util.isUnset(request.tableName)) {
    body.TableName = request.tableName;
  }
  if (!Util.isUnset(request.partitionNames)) {
    body.PartitionNames = request.partitionNames;
  }
  if (!Util.isUnset(request.columnNames)) {
    body.ColumnNames = request.columnNames;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('BatchGetPartitionColumnStatistics', '2020-07-10', 'HTTPS', 'POST', 'AK', `/api/metastore/catalogs/databases/tables/partitions/columnstatistics/batchget`, 'json', req, runtime);
}

model ListFunctionNamesRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  functionNamePattern?: string(name='FunctionNamePattern', description='FunctionNamePattern'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  pageSize?: int32(name='PageSize', description='PageSize'),
}

model ListFunctionNamesResponseBody = {
  code?: string(name='Code', description='Code'),
  functionNames?: [ string ](name='FunctionNames', description='FunctionNames'),
  message?: string(name='Message', description='Message'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model ListFunctionNamesResponse = {
  headers: map[string]string(name='headers'),
  body: ListFunctionNamesResponseBody(name='body'),
}

async function listFunctionNames(request: ListFunctionNamesRequest): ListFunctionNamesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFunctionNamesWithOptions(request, headers, runtime);
}

async function listFunctionNamesWithOptions(request: ListFunctionNamesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListFunctionNamesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    query.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query.DatabaseName = request.databaseName;
  }
  if (!Util.isUnset(request.functionNamePattern)) {
    query.FunctionNamePattern = request.functionNamePattern;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query.NextPageToken = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListFunctionNames', '2020-07-10', 'HTTPS', 'GET', 'AK', `/api/metastore/catalogs/databases/functions/names`, 'json', req, runtime);
}

model ListPartitionsByFilterRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  filter?: string(name='Filter', description='Filter'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  pageSize?: int32(name='PageSize', description='PageSize'),
  tableName?: string(name='TableName', description='TableName'),
}

model ListPartitionsByFilterResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  partitions?: [
    Partition
  ](name='Partitions', description='Partitions'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model ListPartitionsByFilterResponse = {
  headers: map[string]string(name='headers'),
  body: ListPartitionsByFilterResponseBody(name='body'),
}

async function listPartitionsByFilter(request: ListPartitionsByFilterRequest): ListPartitionsByFilterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPartitionsByFilterWithOptions(request, headers, runtime);
}

async function listPartitionsByFilterWithOptions(request: ListPartitionsByFilterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPartitionsByFilterResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body.DatabaseName = request.databaseName;
  }
  if (!Util.isUnset(request.filter)) {
    body.Filter = request.filter;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    body.NextPageToken = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    body.PageSize = request.pageSize;
  }
  if (!Util.isUnset(request.tableName)) {
    body.TableName = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('ListPartitionsByFilter', '2020-07-10', 'HTTPS', 'POST', 'AK', `/api/metastore/catalogs/databases/tables/partitions/listbyfilter`, 'json', req, runtime);
}

model UpdateFunctionRequest {
  catalogId?: string(name='CatalogId'),
  databaseName?: string(name='DatabaseName'),
  functionInput?: FunctionInput(name='FunctionInput'),
  functionName?: string(name='FunctionName'),
}

model UpdateFunctionResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model UpdateFunctionResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateFunctionResponseBody(name='body'),
}

async function updateFunction(request: UpdateFunctionRequest): UpdateFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateFunctionWithOptions(request, headers, runtime);
}

async function updateFunctionWithOptions(request: UpdateFunctionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateFunctionResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body.DatabaseName = request.databaseName;
  }
  if (!Util.isUnset(request.functionInput)) {
    body.FunctionInput = request.functionInput;
  }
  if (!Util.isUnset(request.functionName)) {
    body.FunctionName = request.functionName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('UpdateFunction', '2020-07-10', 'HTTPS', 'PUT', 'AK', `/api/metastore/catalogs/databases/functions`, 'json', req, runtime);
}

model GetPartitionColumnStatisticsRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  tableName?: string(name='TableName', description='TableName'),
  partitionNames?: [ string ](name='PartitionNames'),
  columnNames?: [ string ](name='ColumnNames'),
}

model GetPartitionColumnStatisticsShrinkRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  tableName?: string(name='TableName', description='TableName'),
  partitionNamesShrink?: string(name='PartitionNames'),
  columnNamesShrink?: string(name='ColumnNames'),
}

model GetPartitionColumnStatisticsResponseBody = {
  code?: string(name='Code', description='Code'),
  partitionStatisticsMap?: map[string][
    ColumnStatisticsObj
  ](name='PartitionStatisticsMap', description='PartitionStatisticsMap'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model GetPartitionColumnStatisticsResponse = {
  headers: map[string]string(name='headers'),
  body: GetPartitionColumnStatisticsResponseBody(name='body'),
}

async function getPartitionColumnStatistics(request: GetPartitionColumnStatisticsRequest): GetPartitionColumnStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPartitionColumnStatisticsWithOptions(request, headers, runtime);
}

async function getPartitionColumnStatisticsWithOptions(tmpReq: GetPartitionColumnStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetPartitionColumnStatisticsResponse {
  Util.validateModel(tmpReq);
  var request = new GetPartitionColumnStatisticsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.partitionNames)) {
    request.partitionNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.partitionNames, 'PartitionNames', 'json');
  }
  if (!Util.isUnset(tmpReq.columnNames)) {
    request.columnNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.columnNames, 'ColumnNames', 'json');
  }
  var query : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    query.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query.DatabaseName = request.databaseName;
  }
  if (!Util.isUnset(request.tableName)) {
    query.TableName = request.tableName;
  }
  if (!Util.isUnset(request.partitionNamesShrink)) {
    query.PartitionNames = request.partitionNamesShrink;
  }
  if (!Util.isUnset(request.columnNamesShrink)) {
    query.ColumnNames = request.columnNamesShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetPartitionColumnStatistics', '2020-07-10', 'HTTPS', 'GET', 'AK', `/api/metastore/catalogs/databases/tables/partitions/columnstatistics`, 'json', req, runtime);
}

model BatchUpdateTablesRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  tableInputs?: [
    TableInput
  ](name='TableInputs', description='TableInputs'),
}

model BatchUpdateTablesResponseBody = {
  code?: string(name='Code', description='响应代码'),
  message?: string(name='Message', description='响应消息'),
  requestId?: string(name='RequestId', description='请求ID'),
  success?: boolean(name='Success', description='是否成功'),
  tableErrors?: [
    TableError
  ](name='TableErrors', description='表出错信息'),
}

model BatchUpdateTablesResponse = {
  headers: map[string]string(name='headers'),
  body: BatchUpdateTablesResponseBody(name='body'),
}

async function batchUpdateTables(request: BatchUpdateTablesRequest): BatchUpdateTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchUpdateTablesWithOptions(request, headers, runtime);
}

async function batchUpdateTablesWithOptions(request: BatchUpdateTablesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchUpdateTablesResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body.DatabaseName = request.databaseName;
  }
  if (!Util.isUnset(request.tableInputs)) {
    body.TableInputs = request.tableInputs;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('BatchUpdateTables', '2020-07-10', 'HTTPS', 'POST', 'AK', `/api/metastore/catalogs/databases/tables/batchupdate`, 'json', req, runtime);
}

model DeleteTableVersionRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  tableName?: string(name='TableName', description='TableName'),
  versionId?: int32(name='VersionId', description='table version id'),
}

model DeleteTableVersionResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model DeleteTableVersionResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTableVersionResponseBody(name='body'),
}

async function deleteTableVersion(request: DeleteTableVersionRequest): DeleteTableVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteTableVersionWithOptions(request, headers, runtime);
}

async function deleteTableVersionWithOptions(request: DeleteTableVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteTableVersionResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    query.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query.DatabaseName = request.databaseName;
  }
  if (!Util.isUnset(request.tableName)) {
    query.TableName = request.tableName;
  }
  if (!Util.isUnset(request.versionId)) {
    query.VersionId = request.versionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteTableVersion', '2020-07-10', 'HTTPS', 'DELETE', 'AK', `/api/metastore/catalogs/databases/tables/versions`, 'json', req, runtime);
}

model UpdatePartitionColumnStatisticsRequest {
  updateTablePartitionColumnStatisticsRequest?: UpdateTablePartitionColumnStatisticsRequest(name='UpdateTablePartitionColumnStatisticsRequest'),
}

model UpdatePartitionColumnStatisticsResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model UpdatePartitionColumnStatisticsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdatePartitionColumnStatisticsResponseBody(name='body'),
}

async function updatePartitionColumnStatistics(request: UpdatePartitionColumnStatisticsRequest): UpdatePartitionColumnStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePartitionColumnStatisticsWithOptions(request, headers, runtime);
}

async function updatePartitionColumnStatisticsWithOptions(request: UpdatePartitionColumnStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePartitionColumnStatisticsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.updateTablePartitionColumnStatisticsRequest),
  };
  return doROARequest('UpdatePartitionColumnStatistics', '2020-07-10', 'HTTPS', 'PUT', 'AK', `/api/metastore/catalogs/databases/tables/partitions/columnstatistics`, 'json', req, runtime);
}

model CreatePartitionRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  ifNotExists?: boolean(name='IfNotExists', description='IfNotExists'),
  needResult?: boolean(name='NeedResult', description='NeedResult'),
  partitionInput?: PartitionInput(name='PartitionInput'),
  tableName?: string(name='TableName', description='TableName'),
}

model CreatePartitionResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  partition?: Partition(name='Partition'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model CreatePartitionResponse = {
  headers: map[string]string(name='headers'),
  body: CreatePartitionResponseBody(name='body'),
}

async function createPartition(request: CreatePartitionRequest): CreatePartitionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPartitionWithOptions(request, headers, runtime);
}

async function createPartitionWithOptions(request: CreatePartitionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePartitionResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body.DatabaseName = request.databaseName;
  }
  if (!Util.isUnset(request.ifNotExists)) {
    body.IfNotExists = request.ifNotExists;
  }
  if (!Util.isUnset(request.needResult)) {
    body.NeedResult = request.needResult;
  }
  if (!Util.isUnset(request.partitionInput)) {
    body.PartitionInput = request.partitionInput;
  }
  if (!Util.isUnset(request.tableName)) {
    body.TableName = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('CreatePartition', '2020-07-10', 'HTTPS', 'POST', 'AK', `/api/metastore/catalogs/databases/tables/partitions`, 'json', req, runtime);
}

model ListPartitionsRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  pageSize?: int32(name='PageSize', description='PageSize'),
  partialPartValues?: [ string ](name='PartialPartValues'),
  tableName?: string(name='TableName', description='TableName'),
}

model ListPartitionsResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  partitions?: [
    Partition
  ](name='Partitions', description='Partitions'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model ListPartitionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListPartitionsResponseBody(name='body'),
}

async function listPartitions(request: ListPartitionsRequest): ListPartitionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPartitionsWithOptions(request, headers, runtime);
}

async function listPartitionsWithOptions(request: ListPartitionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPartitionsResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body.DatabaseName = request.databaseName;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    body.NextPageToken = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    body.PageSize = request.pageSize;
  }
  if (!Util.isUnset(request.partialPartValues)) {
    body.PartialPartValues = request.partialPartValues;
  }
  if (!Util.isUnset(request.tableName)) {
    body.TableName = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('ListPartitions', '2020-07-10', 'HTTPS', 'POST', 'AK', `/api/metastore/catalogs/databases/tables/partitions/list`, 'json', req, runtime);
}

model CreateDatabaseRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseInput?: DatabaseInput(name='DatabaseInput'),
}

model CreateDatabaseResponseBody = {
  code?: string(name='Code', description='Response Code'),
  message?: string(name='Message', description='Response Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model CreateDatabaseResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDatabaseResponseBody(name='body'),
}

async function createDatabase(request: CreateDatabaseRequest): CreateDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createDatabaseWithOptions(request, headers, runtime);
}

async function createDatabaseWithOptions(request: CreateDatabaseRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateDatabaseResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.databaseInput)) {
    body.DatabaseInput = request.databaseInput;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('CreateDatabase', '2020-07-10', 'HTTPS', 'POST', 'AK', `/api/metastore/catalogs/databases`, 'json', req, runtime);
}

model DeleteTableColumnStatisticsRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  tableName?: string(name='TableName', description='TableName'),
  columnNames?: [ string ](name='ColumnNames'),
}

model DeleteTableColumnStatisticsShrinkRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  tableName?: string(name='TableName', description='TableName'),
  columnNamesShrink?: string(name='ColumnNames'),
}

model DeleteTableColumnStatisticsResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model DeleteTableColumnStatisticsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTableColumnStatisticsResponseBody(name='body'),
}

async function deleteTableColumnStatistics(request: DeleteTableColumnStatisticsRequest): DeleteTableColumnStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteTableColumnStatisticsWithOptions(request, headers, runtime);
}

async function deleteTableColumnStatisticsWithOptions(tmpReq: DeleteTableColumnStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteTableColumnStatisticsResponse {
  Util.validateModel(tmpReq);
  var request = new DeleteTableColumnStatisticsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.columnNames)) {
    request.columnNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.columnNames, 'ColumnNames', 'json');
  }
  var query : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    query.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query.DatabaseName = request.databaseName;
  }
  if (!Util.isUnset(request.tableName)) {
    query.TableName = request.tableName;
  }
  if (!Util.isUnset(request.columnNamesShrink)) {
    query.ColumnNames = request.columnNamesShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteTableColumnStatistics', '2020-07-10', 'HTTPS', 'DELETE', 'AK', `/api/metastore/catalogs/databases/tables/columnstatistics`, 'json', req, runtime);
}

model ListTableVersionsRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  tableName?: string(name='TableName', description='TableName'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  pageSize?: int32(name='PageSize', description='max result of this query'),
}

model ListTableVersionsResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
  tableVersions?: [
    TableVersion
  ](name='TableVersions', description='table versions'),
}

model ListTableVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListTableVersionsResponseBody(name='body'),
}

async function listTableVersions(request: ListTableVersionsRequest): ListTableVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTableVersionsWithOptions(request, headers, runtime);
}

async function listTableVersionsWithOptions(request: ListTableVersionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTableVersionsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    query.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query.DatabaseName = request.databaseName;
  }
  if (!Util.isUnset(request.tableName)) {
    query.TableName = request.tableName;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query.NextPageToken = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListTableVersions', '2020-07-10', 'HTTPS', 'GET', 'AK', `/api/metastore/catalogs/databases/tables/versions/list`, 'json', req, runtime);
}

model DeletePartitionColumnStatisticsRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  tableName?: string(name='TableName', description='TableName'),
  partitionNames?: [ string ](name='PartitionNames'),
  columnNames?: [ string ](name='ColumnNames'),
}

model DeletePartitionColumnStatisticsShrinkRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  tableName?: string(name='TableName', description='TableName'),
  partitionNamesShrink?: string(name='PartitionNames'),
  columnNamesShrink?: string(name='ColumnNames'),
}

model DeletePartitionColumnStatisticsResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model DeletePartitionColumnStatisticsResponse = {
  headers: map[string]string(name='headers'),
  body: DeletePartitionColumnStatisticsResponseBody(name='body'),
}

async function deletePartitionColumnStatistics(request: DeletePartitionColumnStatisticsRequest): DeletePartitionColumnStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deletePartitionColumnStatisticsWithOptions(request, headers, runtime);
}

async function deletePartitionColumnStatisticsWithOptions(tmpReq: DeletePartitionColumnStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeletePartitionColumnStatisticsResponse {
  Util.validateModel(tmpReq);
  var request = new DeletePartitionColumnStatisticsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.partitionNames)) {
    request.partitionNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.partitionNames, 'PartitionNames', 'json');
  }
  if (!Util.isUnset(tmpReq.columnNames)) {
    request.columnNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.columnNames, 'ColumnNames', 'json');
  }
  var query : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    query.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query.DatabaseName = request.databaseName;
  }
  if (!Util.isUnset(request.tableName)) {
    query.TableName = request.tableName;
  }
  if (!Util.isUnset(request.partitionNamesShrink)) {
    query.PartitionNames = request.partitionNamesShrink;
  }
  if (!Util.isUnset(request.columnNamesShrink)) {
    query.ColumnNames = request.columnNamesShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeletePartitionColumnStatistics', '2020-07-10', 'HTTPS', 'DELETE', 'AK', `/api/metastore/catalogs/databases/tables/partitions/columnstatistics`, 'json', req, runtime);
}

model BatchUpdatePartitionsRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  partitionInputs?: [
    PartitionInput
  ](name='PartitionInputs', description='PartitionInputs'),
  tableName?: string(name='TableName', description='TableName'),
}

model BatchUpdatePartitionsResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  partitionErrors?: [
    PartitionError
  ](name='PartitionErrors', description='PartitionErrors'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model BatchUpdatePartitionsResponse = {
  headers: map[string]string(name='headers'),
  body: BatchUpdatePartitionsResponseBody(name='body'),
}

async function batchUpdatePartitions(request: BatchUpdatePartitionsRequest): BatchUpdatePartitionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchUpdatePartitionsWithOptions(request, headers, runtime);
}

async function batchUpdatePartitionsWithOptions(request: BatchUpdatePartitionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchUpdatePartitionsResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body.DatabaseName = request.databaseName;
  }
  if (!Util.isUnset(request.partitionInputs)) {
    body.PartitionInputs = request.partitionInputs;
  }
  if (!Util.isUnset(request.tableName)) {
    body.TableName = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('BatchUpdatePartitions', '2020-07-10', 'HTTPS', 'PUT', 'AK', `/api/metastore/catalogs/databases/tables/partitions/batchupdate`, 'json', req, runtime);
}

model GetPartitionRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  partitionValues?: [ string ](name='PartitionValues'),
  tableName?: string(name='TableName', description='TableName'),
}

model GetPartitionResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  partition?: Partition(name='Partition'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model GetPartitionResponse = {
  headers: map[string]string(name='headers'),
  body: GetPartitionResponseBody(name='body'),
}

async function getPartition(request: GetPartitionRequest): GetPartitionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPartitionWithOptions(request, headers, runtime);
}

async function getPartitionWithOptions(request: GetPartitionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetPartitionResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body.DatabaseName = request.databaseName;
  }
  if (!Util.isUnset(request.partitionValues)) {
    body.PartitionValues = request.partitionValues;
  }
  if (!Util.isUnset(request.tableName)) {
    body.TableName = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('GetPartition', '2020-07-10', 'HTTPS', 'POST', 'AK', `/api/metastore/catalogs/databases/tables/partitions/get`, 'json', req, runtime);
}

model BatchDeleteTableVersionsRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  tableName?: string(name='TableName', description='TableName'),
  versionIds?: [ int32 ](name='VersionIds', description='Table versionIds'),
}

model BatchDeleteTableVersionsResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model BatchDeleteTableVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: BatchDeleteTableVersionsResponseBody(name='body'),
}

async function batchDeleteTableVersions(request: BatchDeleteTableVersionsRequest): BatchDeleteTableVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchDeleteTableVersionsWithOptions(request, headers, runtime);
}

async function batchDeleteTableVersionsWithOptions(request: BatchDeleteTableVersionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchDeleteTableVersionsResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body.DatabaseName = request.databaseName;
  }
  if (!Util.isUnset(request.tableName)) {
    body.TableName = request.tableName;
  }
  if (!Util.isUnset(request.versionIds)) {
    body.VersionIds = request.versionIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('BatchDeleteTableVersions', '2020-07-10', 'HTTPS', 'POST', 'AK', `/api/metastore/catalogs/databases/tables/versions/batchdelete`, 'json', req, runtime);
}

model BatchDeletePartitionsRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  ifExists?: boolean(name='IfExists', description='IfExists'),
  partitionValueList?: [ 
{
values?: [ string ](name='Values'),
}
](name='PartitionValueList'),
  tableName?: string(name='TableName', description='TableName'),
}

model BatchDeletePartitionsResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  partitionErrors?: [
    PartitionError
  ](name='PartitionErrors', description='PartitionErrors'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model BatchDeletePartitionsResponse = {
  headers: map[string]string(name='headers'),
  body: BatchDeletePartitionsResponseBody(name='body'),
}

async function batchDeletePartitions(request: BatchDeletePartitionsRequest): BatchDeletePartitionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchDeletePartitionsWithOptions(request, headers, runtime);
}

async function batchDeletePartitionsWithOptions(request: BatchDeletePartitionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchDeletePartitionsResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body.DatabaseName = request.databaseName;
  }
  if (!Util.isUnset(request.ifExists)) {
    body.IfExists = request.ifExists;
  }
  if (!Util.isUnset(request.partitionValueList)) {
    body.PartitionValueList = request.partitionValueList;
  }
  if (!Util.isUnset(request.tableName)) {
    body.TableName = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('BatchDeletePartitions', '2020-07-10', 'HTTPS', 'POST', 'AK', `/api/metastore/catalogs/databases/tables/partitions/batchdelete`, 'json', req, runtime);
}

model ListCatalogsRequest {
  idPattern?: string(name='IdPattern', description='catalogId'),
  nextPageToken?: string(name='NextPageToken', description='namePattern'),
  pageSize?: int32(name='PageSize', description='pageSize'),
}

model ListCatalogsResponseBody = {
  catalogs?: [
    Catalog
  ](name='Catalogs', description='Catalogs'),
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model ListCatalogsResponse = {
  headers: map[string]string(name='headers'),
  body: ListCatalogsResponseBody(name='body'),
}

async function listCatalogs(request: ListCatalogsRequest): ListCatalogsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listCatalogsWithOptions(request, headers, runtime);
}

async function listCatalogsWithOptions(request: ListCatalogsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListCatalogsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.idPattern)) {
    query.IdPattern = request.idPattern;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query.NextPageToken = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListCatalogs', '2020-07-10', 'HTTPS', 'GET', 'AK', `/api/metastore/catalogs/list`, 'json', req, runtime);
}

model ListFunctionsRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  functionNamePattern?: string(name='FunctionNamePattern', description='FunctionNamePattern'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  pageSize?: int32(name='PageSize', description='PageSize'),
}

model ListFunctionsResponseBody = {
  code?: string(name='Code', description='Code'),
  functions?: [
    Function
  ](name='Functions', description='Functions'),
  message?: string(name='Message', description='Message'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model ListFunctionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListFunctionsResponseBody(name='body'),
}

async function listFunctions(request: ListFunctionsRequest): ListFunctionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFunctionsWithOptions(request, headers, runtime);
}

async function listFunctionsWithOptions(request: ListFunctionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListFunctionsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    query.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query.DatabaseName = request.databaseName;
  }
  if (!Util.isUnset(request.functionNamePattern)) {
    query.FunctionNamePattern = request.functionNamePattern;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query.NextPageToken = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListFunctions', '2020-07-10', 'HTTPS', 'GET', 'AK', `/api/metastore/catalogs/databases/functions/list`, 'json', req, runtime);
}

model DeleteTableRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  tableName?: string(name='TableName', description='TableName'),
}

model DeleteTableResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model DeleteTableResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTableResponseBody(name='body'),
}

async function deleteTable(request: DeleteTableRequest): DeleteTableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteTableWithOptions(request, headers, runtime);
}

async function deleteTableWithOptions(request: DeleteTableRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteTableResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    query.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query.DatabaseName = request.databaseName;
  }
  if (!Util.isUnset(request.tableName)) {
    query.TableName = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteTable', '2020-07-10', 'HTTPS', 'DELETE', 'AK', `/api/metastore/catalogs/databases/tables`, 'json', req, runtime);
}

model GetTableVersionRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  tableName?: string(name='TableName', description='TableName'),
  versionId?: int32(name='VersionId', description='Table Version'),
}

model GetTableVersionResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
  tableVersion?: TableVersion(name='TableVersion'),
}

model GetTableVersionResponse = {
  headers: map[string]string(name='headers'),
  body: GetTableVersionResponseBody(name='body'),
}

async function getTableVersion(request: GetTableVersionRequest): GetTableVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTableVersionWithOptions(request, headers, runtime);
}

async function getTableVersionWithOptions(request: GetTableVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetTableVersionResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    query.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query.DatabaseName = request.databaseName;
  }
  if (!Util.isUnset(request.tableName)) {
    query.TableName = request.tableName;
  }
  if (!Util.isUnset(request.versionId)) {
    query.VersionId = request.versionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetTableVersion', '2020-07-10', 'HTTPS', 'GET', 'AK', `/api/metastore/catalogs/databases/tables/versions`, 'json', req, runtime);
}

model GetTableRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  tableName?: string(name='TableName', description='TableName'),
}

model GetTableResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
  table?: Table(name='Table'),
}

model GetTableResponse = {
  headers: map[string]string(name='headers'),
  body: GetTableResponseBody(name='body'),
}

async function getTable(request: GetTableRequest): GetTableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTableWithOptions(request, headers, runtime);
}

async function getTableWithOptions(request: GetTableRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetTableResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    query.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query.DatabaseName = request.databaseName;
  }
  if (!Util.isUnset(request.tableName)) {
    query.TableName = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetTable', '2020-07-10', 'HTTPS', 'GET', 'AK', `/api/metastore/catalogs/databases/tables`, 'json', req, runtime);
}

model BatchDeleteTablesRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  ifExists?: boolean(name='IfExists', description='IfExists'),
  tableNames?: [ string ](name='TableNames', description='TableName'),
}

model BatchDeleteTablesResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
  tableErrors?: [
    TableError
  ](name='TableErrors', description='PartitionErrors'),
}

model BatchDeleteTablesResponse = {
  headers: map[string]string(name='headers'),
  body: BatchDeleteTablesResponseBody(name='body'),
}

async function batchDeleteTables(request: BatchDeleteTablesRequest): BatchDeleteTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchDeleteTablesWithOptions(request, headers, runtime);
}

async function batchDeleteTablesWithOptions(request: BatchDeleteTablesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchDeleteTablesResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body.DatabaseName = request.databaseName;
  }
  if (!Util.isUnset(request.ifExists)) {
    body.IfExists = request.ifExists;
  }
  if (!Util.isUnset(request.tableNames)) {
    body.TableNames = request.tableNames;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('BatchDeleteTables', '2020-07-10', 'HTTPS', 'POST', 'AK', `/api/metastore/catalogs/databases/tables/batchdelete`, 'json', req, runtime);
}

model RenameTableRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  tableInput?: TableInput(name='TableInput'),
  tableName?: string(name='TableName', description='TableName'),
}

model RenameTableResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model RenameTableResponse = {
  headers: map[string]string(name='headers'),
  body: RenameTableResponseBody(name='body'),
}

async function renameTable(request: RenameTableRequest): RenameTableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return renameTableWithOptions(request, headers, runtime);
}

async function renameTableWithOptions(request: RenameTableRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RenameTableResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body.DatabaseName = request.databaseName;
  }
  if (!Util.isUnset(request.tableInput)) {
    body.TableInput = request.tableInput;
  }
  if (!Util.isUnset(request.tableName)) {
    body.TableName = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('RenameTable', '2020-07-10', 'HTTPS', 'PUT', 'AK', `/api/metastore/catalogs/databases/tables/rename`, 'json', req, runtime);
}

model UpdateTableRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  skipArchive?: boolean(name='SkipArchive', description='SkipArchive'),
  tableInput?: TableInput(name='TableInput'),
  tableName?: string(name='TableName', description='TableName'),
}

model UpdateTableResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model UpdateTableResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTableResponseBody(name='body'),
}

async function updateTable(request: UpdateTableRequest): UpdateTableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateTableWithOptions(request, headers, runtime);
}

async function updateTableWithOptions(request: UpdateTableRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateTableResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body.DatabaseName = request.databaseName;
  }
  if (!Util.isUnset(request.skipArchive)) {
    body.SkipArchive = request.skipArchive;
  }
  if (!Util.isUnset(request.tableInput)) {
    body.TableInput = request.tableInput;
  }
  if (!Util.isUnset(request.tableName)) {
    body.TableName = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('UpdateTable', '2020-07-10', 'HTTPS', 'PUT', 'AK', `/api/metastore/catalogs/databases/tables`, 'json', req, runtime);
}

model DeletePartitionRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  ifExists?: boolean(name='IfExists', description='IfExists'),
  partitionValues?: [ string ](name='PartitionValues'),
  tableName?: string(name='TableName', description='TableName'),
}

model DeletePartitionResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model DeletePartitionResponse = {
  headers: map[string]string(name='headers'),
  body: DeletePartitionResponseBody(name='body'),
}

async function deletePartition(request: DeletePartitionRequest): DeletePartitionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deletePartitionWithOptions(request, headers, runtime);
}

async function deletePartitionWithOptions(request: DeletePartitionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeletePartitionResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body.DatabaseName = request.databaseName;
  }
  if (!Util.isUnset(request.ifExists)) {
    body.IfExists = request.ifExists;
  }
  if (!Util.isUnset(request.partitionValues)) {
    body.PartitionValues = request.partitionValues;
  }
  if (!Util.isUnset(request.tableName)) {
    body.TableName = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('DeletePartition', '2020-07-10', 'HTTPS', 'POST', 'AK', `/api/metastore/catalogs/databases/tables/partitions/delete`, 'json', req, runtime);
}

model ListTablesRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  tableNamePattern?: string(name='TableNamePattern', description='TableNamePattern'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  pageSize?: int32(name='PageSize', description='PageSize'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  tableType?: string(name='TableType', description='TableType filter'),
}

model ListTablesResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  requestId?: string(name='RequestId', description=' RequestId'),
  success?: boolean(name='Success', description='Success'),
  tables?: [
    Table
  ](name='Tables', description='Tables'),
}

model ListTablesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTablesResponseBody(name='body'),
}

async function listTables(request: ListTablesRequest): ListTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTablesWithOptions(request, headers, runtime);
}

async function listTablesWithOptions(request: ListTablesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTablesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    query.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.tableNamePattern)) {
    query.TableNamePattern = request.tableNamePattern;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query.NextPageToken = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }
  if (!Util.isUnset(request.databaseName)) {
    query.DatabaseName = request.databaseName;
  }
  if (!Util.isUnset(request.tableType)) {
    query.TableType = request.tableType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListTables', '2020-07-10', 'HTTPS', 'GET', 'AK', `/api/metastore/databases/tables/list`, 'json', req, runtime);
}

model DeleteDatabaseRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  name?: string(name='Name', description='Name'),
  cascade?: boolean(name='Cascade', description='Cascade'),
}

model DeleteDatabaseResponseBody = {
  code?: string(name='Code', description='Response Code'),
  message?: string(name='Message', description='Response Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Request is success or not'),
}

model DeleteDatabaseResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDatabaseResponseBody(name='body'),
}

async function deleteDatabase(request: DeleteDatabaseRequest): DeleteDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDatabaseWithOptions(request, headers, runtime);
}

async function deleteDatabaseWithOptions(request: DeleteDatabaseRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteDatabaseResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    query.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.name)) {
    query.Name = request.name;
  }
  if (!Util.isUnset(request.cascade)) {
    query.Cascade = request.cascade;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteDatabase', '2020-07-10', 'HTTPS', 'DELETE', 'AK', `/api/metastore/catalogs/databases`, 'json', req, runtime);
}

model BatchGetTablesRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  tableNames?: [ string ](name='TableNames'),
}

model BatchGetTablesResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
  tableErrors?: [
    TableError
  ](name='TableErrors', description='TableErrors'),
  tables?: [
    Table
  ](name='Tables', description='Tables'),
}

model BatchGetTablesResponse = {
  headers: map[string]string(name='headers'),
  body: BatchGetTablesResponseBody(name='body'),
}

async function batchGetTables(request: BatchGetTablesRequest): BatchGetTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchGetTablesWithOptions(request, headers, runtime);
}

async function batchGetTablesWithOptions(request: BatchGetTablesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchGetTablesResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body.DatabaseName = request.databaseName;
  }
  if (!Util.isUnset(request.tableNames)) {
    body.TableNames = request.tableNames;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('BatchGetTables', '2020-07-10', 'HTTPS', 'POST', 'AK', `/api/metastore/catalogs/databases/tables/batchget`, 'json', req, runtime);
}

model DeleteFunctionRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  functionName?: string(name='FunctionName', description='FunctionName'),
}

model DeleteFunctionResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model DeleteFunctionResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFunctionResponseBody(name='body'),
}

async function deleteFunction(request: DeleteFunctionRequest): DeleteFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteFunctionWithOptions(request, headers, runtime);
}

async function deleteFunctionWithOptions(request: DeleteFunctionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteFunctionResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    query.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query.DatabaseName = request.databaseName;
  }
  if (!Util.isUnset(request.functionName)) {
    query.FunctionName = request.functionName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteFunction', '2020-07-10', 'HTTPS', 'DELETE', 'AK', `/api/metastore/catalogs/databases/functions`, 'json', req, runtime);
}

model GetDatabaseRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  name?: string(name='Name', description='The name of the database to query.'),
}

model GetDatabaseResponseBody = {
  code?: string(name='Code', description='Response Code'),
  database?: Database(name='Database'),
  message?: string(name='Message', description='Response Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='API is success or not'),
}

model GetDatabaseResponse = {
  headers: map[string]string(name='headers'),
  body: GetDatabaseResponseBody(name='body'),
}

async function getDatabase(request: GetDatabaseRequest): GetDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDatabaseWithOptions(request, headers, runtime);
}

async function getDatabaseWithOptions(request: GetDatabaseRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetDatabaseResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    query.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.name)) {
    query.Name = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetDatabase', '2020-07-10', 'HTTPS', 'GET', 'AK', `/api/metastore/catalogs/databases`, 'json', req, runtime);
}

model GetFunctionRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  functionName?: string(name='FunctionName', description='FunctionName'),
}

model GetFunctionResponseBody = {
  code?: string(name='Code', description='Code'),
  function?: Function(name='Function'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model GetFunctionResponse = {
  headers: map[string]string(name='headers'),
  body: GetFunctionResponseBody(name='body'),
}

async function getFunction(request: GetFunctionRequest): GetFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFunctionWithOptions(request, headers, runtime);
}

async function getFunctionWithOptions(request: GetFunctionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetFunctionResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    query.CatalogId = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query.DatabaseName = request.databaseName;
  }
  if (!Util.isUnset(request.functionName)) {
    query.FunctionName = request.functionName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetFunction', '2020-07-10', 'HTTPS', 'GET', 'AK', `/api/metastore/catalogs/databases/functions`, 'json', req, runtime);
}

