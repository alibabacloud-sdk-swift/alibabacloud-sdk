import Util;
import RPC;
import EndpointUtil;

extends RPC;

init(config: RPC.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('cms', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

model PutCustomMetricRuleRequest = {
  groupId?: string(name='GroupId'),
  ruleId: string(name='RuleId'),
  ruleName?: string(name='RuleName'),
  metricName: string(name='MetricName'),
  resources: string(name='Resources'),
  contactGroups: string(name='ContactGroups'),
  webhook?: string(name='Webhook'),
  effectiveInterval?: string(name='EffectiveInterval'),
  silenceTime?: integer(name='SilenceTime'),
  period?: string(name='Period'),
  emailSubject?: string(name='EmailSubject'),
  threshold: string(name='Threshold'),
  level: string(name='Level'),
  evaluationCount: integer(name='EvaluationCount'),
  statistics: string(name='Statistics'),
  comparisonOperator: string(name='ComparisonOperator'),
}

model PutCustomMetricRuleResponse = {
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

async function putCustomMetricRuleWithOptions(request: PutCustomMetricRuleRequest, runtime: Util.RuntimeOptions): PutCustomMetricRuleResponse {
  Util.validateModel(request);
  return doRequest('PutCustomMetricRule', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function putCustomMetricRule(request: PutCustomMetricRuleRequest): PutCustomMetricRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return putCustomMetricRuleWithOptions(request, runtime);
}

model PutCustomEventRuleRequest = {
  groupId: string(name='GroupId'),
  ruleId: string(name='RuleId'),
  ruleName?: string(name='RuleName'),
  eventName?: string(name='EventName'),
  contactGroups: string(name='ContactGroups'),
  webhook?: string(name='Webhook'),
  effectiveInterval?: string(name='EffectiveInterval'),
  period?: string(name='Period'),
  emailSubject?: string(name='EmailSubject'),
  threshold: string(name='Threshold'),
  level: string(name='Level'),
}

model PutCustomEventRuleResponse = {
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

async function putCustomEventRuleWithOptions(request: PutCustomEventRuleRequest, runtime: Util.RuntimeOptions): PutCustomEventRuleResponse {
  Util.validateModel(request);
  return doRequest('PutCustomEventRule', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function putCustomEventRule(request: PutCustomEventRuleRequest): PutCustomEventRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return putCustomEventRuleWithOptions(request, runtime);
}

model PutLogMonitorRequest = {
  logId?: string(name='LogId'),
  slsRegionId: string(name='SlsRegionId'),
  slsProject: string(name='SlsProject'),
  slsLogstore: string(name='SlsLogstore'),
  metricName?: string(name='MetricName'),
  metricExpress?: string(name='MetricExpress'),
  groupId?: string(name='GroupId'),
  aggregates: [
    {
      alias: string(name='Alias'),
      fieldName: string(name='FieldName'),
      function: string(name='Function'),
    }
  ](name='Aggregates'),
  groupbys?: [
    {
      alias?: string(name='Alias'),
      fieldName?: string(name='FieldName'),
    }
  ](name='Groupbys'),
  valueFilterRelation?: string(name='ValueFilterRelation'),
  valueFilter?: [
    {
      key?: string(name='Key'),
      operator?: string(name='Operator'),
      value?: string(name='Value'),
    }
  ](name='ValueFilter'),
  tumblingwindows?: string(name='Tumblingwindows'),
  unit?: string(name='Unit'),
}

model PutLogMonitorResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  logId: string(name='LogId'),
}

async function putLogMonitorWithOptions(request: PutLogMonitorRequest, runtime: Util.RuntimeOptions): PutLogMonitorResponse {
  Util.validateModel(request);
  return doRequest('PutLogMonitor', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function putLogMonitor(request: PutLogMonitorRequest): PutLogMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return putLogMonitorWithOptions(request, runtime);
}

model DeleteLogMonitorRequest = {
  logId: long(name='LogId'),
}

model DeleteLogMonitorResponse = {
  code: string(name='Code'),
  success: boolean(name='Success'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

async function deleteLogMonitorWithOptions(request: DeleteLogMonitorRequest, runtime: Util.RuntimeOptions): DeleteLogMonitorResponse {
  Util.validateModel(request);
  return doRequest('DeleteLogMonitor', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteLogMonitor(request: DeleteLogMonitorRequest): DeleteLogMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLogMonitorWithOptions(request, runtime);
}

model DescribeLogMonitorListRequest = {
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  searchValue?: string(name='SearchValue'),
  groupId?: long(name='GroupId'),
}

model DescribeLogMonitorListResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
  total: long(name='Total'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  logMonitorList: [
    {
      logId: long(name='LogId'),
      slsRegionId: string(name='SlsRegionId'),
      slsProject: string(name='SlsProject'),
      slsLogstore: string(name='SlsLogstore'),
      metricName: string(name='MetricName'),
      gmtCreate: long(name='GmtCreate'),
      valueFilterRelation: string(name='ValueFilterRelation'),
      groupId: long(name='GroupId'),
      valueFilter: [
        {
          key: string(name='Key'),
          operator: string(name='Operator'),
          value: string(name='Value'),
        }
      ](name='ValueFilter'),
    }
  ](name='LogMonitorList'),
}

async function describeLogMonitorListWithOptions(request: DescribeLogMonitorListRequest, runtime: Util.RuntimeOptions): DescribeLogMonitorListResponse {
  Util.validateModel(request);
  return doRequest('DescribeLogMonitorList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeLogMonitorList(request: DescribeLogMonitorListRequest): DescribeLogMonitorListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLogMonitorListWithOptions(request, runtime);
}

model DescribeLogMonitorAttributeRequest = {
  metricName: string(name='MetricName'),
}

model DescribeLogMonitorAttributeResponse = {
  code: string(name='Code'),
  success: boolean(name='Success'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  logMonitor: {
    logId: long(name='LogId'),
    slsRegionId: string(name='SlsRegionId'),
    slsProject: string(name='SlsProject'),
    slsLogstore: string(name='SlsLogstore'),
    metricName: string(name='MetricName'),
    metricExpress: string(name='MetricExpress'),
    gmtCreate: long(name='GmtCreate'),
    valueFilterRelation: string(name='ValueFilterRelation'),
    groupId: long(name='GroupId'),
    aggregates: [
      {
        alias: string(name='Alias'),
        fieldName: string(name='FieldName'),
        function: string(name='Function'),
        min: string(name='Min'),
        max: string(name='Max'),
      }
    ](name='Aggregates'),
    valueFilter: [
      {
        key: string(name='Key'),
        operator: string(name='Operator'),
        value: string(name='Value'),
      }
    ](name='ValueFilter'),
    tumblingwindows: [ string ](name='Tumblingwindows'),
    groupbys: [ string ](name='Groupbys'),
  }(name='LogMonitor'),
}

async function describeLogMonitorAttributeWithOptions(request: DescribeLogMonitorAttributeRequest, runtime: Util.RuntimeOptions): DescribeLogMonitorAttributeResponse {
  Util.validateModel(request);
  return doRequest('DescribeLogMonitorAttribute', 'HTTPS', 'GET', '2019-01-01', 'AK', request, null, runtime);
}

async function describeLogMonitorAttribute(request: DescribeLogMonitorAttributeRequest): DescribeLogMonitorAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLogMonitorAttributeWithOptions(request, runtime);
}

model ModifyHostInfoRequest = {
  instanceId: string(name='InstanceId'),
  hostName?: string(name='HostName'),
}

model ModifyHostInfoResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
}

async function modifyHostInfoWithOptions(request: ModifyHostInfoRequest, runtime: Util.RuntimeOptions): ModifyHostInfoResponse {
  Util.validateModel(request);
  return doRequest('ModifyHostInfo', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function modifyHostInfo(request: ModifyHostInfoRequest): ModifyHostInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyHostInfoWithOptions(request, runtime);
}

model DescribeExporterOutputListRequest = {
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model DescribeExporterOutputListResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  total: integer(name='Total'),
  pageNumber: integer(name='PageNumber'),
  success: boolean(name='Success'),
  datapoints: {
    datapoint: [
      {
        destName: string(name='DestName'),
        destType: string(name='DestType'),
        createTime: long(name='CreateTime'),
        configJson: {
          logstore: string(name='logstore'),
          project: string(name='project'),
          endpoint: string(name='endpoint'),
          as: string(name='as'),
          ak: string(name='ak'),
        }(name='ConfigJson'),
      }
    ](name='Datapoint'),
  }(name='Datapoints'),
}

async function describeExporterOutputListWithOptions(request: DescribeExporterOutputListRequest, runtime: Util.RuntimeOptions): DescribeExporterOutputListResponse {
  Util.validateModel(request);
  return doRequest('DescribeExporterOutputList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeExporterOutputList(request: DescribeExporterOutputListRequest): DescribeExporterOutputListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeExporterOutputListWithOptions(request, runtime);
}

model DeleteExporterOutputRequest = {
  destName: string(name='DestName'),
}

model DeleteExporterOutputResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
}

async function deleteExporterOutputWithOptions(request: DeleteExporterOutputRequest, runtime: Util.RuntimeOptions): DeleteExporterOutputResponse {
  Util.validateModel(request);
  return doRequest('DeleteExporterOutput', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteExporterOutput(request: DeleteExporterOutputRequest): DeleteExporterOutputResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteExporterOutputWithOptions(request, runtime);
}

model PutExporterOutputRequest = {
  destName: string(name='DestName'),
  configJson: string(name='ConfigJson'),
  desc?: string(name='Desc'),
  destType?: string(name='DestType'),
}

model PutExporterOutputResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
}

async function putExporterOutputWithOptions(request: PutExporterOutputRequest, runtime: Util.RuntimeOptions): PutExporterOutputResponse {
  Util.validateModel(request);
  return doRequest('PutExporterOutput', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function putExporterOutput(request: PutExporterOutputRequest): PutExporterOutputResponse {
  var runtime = new Util.RuntimeOptions{};
  return putExporterOutputWithOptions(request, runtime);
}

model DescribeFolderListRequest = {
  appName?: string(name='AppName'),
}

model DescribeFolderListResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: integer(name='Code'),
  message: string(name='Message'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  total: integer(name='Total'),
  resource: {
    name: string(name='Name'),
    serviceId: long(name='ServiceId'),
  }(name='Resource'),
}

async function describeFolderListWithOptions(request: DescribeFolderListRequest, runtime: Util.RuntimeOptions): DescribeFolderListResponse {
  Util.validateModel(request);
  return doRequest('DescribeFolderList', 'HTTPS', 'GET', '2019-01-01', 'AK', request, null, runtime);
}

async function describeFolderList(request: DescribeFolderListRequest): DescribeFolderListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFolderListWithOptions(request, runtime);
}

model DeleteExporterRuleRequest = {
  ruleName: string(name='RuleName'),
}

model DeleteExporterRuleResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
}

async function deleteExporterRuleWithOptions(request: DeleteExporterRuleRequest, runtime: Util.RuntimeOptions): DeleteExporterRuleResponse {
  Util.validateModel(request);
  return doRequest('DeleteExporterRule', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteExporterRule(request: DeleteExporterRuleRequest): DeleteExporterRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteExporterRuleWithOptions(request, runtime);
}

model DescribeExporterRuleListRequest = {
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model DescribeExporterRuleListResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  total: integer(name='Total'),
  pageNumber: integer(name='PageNumber'),
  success: boolean(name='Success'),
  datapoints: {
    datapoint: [
      {
        ruleName: string(name='RuleName'),
        namespace: string(name='Namespace'),
        metricName: string(name='MetricName'),
        enabled: boolean(name='Enabled'),
        targetWindows: string(name='TargetWindows'),
        describe: string(name='Describe'),
        dimension: string(name='Dimension'),
        createTime: long(name='CreateTime'),
        dstName: {
          dstName: [ string ](name='DstName', description='DstName'),
        }(name='DstName'),
      }
    ](name='Datapoint'),
  }(name='Datapoints'),
}

async function describeExporterRuleListWithOptions(request: DescribeExporterRuleListRequest, runtime: Util.RuntimeOptions): DescribeExporterRuleListResponse {
  Util.validateModel(request);
  return doRequest('DescribeExporterRuleList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeExporterRuleList(request: DescribeExporterRuleListRequest): DescribeExporterRuleListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeExporterRuleListWithOptions(request, runtime);
}

model PutExporterRuleRequest = {
  ruleName?: string(name='RuleName'),
  dstNames?: [ string ](name='DstNames'),
  namespace?: string(name='Namespace'),
  metricName?: string(name='MetricName'),
  targetWindows?: string(name='TargetWindows'),
  describe?: string(name='Describe'),
}

model PutExporterRuleResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
}

async function putExporterRuleWithOptions(request: PutExporterRuleRequest, runtime: Util.RuntimeOptions): PutExporterRuleResponse {
  Util.validateModel(request);
  return doRequest('PutExporterRule', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function putExporterRule(request: PutExporterRuleRequest): PutExporterRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return putExporterRuleWithOptions(request, runtime);
}

model DescribeDynamicTagRuleListRequest = {
  tagKey?: string(name='TagKey'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
}

model DescribeDynamicTagRuleListResponse = {
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  total: integer(name='Total'),
  pageNumber: string(name='PageNumber'),
  pageSize: string(name='PageSize'),
  tagGroupList: {
    tagGroup: [
      {
        dynamicTagRuleId: string(name='DynamicTagRuleId'),
        tagKey: string(name='TagKey'),
        regionId: string(name='RegionId'),
        matchExpressFilterRelation: string(name='MatchExpressFilterRelation'),
        status: string(name='Status'),
        matchExpress: {
          matchExpress: [
            {
              tagValueMatchFunction: string(name='TagValueMatchFunction'),
              tagValue: string(name='TagValue'),
            }
          ](name='MatchExpress'),
        }(name='MatchExpress'),
        templateIdList: {
          templateIdList: [ string ](name='TemplateIdList', description='TemplateIdList'),
        }(name='TemplateIdList'),
      }
    ](name='TagGroup'),
  }(name='TagGroupList'),
}

async function describeDynamicTagRuleListWithOptions(request: DescribeDynamicTagRuleListRequest, runtime: Util.RuntimeOptions): DescribeDynamicTagRuleListResponse {
  Util.validateModel(request);
  return doRequest('DescribeDynamicTagRuleList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeDynamicTagRuleList(request: DescribeDynamicTagRuleListRequest): DescribeDynamicTagRuleListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDynamicTagRuleListWithOptions(request, runtime);
}

model DescribeProductResourceTagKeyListRequest = {
  nextToken?: string(name='NextToken'),
}

model DescribeProductResourceTagKeyListResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
  nextToken: string(name='NextToken'),
  tagKeys: {
    tagKey: [ string ](name='TagKey'),
  }(name='TagKeys'),
}

async function describeProductResourceTagKeyListWithOptions(request: DescribeProductResourceTagKeyListRequest, runtime: Util.RuntimeOptions): DescribeProductResourceTagKeyListResponse {
  Util.validateModel(request);
  return doRequest('DescribeProductResourceTagKeyList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeProductResourceTagKeyList(request: DescribeProductResourceTagKeyListRequest): DescribeProductResourceTagKeyListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeProductResourceTagKeyListWithOptions(request, runtime);
}

model CreateDynamicTagGroupRequest = {
  tagKey: string(name='TagKey'),
  enableSubscribeEvent?: boolean(name='EnableSubscribeEvent'),
  enableInstallAgent?: boolean(name='EnableInstallAgent'),
  regionId: string(name='RegionId'),
  matchExpressFilterRelation?: string(name='MatchExpressFilterRelation'),
  matchExpress?: [
    {
      tagValueMatchFunction?: string(name='TagValueMatchFunction'),
      tagValue?: string(name='TagValue'),
    }
  ](name='MatchExpress'),
  contactGroupList: [ string ](name='ContactGroupList'),
  templateIdList?: [ string ](name='TemplateIdList'),
}

model CreateDynamicTagGroupResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
}

async function createDynamicTagGroupWithOptions(request: CreateDynamicTagGroupRequest, runtime: Util.RuntimeOptions): CreateDynamicTagGroupResponse {
  Util.validateModel(request);
  return doRequest('CreateDynamicTagGroup', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function createDynamicTagGroup(request: CreateDynamicTagGroupRequest): CreateDynamicTagGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDynamicTagGroupWithOptions(request, runtime);
}

model DeleteDynamicTagGroupRequest = {
  dynamicTagRuleId: string(name='DynamicTagRuleId'),
}

model DeleteDynamicTagGroupResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
}

async function deleteDynamicTagGroupWithOptions(request: DeleteDynamicTagGroupRequest, runtime: Util.RuntimeOptions): DeleteDynamicTagGroupResponse {
  Util.validateModel(request);
  return doRequest('DeleteDynamicTagGroup', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteDynamicTagGroup(request: DeleteDynamicTagGroupRequest): DeleteDynamicTagGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDynamicTagGroupWithOptions(request, runtime);
}

model ModifyGroupMonitoringAgentProcessRequest = {
  id: string(name='Id'),
  groupId: string(name='GroupId'),
  matchExpressFilterRelation?: string(name='MatchExpressFilterRelation'),
  alertConfig: [
    {
      effectiveInterval: string(name='EffectiveInterval'),
      noEffectiveInterval: string(name='NoEffectiveInterval'),
      silenceTime: string(name='SilenceTime'),
      webhook: string(name='Webhook'),
      escalationsLevel: string(name='EscalationsLevel'),
      comparisonOperator: string(name='ComparisonOperator'),
      statistics?: string(name='Statistics'),
      threshold: string(name='Threshold'),
      times: string(name='Times'),
    }
  ](name='AlertConfig'),
}

model ModifyGroupMonitoringAgentProcessResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
}

async function modifyGroupMonitoringAgentProcessWithOptions(request: ModifyGroupMonitoringAgentProcessRequest, runtime: Util.RuntimeOptions): ModifyGroupMonitoringAgentProcessResponse {
  Util.validateModel(request);
  return doRequest('ModifyGroupMonitoringAgentProcess', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function modifyGroupMonitoringAgentProcess(request: ModifyGroupMonitoringAgentProcessRequest): ModifyGroupMonitoringAgentProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyGroupMonitoringAgentProcessWithOptions(request, runtime);
}

model DeleteGroupMonitoringAgentProcessRequest = {
  groupId: string(name='GroupId'),
  id?: string(name='Id'),
}

model DeleteGroupMonitoringAgentProcessResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
}

async function deleteGroupMonitoringAgentProcessWithOptions(request: DeleteGroupMonitoringAgentProcessRequest, runtime: Util.RuntimeOptions): DeleteGroupMonitoringAgentProcessResponse {
  Util.validateModel(request);
  return doRequest('DeleteGroupMonitoringAgentProcess', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteGroupMonitoringAgentProcess(request: DeleteGroupMonitoringAgentProcessRequest): DeleteGroupMonitoringAgentProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGroupMonitoringAgentProcessWithOptions(request, runtime);
}

model CreateGroupMonitoringAgentProcessRequest = {
  groupId: string(name='GroupId'),
  processName?: string(name='ProcessName'),
  matchExpressFilterRelation?: string(name='MatchExpressFilterRelation'),
  matchExpress?: [
    {
      name?: string(name='Name'),
      function?: string(name='Function'),
      value?: string(name='Value'),
    }
  ](name='MatchExpress'),
  alertConfig: [
    {
      effectiveInterval: string(name='EffectiveInterval'),
      noEffectiveInterval: string(name='NoEffectiveInterval'),
      silenceTime: string(name='SilenceTime'),
      webhook: string(name='Webhook'),
      escalationsLevel: string(name='EscalationsLevel'),
      comparisonOperator: string(name='ComparisonOperator'),
      statistics?: string(name='Statistics'),
      threshold: string(name='Threshold'),
      times: string(name='Times'),
    }
  ](name='AlertConfig'),
}

model CreateGroupMonitoringAgentProcessResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
}

async function createGroupMonitoringAgentProcessWithOptions(request: CreateGroupMonitoringAgentProcessRequest, runtime: Util.RuntimeOptions): CreateGroupMonitoringAgentProcessResponse {
  Util.validateModel(request);
  return doRequest('CreateGroupMonitoringAgentProcess', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function createGroupMonitoringAgentProcess(request: CreateGroupMonitoringAgentProcessRequest): CreateGroupMonitoringAgentProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGroupMonitoringAgentProcessWithOptions(request, runtime);
}

model DescribeTagKeyListRequest = {
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model DescribeTagKeyListResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
  tagKeys: {
    tagKey: [ string ](name='TagKey'),
  }(name='TagKeys'),
}

async function describeTagKeyListWithOptions(request: DescribeTagKeyListRequest, runtime: Util.RuntimeOptions): DescribeTagKeyListResponse {
  Util.validateModel(request);
  return doRequest('DescribeTagKeyList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeTagKeyList(request: DescribeTagKeyListRequest): DescribeTagKeyListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTagKeyListWithOptions(request, runtime);
}

model DescribeTagValueListRequest = {
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  tagKey: string(name='TagKey'),
}

model DescribeTagValueListResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
  tagValues: {
    tagValue: [ string ](name='TagValue'),
  }(name='TagValues'),
}

async function describeTagValueListWithOptions(request: DescribeTagValueListRequest, runtime: Util.RuntimeOptions): DescribeTagValueListResponse {
  Util.validateModel(request);
  return doRequest('DescribeTagValueList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeTagValueList(request: DescribeTagValueListRequest): DescribeTagValueListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTagValueListWithOptions(request, runtime);
}

model RemoveTagsRequest = {
  tag?: [
    {
      key: string(name='Key'),
      value: string(name='Value'),
    }
  ](name='Tag'),
  groupIds: [ string ](name='GroupIds'),
}

model RemoveTagsResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
  tag: {
    tags: [ string ](name='Tags'),
  }(name='Tag'),
}

async function removeTagsWithOptions(request: RemoveTagsRequest, runtime: Util.RuntimeOptions): RemoveTagsResponse {
  Util.validateModel(request);
  return doRequest('RemoveTags', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function removeTags(request: RemoveTagsRequest): RemoveTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeTagsWithOptions(request, runtime);
}

model AddTagsRequest = {
  tag: [
    {
      key: string(name='Key'),
      value: string(name='Value'),
    }
  ](name='Tag'),
  groupIds: [ string ](name='GroupIds'),
}

model AddTagsResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
}

async function addTagsWithOptions(request: AddTagsRequest, runtime: Util.RuntimeOptions): AddTagsResponse {
  Util.validateModel(request);
  return doRequest('AddTags', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function addTags(request: AddTagsRequest): AddTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return addTagsWithOptions(request, runtime);
}

model DescribeGroupMonitoringAgentProcessRequest = {
  groupId: string(name='GroupId'),
  processName?: string(name='ProcessName'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model DescribeGroupMonitoringAgentProcessResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
  total: string(name='Total'),
  pageSize: string(name='PageSize'),
  pageNumber: string(name='PageNumber'),
  processes: {
    process: [
      {
        id: string(name='Id'),
        groupId: string(name='GroupId'),
        processName: string(name='ProcessName'),
        matchExpressFilterRelation: string(name='MatchExpressFilterRelation'),
        matchExpress: {
          matchExpress: [
            {
              name: string(name='Name'),
              function: string(name='Function'),
              value: string(name='Value'),
            }
          ](name='MatchExpress'),
        }(name='MatchExpress'),
        alertConfig: {
          alertConfig: [
            {
              effectiveInterval: string(name='EffectiveInterval'),
              noEffectiveInterval: string(name='NoEffectiveInterval'),
              silenceTime: string(name='SilenceTime'),
              webhook: string(name='Webhook'),
              escalationsLevel: string(name='EscalationsLevel'),
              comparisonOperator: string(name='ComparisonOperator'),
              statistics: string(name='Statistics'),
              threshold: string(name='Threshold'),
              times: string(name='Times'),
            }
          ](name='AlertConfig'),
        }(name='AlertConfig'),
      }
    ](name='Process'),
  }(name='Processes'),
}

async function describeGroupMonitoringAgentProcessWithOptions(request: DescribeGroupMonitoringAgentProcessRequest, runtime: Util.RuntimeOptions): DescribeGroupMonitoringAgentProcessResponse {
  Util.validateModel(request);
  return doRequest('DescribeGroupMonitoringAgentProcess', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeGroupMonitoringAgentProcess(request: DescribeGroupMonitoringAgentProcessRequest): DescribeGroupMonitoringAgentProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGroupMonitoringAgentProcessWithOptions(request, runtime);
}

model PutResourceMetricRulesRequest = {
  rules: [
    {
      ruleId: string(name='RuleId'),
      ruleName: string(name='RuleName'),
      namespace: string(name='Namespace'),
      metricName: string(name='MetricName'),
      resources: string(name='Resources'),
      contactGroups: string(name='ContactGroups'),
      webhook?: string(name='Webhook'),
      effectiveInterval?: string(name='EffectiveInterval'),
      noEffectiveInterval?: string(name='NoEffectiveInterval'),
      silenceTime?: integer(name='SilenceTime'),
      period?: string(name='Period'),
      interval?: string(name='Interval'),
      emailSubject?: string(name='EmailSubject'),
      escalations?: {
        critical: {
          statistics?: string(name='Statistics'),
          comparisonOperator?: string(name='ComparisonOperator'),
          threshold?: string(name='Threshold'),
          times?: integer(name='Times'),
        }(name='Critical'),
        warn: {
          statistics?: string(name='Statistics'),
          comparisonOperator?: string(name='ComparisonOperator'),
          threshold?: string(name='Threshold'),
          times?: integer(name='Times'),
        }(name='Warn'),
        info: {
          statistics?: string(name='Statistics'),
          comparisonOperator?: string(name='ComparisonOperator'),
          threshold?: string(name='Threshold'),
          times?: integer(name='Times'),
        }(name='Info'),
      }(name='Escalations'),
    }
  ](name='Rules'),
}

model PutResourceMetricRulesResponse = {
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  failedListResult: {
    target: [
      {
        ruleId: string(name='RuleId'),
        result: {
          code: string(name='Code'),
          message: string(name='Message'),
          success: boolean(name='Success'),
        }(name='Result'),
      }
    ](name='Target'),
  }(name='FailedListResult'),
}

async function putResourceMetricRulesWithOptions(request: PutResourceMetricRulesRequest, runtime: Util.RuntimeOptions): PutResourceMetricRulesResponse {
  Util.validateModel(request);
  return doRequest('PutResourceMetricRules', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function putResourceMetricRules(request: PutResourceMetricRulesRequest): PutResourceMetricRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return putResourceMetricRulesWithOptions(request, runtime);
}

model CreateMetricRuleResourcesRequest = {
  ruleId?: string(name='RuleId'),
  overwrite?: string(name='Overwrite'),
  resources: string(name='Resources'),
}

model CreateMetricRuleResourcesResponse = {
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

async function createMetricRuleResourcesWithOptions(request: CreateMetricRuleResourcesRequest, runtime: Util.RuntimeOptions): CreateMetricRuleResourcesResponse {
  Util.validateModel(request);
  return doRequest('CreateMetricRuleResources', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function createMetricRuleResources(request: CreateMetricRuleResourcesRequest): CreateMetricRuleResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMetricRuleResourcesWithOptions(request, runtime);
}

model DeleteMetricRuleResourcesRequest = {
  ruleId?: string(name='RuleId'),
  resources: string(name='Resources'),
}

model DeleteMetricRuleResourcesResponse = {
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

async function deleteMetricRuleResourcesWithOptions(request: DeleteMetricRuleResourcesRequest, runtime: Util.RuntimeOptions): DeleteMetricRuleResourcesResponse {
  Util.validateModel(request);
  return doRequest('DeleteMetricRuleResources', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteMetricRuleResources(request: DeleteMetricRuleResourcesRequest): DeleteMetricRuleResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMetricRuleResourcesWithOptions(request, runtime);
}

model DeleteMetricRuleTargetsRequest = {
  ruleId: string(name='RuleId'),
  targetIds?: [ string ](name='TargetIds'),
}

model DeleteMetricRuleTargetsResponse = {
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  failIds: {
    targetIds: {
      targetId: [ string ](name='TargetId', description='TargetId'),
    }(name='TargetIds'),
  }(name='FailIds'),
}

async function deleteMetricRuleTargetsWithOptions(request: DeleteMetricRuleTargetsRequest, runtime: Util.RuntimeOptions): DeleteMetricRuleTargetsResponse {
  Util.validateModel(request);
  return doRequest('DeleteMetricRuleTargets', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteMetricRuleTargets(request: DeleteMetricRuleTargetsRequest): DeleteMetricRuleTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMetricRuleTargetsWithOptions(request, runtime);
}

model PutMetricRuleTargetsRequest = {
  ruleId: string(name='RuleId'),
  targets: [
    {
      id: string(name='Id'),
      arn: string(name='Arn'),
      level?: string(name='Level'),
    }
  ](name='Targets'),
}

model PutMetricRuleTargetsResponse = {
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  failData: {
    targets: {
      target: [
        {
          id: string(name='Id'),
          arn: string(name='Arn'),
          level: string(name='Level'),
        }
      ](name='Target'),
    }(name='Targets'),
  }(name='FailData'),
}

async function putMetricRuleTargetsWithOptions(request: PutMetricRuleTargetsRequest, runtime: Util.RuntimeOptions): PutMetricRuleTargetsResponse {
  Util.validateModel(request);
  return doRequest('PutMetricRuleTargets', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function putMetricRuleTargets(request: PutMetricRuleTargetsRequest): PutMetricRuleTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return putMetricRuleTargetsWithOptions(request, runtime);
}

model DescribeMetricRuleTargetsRequest = {
  ruleId: string(name='RuleId'),
}

model DescribeMetricRuleTargetsResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
  targets: {
    target: [
      {
        id: string(name='Id'),
        arn: string(name='Arn'),
        level: string(name='Level'),
      }
    ](name='Target'),
  }(name='Targets'),
}

async function describeMetricRuleTargetsWithOptions(request: DescribeMetricRuleTargetsRequest, runtime: Util.RuntimeOptions): DescribeMetricRuleTargetsResponse {
  Util.validateModel(request);
  return doRequest('DescribeMetricRuleTargets', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMetricRuleTargets(request: DescribeMetricRuleTargetsRequest): DescribeMetricRuleTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricRuleTargetsWithOptions(request, runtime);
}

model ModifyMonitorGroupInstancesRequest = {
  groupId: long(name='GroupId'),
  instances: [
    {
      category: string(name='Category'),
      instanceId: string(name='InstanceId'),
      regionId: string(name='RegionId'),
      instanceName: string(name='InstanceName'),
    }
  ](name='Instances'),
}

model ModifyMonitorGroupInstancesResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: integer(name='Code'),
  message: string(name='Message'),
}

async function modifyMonitorGroupInstancesWithOptions(request: ModifyMonitorGroupInstancesRequest, runtime: Util.RuntimeOptions): ModifyMonitorGroupInstancesResponse {
  Util.validateModel(request);
  return doRequest('ModifyMonitorGroupInstances', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function modifyMonitorGroupInstances(request: ModifyMonitorGroupInstancesRequest): ModifyMonitorGroupInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyMonitorGroupInstancesWithOptions(request, runtime);
}

model DescribeMonitoringAgentStatusesRequest = {
  instanceIds: string(name='InstanceIds'),
}

model DescribeMonitoringAgentStatusesResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
  nodeStatusList: {
    nodeStatus: [
      {
        instanceId: string(name='InstanceId'),
        autoInstall: boolean(name='AutoInstall'),
        status: string(name='Status'),
      }
    ](name='NodeStatus'),
  }(name='NodeStatusList'),
}

async function describeMonitoringAgentStatusesWithOptions(request: DescribeMonitoringAgentStatusesRequest, runtime: Util.RuntimeOptions): DescribeMonitoringAgentStatusesResponse {
  Util.validateModel(request);
  return doRequest('DescribeMonitoringAgentStatuses', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMonitoringAgentStatuses(request: DescribeMonitoringAgentStatusesRequest): DescribeMonitoringAgentStatusesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitoringAgentStatusesWithOptions(request, runtime);
}

model CreateMonitorAgentProcessRequest = {
  processName: string(name='ProcessName'),
  instanceId: string(name='InstanceId'),
  processUser?: string(name='ProcessUser'),
}

model CreateMonitorAgentProcessResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
  id: long(name='Id'),
}

async function createMonitorAgentProcessWithOptions(request: CreateMonitorAgentProcessRequest, runtime: Util.RuntimeOptions): CreateMonitorAgentProcessResponse {
  Util.validateModel(request);
  return doRequest('CreateMonitorAgentProcess', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function createMonitorAgentProcess(request: CreateMonitorAgentProcessRequest): CreateMonitorAgentProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMonitorAgentProcessWithOptions(request, runtime);
}

model DescribeAlertHistoryListRequest = {
  ruleId?: string(name='RuleId'),
  ruleName?: string(name='RuleName'),
  namespace?: string(name='Namespace'),
  metricName?: string(name='MetricName'),
  groupId?: string(name='GroupId'),
  status?: string(name='Status'),
  state?: string(name='State'),
  ascending?: boolean(name='Ascending'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
  pageSize?: integer(name='PageSize'),
  page?: integer(name='Page'),
}

model DescribeAlertHistoryListResponse = {
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  total: string(name='Total'),
  requestId: string(name='RequestId'),
  alarmHistoryList: {
    alarmHistory: [
      {
        ruleId: string(name='RuleId'),
        groupId: string(name='GroupId'),
        namespace: string(name='Namespace'),
        metricName: string(name='MetricName'),
        dimensions: string(name='Dimensions'),
        expression: string(name='Expression'),
        evaluationCount: integer(name='EvaluationCount'),
        value: string(name='Value'),
        alertTime: long(name='AlertTime'),
        lastTime: long(name='LastTime'),
        level: string(name='Level'),
        preLevel: string(name='PreLevel'),
        ruleName: string(name='RuleName'),
        state: string(name='State'),
        status: integer(name='Status'),
        webhooks: string(name='Webhooks'),
        instanceName: string(name='InstanceName'),
        contactGroups: {
          contactGroup: [ string ](name='ContactGroup', description='ContactGroup'),
        }(name='ContactGroups'),
        contacts: {
          contact: [ string ](name='Contact', description='Contact'),
        }(name='Contacts'),
        contactALIIMs: {
          contactALIIM: [ string ](name='ContactALIIM', description='ContactALIIM'),
        }(name='ContactALIIMs'),
        contactSmses: {
          contactSms: [ string ](name='ContactSms', description='ContactSms'),
        }(name='ContactSmses'),
        contactMails: {
          contactMail: [ string ](name='ContactMail', description='ContactMail'),
        }(name='ContactMails'),
      }
    ](name='AlarmHistory'),
  }(name='AlarmHistoryList'),
}

async function describeAlertHistoryListWithOptions(request: DescribeAlertHistoryListRequest, runtime: Util.RuntimeOptions): DescribeAlertHistoryListResponse {
  Util.validateModel(request);
  return doRequest('DescribeAlertHistoryList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeAlertHistoryList(request: DescribeAlertHistoryListRequest): DescribeAlertHistoryListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAlertHistoryListWithOptions(request, runtime);
}

model DescribeAlertingMetricRuleResourcesRequest = {
  ruleId?: string(name='RuleId'),
  groupId?: string(name='GroupId'),
  page?: integer(name='Page'),
  pageSize?: integer(name='PageSize'),
}

model DescribeAlertingMetricRuleResourcesResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: integer(name='Code'),
  message: string(name='Message'),
  total: integer(name='Total'),
  resources: {
    resource: [
      {
        ruleId: string(name='RuleId'),
        ruleName: string(name='RuleName'),
        groupId: string(name='GroupId'),
        resource: string(name='Resource'),
        enable: string(name='Enable'),
        lastAlertTime: string(name='LastAlertTime'),
        lastModifyTime: string(name='LastModifyTime'),
        startTime: string(name='StartTime'),
        metricValues: string(name='MetricValues'),
        retryTimes: string(name='RetryTimes'),
        threshold: string(name='Threshold'),
      }
    ](name='Resource'),
  }(name='Resources'),
}

async function describeAlertingMetricRuleResourcesWithOptions(request: DescribeAlertingMetricRuleResourcesRequest, runtime: Util.RuntimeOptions): DescribeAlertingMetricRuleResourcesResponse {
  Util.validateModel(request);
  return doRequest('DescribeAlertingMetricRuleResources', 'HTTPS', 'GET', '2019-01-01', 'AK', request, null, runtime);
}

async function describeAlertingMetricRuleResources(request: DescribeAlertingMetricRuleResourcesRequest): DescribeAlertingMetricRuleResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAlertingMetricRuleResourcesWithOptions(request, runtime);
}

model DisableActiveMetricRuleRequest = {
  product: string(name='Product'),
}

model DisableActiveMetricRuleResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
}

async function disableActiveMetricRuleWithOptions(request: DisableActiveMetricRuleRequest, runtime: Util.RuntimeOptions): DisableActiveMetricRuleResponse {
  Util.validateModel(request);
  return doRequest('DisableActiveMetricRule', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function disableActiveMetricRule(request: DisableActiveMetricRuleRequest): DisableActiveMetricRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableActiveMetricRuleWithOptions(request, runtime);
}

model DescribeActiveMetricRuleListRequest = {
  product: string(name='Product'),
}

model DescribeActiveMetricRuleListResponse = {
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  datapoints: {
    alarm: [
      {
        ruleId: string(name='RuleId'),
        namespace: string(name='Namespace'),
        metricName: string(name='MetricName'),
        period: string(name='Period'),
        statistics: string(name='Statistics'),
        comparisonOperator: string(name='ComparisonOperator'),
        threshold: string(name='Threshold'),
        evaluationCount: string(name='EvaluationCount'),
        startTime: string(name='StartTime'),
        endTime: string(name='EndTime'),
        silenceTime: string(name='SilenceTime'),
        enable: string(name='Enable'),
        state: string(name='State'),
        contactGroups: string(name='ContactGroups'),
        webhook: string(name='Webhook'),
        ruleName: string(name='RuleName'),
      }
    ](name='Alarm'),
  }(name='Datapoints'),
  alertList: {
    alert: [
      {
        ruleId: string(name='RuleId'),
        namespace: string(name='Namespace'),
        metricName: string(name='MetricName'),
        period: string(name='Period'),
        effectiveInterval: string(name='EffectiveInterval'),
        noEffectiveInterval: string(name='NoEffectiveInterval'),
        silenceTime: string(name='SilenceTime'),
        enableState: boolean(name='EnableState'),
        alertState: string(name='AlertState'),
        contactGroups: string(name='ContactGroups'),
        webhook: string(name='Webhook'),
        mailSubject: string(name='MailSubject'),
        ruleName: string(name='RuleName'),
        resources: string(name='Resources'),
        dimensions: string(name='Dimensions'),
        escalations: {
          info: {
            comparisonOperator: string(name='ComparisonOperator'),
            statistics: string(name='Statistics'),
            threshold: string(name='Threshold'),
            times: string(name='Times'),
          }(name='Info'),
          warn: {
            comparisonOperator: string(name='ComparisonOperator'),
            statistics: string(name='Statistics'),
            threshold: string(name='Threshold'),
            times: string(name='Times'),
          }(name='Warn'),
          critical: {
            comparisonOperator: string(name='ComparisonOperator'),
            statistics: string(name='Statistics'),
            threshold: string(name='Threshold'),
            times: string(name='Times'),
          }(name='Critical'),
        }(name='Escalations'),
      }
    ](name='Alert'),
  }(name='AlertList'),
}

async function describeActiveMetricRuleListWithOptions(request: DescribeActiveMetricRuleListRequest, runtime: Util.RuntimeOptions): DescribeActiveMetricRuleListResponse {
  Util.validateModel(request);
  return doRequest('DescribeActiveMetricRuleList', 'HTTPS', 'GET', '2019-01-01', 'AK', request, null, runtime);
}

async function describeActiveMetricRuleList(request: DescribeActiveMetricRuleListRequest): DescribeActiveMetricRuleListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeActiveMetricRuleListWithOptions(request, runtime);
}

model DescribeProductsOfActiveMetricRuleRequest = {
}

model DescribeProductsOfActiveMetricRuleResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: integer(name='Code'),
  message: string(name='Message'),
  datapoints: string(name='Datapoints'),
  allProductInitMetricRuleList: {
    allProductInitMetricRule: [
      {
        product: string(name='Product'),
        alertInitConfigList: {
          alertInitConfig: [
            {
              namespace: string(name='Namespace'),
              metricName: string(name='MetricName'),
              statistics: string(name='Statistics'),
              evaluationCount: string(name='EvaluationCount'),
              threshold: string(name='Threshold'),
              period: string(name='Period'),
            }
          ](name='AlertInitConfig'),
        }(name='AlertInitConfigList'),
      }
    ](name='AllProductInitMetricRule'),
  }(name='AllProductInitMetricRuleList'),
}

async function describeProductsOfActiveMetricRuleWithOptions(request: DescribeProductsOfActiveMetricRuleRequest, runtime: Util.RuntimeOptions): DescribeProductsOfActiveMetricRuleResponse {
  Util.validateModel(request);
  return doRequest('DescribeProductsOfActiveMetricRule', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeProductsOfActiveMetricRule(request: DescribeProductsOfActiveMetricRuleRequest): DescribeProductsOfActiveMetricRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeProductsOfActiveMetricRuleWithOptions(request, runtime);
}

model EnableActiveMetricRuleRequest = {
  product: string(name='Product'),
}

model EnableActiveMetricRuleResponse = {
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

async function enableActiveMetricRuleWithOptions(request: EnableActiveMetricRuleRequest, runtime: Util.RuntimeOptions): EnableActiveMetricRuleResponse {
  Util.validateModel(request);
  return doRequest('EnableActiveMetricRule', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function enableActiveMetricRule(request: EnableActiveMetricRuleRequest): EnableActiveMetricRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableActiveMetricRuleWithOptions(request, runtime);
}

model DescribeMonitorGroupInstanceAttributeRequest = {
  groupId: long(name='GroupId'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  total?: boolean(name='Total'),
  category?: string(name='Category'),
  keyword?: string(name='Keyword'),
  instanceIds?: string(name='InstanceIds'),
}

model DescribeMonitorGroupInstanceAttributeResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: integer(name='Code'),
  message: string(name='Message'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  total: integer(name='Total'),
  resources: {
    resource: [
      {
        instanceName: string(name='InstanceName'),
        instanceId: string(name='InstanceId'),
        desc: string(name='Desc'),
        networkType: string(name='NetworkType'),
        category: string(name='Category'),
        dimension: string(name='Dimension'),
        tags: {
          tag: [
            {
              key: string(name='Key'),
              value: string(name='Value'),
            }
          ](name='Tag'),
        }(name='Tags'),
        region: {
          regionId: string(name='RegionId'),
          availabilityZone: string(name='AvailabilityZone'),
        }(name='Region'),
        vpc: {
          vpcInstanceId: string(name='VpcInstanceId'),
          vswitchInstanceId: string(name='VswitchInstanceId'),
        }(name='Vpc'),
      }
    ](name='Resource'),
  }(name='Resources'),
}

async function describeMonitorGroupInstanceAttributeWithOptions(request: DescribeMonitorGroupInstanceAttributeRequest, runtime: Util.RuntimeOptions): DescribeMonitorGroupInstanceAttributeResponse {
  Util.validateModel(request);
  return doRequest('DescribeMonitorGroupInstanceAttribute', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMonitorGroupInstanceAttribute(request: DescribeMonitorGroupInstanceAttributeRequest): DescribeMonitorGroupInstanceAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitorGroupInstanceAttributeWithOptions(request, runtime);
}

model DescribeMonitorGroupNotifyPolicyListRequest = {
  policyType: string(name='PolicyType'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  groupId?: string(name='GroupId'),
}

model DescribeMonitorGroupNotifyPolicyListResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: string(name='Success'),
  requestId: string(name='RequestId'),
  total: integer(name='Total'),
  notifyPolicyList: {
    notifyPolicy: [
      {
        type: string(name='Type'),
        id: string(name='Id'),
        startTime: long(name='StartTime'),
        endTime: long(name='EndTime'),
        groupId: string(name='GroupId'),
      }
    ](name='NotifyPolicy'),
  }(name='NotifyPolicyList'),
}

async function describeMonitorGroupNotifyPolicyListWithOptions(request: DescribeMonitorGroupNotifyPolicyListRequest, runtime: Util.RuntimeOptions): DescribeMonitorGroupNotifyPolicyListResponse {
  Util.validateModel(request);
  return doRequest('DescribeMonitorGroupNotifyPolicyList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMonitorGroupNotifyPolicyList(request: DescribeMonitorGroupNotifyPolicyListRequest): DescribeMonitorGroupNotifyPolicyListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitorGroupNotifyPolicyListWithOptions(request, runtime);
}

model DeleteMonitorGroupRequest = {
  groupId: long(name='GroupId'),
}

model DeleteMonitorGroupResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: integer(name='Code'),
  message: string(name='Message'),
  group: {
    groupName: string(name='GroupName'),
    contactGroups: {
      contactGroup: [
        {
          name: string(name='Name'),
        }
      ](name='ContactGroup'),
    }(name='ContactGroups'),
  }(name='Group'),
}

async function deleteMonitorGroupWithOptions(request: DeleteMonitorGroupRequest, runtime: Util.RuntimeOptions): DeleteMonitorGroupResponse {
  Util.validateModel(request);
  return doRequest('DeleteMonitorGroup', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteMonitorGroup(request: DeleteMonitorGroupRequest): DeleteMonitorGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMonitorGroupWithOptions(request, runtime);
}

model CreateMonitorGroupRequest = {
  groupName: string(name='GroupName'),
  contactGroups?: string(name='ContactGroups'),
}

model CreateMonitorGroupResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: integer(name='Code'),
  message: string(name='Message'),
  groupId: long(name='GroupId'),
}

async function createMonitorGroupWithOptions(request: CreateMonitorGroupRequest, runtime: Util.RuntimeOptions): CreateMonitorGroupResponse {
  Util.validateModel(request);
  return doRequest('CreateMonitorGroup', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function createMonitorGroup(request: CreateMonitorGroupRequest): CreateMonitorGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMonitorGroupWithOptions(request, runtime);
}

model DescribeMonitorGroupsRequest = {
  selectContactGroups?: boolean(name='SelectContactGroups'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  keyword?: string(name='Keyword'),
  instanceId?: string(name='InstanceId'),
  groupName?: string(name='GroupName'),
  includeTemplateHistory?: boolean(name='IncludeTemplateHistory'),
  tag?: [
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  type?: string(name='Type'),
  dynamicTagRuleId?: string(name='DynamicTagRuleId'),
  groupId?: string(name='GroupId'),
}

model DescribeMonitorGroupsResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: integer(name='Code'),
  message: string(name='Message'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  total: integer(name='Total'),
  resources: {
    resource: [
      {
        groupId: long(name='GroupId'),
        groupName: string(name='GroupName'),
        serviceId: string(name='ServiceId'),
        type: string(name='Type'),
        gmtModified: long(name='GmtModified'),
        gmtCreate: long(name='GmtCreate'),
        bindUrl: string(name='BindUrl'),
        dynamicTagRuleId: string(name='DynamicTagRuleId'),
        groupFounderTagKey: string(name='GroupFounderTagKey'),
        groupFounderTagValue: string(name='GroupFounderTagValue'),
        contactGroups: {
          contactGroup: [
            {
              name: string(name='Name'),
            }
          ](name='ContactGroup'),
        }(name='ContactGroups'),
        tags: {
          tag: [
            {
              key: string(name='Key'),
              value: string(name='Value'),
            }
          ](name='Tag'),
        }(name='Tags'),
        templateIds: {
          templateId: [ string ](name='TemplateId', description='TemplateId'),
        }(name='TemplateIds'),
      }
    ](name='Resource'),
  }(name='Resources'),
}

async function describeMonitorGroupsWithOptions(request: DescribeMonitorGroupsRequest, runtime: Util.RuntimeOptions): DescribeMonitorGroupsResponse {
  Util.validateModel(request);
  return doRequest('DescribeMonitorGroups', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMonitorGroups(request: DescribeMonitorGroupsRequest): DescribeMonitorGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitorGroupsWithOptions(request, runtime);
}

model DeleteMonitorGroupNotifyPolicyRequest = {
  policyType: string(name='PolicyType'),
  groupId?: string(name='GroupId'),
}

model DeleteMonitorGroupNotifyPolicyResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: string(name='Success'),
  requestId: string(name='RequestId'),
  result: integer(name='Result'),
}

async function deleteMonitorGroupNotifyPolicyWithOptions(request: DeleteMonitorGroupNotifyPolicyRequest, runtime: Util.RuntimeOptions): DeleteMonitorGroupNotifyPolicyResponse {
  Util.validateModel(request);
  return doRequest('DeleteMonitorGroupNotifyPolicy', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteMonitorGroupNotifyPolicy(request: DeleteMonitorGroupNotifyPolicyRequest): DeleteMonitorGroupNotifyPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMonitorGroupNotifyPolicyWithOptions(request, runtime);
}

model DescribeMonitorGroupDynamicRulesRequest = {
  groupId: long(name='GroupId'),
}

model DescribeMonitorGroupDynamicRulesResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: integer(name='Code'),
  message: string(name='Message'),
  resource: {
    resource: [
      {
        groupId: long(name='GroupId'),
        category: string(name='Category'),
        filterRelation: string(name='FilterRelation'),
        filters: {
          filter: [
            {
              function: string(name='Function'),
              name: string(name='Name'),
              value: string(name='Value'),
            }
          ](name='Filter'),
        }(name='Filters'),
      }
    ](name='Resource'),
  }(name='Resource'),
}

async function describeMonitorGroupDynamicRulesWithOptions(request: DescribeMonitorGroupDynamicRulesRequest, runtime: Util.RuntimeOptions): DescribeMonitorGroupDynamicRulesResponse {
  Util.validateModel(request);
  return doRequest('DescribeMonitorGroupDynamicRules', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMonitorGroupDynamicRules(request: DescribeMonitorGroupDynamicRulesRequest): DescribeMonitorGroupDynamicRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitorGroupDynamicRulesWithOptions(request, runtime);
}

model CreateMonitorGroupInstancesRequest = {
  groupId: long(name='GroupId'),
  instances: [
    {
      category: string(name='Category'),
      instanceId: string(name='InstanceId'),
      regionId: string(name='RegionId'),
      instanceName: string(name='InstanceName'),
    }
  ](name='Instances'),
}

model CreateMonitorGroupInstancesResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: integer(name='Code'),
  message: string(name='Message'),
}

async function createMonitorGroupInstancesWithOptions(request: CreateMonitorGroupInstancesRequest, runtime: Util.RuntimeOptions): CreateMonitorGroupInstancesResponse {
  Util.validateModel(request);
  return doRequest('CreateMonitorGroupInstances', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function createMonitorGroupInstances(request: CreateMonitorGroupInstancesRequest): CreateMonitorGroupInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMonitorGroupInstancesWithOptions(request, runtime);
}

model CreateMonitorGroupNotifyPolicyRequest = {
  policyType: string(name='PolicyType'),
  groupId: string(name='GroupId'),
  startTime: long(name='StartTime'),
  endTime: long(name='EndTime'),
}

model CreateMonitorGroupNotifyPolicyResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: string(name='Success'),
  requestId: string(name='RequestId'),
  result: integer(name='Result'),
}

async function createMonitorGroupNotifyPolicyWithOptions(request: CreateMonitorGroupNotifyPolicyRequest, runtime: Util.RuntimeOptions): CreateMonitorGroupNotifyPolicyResponse {
  Util.validateModel(request);
  return doRequest('CreateMonitorGroupNotifyPolicy', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function createMonitorGroupNotifyPolicy(request: CreateMonitorGroupNotifyPolicyRequest): CreateMonitorGroupNotifyPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMonitorGroupNotifyPolicyWithOptions(request, runtime);
}

model DeleteMonitorGroupInstancesRequest = {
  groupId: long(name='GroupId'),
  instanceIdList: string(name='InstanceIdList'),
  category: string(name='Category'),
}

model DeleteMonitorGroupInstancesResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: integer(name='Code'),
  message: string(name='Message'),
}

async function deleteMonitorGroupInstancesWithOptions(request: DeleteMonitorGroupInstancesRequest, runtime: Util.RuntimeOptions): DeleteMonitorGroupInstancesResponse {
  Util.validateModel(request);
  return doRequest('DeleteMonitorGroupInstances', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteMonitorGroupInstances(request: DeleteMonitorGroupInstancesRequest): DeleteMonitorGroupInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMonitorGroupInstancesWithOptions(request, runtime);
}

model DeleteMonitorGroupDynamicRuleRequest = {
  groupId: long(name='GroupId'),
  category: string(name='Category'),
}

model DeleteMonitorGroupDynamicRuleResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: integer(name='Code'),
  message: string(name='Message'),
}

async function deleteMonitorGroupDynamicRuleWithOptions(request: DeleteMonitorGroupDynamicRuleRequest, runtime: Util.RuntimeOptions): DeleteMonitorGroupDynamicRuleResponse {
  Util.validateModel(request);
  return doRequest('DeleteMonitorGroupDynamicRule', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteMonitorGroupDynamicRule(request: DeleteMonitorGroupDynamicRuleRequest): DeleteMonitorGroupDynamicRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMonitorGroupDynamicRuleWithOptions(request, runtime);
}

model PutMonitorGroupDynamicRuleRequest = {
  groupId: long(name='GroupId'),
  groupRules: [
    {
      category: string(name='Category'),
      filterRelation: string(name='FilterRelation'),
      filters: [
        {
          name: string(name='Name'),
          function: string(name='Function'),
          value: string(name='Value'),
        }
      ](name='Filters'),
    }
  ](name='GroupRules'),
}

model PutMonitorGroupDynamicRuleResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: integer(name='Code'),
  message: string(name='Message'),
}

async function putMonitorGroupDynamicRuleWithOptions(request: PutMonitorGroupDynamicRuleRequest, runtime: Util.RuntimeOptions): PutMonitorGroupDynamicRuleResponse {
  Util.validateModel(request);
  return doRequest('PutMonitorGroupDynamicRule', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function putMonitorGroupDynamicRule(request: PutMonitorGroupDynamicRuleRequest): PutMonitorGroupDynamicRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return putMonitorGroupDynamicRuleWithOptions(request, runtime);
}

model DescribeMonitorGroupInstancesRequest = {
  pageSize?: integer(name='PageSize'),
  pageNumber?: integer(name='PageNumber'),
  groupId: long(name='GroupId'),
  category?: string(name='Category'),
  keyword?: string(name='Keyword'),
  instanceIds?: string(name='InstanceIds'),
}

model DescribeMonitorGroupInstancesResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: integer(name='Code'),
  message: string(name='Message'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  total: integer(name='Total'),
  resources: {
    resource: [
      {
        id: long(name='Id'),
        regionId: string(name='RegionId'),
        instanceId: string(name='InstanceId'),
        category: string(name='Category'),
        instanceName: string(name='InstanceName'),
      }
    ](name='Resource'),
  }(name='Resources'),
}

async function describeMonitorGroupInstancesWithOptions(request: DescribeMonitorGroupInstancesRequest, runtime: Util.RuntimeOptions): DescribeMonitorGroupInstancesResponse {
  Util.validateModel(request);
  return doRequest('DescribeMonitorGroupInstances', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMonitorGroupInstances(request: DescribeMonitorGroupInstancesRequest): DescribeMonitorGroupInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitorGroupInstancesWithOptions(request, runtime);
}

model DescribeMonitorGroupCategoriesRequest = {
  groupId: long(name='GroupId'),
}

model DescribeMonitorGroupCategoriesResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: integer(name='Code'),
  message: string(name='Message'),
  monitorGroupCategories: {
    groupId: long(name='GroupId'),
    monitorGroupCategory: {
      categoryItem: [
        {
          category: string(name='Category'),
          count: integer(name='Count'),
        }
      ](name='CategoryItem'),
    }(name='MonitorGroupCategory'),
  }(name='MonitorGroupCategories'),
}

async function describeMonitorGroupCategoriesWithOptions(request: DescribeMonitorGroupCategoriesRequest, runtime: Util.RuntimeOptions): DescribeMonitorGroupCategoriesResponse {
  Util.validateModel(request);
  return doRequest('DescribeMonitorGroupCategories', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMonitorGroupCategories(request: DescribeMonitorGroupCategoriesRequest): DescribeMonitorGroupCategoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitorGroupCategoriesWithOptions(request, runtime);
}

model ModifyMonitorGroupRequest = {
  groupId: string(name='GroupId'),
  groupName?: string(name='GroupName'),
  contactGroups?: string(name='ContactGroups'),
}

model ModifyMonitorGroupResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: integer(name='Code'),
  message: string(name='Message'),
}

async function modifyMonitorGroupWithOptions(request: ModifyMonitorGroupRequest, runtime: Util.RuntimeOptions): ModifyMonitorGroupResponse {
  Util.validateModel(request);
  return doRequest('ModifyMonitorGroup', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function modifyMonitorGroup(request: ModifyMonitorGroupRequest): ModifyMonitorGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyMonitorGroupWithOptions(request, runtime);
}

model DescribeMetricRuleListRequest = {
  metricName?: string(name='MetricName'),
  enableState?: boolean(name='EnableState'),
  namespace?: string(name='Namespace'),
  page?: string(name='Page'),
  pageSize?: string(name='PageSize'),
  alertState?: string(name='AlertState'),
  dimensions?: string(name='Dimensions'),
  ruleName?: string(name='RuleName'),
  groupId?: string(name='GroupId'),
  ruleIds?: string(name='RuleIds'),
}

model DescribeMetricRuleListResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: integer(name='Code'),
  message: string(name='Message'),
  total: string(name='Total'),
  alarms: {
    alarm: [
      {
        ruleId: string(name='RuleId'),
        namespace: string(name='Namespace'),
        metricName: string(name='MetricName'),
        period: string(name='Period'),
        effectiveInterval: string(name='EffectiveInterval'),
        noEffectiveInterval: string(name='NoEffectiveInterval'),
        silenceTime: string(name='SilenceTime'),
        enableState: boolean(name='EnableState'),
        alertState: string(name='AlertState'),
        contactGroups: string(name='ContactGroups'),
        webhook: string(name='Webhook'),
        mailSubject: string(name='MailSubject'),
        ruleName: string(name='RuleName'),
        resources: string(name='Resources'),
        groupId: string(name='GroupId'),
        groupName: string(name='GroupName'),
        dimensions: string(name='Dimensions'),
        sourceType: string(name='SourceType'),
        escalations: {
          info: {
            comparisonOperator: string(name='ComparisonOperator'),
            statistics: string(name='Statistics'),
            threshold: string(name='Threshold'),
            times: string(name='Times'),
          }(name='Info'),
          warn: {
            comparisonOperator: string(name='ComparisonOperator'),
            statistics: string(name='Statistics'),
            threshold: string(name='Threshold'),
            times: string(name='Times'),
          }(name='Warn'),
          critical: {
            comparisonOperator: string(name='ComparisonOperator'),
            statistics: string(name='Statistics'),
            threshold: string(name='Threshold'),
            times: string(name='Times'),
          }(name='Critical'),
        }(name='Escalations'),
      }
    ](name='Alarm'),
  }(name='Alarms'),
}

async function describeMetricRuleListWithOptions(request: DescribeMetricRuleListRequest, runtime: Util.RuntimeOptions): DescribeMetricRuleListResponse {
  Util.validateModel(request);
  return doRequest('DescribeMetricRuleList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMetricRuleList(request: DescribeMetricRuleListRequest): DescribeMetricRuleListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricRuleListWithOptions(request, runtime);
}

model PutResourceMetricRuleRequest = {
  ruleId: string(name='RuleId'),
  ruleName?: string(name='RuleName'),
  namespace: string(name='Namespace'),
  metricName: string(name='MetricName'),
  resources: string(name='Resources'),
  contactGroups: string(name='ContactGroups'),
  webhook?: string(name='Webhook'),
  effectiveInterval?: string(name='EffectiveInterval'),
  noEffectiveInterval?: string(name='NoEffectiveInterval'),
  silenceTime?: integer(name='SilenceTime'),
  period?: string(name='Period'),
  interval?: string(name='Interval'),
  emailSubject?: string(name='EmailSubject'),
  escalations?: {
    critical: {
      statistics?: string(name='Statistics'),
      comparisonOperator?: string(name='ComparisonOperator'),
      threshold?: string(name='Threshold'),
      times?: integer(name='Times'),
    }(name='Critical'),
    warn: {
      statistics?: string(name='Statistics'),
      comparisonOperator?: string(name='ComparisonOperator'),
      threshold?: string(name='Threshold'),
      times?: integer(name='Times'),
    }(name='Warn'),
    info: {
      statistics?: string(name='Statistics'),
      comparisonOperator?: string(name='ComparisonOperator'),
      threshold?: string(name='Threshold'),
      times?: integer(name='Times'),
    }(name='Info'),
  }(name='Escalations'),
}

model PutResourceMetricRuleResponse = {
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

async function putResourceMetricRuleWithOptions(request: PutResourceMetricRuleRequest, runtime: Util.RuntimeOptions): PutResourceMetricRuleResponse {
  Util.validateModel(request);
  return doRequest('PutResourceMetricRule', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function putResourceMetricRule(request: PutResourceMetricRuleRequest): PutResourceMetricRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return putResourceMetricRuleWithOptions(request, runtime);
}

model PutGroupMetricRuleRequest = {
  groupId: string(name='GroupId'),
  ruleId: string(name='RuleId'),
  category: string(name='Category'),
  ruleName?: string(name='RuleName'),
  namespace: string(name='Namespace'),
  metricName: string(name='MetricName'),
  dimensions?: string(name='Dimensions'),
  effectiveInterval?: string(name='EffectiveInterval'),
  noEffectiveInterval?: string(name='NoEffectiveInterval'),
  silenceTime?: integer(name='SilenceTime'),
  period?: string(name='Period'),
  interval?: string(name='Interval'),
  webhook?: string(name='Webhook'),
  emailSubject?: string(name='EmailSubject'),
  escalations?: {
    critical: {
      statistics?: string(name='Statistics'),
      comparisonOperator?: string(name='ComparisonOperator'),
      threshold?: string(name='Threshold'),
      times?: integer(name='Times'),
    }(name='Critical'),
    warn: {
      statistics?: string(name='Statistics'),
      comparisonOperator?: string(name='ComparisonOperator'),
      threshold?: string(name='Threshold'),
      times?: integer(name='Times'),
    }(name='Warn'),
    info: {
      statistics?: string(name='Statistics'),
      comparisonOperator?: string(name='ComparisonOperator'),
      threshold?: string(name='Threshold'),
      times?: integer(name='Times'),
    }(name='Info'),
  }(name='Escalations'),
}

model PutGroupMetricRuleResponse = {
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

async function putGroupMetricRuleWithOptions(request: PutGroupMetricRuleRequest, runtime: Util.RuntimeOptions): PutGroupMetricRuleResponse {
  Util.validateModel(request);
  return doRequest('PutGroupMetricRule', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function putGroupMetricRule(request: PutGroupMetricRuleRequest): PutGroupMetricRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return putGroupMetricRuleWithOptions(request, runtime);
}

model EnableMetricRulesRequest = {
  ruleId: [ string ](name='RuleId'),
}

model EnableMetricRulesResponse = {
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

async function enableMetricRulesWithOptions(request: EnableMetricRulesRequest, runtime: Util.RuntimeOptions): EnableMetricRulesResponse {
  Util.validateModel(request);
  return doRequest('EnableMetricRules', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function enableMetricRules(request: EnableMetricRulesRequest): EnableMetricRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableMetricRulesWithOptions(request, runtime);
}

model DescribeMetricRuleCountRequest = {
  namespace?: string(name='Namespace'),
  metricName?: string(name='MetricName'),
}

model DescribeMetricRuleCountResponse = {
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  metricRuleCount: {
    alarm: integer(name='Alarm'),
    disable: integer(name='Disable'),
    nodata: integer(name='Nodata'),
    ok: integer(name='Ok'),
    total: integer(name='Total'),
  }(name='MetricRuleCount'),
}

async function describeMetricRuleCountWithOptions(request: DescribeMetricRuleCountRequest, runtime: Util.RuntimeOptions): DescribeMetricRuleCountResponse {
  Util.validateModel(request);
  return doRequest('DescribeMetricRuleCount', 'HTTPS', 'GET', '2019-01-01', 'AK', request, null, runtime);
}

async function describeMetricRuleCount(request: DescribeMetricRuleCountRequest): DescribeMetricRuleCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricRuleCountWithOptions(request, runtime);
}

model CreateGroupMetricRulesRequest = {
  groupId: long(name='GroupId'),
  groupMetricRules?: [
    {
      category: string(name='Category'),
      ruleName: string(name='RuleName'),
      ruleId: string(name='RuleId'),
      namespace: string(name='Namespace'),
      metricName: string(name='MetricName'),
      dimensions?: string(name='Dimensions'),
      effectiveInterval?: string(name='EffectiveInterval'),
      noEffectiveInterval?: string(name='NoEffectiveInterval'),
      silenceTime?: integer(name='SilenceTime'),
      period?: string(name='Period'),
      interval?: string(name='Interval'),
      webhook?: string(name='Webhook'),
      emailSubject?: string(name='EmailSubject'),
      escalations?: {
        critical: {
          statistics?: string(name='Statistics'),
          comparisonOperator?: string(name='ComparisonOperator'),
          threshold?: string(name='Threshold'),
          times?: integer(name='Times'),
        }(name='Critical'),
        warn: {
          statistics?: string(name='Statistics'),
          comparisonOperator?: string(name='ComparisonOperator'),
          threshold?: string(name='Threshold'),
          times?: integer(name='Times'),
        }(name='Warn'),
        info: {
          statistics?: string(name='Statistics'),
          comparisonOperator?: string(name='ComparisonOperator'),
          threshold?: string(name='Threshold'),
          times?: integer(name='Times'),
        }(name='Info'),
      }(name='Escalations'),
    }
  ](name='GroupMetricRules'),
}

model CreateGroupMetricRulesResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: integer(name='Code'),
  message: string(name='Message'),
  resources: {
    alertResult: [
      {
        ruleId: string(name='RuleId'),
        ruleName: string(name='RuleName'),
        message: string(name='Message'),
        code: integer(name='Code'),
        success: boolean(name='Success'),
      }
    ](name='AlertResult'),
  }(name='Resources'),
}

async function createGroupMetricRulesWithOptions(request: CreateGroupMetricRulesRequest, runtime: Util.RuntimeOptions): CreateGroupMetricRulesResponse {
  Util.validateModel(request);
  return doRequest('CreateGroupMetricRules', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function createGroupMetricRules(request: CreateGroupMetricRulesRequest): CreateGroupMetricRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGroupMetricRulesWithOptions(request, runtime);
}

model DisableMetricRulesRequest = {
  ruleId: [ string ](name='RuleId'),
}

model DisableMetricRulesResponse = {
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

async function disableMetricRulesWithOptions(request: DisableMetricRulesRequest, runtime: Util.RuntimeOptions): DisableMetricRulesResponse {
  Util.validateModel(request);
  return doRequest('DisableMetricRules', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function disableMetricRules(request: DisableMetricRulesRequest): DisableMetricRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableMetricRulesWithOptions(request, runtime);
}

model DeleteMetricRulesRequest = {
  id: [ string ](name='Id'),
}

model DeleteMetricRulesResponse = {
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

async function deleteMetricRulesWithOptions(request: DeleteMetricRulesRequest, runtime: Util.RuntimeOptions): DeleteMetricRulesResponse {
  Util.validateModel(request);
  return doRequest('DeleteMetricRules', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteMetricRules(request: DeleteMetricRulesRequest): DeleteMetricRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMetricRulesWithOptions(request, runtime);
}

model ModifyMetricRuleTemplateRequest = {
  templateId: long(name='TemplateId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  restVersion: long(name='RestVersion'),
  alertTemplates?: [
    {
      metricName: string(name='MetricName'),
      ruleName: string(name='RuleName'),
      category: string(name='Category'),
      namespace: string(name='Namespace'),
      period: integer(name='Period'),
      selector: string(name='Selector'),
      webhook: string(name='Webhook'),
      escalations?: {
        critical: {
          statistics: string(name='Statistics'),
          comparisonOperator: string(name='ComparisonOperator'),
          threshold: string(name='Threshold'),
          times: integer(name='Times'),
        }(name='Critical'),
        warn: {
          statistics: string(name='Statistics'),
          comparisonOperator: string(name='ComparisonOperator'),
          threshold: string(name='Threshold'),
          times: integer(name='Times'),
        }(name='Warn'),
        info: {
          statistics: string(name='Statistics'),
          comparisonOperator: string(name='ComparisonOperator'),
          threshold: string(name='Threshold'),
          times: integer(name='Times'),
        }(name='Info'),
      }(name='Escalations'),
    }
  ](name='AlertTemplates'),
}

model ModifyMetricRuleTemplateResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: integer(name='Code'),
  message: string(name='Message'),
}

async function modifyMetricRuleTemplateWithOptions(request: ModifyMetricRuleTemplateRequest, runtime: Util.RuntimeOptions): ModifyMetricRuleTemplateResponse {
  Util.validateModel(request);
  return doRequest('ModifyMetricRuleTemplate', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function modifyMetricRuleTemplate(request: ModifyMetricRuleTemplateRequest): ModifyMetricRuleTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyMetricRuleTemplateWithOptions(request, runtime);
}

model ApplyMetricRuleTemplateRequest = {
  silenceTime?: long(name='SilenceTime'),
  groupId: long(name='GroupId'),
  templateIds: string(name='TemplateIds'),
  enableStartTime?: long(name='EnableStartTime'),
  enableEndTime?: long(name='EnableEndTime'),
  notifyLevel?: long(name='NotifyLevel'),
  applyMode?: string(name='ApplyMode'),
  webhook?: string(name='Webhook'),
}

model ApplyMetricRuleTemplateResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: integer(name='Code'),
  message: string(name='Message'),
  resource: {
    groupId: long(name='GroupId'),
    alertResults: [
      {
        groupId: long(name='GroupId'),
        ruleId: string(name='RuleId'),
        message: string(name='Message'),
        ruleName: string(name='RuleName'),
        code: string(name='Code'),
        success: boolean(name='Success'),
      }
    ](name='AlertResults'),
  }(name='Resource'),
}

async function applyMetricRuleTemplateWithOptions(request: ApplyMetricRuleTemplateRequest, runtime: Util.RuntimeOptions): ApplyMetricRuleTemplateResponse {
  Util.validateModel(request);
  return doRequest('ApplyMetricRuleTemplate', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function applyMetricRuleTemplate(request: ApplyMetricRuleTemplateRequest): ApplyMetricRuleTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return applyMetricRuleTemplateWithOptions(request, runtime);
}

model DescribeMetricRuleTemplateAttributeRequest = {
  name?: string(name='Name'),
  templateId?: string(name='TemplateId'),
}

model DescribeMetricRuleTemplateAttributeResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: integer(name='Code'),
  message: string(name='Message'),
  resource: {
    name: string(name='Name'),
    templateId: string(name='TemplateId'),
    restVersion: string(name='RestVersion'),
    description: string(name='Description'),
    alertTemplates: {
      alertTemplate: [
        {
          ruleName: string(name='RuleName'),
          category: string(name='Category'),
          namespace: string(name='Namespace'),
          metricName: string(name='MetricName'),
          selector: string(name='Selector'),
          webhook: string(name='Webhook'),
          escalations: {
            info: {
              statistics: string(name='Statistics'),
              comparisonOperator: string(name='ComparisonOperator'),
              threshold: string(name='Threshold'),
              times: integer(name='Times'),
            }(name='Info'),
            warn: {
              statistics: string(name='Statistics'),
              comparisonOperator: string(name='ComparisonOperator'),
              threshold: string(name='Threshold'),
              times: integer(name='Times'),
            }(name='Warn'),
            critical: {
              statistics: string(name='Statistics'),
              comparisonOperator: string(name='ComparisonOperator'),
              threshold: string(name='Threshold'),
              times: integer(name='Times'),
            }(name='Critical'),
          }(name='Escalations'),
        }
      ](name='AlertTemplate'),
    }(name='AlertTemplates'),
  }(name='Resource'),
}

async function describeMetricRuleTemplateAttributeWithOptions(request: DescribeMetricRuleTemplateAttributeRequest, runtime: Util.RuntimeOptions): DescribeMetricRuleTemplateAttributeResponse {
  Util.validateModel(request);
  return doRequest('DescribeMetricRuleTemplateAttribute', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMetricRuleTemplateAttribute(request: DescribeMetricRuleTemplateAttributeRequest): DescribeMetricRuleTemplateAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricRuleTemplateAttributeWithOptions(request, runtime);
}

model CreateMetricRuleTemplateRequest = {
  name: string(name='Name'),
  description?: string(name='Description'),
  alertTemplates?: [
    {
      metricName: string(name='MetricName'),
      ruleName: string(name='RuleName'),
      category: string(name='Category'),
      namespace: string(name='Namespace'),
      period: integer(name='Period'),
      selector: string(name='Selector'),
      webhook: string(name='Webhook'),
      escalations?: {
        critical: {
          statistics: string(name='Statistics'),
          comparisonOperator: string(name='ComparisonOperator'),
          threshold: string(name='Threshold'),
          times: integer(name='Times'),
        }(name='Critical'),
        warn: {
          statistics: string(name='Statistics'),
          comparisonOperator: string(name='ComparisonOperator'),
          threshold: string(name='Threshold'),
          times: integer(name='Times'),
        }(name='Warn'),
        info: {
          statistics: string(name='Statistics'),
          comparisonOperator: string(name='ComparisonOperator'),
          threshold: string(name='Threshold'),
          times: integer(name='Times'),
        }(name='Info'),
      }(name='Escalations'),
    }
  ](name='AlertTemplates'),
}

model CreateMetricRuleTemplateResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: integer(name='Code'),
  message: string(name='Message'),
  id: long(name='Id'),
}

async function createMetricRuleTemplateWithOptions(request: CreateMetricRuleTemplateRequest, runtime: Util.RuntimeOptions): CreateMetricRuleTemplateResponse {
  Util.validateModel(request);
  return doRequest('CreateMetricRuleTemplate', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function createMetricRuleTemplate(request: CreateMetricRuleTemplateRequest): CreateMetricRuleTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMetricRuleTemplateWithOptions(request, runtime);
}

model DeleteMetricRuleTemplateRequest = {
  templateId: string(name='TemplateId'),
}

model DeleteMetricRuleTemplateResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: integer(name='Code'),
  message: string(name='Message'),
  resource: {
    templateId: string(name='TemplateId'),
  }(name='Resource'),
}

async function deleteMetricRuleTemplateWithOptions(request: DeleteMetricRuleTemplateRequest, runtime: Util.RuntimeOptions): DeleteMetricRuleTemplateResponse {
  Util.validateModel(request);
  return doRequest('DeleteMetricRuleTemplate', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteMetricRuleTemplate(request: DeleteMetricRuleTemplateRequest): DeleteMetricRuleTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMetricRuleTemplateWithOptions(request, runtime);
}

model DescribeMetricRuleTemplateListRequest = {
  name?: string(name='Name'),
  keyword?: string(name='Keyword'),
  templateId?: long(name='TemplateId'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  history?: boolean(name='History'),
}

model DescribeMetricRuleTemplateListResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: integer(name='Code'),
  message: string(name='Message'),
  total: long(name='Total'),
  templates: {
    template: [
      {
        name: string(name='Name'),
        description: string(name='Description'),
        restVersion: long(name='RestVersion'),
        templateId: long(name='TemplateId'),
        gmtCreate: long(name='GmtCreate'),
        gmtModified: long(name='GmtModified'),
        applyHistories: {
          applyHistory: [
            {
              groupId: long(name='GroupId'),
              groupName: string(name='GroupName'),
              applyTime: long(name='ApplyTime'),
            }
          ](name='ApplyHistory'),
        }(name='ApplyHistories'),
      }
    ](name='Template'),
  }(name='Templates'),
}

async function describeMetricRuleTemplateListWithOptions(request: DescribeMetricRuleTemplateListRequest, runtime: Util.RuntimeOptions): DescribeMetricRuleTemplateListResponse {
  Util.validateModel(request);
  return doRequest('DescribeMetricRuleTemplateList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMetricRuleTemplateList(request: DescribeMetricRuleTemplateListRequest): DescribeMetricRuleTemplateListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricRuleTemplateListWithOptions(request, runtime);
}

model PutCustomEventRequest = {
  eventInfo: [
    {
      eventName: string(name='EventName'),
      content: string(name='Content'),
      time: string(name='Time'),
      groupId: string(name='GroupId'),
    }
  ](name='EventInfo'),
}

model PutCustomEventResponse = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
}

async function putCustomEventWithOptions(request: PutCustomEventRequest, runtime: Util.RuntimeOptions): PutCustomEventResponse {
  Util.validateModel(request);
  return doRequest('PutCustomEvent', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function putCustomEvent(request: PutCustomEventRequest): PutCustomEventResponse {
  var runtime = new Util.RuntimeOptions{};
  return putCustomEventWithOptions(request, runtime);
}

model DescribeCustomEventCountRequest = {
  name?: string(name='Name'),
  eventId?: string(name='EventId'),
  groupId?: string(name='GroupId'),
  searchKeywords?: string(name='SearchKeywords'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
}

model DescribeCustomEventCountResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  customEventCounts: {
    customEventCount: [
      {
        name: string(name='Name'),
        num: integer(name='Num'),
        time: long(name='Time'),
      }
    ](name='CustomEventCount'),
  }(name='CustomEventCounts'),
}

async function describeCustomEventCountWithOptions(request: DescribeCustomEventCountRequest, runtime: Util.RuntimeOptions): DescribeCustomEventCountResponse {
  Util.validateModel(request);
  return doRequest('DescribeCustomEventCount', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeCustomEventCount(request: DescribeCustomEventCountRequest): DescribeCustomEventCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomEventCountWithOptions(request, runtime);
}

model DescribeCustomEventAttributeRequest = {
  name?: string(name='Name'),
  eventId?: string(name='EventId'),
  groupId?: string(name='GroupId'),
  searchKeywords?: string(name='SearchKeywords'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model DescribeCustomEventAttributeResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  success: string(name='Success'),
  customEvents: {
    customEvent: [
      {
        id: string(name='Id'),
        content: string(name='Content'),
        groupId: string(name='GroupId'),
        name: string(name='Name'),
        time: string(name='Time'),
      }
    ](name='CustomEvent'),
  }(name='CustomEvents'),
}

async function describeCustomEventAttributeWithOptions(request: DescribeCustomEventAttributeRequest, runtime: Util.RuntimeOptions): DescribeCustomEventAttributeResponse {
  Util.validateModel(request);
  return doRequest('DescribeCustomEventAttribute', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeCustomEventAttribute(request: DescribeCustomEventAttributeRequest): DescribeCustomEventAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomEventAttributeWithOptions(request, runtime);
}

model DescribeCustomEventHistogramRequest = {
  name?: string(name='Name'),
  level?: string(name='Level'),
  eventId?: string(name='EventId'),
  groupId?: string(name='GroupId'),
  searchKeywords?: string(name='SearchKeywords'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
}

model DescribeCustomEventHistogramResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  success: string(name='Success'),
  eventHistograms: {
    eventHistogram: [
      {
        count: long(name='Count'),
        startTime: long(name='StartTime'),
        endTime: long(name='EndTime'),
      }
    ](name='EventHistogram'),
  }(name='EventHistograms'),
}

async function describeCustomEventHistogramWithOptions(request: DescribeCustomEventHistogramRequest, runtime: Util.RuntimeOptions): DescribeCustomEventHistogramResponse {
  Util.validateModel(request);
  return doRequest('DescribeCustomEventHistogram', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeCustomEventHistogram(request: DescribeCustomEventHistogramRequest): DescribeCustomEventHistogramResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomEventHistogramWithOptions(request, runtime);
}

model DeleteCustomMetricRequest = {
  groupId: string(name='GroupId'),
  metricName: string(name='MetricName'),
  md5?: string(name='Md5'),
  UUID?: string(name='UUID'),
}

model DeleteCustomMetricResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

async function deleteCustomMetricWithOptions(request: DeleteCustomMetricRequest, runtime: Util.RuntimeOptions): DeleteCustomMetricResponse {
  Util.validateModel(request);
  return doRequest('DeleteCustomMetric', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteCustomMetric(request: DeleteCustomMetricRequest): DeleteCustomMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCustomMetricWithOptions(request, runtime);
}

model DescribeCustomMetricListRequest = {
  groupId: string(name='GroupId'),
  metricName?: string(name='MetricName'),
  dimension?: string(name='Dimension'),
  md5?: string(name='Md5'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
}

model DescribeCustomMetricListResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  result: string(name='Result'),
}

async function describeCustomMetricListWithOptions(request: DescribeCustomMetricListRequest, runtime: Util.RuntimeOptions): DescribeCustomMetricListResponse {
  Util.validateModel(request);
  return doRequest('DescribeCustomMetricList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeCustomMetricList(request: DescribeCustomMetricListRequest): DescribeCustomMetricListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomMetricListWithOptions(request, runtime);
}

model PutCustomMetricRequest = {
  metricList: [
    {
      groupId: string(name='GroupId'),
      metricName: string(name='MetricName'),
      dimensions: string(name='Dimensions'),
      time?: string(name='Time'),
      type?: string(name='Type'),
      period?: string(name='Period'),
      values: string(name='Values'),
    }
  ](name='MetricList'),
}

model PutCustomMetricResponse = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
}

async function putCustomMetricWithOptions(request: PutCustomMetricRequest, runtime: Util.RuntimeOptions): PutCustomMetricResponse {
  Util.validateModel(request);
  return doRequest('PutCustomMetric', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function putCustomMetric(request: PutCustomMetricRequest): PutCustomMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  return putCustomMetricWithOptions(request, runtime);
}

model DescribeEventRuleAttributeRequest = {
  ruleName: string(name='RuleName'),
}

model DescribeEventRuleAttributeResponse = {
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  result: {
    description: string(name='Description'),
    name: string(name='Name'),
    eventType: string(name='EventType'),
    groupId: string(name='GroupId'),
    state: string(name='State'),
    eventPattern: {
      product: string(name='Product'),
      nameList: {
        nameList: [ string ](name='NameList', description='NameList'),
      }(name='NameList'),
      statusList: {
        statusList: [ string ](name='StatusList', description='StatusList'),
      }(name='StatusList'),
      levelList: {
        levelList: [ string ](name='LevelList', description='LevelList'),
      }(name='LevelList'),
    }(name='EventPattern'),
  }(name='Result'),
}

async function describeEventRuleAttributeWithOptions(request: DescribeEventRuleAttributeRequest, runtime: Util.RuntimeOptions): DescribeEventRuleAttributeResponse {
  Util.validateModel(request);
  return doRequest('DescribeEventRuleAttribute', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeEventRuleAttribute(request: DescribeEventRuleAttributeRequest): DescribeEventRuleAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEventRuleAttributeWithOptions(request, runtime);
}

model DeleteContactGroupRequest = {
  contactGroupName: string(name='ContactGroupName'),
}

model DeleteContactGroupResponse = {
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

async function deleteContactGroupWithOptions(request: DeleteContactGroupRequest, runtime: Util.RuntimeOptions): DeleteContactGroupResponse {
  Util.validateModel(request);
  return doRequest('DeleteContactGroup', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteContactGroup(request: DeleteContactGroupRequest): DeleteContactGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteContactGroupWithOptions(request, runtime);
}

model DescribeContactListRequest = {
  pageSize?: integer(name='PageSize'),
  pageNumber?: integer(name='PageNumber'),
  contactName?: string(name='ContactName'),
  chanelType?: string(name='ChanelType'),
  chanelValue?: string(name='ChanelValue'),
}

model DescribeContactListResponse = {
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  total: integer(name='Total'),
  requestId: string(name='RequestId'),
  contacts: {
    contact: [
      {
        name: string(name='Name'),
        desc: string(name='Desc'),
        createTime: long(name='CreateTime'),
        updateTime: long(name='UpdateTime'),
        channels: {
          SMS: string(name='SMS'),
          mail: string(name='Mail'),
          aliIM: string(name='AliIM'),
          dingWebHook: string(name='DingWebHook'),
        }(name='Channels'),
        channelsState: {
          SMS: string(name='SMS'),
          mail: string(name='Mail'),
          aliIM: string(name='AliIM'),
          dingWebHook: string(name='DingWebHook'),
        }(name='ChannelsState'),
        contactGroups: {
          contactGroup: [ string ](name='ContactGroup', description='ContactGroup'),
        }(name='ContactGroups'),
      }
    ](name='Contact'),
  }(name='Contacts'),
}

async function describeContactListWithOptions(request: DescribeContactListRequest, runtime: Util.RuntimeOptions): DescribeContactListResponse {
  Util.validateModel(request);
  return doRequest('DescribeContactList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeContactList(request: DescribeContactListRequest): DescribeContactListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContactListWithOptions(request, runtime);
}

model DescribeContactListByContactGroupRequest = {
  contactGroupName: string(name='ContactGroupName'),
}

model DescribeContactListByContactGroupResponse = {
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  contacts: {
    contact: [
      {
        name: string(name='Name'),
        desc: string(name='Desc'),
        createTime: long(name='CreateTime'),
        updateTime: long(name='UpdateTime'),
        channels: {
          SMS: string(name='SMS'),
          mail: string(name='Mail'),
          aliIM: string(name='AliIM'),
          dingWebHook: string(name='DingWebHook'),
        }(name='Channels'),
      }
    ](name='Contact'),
  }(name='Contacts'),
}

async function describeContactListByContactGroupWithOptions(request: DescribeContactListByContactGroupRequest, runtime: Util.RuntimeOptions): DescribeContactListByContactGroupResponse {
  Util.validateModel(request);
  return doRequest('DescribeContactListByContactGroup', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeContactListByContactGroup(request: DescribeContactListByContactGroupRequest): DescribeContactListByContactGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContactListByContactGroupWithOptions(request, runtime);
}

model DeleteContactRequest = {
  contactName: string(name='ContactName'),
}

model DeleteContactResponse = {
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

async function deleteContactWithOptions(request: DeleteContactRequest, runtime: Util.RuntimeOptions): DeleteContactResponse {
  Util.validateModel(request);
  return doRequest('DeleteContact', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteContact(request: DeleteContactRequest): DeleteContactResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteContactWithOptions(request, runtime);
}

model PutContactGroupRequest = {
  contactGroupName: string(name='ContactGroupName'),
  describe?: string(name='Describe'),
  contactNames: [ string ](name='ContactNames'),
}

model PutContactGroupResponse = {
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

async function putContactGroupWithOptions(request: PutContactGroupRequest, runtime: Util.RuntimeOptions): PutContactGroupResponse {
  Util.validateModel(request);
  return doRequest('PutContactGroup', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function putContactGroup(request: PutContactGroupRequest): PutContactGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return putContactGroupWithOptions(request, runtime);
}

model PutContactRequest = {
  contactName: string(name='ContactName'),
  describe: string(name='Describe'),
  channels?: {
    SMS?: string(name='SMS'),
    mail?: string(name='Mail'),
    aliIM?: string(name='AliIM'),
    dingWebHook?: string(name='DingWebHook'),
  }(name='Channels'),
}

model PutContactResponse = {
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

async function putContactWithOptions(request: PutContactRequest, runtime: Util.RuntimeOptions): PutContactResponse {
  Util.validateModel(request);
  return doRequest('PutContact', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function putContact(request: PutContactRequest): PutContactResponse {
  var runtime = new Util.RuntimeOptions{};
  return putContactWithOptions(request, runtime);
}

model DescribeContactGroupListRequest = {
  pageSize?: integer(name='PageSize'),
  pageNumber?: integer(name='PageNumber'),
}

model DescribeContactGroupListResponse = {
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  total: integer(name='Total'),
  requestId: string(name='RequestId'),
  contactGroupList: {
    contactGroup: [
      {
        name: string(name='Name'),
        describe: string(name='Describe'),
        createTime: long(name='CreateTime'),
        updateTime: long(name='UpdateTime'),
        enabledWeeklyReport: boolean(name='EnabledWeeklyReport'),
        enableSubscribed: boolean(name='EnableSubscribed'),
        contacts: {
          contact: [ string ](name='Contact', description='Contact'),
        }(name='Contacts'),
      }
    ](name='ContactGroup'),
  }(name='ContactGroupList'),
  contactGroups: {
    contactGroup: [ string ](name='ContactGroup'),
  }(name='ContactGroups'),
}

async function describeContactGroupListWithOptions(request: DescribeContactGroupListRequest, runtime: Util.RuntimeOptions): DescribeContactGroupListResponse {
  Util.validateModel(request);
  return doRequest('DescribeContactGroupList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeContactGroupList(request: DescribeContactGroupListRequest): DescribeContactGroupListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContactGroupListWithOptions(request, runtime);
}

model PutEventRuleTargetsRequest = {
  ruleName: string(name='RuleName'),
  fcParameters?: [
    {
      id?: string(name='Id'),
      region?: string(name='Region'),
      serviceName?: string(name='ServiceName'),
      functionName?: string(name='FunctionName'),
    }
  ](name='FcParameters'),
  contactParameters?: [
    {
      id?: string(name='Id'),
      contactGroupName?: string(name='ContactGroupName'),
      level?: string(name='Level'),
    }
  ](name='ContactParameters'),
  mnsParameters?: [
    {
      id?: string(name='Id'),
      region?: string(name='Region'),
      queue?: string(name='Queue'),
    }
  ](name='MnsParameters'),
  webhookParameters?: [
    {
      id?: string(name='Id'),
      protocol?: string(name='Protocol'),
      url?: string(name='Url'),
      method?: string(name='Method'),
    }
  ](name='WebhookParameters'),
  slsParameters?: [
    {
      id?: string(name='Id'),
      region?: string(name='Region'),
      project?: string(name='Project'),
      logStore?: string(name='LogStore'),
    }
  ](name='SlsParameters'),
}

model PutEventRuleTargetsResponse = {
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  failedParameterCount: string(name='FailedParameterCount'),
  failedContactParameters: {
    contactParameter: [
      {
        id: integer(name='Id'),
        contactGroupName: string(name='ContactGroupName'),
        level: string(name='Level'),
      }
    ](name='ContactParameter'),
  }(name='FailedContactParameters'),
  failedMnsParameters: {
    mnsParameter: [
      {
        id: integer(name='Id'),
        region: string(name='Region'),
        queue: string(name='Queue'),
      }
    ](name='MnsParameter'),
  }(name='FailedMnsParameters'),
  failedFcParameters: {
    fcParameter: [
      {
        id: integer(name='Id'),
        region: string(name='Region'),
        serviceName: string(name='ServiceName'),
        functionName: string(name='FunctionName'),
      }
    ](name='FcParameter'),
  }(name='FailedFcParameters'),
}

async function putEventRuleTargetsWithOptions(request: PutEventRuleTargetsRequest, runtime: Util.RuntimeOptions): PutEventRuleTargetsResponse {
  Util.validateModel(request);
  return doRequest('PutEventRuleTargets', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function putEventRuleTargets(request: PutEventRuleTargetsRequest): PutEventRuleTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return putEventRuleTargetsWithOptions(request, runtime);
}

model DeleteEventRuleTargetsRequest = {
  ruleName: string(name='RuleName'),
  ids: [ string ](name='Ids'),
}

model DeleteEventRuleTargetsResponse = {
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

async function deleteEventRuleTargetsWithOptions(request: DeleteEventRuleTargetsRequest, runtime: Util.RuntimeOptions): DeleteEventRuleTargetsResponse {
  Util.validateModel(request);
  return doRequest('DeleteEventRuleTargets', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteEventRuleTargets(request: DeleteEventRuleTargetsRequest): DeleteEventRuleTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEventRuleTargetsWithOptions(request, runtime);
}

model DisableEventRulesRequest = {
  ruleNames: [ string ](name='RuleNames'),
}

model DisableEventRulesResponse = {
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

async function disableEventRulesWithOptions(request: DisableEventRulesRequest, runtime: Util.RuntimeOptions): DisableEventRulesResponse {
  Util.validateModel(request);
  return doRequest('DisableEventRules', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function disableEventRules(request: DisableEventRulesRequest): DisableEventRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableEventRulesWithOptions(request, runtime);
}

model DescribeEventRuleTargetListRequest = {
  ruleName: string(name='RuleName'),
}

model DescribeEventRuleTargetListResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  contactParameters: {
    contactParameter: [
      {
        contactGroupName: string(name='ContactGroupName'),
        level: string(name='Level'),
        id: string(name='Id'),
      }
    ](name='ContactParameter'),
  }(name='ContactParameters'),
  fcParameters: {
    FCParameter: [
      {
        region: string(name='Region'),
        serviceName: string(name='ServiceName'),
        functionName: string(name='FunctionName'),
        id: string(name='Id'),
        arn: string(name='Arn'),
      }
    ](name='FCParameter'),
  }(name='FcParameters'),
  mnsParameters: {
    mnsParameter: [
      {
        region: string(name='Region'),
        queue: string(name='Queue'),
        id: string(name='Id'),
        arn: string(name='Arn'),
      }
    ](name='MnsParameter'),
  }(name='MnsParameters'),
  webhookParameters: {
    webhookParameter: [
      {
        id: string(name='Id'),
        protocol: string(name='Protocol'),
        method: string(name='Method'),
        url: string(name='Url'),
      }
    ](name='WebhookParameter'),
  }(name='WebhookParameters'),
  slsParameters: {
    slsParameter: [
      {
        id: string(name='Id'),
        region: string(name='Region'),
        project: string(name='Project'),
        logStore: string(name='LogStore'),
        arn: string(name='Arn'),
      }
    ](name='SlsParameter'),
  }(name='SlsParameters'),
}

async function describeEventRuleTargetListWithOptions(request: DescribeEventRuleTargetListRequest, runtime: Util.RuntimeOptions): DescribeEventRuleTargetListResponse {
  Util.validateModel(request);
  return doRequest('DescribeEventRuleTargetList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeEventRuleTargetList(request: DescribeEventRuleTargetListRequest): DescribeEventRuleTargetListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEventRuleTargetListWithOptions(request, runtime);
}

model DeleteEventRulesRequest = {
  ruleNames: [ string ](name='RuleNames'),
}

model DeleteEventRulesResponse = {
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

async function deleteEventRulesWithOptions(request: DeleteEventRulesRequest, runtime: Util.RuntimeOptions): DeleteEventRulesResponse {
  Util.validateModel(request);
  return doRequest('DeleteEventRules', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteEventRules(request: DeleteEventRulesRequest): DeleteEventRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEventRulesWithOptions(request, runtime);
}

model EnableEventRulesRequest = {
  ruleNames: [ string ](name='RuleNames'),
}

model EnableEventRulesResponse = {
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
}

async function enableEventRulesWithOptions(request: EnableEventRulesRequest, runtime: Util.RuntimeOptions): EnableEventRulesResponse {
  Util.validateModel(request);
  return doRequest('EnableEventRules', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function enableEventRules(request: EnableEventRulesRequest): EnableEventRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableEventRulesWithOptions(request, runtime);
}

model PutEventRuleRequest = {
  ruleName: string(name='RuleName'),
  groupId?: string(name='GroupId'),
  eventType?: string(name='EventType'),
  description?: string(name='Description'),
  state?: string(name='State'),
  eventPattern: [
    {
      product: string(name='Product'),
      nameList: [ string ](name='NameList'),
      statusList: [ string ](name='StatusList'),
      levelList: [ string ](name='LevelList'),
      eventTypeList: [ string ](name='EventTypeList'),
    }
  ](name='EventPattern'),
}

model PutEventRuleResponse = {
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  data: string(name='Data'),
}

async function putEventRuleWithOptions(request: PutEventRuleRequest, runtime: Util.RuntimeOptions): PutEventRuleResponse {
  Util.validateModel(request);
  return doRequest('PutEventRule', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function putEventRule(request: PutEventRuleRequest): PutEventRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return putEventRuleWithOptions(request, runtime);
}

model DescribeEventRuleListRequest = {
  namePrefix?: string(name='NamePrefix'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  groupId?: string(name='GroupId'),
}

model DescribeEventRuleListResponse = {
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  total: integer(name='Total'),
  eventRules: {
    eventRule: [
      {
        name: string(name='Name'),
        groupId: string(name='GroupId'),
        eventType: string(name='EventType'),
        state: string(name='State'),
        description: string(name='Description'),
        eventPattern: {
          eventPattern: [
            {
              product: string(name='Product'),
              nameList: {
                nameList: [ string ](name='NameList', description='NameList'),
              }(name='NameList'),
              levelList: {
                levelList: [ string ](name='LevelList', description='LevelList'),
              }(name='LevelList'),
              eventTypeList: {
                eventTypeList: [ string ](name='EventTypeList', description='EventTypeList'),
              }(name='EventTypeList'),
            }
          ](name='EventPattern'),
        }(name='EventPattern'),
      }
    ](name='EventRule'),
  }(name='EventRules'),
}

async function describeEventRuleListWithOptions(request: DescribeEventRuleListRequest, runtime: Util.RuntimeOptions): DescribeEventRuleListResponse {
  Util.validateModel(request);
  return doRequest('DescribeEventRuleList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeEventRuleList(request: DescribeEventRuleListRequest): DescribeEventRuleListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEventRuleListWithOptions(request, runtime);
}

model DescribeSystemEventAttributeRequest = {
  product?: string(name='Product'),
  eventType?: string(name='EventType'),
  name?: string(name='Name'),
  level?: string(name='Level'),
  status?: string(name='Status'),
  groupId?: string(name='GroupId'),
  searchKeywords?: string(name='SearchKeywords'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model DescribeSystemEventAttributeResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  success: string(name='Success'),
  systemEvents: {
    systemEvent: [
      {
        content: string(name='Content'),
        product: string(name='Product'),
        name: string(name='Name'),
        groupId: string(name='GroupId'),
        level: string(name='Level'),
        status: string(name='Status'),
        resourceId: string(name='ResourceId'),
        regionId: string(name='RegionId'),
        instanceName: string(name='InstanceName'),
        time: long(name='Time'),
      }
    ](name='SystemEvent'),
  }(name='SystemEvents'),
}

async function describeSystemEventAttributeWithOptions(request: DescribeSystemEventAttributeRequest, runtime: Util.RuntimeOptions): DescribeSystemEventAttributeResponse {
  Util.validateModel(request);
  return doRequest('DescribeSystemEventAttribute', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeSystemEventAttribute(request: DescribeSystemEventAttributeRequest): DescribeSystemEventAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSystemEventAttributeWithOptions(request, runtime);
}

model DescribeSystemEventHistogramRequest = {
  product?: string(name='Product'),
  eventType?: string(name='EventType'),
  name?: string(name='Name'),
  level?: string(name='Level'),
  status?: string(name='Status'),
  groupId?: string(name='GroupId'),
  searchKeywords?: string(name='SearchKeywords'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
}

model DescribeSystemEventHistogramResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  success: string(name='Success'),
  systemEventHistograms: {
    systemEventHistogram: [
      {
        count: long(name='Count'),
        startTime: long(name='StartTime'),
        endTime: long(name='EndTime'),
      }
    ](name='SystemEventHistogram'),
  }(name='SystemEventHistograms'),
}

async function describeSystemEventHistogramWithOptions(request: DescribeSystemEventHistogramRequest, runtime: Util.RuntimeOptions): DescribeSystemEventHistogramResponse {
  Util.validateModel(request);
  return doRequest('DescribeSystemEventHistogram', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeSystemEventHistogram(request: DescribeSystemEventHistogramRequest): DescribeSystemEventHistogramResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSystemEventHistogramWithOptions(request, runtime);
}

model DescribeSystemEventCountRequest = {
  product?: string(name='Product'),
  eventType?: string(name='EventType'),
  name?: string(name='Name'),
  level?: string(name='Level'),
  status?: string(name='Status'),
  groupId?: string(name='GroupId'),
  searchKeywords?: string(name='SearchKeywords'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
}

model DescribeSystemEventCountResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  success: string(name='Success'),
  systemEventCounts: {
    systemEventCount: [
      {
        content: string(name='Content'),
        product: string(name='Product'),
        name: string(name='Name'),
        groupId: string(name='GroupId'),
        num: long(name='Num'),
        level: string(name='Level'),
        status: string(name='Status'),
        resourceId: string(name='ResourceId'),
        regionId: string(name='RegionId'),
        instanceName: string(name='InstanceName'),
        time: long(name='Time'),
      }
    ](name='SystemEventCount'),
  }(name='SystemEventCounts'),
}

async function describeSystemEventCountWithOptions(request: DescribeSystemEventCountRequest, runtime: Util.RuntimeOptions): DescribeSystemEventCountResponse {
  Util.validateModel(request);
  return doRequest('DescribeSystemEventCount', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeSystemEventCount(request: DescribeSystemEventCountRequest): DescribeSystemEventCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSystemEventCountWithOptions(request, runtime);
}

model DescribeSystemEventMetaListRequest = {
}

model DescribeSystemEventMetaListResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: integer(name='Code'),
  message: string(name='Message'),
  data: {
    resource: [
      {
        product: string(name='Product'),
        name: string(name='Name'),
        nameDesc: string(name='NameDesc'),
        level: string(name='Level'),
        status: string(name='Status'),
        statusDesc: string(name='StatusDesc'),
        eventType: string(name='EventType'),
      }
    ](name='Resource'),
  }(name='Data'),
}

async function describeSystemEventMetaListWithOptions(request: DescribeSystemEventMetaListRequest, runtime: Util.RuntimeOptions): DescribeSystemEventMetaListResponse {
  Util.validateModel(request);
  return doRequest('DescribeSystemEventMetaList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeSystemEventMetaList(request: DescribeSystemEventMetaListRequest): DescribeSystemEventMetaListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSystemEventMetaListWithOptions(request, runtime);
}

model DescribeMonitoringAgentProcessesRequest = {
  instanceId: string(name='InstanceId'),
}

model DescribeMonitoringAgentProcessesResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
  nodeProcesses: {
    nodeProcess: [
      {
        processId: long(name='ProcessId'),
        instanceId: string(name='InstanceId'),
        processName: string(name='ProcessName'),
        processUser: string(name='ProcessUser'),
        command: string(name='Command'),
        groupId: string(name='GroupId'),
      }
    ](name='NodeProcess'),
  }(name='NodeProcesses'),
}

async function describeMonitoringAgentProcessesWithOptions(request: DescribeMonitoringAgentProcessesRequest, runtime: Util.RuntimeOptions): DescribeMonitoringAgentProcessesResponse {
  Util.validateModel(request);
  return doRequest('DescribeMonitoringAgentProcesses', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMonitoringAgentProcesses(request: DescribeMonitoringAgentProcessesRequest): DescribeMonitoringAgentProcessesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitoringAgentProcessesWithOptions(request, runtime);
}

model UninstallMonitoringAgentRequest = {
  instanceId: string(name='InstanceId'),
}

model UninstallMonitoringAgentResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
}

async function uninstallMonitoringAgentWithOptions(request: UninstallMonitoringAgentRequest, runtime: Util.RuntimeOptions): UninstallMonitoringAgentResponse {
  Util.validateModel(request);
  return doRequest('UninstallMonitoringAgent', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function uninstallMonitoringAgent(request: UninstallMonitoringAgentRequest): UninstallMonitoringAgentResponse {
  var runtime = new Util.RuntimeOptions{};
  return uninstallMonitoringAgentWithOptions(request, runtime);
}

model DescribeMonitoringAgentAccessKeyRequest = {
}

model DescribeMonitoringAgentAccessKeyResponse = {
  code: integer(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
  accessKey: string(name='AccessKey'),
  secretKey: string(name='SecretKey'),
}

async function describeMonitoringAgentAccessKeyWithOptions(request: DescribeMonitoringAgentAccessKeyRequest, runtime: Util.RuntimeOptions): DescribeMonitoringAgentAccessKeyResponse {
  Util.validateModel(request);
  return doRequest('DescribeMonitoringAgentAccessKey', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMonitoringAgentAccessKey(request: DescribeMonitoringAgentAccessKeyRequest): DescribeMonitoringAgentAccessKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitoringAgentAccessKeyWithOptions(request, runtime);
}

model InstallMonitoringAgentRequest = {
  force?: boolean(name='Force'),
  instanceIds: [ string ](name='InstanceIds'),
}

model InstallMonitoringAgentResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
}

async function installMonitoringAgentWithOptions(request: InstallMonitoringAgentRequest, runtime: Util.RuntimeOptions): InstallMonitoringAgentResponse {
  Util.validateModel(request);
  return doRequest('InstallMonitoringAgent', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function installMonitoringAgent(request: InstallMonitoringAgentRequest): InstallMonitoringAgentResponse {
  var runtime = new Util.RuntimeOptions{};
  return installMonitoringAgentWithOptions(request, runtime);
}

model SendDryRunSystemEventRequest = {
  product: string(name='Product'),
  eventName: string(name='EventName'),
  groupId?: string(name='GroupId'),
  eventContent?: string(name='EventContent'),
}

model SendDryRunSystemEventResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  success: string(name='Success'),
}

async function sendDryRunSystemEventWithOptions(request: SendDryRunSystemEventRequest, runtime: Util.RuntimeOptions): SendDryRunSystemEventResponse {
  Util.validateModel(request);
  return doRequest('SendDryRunSystemEvent', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function sendDryRunSystemEvent(request: SendDryRunSystemEventRequest): SendDryRunSystemEventResponse {
  var runtime = new Util.RuntimeOptions{};
  return sendDryRunSystemEventWithOptions(request, runtime);
}

model CreateMonitoringAgentProcessRequest = {
  processName?: string(name='ProcessName'),
  instanceId: string(name='InstanceId'),
  processUser?: string(name='ProcessUser'),
}

model CreateMonitoringAgentProcessResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
  id: long(name='Id'),
}

async function createMonitoringAgentProcessWithOptions(request: CreateMonitoringAgentProcessRequest, runtime: Util.RuntimeOptions): CreateMonitoringAgentProcessResponse {
  Util.validateModel(request);
  return doRequest('CreateMonitoringAgentProcess', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function createMonitoringAgentProcess(request: CreateMonitoringAgentProcessRequest): CreateMonitoringAgentProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMonitoringAgentProcessWithOptions(request, runtime);
}

model DescribeMonitoringAgentConfigRequest = {
}

model DescribeMonitoringAgentConfigResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
  autoInstall: boolean(name='AutoInstall'),
  enableInstallAgentNewECS: boolean(name='EnableInstallAgentNewECS'),
  enableActiveAlert: string(name='EnableActiveAlert'),
}

async function describeMonitoringAgentConfigWithOptions(request: DescribeMonitoringAgentConfigRequest, runtime: Util.RuntimeOptions): DescribeMonitoringAgentConfigResponse {
  Util.validateModel(request);
  return doRequest('DescribeMonitoringAgentConfig', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMonitoringAgentConfig(request: DescribeMonitoringAgentConfigRequest): DescribeMonitoringAgentConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitoringAgentConfigWithOptions(request, runtime);
}

model DeleteMonitoringAgentProcessRequest = {
  instanceId: string(name='InstanceId'),
  processName?: string(name='ProcessName'),
  processId?: string(name='ProcessId'),
}

model DeleteMonitoringAgentProcessResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
}

async function deleteMonitoringAgentProcessWithOptions(request: DeleteMonitoringAgentProcessRequest, runtime: Util.RuntimeOptions): DeleteMonitoringAgentProcessResponse {
  Util.validateModel(request);
  return doRequest('DeleteMonitoringAgentProcess', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteMonitoringAgentProcess(request: DeleteMonitoringAgentProcessRequest): DeleteMonitoringAgentProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMonitoringAgentProcessWithOptions(request, runtime);
}

model DescribeMonitoringAgentHostsRequest = {
  keyWord?: string(name='KeyWord'),
  hostName?: string(name='HostName'),
  instanceIds?: string(name='InstanceIds'),
  serialNumbers?: string(name='SerialNumbers'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  instanceRegionId?: string(name='InstanceRegionId'),
  aliyunHost?: boolean(name='AliyunHost'),
}

model DescribeMonitoringAgentHostsResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
  pageTotal: integer(name='PageTotal'),
  total: integer(name='Total'),
  hosts: {
    host: [
      {
        instanceId: string(name='InstanceId'),
        serialNumber: string(name='SerialNumber'),
        hostName: string(name='HostName'),
        aliUid: long(name='AliUid'),
        operatingSystem: string(name='OperatingSystem'),
        ipGroup: string(name='IpGroup'),
        region: string(name='Region'),
        agentVersion: string(name='AgentVersion'),
        eipAddress: string(name='EipAddress'),
        eipId: string(name='EipId'),
        isAliyunHost: boolean(name='isAliyunHost'),
        natIp: string(name='NatIp'),
        networkType: string(name='NetworkType'),
        instanceTypeFamily: string(name='InstanceTypeFamily'),
      }
    ](name='Host'),
  }(name='Hosts'),
}

async function describeMonitoringAgentHostsWithOptions(request: DescribeMonitoringAgentHostsRequest, runtime: Util.RuntimeOptions): DescribeMonitoringAgentHostsResponse {
  Util.validateModel(request);
  return doRequest('DescribeMonitoringAgentHosts', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMonitoringAgentHosts(request: DescribeMonitoringAgentHostsRequest): DescribeMonitoringAgentHostsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitoringAgentHostsWithOptions(request, runtime);
}

model DescribeSiteMonitorDataRequest = {
  taskId: string(name='TaskId'),
  type?: string(name='Type'),
  metricName: string(name='MetricName'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
  period?: string(name='Period'),
  nextToken?: string(name='NextToken'),
  length?: integer(name='Length'),
}

model DescribeSiteMonitorDataResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: string(name='Success'),
  requestId: string(name='RequestId'),
  nextToken: string(name='NextToken'),
  data: string(name='Data'),
}

async function describeSiteMonitorDataWithOptions(request: DescribeSiteMonitorDataRequest, runtime: Util.RuntimeOptions): DescribeSiteMonitorDataResponse {
  Util.validateModel(request);
  return doRequest('DescribeSiteMonitorData', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeSiteMonitorData(request: DescribeSiteMonitorDataRequest): DescribeSiteMonitorDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSiteMonitorDataWithOptions(request, runtime);
}

model ModifySiteMonitorRequest = {
  address?: string(name='Address'),
  taskId: string(name='TaskId'),
  taskName?: string(name='TaskName'),
  interval?: string(name='Interval'),
  ispCities?: string(name='IspCities'),
  optionsJson?: string(name='OptionsJson'),
  alertIds?: string(name='AlertIds'),
}

model ModifySiteMonitorResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: string(name='Success'),
  requestId: string(name='RequestId'),
  data: {
    count: integer(name='count'),
  }(name='Data'),
}

async function modifySiteMonitorWithOptions(request: ModifySiteMonitorRequest, runtime: Util.RuntimeOptions): ModifySiteMonitorResponse {
  Util.validateModel(request);
  return doRequest('ModifySiteMonitor', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function modifySiteMonitor(request: ModifySiteMonitorRequest): ModifySiteMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySiteMonitorWithOptions(request, runtime);
}

model DescribeSiteMonitorISPCityListRequest = {
  isp?: string(name='Isp'),
  city?: string(name='City'),
}

model DescribeSiteMonitorISPCityListResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: string(name='Success'),
  requestId: string(name='RequestId'),
  ispCityList: {
    ispCity: [
      {
        isp: string(name='Isp'),
        city: string(name='City'),
        region: string(name='Region'),
        country: string(name='Country'),
        ispName: {
          en: string(name='en'),
          zhCN: string(name='zh_CN'),
        }(name='IspName'),
        cityName: {
          en: string(name='en'),
          zhCN: string(name='zh_CN'),
        }(name='CityName'),
      }
    ](name='IspCity'),
  }(name='IspCityList'),
}

async function describeSiteMonitorISPCityListWithOptions(request: DescribeSiteMonitorISPCityListRequest, runtime: Util.RuntimeOptions): DescribeSiteMonitorISPCityListResponse {
  Util.validateModel(request);
  return doRequest('DescribeSiteMonitorISPCityList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeSiteMonitorISPCityList(request: DescribeSiteMonitorISPCityListRequest): DescribeSiteMonitorISPCityListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSiteMonitorISPCityListWithOptions(request, runtime);
}

model DescribeSiteMonitorQuotaRequest = {
}

model DescribeSiteMonitorQuotaResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: string(name='Success'),
  requestId: string(name='RequestId'),
  data: {
    siteMonitorIdcQuota: integer(name='SiteMonitorIdcQuota'),
    siteMonitorOperatorQuotaQuota: integer(name='SiteMonitorOperatorQuotaQuota'),
    siteMonitorTaskQuota: integer(name='SiteMonitorTaskQuota'),
    siteMonitorQuotaTaskUsed: integer(name='SiteMonitorQuotaTaskUsed'),
    siteMonitorVersion: string(name='SiteMonitorVersion'),
    secondMonitor: boolean(name='SecondMonitor'),
  }(name='Data'),
}

async function describeSiteMonitorQuotaWithOptions(request: DescribeSiteMonitorQuotaRequest, runtime: Util.RuntimeOptions): DescribeSiteMonitorQuotaResponse {
  Util.validateModel(request);
  return doRequest('DescribeSiteMonitorQuota', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeSiteMonitorQuota(request: DescribeSiteMonitorQuotaRequest): DescribeSiteMonitorQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSiteMonitorQuotaWithOptions(request, runtime);
}

model DescribeSiteMonitorStatisticsRequest = {
  taskId: string(name='TaskId'),
  timeRange?: string(name='TimeRange'),
  startTime?: string(name='StartTime'),
  metricName: string(name='MetricName'),
}

model DescribeSiteMonitorStatisticsResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: string(name='Success'),
  requestId: string(name='RequestId'),
  data: string(name='Data'),
}

async function describeSiteMonitorStatisticsWithOptions(request: DescribeSiteMonitorStatisticsRequest, runtime: Util.RuntimeOptions): DescribeSiteMonitorStatisticsResponse {
  Util.validateModel(request);
  return doRequest('DescribeSiteMonitorStatistics', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeSiteMonitorStatistics(request: DescribeSiteMonitorStatisticsRequest): DescribeSiteMonitorStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSiteMonitorStatisticsWithOptions(request, runtime);
}

model EnableSiteMonitorsRequest = {
  taskIds: string(name='TaskIds'),
}

model EnableSiteMonitorsResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: string(name='Success'),
  requestId: string(name='RequestId'),
  data: {
    count: integer(name='count'),
  }(name='Data'),
}

async function enableSiteMonitorsWithOptions(request: EnableSiteMonitorsRequest, runtime: Util.RuntimeOptions): EnableSiteMonitorsResponse {
  Util.validateModel(request);
  return doRequest('EnableSiteMonitors', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function enableSiteMonitors(request: EnableSiteMonitorsRequest): EnableSiteMonitorsResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableSiteMonitorsWithOptions(request, runtime);
}

model DescribeSiteMonitorAttributeRequest = {
  taskId: string(name='TaskId'),
  includeAlert?: boolean(name='IncludeAlert'),
}

model DescribeSiteMonitorAttributeResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
  metricRules: {
    metricRule: [
      {
        ruleId: string(name='RuleId'),
        ruleName: string(name='RuleName'),
        namespace: string(name='Namespace'),
        metricName: string(name='MetricName'),
        okActions: string(name='OkActions'),
        alarmActions: string(name='AlarmActions'),
        statistics: string(name='Statistics'),
        actionEnable: string(name='ActionEnable'),
        period: string(name='Period'),
        comparisonOperator: string(name='ComparisonOperator'),
        threshold: string(name='Threshold'),
        evaluationCount: string(name='EvaluationCount'),
        level: string(name='Level'),
        expression: string(name='Expression'),
        stateValue: string(name='StateValue'),
        dimensions: string(name='Dimensions'),
      }
    ](name='MetricRule'),
  }(name='MetricRules'),
  siteMonitors: {
    taskType: string(name='TaskType'),
    address: string(name='Address'),
    taskState: string(name='TaskState'),
    taskName: string(name='TaskName'),
    interval: string(name='Interval'),
    taskId: string(name='TaskId'),
    ispCities: {
      ispCity: [
        {
          cityName: string(name='CityName'),
          ispName: string(name='IspName'),
          city: string(name='City'),
          isp: string(name='Isp'),
        }
      ](name='IspCity'),
    }(name='IspCities'),
    optionJson: {
      dnsType: string(name='dns_type'),
      dnsServer: string(name='dns_server'),
      expectValue: string(name='expect_value'),
      httpMethod: string(name='http_method'),
      responseContent: string(name='response_content'),
      matchRule: integer(name='match_rule'),
      requestContent: string(name='request_content'),
      cookie: string(name='cookie'),
      header: string(name='header'),
      username: string(name='username'),
      password: string(name='password'),
      timeOut: long(name='time_out'),
      pingNum: integer(name='ping_num'),
      failureRate: float(name='failure_rate'),
      requestFormat: string(name='request_format'),
      responseFormat: string(name='response_format'),
      port: integer(name='port'),
      authentication: integer(name='authentication'),
      traceroute: long(name='traceroute'),
    }(name='OptionJson'),
  }(name='SiteMonitors'),
}

async function describeSiteMonitorAttributeWithOptions(request: DescribeSiteMonitorAttributeRequest, runtime: Util.RuntimeOptions): DescribeSiteMonitorAttributeResponse {
  Util.validateModel(request);
  return doRequest('DescribeSiteMonitorAttribute', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeSiteMonitorAttribute(request: DescribeSiteMonitorAttributeRequest): DescribeSiteMonitorAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSiteMonitorAttributeWithOptions(request, runtime);
}

model DescribeSiteMonitorListRequest = {
  taskId?: string(name='TaskId'),
  taskType?: string(name='TaskType'),
  keyword?: string(name='Keyword'),
  page?: integer(name='Page'),
  pageSize?: integer(name='PageSize'),
}

model DescribeSiteMonitorListResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: string(name='Success'),
  requestId: string(name='RequestId'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  totalCount: integer(name='TotalCount'),
  siteMonitors: {
    siteMonitor: [
      {
        taskId: string(name='TaskId'),
        taskType: string(name='TaskType'),
        address: string(name='Address'),
        taskState: string(name='TaskState'),
        createTime: string(name='CreateTime'),
        taskName: string(name='TaskName'),
        interval: string(name='Interval'),
        updateTime: string(name='UpdateTime'),
        optionsJson: {
          dnsType: string(name='dns_type'),
          dnsServer: string(name='dns_server'),
          expectValue: string(name='expect_value'),
          httpMethod: string(name='http_method'),
          responseContent: string(name='response_content'),
          matchRule: integer(name='match_rule'),
          requestContent: string(name='request_content'),
          cookie: string(name='cookie'),
          header: string(name='header'),
          username: string(name='username'),
          password: string(name='password'),
          timeOut: long(name='time_out'),
          pingNum: integer(name='ping_num'),
          failureRate: float(name='failure_rate'),
          requestFormat: string(name='request_format'),
          responseFormat: string(name='response_format'),
          port: integer(name='port'),
          authentication: integer(name='authentication'),
          traceroute: long(name='traceroute'),
        }(name='OptionsJson'),
      }
    ](name='SiteMonitor'),
  }(name='SiteMonitors'),
}

async function describeSiteMonitorListWithOptions(request: DescribeSiteMonitorListRequest, runtime: Util.RuntimeOptions): DescribeSiteMonitorListResponse {
  Util.validateModel(request);
  return doRequest('DescribeSiteMonitorList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeSiteMonitorList(request: DescribeSiteMonitorListRequest): DescribeSiteMonitorListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSiteMonitorListWithOptions(request, runtime);
}

model DeleteSiteMonitorsRequest = {
  taskIds: string(name='TaskIds'),
  isDeleteAlarms?: boolean(name='IsDeleteAlarms'),
}

model DeleteSiteMonitorsResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: string(name='Success'),
  requestId: string(name='RequestId'),
  data: {
    count: integer(name='count'),
  }(name='Data'),
}

async function deleteSiteMonitorsWithOptions(request: DeleteSiteMonitorsRequest, runtime: Util.RuntimeOptions): DeleteSiteMonitorsResponse {
  Util.validateModel(request);
  return doRequest('DeleteSiteMonitors', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteSiteMonitors(request: DeleteSiteMonitorsRequest): DeleteSiteMonitorsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSiteMonitorsWithOptions(request, runtime);
}

model DisableSiteMonitorsRequest = {
  taskIds: string(name='TaskIds'),
}

model DisableSiteMonitorsResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: string(name='Success'),
  requestId: string(name='RequestId'),
  data: {
    count: integer(name='count'),
  }(name='Data'),
}

async function disableSiteMonitorsWithOptions(request: DisableSiteMonitorsRequest, runtime: Util.RuntimeOptions): DisableSiteMonitorsResponse {
  Util.validateModel(request);
  return doRequest('DisableSiteMonitors', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function disableSiteMonitors(request: DisableSiteMonitorsRequest): DisableSiteMonitorsResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableSiteMonitorsWithOptions(request, runtime);
}

model CreateSiteMonitorRequest = {
  address: string(name='Address'),
  taskType: string(name='TaskType'),
  taskName: string(name='TaskName'),
  interval?: string(name='Interval'),
  ispCities?: string(name='IspCities'),
  optionsJson?: string(name='OptionsJson'),
  alertIds?: string(name='AlertIds'),
}

model CreateSiteMonitorResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: string(name='Success'),
  requestId: string(name='RequestId'),
  alertRule: string(name='AlertRule'),
  data: {
    attachAlertResult: {
      contact: [
        {
          message: string(name='Message'),
          requestId: string(name='RequestId'),
          code: string(name='Code'),
          success: string(name='Success'),
          ruleId: string(name='RuleId'),
        }
      ](name='Contact'),
    }(name='AttachAlertResult'),
  }(name='Data'),
}

async function createSiteMonitorWithOptions(request: CreateSiteMonitorRequest, runtime: Util.RuntimeOptions): CreateSiteMonitorResponse {
  Util.validateModel(request);
  return doRequest('CreateSiteMonitor', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function createSiteMonitor(request: CreateSiteMonitorRequest): CreateSiteMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSiteMonitorWithOptions(request, runtime);
}

model DescribeProjectMetaRequest = {
  labels?: string(name='Labels'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model DescribeProjectMetaResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  total: string(name='Total'),
  pageNumber: string(name='PageNumber'),
  pageSize: string(name='PageSize'),
  resources: {
    resource: [
      {
        namespace: string(name='Namespace'),
        description: string(name='Description'),
        labels: string(name='Labels'),
      }
    ](name='Resource'),
  }(name='Resources'),
}

async function describeProjectMetaWithOptions(request: DescribeProjectMetaRequest, runtime: Util.RuntimeOptions): DescribeProjectMetaResponse {
  Util.validateModel(request);
  return doRequest('DescribeProjectMeta', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeProjectMeta(request: DescribeProjectMetaRequest): DescribeProjectMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeProjectMetaWithOptions(request, runtime);
}

model DescribeMetricListRequest = {
  namespace: string(name='Namespace'),
  metricName: string(name='MetricName'),
  period?: string(name='Period'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
  dimensions?: string(name='Dimensions'),
  nextToken?: string(name='NextToken'),
  length?: string(name='Length'),
  express?: string(name='Express'),
}

model DescribeMetricListResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  nextToken: string(name='NextToken'),
  datapoints: string(name='Datapoints'),
  period: string(name='Period'),
  success: boolean(name='Success'),
}

async function describeMetricListWithOptions(request: DescribeMetricListRequest, runtime: Util.RuntimeOptions): DescribeMetricListResponse {
  Util.validateModel(request);
  return doRequest('DescribeMetricList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMetricList(request: DescribeMetricListRequest): DescribeMetricListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricListWithOptions(request, runtime);
}

model DescribeMetricMetaListRequest = {
  namespace?: string(name='Namespace'),
  labels?: string(name='Labels'),
  metricName?: string(name='MetricName'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model DescribeMetricMetaListResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  totalCount: string(name='TotalCount'),
  resources: {
    resource: [
      {
        namespace: string(name='Namespace'),
        metricName: string(name='MetricName'),
        statistics: string(name='Statistics'),
        unit: string(name='Unit'),
        description: string(name='Description'),
        dimensions: string(name='Dimensions'),
        periods: string(name='Periods'),
        labels: string(name='Labels'),
      }
    ](name='Resource'),
  }(name='Resources'),
}

async function describeMetricMetaListWithOptions(request: DescribeMetricMetaListRequest, runtime: Util.RuntimeOptions): DescribeMetricMetaListResponse {
  Util.validateModel(request);
  return doRequest('DescribeMetricMetaList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMetricMetaList(request: DescribeMetricMetaListRequest): DescribeMetricMetaListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricMetaListWithOptions(request, runtime);
}

model DescribeMetricTopRequest = {
  period?: string(name='Period'),
  namespace: string(name='Namespace'),
  metricName: string(name='MetricName'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
  dimensions?: string(name='Dimensions'),
  orderby: string(name='Orderby'),
  orderDesc?: string(name='OrderDesc'),
  length?: string(name='Length'),
  express?: string(name='Express'),
}

model DescribeMetricTopResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  datapoints: string(name='Datapoints'),
  period: string(name='Period'),
}

async function describeMetricTopWithOptions(request: DescribeMetricTopRequest, runtime: Util.RuntimeOptions): DescribeMetricTopResponse {
  Util.validateModel(request);
  return doRequest('DescribeMetricTop', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMetricTop(request: DescribeMetricTopRequest): DescribeMetricTopResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricTopWithOptions(request, runtime);
}

model DescribeMetricDataRequest = {
  namespace: string(name='Namespace'),
  metricName: string(name='MetricName'),
  period?: string(name='Period'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
  dimensions?: string(name='Dimensions'),
  express?: string(name='Express'),
  length?: string(name='Length'),
}

model DescribeMetricDataResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  datapoints: string(name='Datapoints'),
  period: string(name='Period'),
}

async function describeMetricDataWithOptions(request: DescribeMetricDataRequest, runtime: Util.RuntimeOptions): DescribeMetricDataResponse {
  Util.validateModel(request);
  return doRequest('DescribeMetricData', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMetricData(request: DescribeMetricDataRequest): DescribeMetricDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricDataWithOptions(request, runtime);
}

model DescribeMetricLastRequest = {
  namespace: string(name='Namespace'),
  metricName: string(name='MetricName'),
  period?: string(name='Period'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
  dimensions?: string(name='Dimensions'),
  nextToken?: string(name='NextToken'),
  length?: string(name='Length'),
  express?: string(name='Express'),
}

model DescribeMetricLastResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  nextToken: string(name='NextToken'),
  datapoints: string(name='Datapoints'),
  period: string(name='Period'),
  success: boolean(name='Success'),
}

async function describeMetricLastWithOptions(request: DescribeMetricLastRequest, runtime: Util.RuntimeOptions): DescribeMetricLastResponse {
  Util.validateModel(request);
  return doRequest('DescribeMetricLast', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMetricLast(request: DescribeMetricLastRequest): DescribeMetricLastResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricLastWithOptions(request, runtime);
}

model EnableHostAvailabilityRequest = {
  id: [ long ](name='Id'),
}

model EnableHostAvailabilityResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
}

async function enableHostAvailabilityWithOptions(request: EnableHostAvailabilityRequest, runtime: Util.RuntimeOptions): EnableHostAvailabilityResponse {
  Util.validateModel(request);
  return doRequest('EnableHostAvailability', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function enableHostAvailability(request: EnableHostAvailabilityRequest): EnableHostAvailabilityResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableHostAvailabilityWithOptions(request, runtime);
}

model ModifyHostAvailabilityRequest = {
  groupId: long(name='GroupId'),
  id: long(name='Id'),
  taskName: string(name='TaskName'),
  taskScope?: string(name='TaskScope'),
  taskOption?: {
    httpURI?: string(name='HttpURI'),
    telnetOrPingHost?: string(name='TelnetOrPingHost'),
    httpResponseCharset?: string(name='HttpResponseCharset'),
    httpResponseMatchContent?: string(name='HttpResponseMatchContent'),
    httpMethod?: string(name='HttpMethod'),
    httpNegative?: boolean(name='HttpNegative'),
  }(name='TaskOption'),
  alertConfig?: {
    notifyType: integer(name='NotifyType'),
    startTime?: integer(name='StartTime'),
    endTime?: integer(name='EndTime'),
    silenceTime?: integer(name='SilenceTime'),
    webHook?: string(name='WebHook'),
  }(name='AlertConfig'),
  alertConfigEscalationList: [
    {
      metricName: string(name='MetricName'),
      aggregate: string(name='Aggregate'),
      times: integer(name='Times'),
      operator: string(name='Operator'),
      value: string(name='Value'),
    }
  ](name='AlertConfigEscalationList'),
  instanceList?: [ string ](name='InstanceList'),
}

model ModifyHostAvailabilityResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
}

async function modifyHostAvailabilityWithOptions(request: ModifyHostAvailabilityRequest, runtime: Util.RuntimeOptions): ModifyHostAvailabilityResponse {
  Util.validateModel(request);
  return doRequest('ModifyHostAvailability', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function modifyHostAvailability(request: ModifyHostAvailabilityRequest): ModifyHostAvailabilityResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyHostAvailabilityWithOptions(request, runtime);
}

model DisableHostAvailabilityRequest = {
  id: [ long ](name='Id'),
}

model DisableHostAvailabilityResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
}

async function disableHostAvailabilityWithOptions(request: DisableHostAvailabilityRequest, runtime: Util.RuntimeOptions): DisableHostAvailabilityResponse {
  Util.validateModel(request);
  return doRequest('DisableHostAvailability', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function disableHostAvailability(request: DisableHostAvailabilityRequest): DisableHostAvailabilityResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableHostAvailabilityWithOptions(request, runtime);
}

model DescribeUnhealthyHostAvailabilityRequest = {
  id?: [ long ](name='Id'),
}

model DescribeUnhealthyHostAvailabilityResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
  unhealthyList: {
    nodeTaskInstance: [
      {
        id: long(name='Id'),
        instanceList: {
          string: [ string ](name='String', description='String'),
        }(name='InstanceList'),
      }
    ](name='NodeTaskInstance'),
  }(name='UnhealthyList'),
}

async function describeUnhealthyHostAvailabilityWithOptions(request: DescribeUnhealthyHostAvailabilityRequest, runtime: Util.RuntimeOptions): DescribeUnhealthyHostAvailabilityResponse {
  Util.validateModel(request);
  return doRequest('DescribeUnhealthyHostAvailability', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeUnhealthyHostAvailability(request: DescribeUnhealthyHostAvailabilityRequest): DescribeUnhealthyHostAvailabilityResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUnhealthyHostAvailabilityWithOptions(request, runtime);
}

model CreateHostAvailabilityRequest = {
  groupId: long(name='GroupId'),
  taskName: string(name='TaskName'),
  taskScope?: string(name='TaskScope'),
  taskType: string(name='TaskType'),
  taskOption?: {
    httpURI?: string(name='HttpURI'),
    telnetOrPingHost?: string(name='TelnetOrPingHost'),
    httpResponseCharset?: string(name='HttpResponseCharset'),
    httpResponseMatchContent?: string(name='HttpResponseMatchContent'),
    httpMethod?: string(name='HttpMethod'),
    httpNegative?: boolean(name='HttpNegative'),
  }(name='TaskOption'),
  alertConfig?: {
    notifyType: integer(name='NotifyType'),
    startTime?: integer(name='StartTime'),
    endTime?: integer(name='EndTime'),
    silenceTime?: integer(name='SilenceTime'),
    webHook?: string(name='WebHook'),
  }(name='AlertConfig'),
  alertConfigEscalationList: [
    {
      metricName: string(name='MetricName'),
      aggregate: string(name='Aggregate'),
      times: integer(name='Times'),
      operator: string(name='Operator'),
      value: string(name='Value'),
    }
  ](name='AlertConfigEscalationList'),
  instanceList?: [ string ](name='InstanceList'),
}

model CreateHostAvailabilityResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
  taskId: long(name='TaskId'),
}

async function createHostAvailabilityWithOptions(request: CreateHostAvailabilityRequest, runtime: Util.RuntimeOptions): CreateHostAvailabilityResponse {
  Util.validateModel(request);
  return doRequest('CreateHostAvailability', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function createHostAvailability(request: CreateHostAvailabilityRequest): CreateHostAvailabilityResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHostAvailabilityWithOptions(request, runtime);
}

model DescribeHostAvailabilityListRequest = {
  id?: long(name='Id'),
  taskName?: string(name='TaskName'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  groupId?: long(name='GroupId'),
}

model DescribeHostAvailabilityListResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
  total: integer(name='Total'),
  taskList: {
    nodeTaskConfig: [
      {
        id: long(name='Id'),
        taskName: string(name='TaskName'),
        taskType: string(name='TaskType'),
        taskScope: string(name='TaskScope'),
        disabled: boolean(name='Disabled'),
        groupId: long(name='GroupId'),
        groupName: string(name='GroupName'),
        taskOption: {
          httpURI: string(name='HttpURI'),
          telnetOrPingHost: string(name='TelnetOrPingHost'),
          httpResponseCharset: string(name='HttpResponseCharset'),
          httpKeyword: string(name='HttpKeyword'),
          httpMethod: string(name='HttpMethod'),
          httpNegative: boolean(name='HttpNegative'),
        }(name='TaskOption'),
        alertConfig: {
          notifyType: integer(name='NotifyType'),
          startTime: integer(name='StartTime'),
          endTime: integer(name='EndTime'),
          silenceTime: integer(name='SilenceTime'),
          webHook: string(name='WebHook'),
          escalationList: {
            escalationList: [
              {
                metricName: string(name='MetricName'),
                aggregate: string(name='Aggregate'),
                operator: string(name='Operator'),
                value: string(name='Value'),
                times: string(name='Times'),
              }
            ](name='escalationList'),
          }(name='EscalationList'),
        }(name='AlertConfig'),
        instances: {
          instance: [ string ](name='Instance', description='Instance'),
        }(name='Instances'),
      }
    ](name='NodeTaskConfig'),
  }(name='TaskList'),
}

async function describeHostAvailabilityListWithOptions(request: DescribeHostAvailabilityListRequest, runtime: Util.RuntimeOptions): DescribeHostAvailabilityListResponse {
  Util.validateModel(request);
  return doRequest('DescribeHostAvailabilityList', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeHostAvailabilityList(request: DescribeHostAvailabilityListRequest): DescribeHostAvailabilityListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHostAvailabilityListWithOptions(request, runtime);
}

model DeleteHostAvailabilityRequest = {
  id: [ long ](name='Id'),
}

model DeleteHostAvailabilityResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
}

async function deleteHostAvailabilityWithOptions(request: DeleteHostAvailabilityRequest, runtime: Util.RuntimeOptions): DeleteHostAvailabilityResponse {
  Util.validateModel(request);
  return doRequest('DeleteHostAvailability', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function deleteHostAvailability(request: DeleteHostAvailabilityRequest): DeleteHostAvailabilityResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHostAvailabilityWithOptions(request, runtime);
}

model DescribeMonitoringConfigRequest = {
}

model DescribeMonitoringConfigResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
  autoInstall: boolean(name='AutoInstall'),
  enableInstallAgentNewECS: boolean(name='EnableInstallAgentNewECS'),
}

async function describeMonitoringConfigWithOptions(request: DescribeMonitoringConfigRequest, runtime: Util.RuntimeOptions): DescribeMonitoringConfigResponse {
  Util.validateModel(request);
  return doRequest('DescribeMonitoringConfig', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function describeMonitoringConfig(request: DescribeMonitoringConfigRequest): DescribeMonitoringConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitoringConfigWithOptions(request, runtime);
}

model PutMonitoringConfigRequest = {
  autoInstall?: boolean(name='AutoInstall'),
  enableInstallAgentNewECS?: boolean(name='EnableInstallAgentNewECS'),
}

model PutMonitoringConfigResponse = {
  code: integer(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
}

async function putMonitoringConfigWithOptions(request: PutMonitoringConfigRequest, runtime: Util.RuntimeOptions): PutMonitoringConfigResponse {
  Util.validateModel(request);
  return doRequest('PutMonitoringConfig', 'HTTPS', 'POST', '2019-01-01', 'AK', null, request, runtime);
}

async function putMonitoringConfig(request: PutMonitoringConfigRequest): PutMonitoringConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return putMonitoringConfigWithOptions(request, runtime);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
