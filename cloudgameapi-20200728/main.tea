import Util;

import RPC;
import EndpointUtil;

extends RPC;

init(config: RPC.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('cloudgameapi', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

model CreateTokenRequest = {
  session: string(name='Session'),
  currentToken?: string(name='CurrentToken'),
  clientToken?: string(name='ClientToken'),
}

model CreateTokenResponse = {
  requestId: string(name='RequestId'),
  data: {
    token: string(name='Token'),
  }(name='Data'),
}

async function createTokenWithOptions(request: CreateTokenRequest, runtime: Util.RuntimeOptions): CreateTokenResponse {
  Util.validateModel(request);
  return doRequest('CreateToken', 'HTTPS', 'POST', '2020-07-28', 'AK', null, request, runtime);
}

async function createToken(request: CreateTokenRequest): CreateTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTokenWithOptions(request, runtime);
}

model GetSessionRequest = {
  token: string(name='Token'),
}

model GetSessionResponse = {
  requestId: string(name='RequestId'),
  data: {
    session: string(name='Session'),
  }(name='Data'),
}

async function getSessionWithOptions(request: GetSessionRequest, runtime: Util.RuntimeOptions): GetSessionResponse {
  Util.validateModel(request);
  return doRequest('GetSession', 'HTTPS', 'POST', '2020-07-28', 'AK', null, request, runtime);
}

async function getSession(request: GetSessionRequest): GetSessionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSessionWithOptions(request, runtime);
}

model SkipTrialPolicyRequest = {
  gameSessionId: string(name='GameSessionId'),
}

model SkipTrialPolicyResponse = {
  requestId: string(name='RequestId'),
  data: {
    skipResult: integer(name='SkipResult'),
  }(name='Data'),
}

async function skipTrialPolicyWithOptions(request: SkipTrialPolicyRequest, runtime: Util.RuntimeOptions): SkipTrialPolicyResponse {
  Util.validateModel(request);
  return doRequest('SkipTrialPolicy', 'HTTPS', 'POST', '2020-07-28', 'AK', null, request, runtime);
}

async function skipTrialPolicy(request: SkipTrialPolicyRequest): SkipTrialPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return skipTrialPolicyWithOptions(request, runtime);
}

model QueryTenantRequest = {
  param?: string(name='Param'),
  pageNo: integer(name='PageNo'),
  pageSize: integer(name='PageSize'),
}

model QueryTenantResponse = {
  requestId: string(name='RequestId'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  totalCount: integer(name='TotalCount'),
  data: [
    {
      tenantId: long(name='TenantId'),
      name: string(name='Name'),
      gmtCreate: string(name='GmtCreate'),
    }
  ](name='Data'),
}

async function queryTenantWithOptions(request: QueryTenantRequest, runtime: Util.RuntimeOptions): QueryTenantResponse {
  Util.validateModel(request);
  return doRequest('QueryTenant', 'HTTPS', 'POST', '2020-07-28', 'AK', null, request, runtime);
}

async function queryTenant(request: QueryTenantRequest): QueryTenantResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTenantWithOptions(request, runtime);
}

model QueryProjectRequest = {
  pageNo: integer(name='PageNo'),
  pageSize: integer(name='PageSize'),
  projectId?: long(name='ProjectId'),
  tenantId?: long(name='TenantId'),
}

model QueryProjectResponse = {
  requestId: string(name='RequestId'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  totalCount: integer(name='TotalCount'),
  data: [
    {
      tenantId: long(name='TenantId'),
      name: string(name='Name'),
      id: long(name='Id'),
    }
  ](name='Data'),
}

async function queryProjectWithOptions(request: QueryProjectRequest, runtime: Util.RuntimeOptions): QueryProjectResponse {
  Util.validateModel(request);
  return doRequest('QueryProject', 'HTTPS', 'POST', '2020-07-28', 'AK', null, request, runtime);
}

async function queryProject(request: QueryProjectRequest): QueryProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryProjectWithOptions(request, runtime);
}

model QueryGameRequest = {
  projectId?: long(name='ProjectId'),
  pageNo: integer(name='PageNo'),
  pageSize: integer(name='PageSize'),
  tenantId?: long(name='TenantId'),
}

model QueryGameResponse = {
  requestId: string(name='RequestId'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  totalCount: integer(name='TotalCount'),
  data: [
    {
      tenantId: long(name='TenantId'),
      name: string(name='Name'),
      gmtCreate: string(name='GmtCreate'),
      projectId: long(name='ProjectId'),
      gameId: long(name='GameId'),
      version: string(name='Version'),
    }
  ](name='Data'),
}

async function queryGameWithOptions(request: QueryGameRequest, runtime: Util.RuntimeOptions): QueryGameResponse {
  Util.validateModel(request);
  return doRequest('QueryGame', 'HTTPS', 'POST', '2020-07-28', 'AK', null, request, runtime);
}

async function queryGame(request: QueryGameRequest): QueryGameResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryGameWithOptions(request, runtime);
}

model BatchStopGameSessionsRequest = {
  projectId: string(name='ProjectId'),
  gameId?: string(name='GameId'),
  token?: string(name='Token'),
  reason?: string(name='Reason'),
  trackInfo?: string(name='TrackInfo'),
}

model BatchStopGameSessionsResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  queueState: integer(name='QueueState'),
  message: string(name='Message'),
  gameId: string(name='GameId'),
  projectId: string(name='ProjectId'),
  trackInfo: string(name='TrackInfo'),
}

async function batchStopGameSessionsWithOptions(request: BatchStopGameSessionsRequest, runtime: Util.RuntimeOptions): BatchStopGameSessionsResponse {
  Util.validateModel(request);
  return doRequest('BatchStopGameSessions', 'HTTPS', 'POST', '2020-07-28', 'AK', null, request, runtime);
}

async function batchStopGameSessions(request: BatchStopGameSessionsRequest): BatchStopGameSessionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchStopGameSessionsWithOptions(request, runtime);
}

model GetStopGameTokenRequest = {
  gameId: string(name='GameId'),
  accessKey: string(name='AccessKey'),
}

model GetStopGameTokenResponse = {
  requestId: string(name='RequestId'),
  token: string(name='Token'),
  expireTime: long(name='ExpireTime'),
}

async function getStopGameTokenWithOptions(request: GetStopGameTokenRequest, runtime: Util.RuntimeOptions): GetStopGameTokenResponse {
  Util.validateModel(request);
  return doRequest('GetStopGameToken', 'HTTPS', 'POST', '2020-07-28', 'AK', null, request, runtime);
}

async function getStopGameToken(request: GetStopGameTokenRequest): GetStopGameTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return getStopGameTokenWithOptions(request, runtime);
}

model QueryItemsRequest = {
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
}

model QueryItemsResponse = {
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
  httpStatusCode: long(name='HttpStatusCode'),
  data: {
    pageNumber: integer(name='PageNumber'),
    pageSize: integer(name='PageSize'),
    totalCount: long(name='TotalCount'),
    items: [
      {
        modifyTime: long(name='ModifyTime'),
        salePrice: long(name='SalePrice'),
        description: string(name='Description'),
        originPrice: long(name='OriginPrice'),
        createTime: long(name='CreateTime'),
        title: string(name='Title'),
        itemId: string(name='ItemId'),
        sellerId: string(name='SellerId'),
        supplier: string(name='Supplier'),
        categoryId: long(name='CategoryId'),
        status: integer(name='Status'),
        skus: [
          {
            itemId: string(name='ItemId'),
            modifyTime: long(name='ModifyTime'),
            salePrice: long(name='SalePrice'),
            originPrice: long(name='OriginPrice'),
            createTime: long(name='CreateTime'),
            skuId: string(name='SkuId'),
            status: integer(name='Status'),
            saleProps: [
              {
                valueId: long(name='ValueId'),
                propertyName: string(name='PropertyName'),
                propertyId: long(name='PropertyId'),
                value: string(name='Value'),
              }
            ](name='SaleProps'),
          }
        ](name='Skus'),
        games: [
          {
            gameId: string(name='GameId'),
            name: string(name='Name'),
          }
        ](name='Games'),
      }
    ](name='Items'),
  }(name='Data'),
}

async function queryItemsWithOptions(request: QueryItemsRequest, runtime: Util.RuntimeOptions): QueryItemsResponse {
  Util.validateModel(request);
  return doRequest('QueryItems', 'HTTPS', 'POST', '2020-07-28', 'AK', null, request, runtime);
}

async function queryItems(request: QueryItemsRequest): QueryItemsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryItemsWithOptions(request, runtime);
}

model GetItemRequest = {
  itemId: string(name='ItemId'),
}

model GetItemResponse = {
  requestId: string(name='RequestId'),
  data: {
    itemId: string(name='ItemId'),
    createTime: long(name='CreateTime'),
    modifyTime: long(name='ModifyTime'),
    sellerId: string(name='SellerId'),
    categoryId: long(name='CategoryId'),
    title: string(name='Title'),
    originPrice: long(name='OriginPrice'),
    salePrice: long(name='SalePrice'),
    status: integer(name='Status'),
    description: string(name='Description'),
    supplier: string(name='Supplier'),
    games: [
      {
        gameId: string(name='GameId'),
        name: string(name='Name'),
      }
    ](name='Games'),
    skus: [
      {
        skuId: string(name='SkuId'),
        createTime: long(name='CreateTime'),
        modifyTime: long(name='ModifyTime'),
        itemId: string(name='ItemId'),
        originPrice: long(name='OriginPrice'),
        salePrice: long(name='SalePrice'),
        status: integer(name='Status'),
        saleProps: [
          {
            propertyId: long(name='PropertyId'),
            propertyName: string(name='PropertyName'),
            valueId: long(name='ValueId'),
            value: string(name='Value'),
          }
        ](name='SaleProps'),
      }
    ](name='Skus'),
  }(name='Data'),
}

async function getItemWithOptions(request: GetItemRequest, runtime: Util.RuntimeOptions): GetItemResponse {
  Util.validateModel(request);
  return doRequest('GetItem', 'HTTPS', 'POST', '2020-07-28', 'AK', null, request, runtime);
}

async function getItem(request: GetItemRequest): GetItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return getItemWithOptions(request, runtime);
}

model DeliveryOrderRequest = {
  buyerAccountId: string(name='BuyerAccountId'),
  orderId: string(name='OrderId'),
  accountDomain?: string(name='AccountDomain'),
}

model DeliveryOrderResponse = {
  requestId: string(name='RequestId'),
  data: {
    deliveryStatus: string(name='DeliveryStatus'),
  }(name='Data'),
}

async function deliveryOrderWithOptions(request: DeliveryOrderRequest, runtime: Util.RuntimeOptions): DeliveryOrderResponse {
  Util.validateModel(request);
  return doRequest('DeliveryOrder', 'HTTPS', 'POST', '2020-07-28', 'AK', null, request, runtime);
}

async function deliveryOrder(request: DeliveryOrderRequest): DeliveryOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return deliveryOrderWithOptions(request, runtime);
}

model CreateOrderRequest = {
  buyerAccountId: string(name='BuyerAccountId'),
  itemId: string(name='ItemId'),
  skuId: string(name='SkuId'),
  originPrice: long(name='OriginPrice'),
  settlementPrice: long(name='SettlementPrice'),
  amount: long(name='Amount'),
  gameIdList: string(name='GameIdList'),
  idempotentCode: string(name='IdempotentCode'),
  accountDomain?: string(name='AccountDomain'),
}

model CreateOrderResponse = {
  requestId: string(name='RequestId'),
  data: {
    orderId: string(name='OrderId'),
    itemId: string(name='ItemId'),
    skuId: string(name='SkuId'),
    createTime: long(name='CreateTime'),
    applyDeliveryTime: long(name='ApplyDeliveryTime'),
    finishTime: long(name='FinishTime'),
    originPrice: long(name='OriginPrice'),
    settlementPrice: long(name='SettlementPrice'),
    amount: long(name='Amount'),
    status: string(name='Status'),
    buyerAccountId: string(name='BuyerAccountId'),
    autoUnlockTime: long(name='AutoUnlockTime'),
    accountDomain: string(name='AccountDomain'),
  }(name='Data'),
}

async function createOrderWithOptions(request: CreateOrderRequest, runtime: Util.RuntimeOptions): CreateOrderResponse {
  Util.validateModel(request);
  return doRequest('CreateOrder', 'HTTPS', 'POST', '2020-07-28', 'AK', null, request, runtime);
}

async function createOrder(request: CreateOrderRequest): CreateOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOrderWithOptions(request, runtime);
}

model QueryOrderRequest = {
  buyerAccountId: string(name='BuyerAccountId'),
  orderId: string(name='OrderId'),
  accountDomain?: string(name='AccountDomain'),
}

model QueryOrderResponse = {
  requestId: string(name='RequestId'),
  deliveryStatus: string(name='DeliveryStatus'),
  refundStatus: string(name='RefundStatus'),
  data: {
    orderId: string(name='OrderId'),
    itemId: string(name='ItemId'),
    skuId: string(name='SkuId'),
    createTime: long(name='CreateTime'),
    applyDeliveryTime: long(name='ApplyDeliveryTime'),
    finishTime: long(name='FinishTime'),
    originPrice: long(name='OriginPrice'),
    settlementPrice: long(name='SettlementPrice'),
    amount: long(name='Amount'),
    status: string(name='Status'),
    buyerAccountId: string(name='BuyerAccountId'),
    autoUnlockTime: long(name='AutoUnlockTime'),
    accountDomain: string(name='AccountDomain'),
  }(name='Data'),
}

async function queryOrderWithOptions(request: QueryOrderRequest, runtime: Util.RuntimeOptions): QueryOrderResponse {
  Util.validateModel(request);
  return doRequest('QueryOrder', 'HTTPS', 'POST', '2020-07-28', 'AK', null, request, runtime);
}

async function queryOrder(request: QueryOrderRequest): QueryOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryOrderWithOptions(request, runtime);
}

model ListBoughtGamesRequest = {
  accountId: string(name='AccountId'),
  accountDomain?: string(name='AccountDomain'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model ListBoughtGamesResponse = {
  requestId: string(name='RequestId'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  totalCount: integer(name='TotalCount'),
  items: [
    {
      gameId: string(name='GameId'),
      gameName: string(name='GameName'),
      startTime: long(name='StartTime'),
      endTime: long(name='EndTime'),
    }
  ](name='Items'),
}

async function listBoughtGamesWithOptions(request: ListBoughtGamesRequest, runtime: Util.RuntimeOptions): ListBoughtGamesResponse {
  Util.validateModel(request);
  return doRequest('ListBoughtGames', 'HTTPS', 'POST', '2020-07-28', 'AK', null, request, runtime);
}

async function listBoughtGames(request: ListBoughtGamesRequest): ListBoughtGamesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBoughtGamesWithOptions(request, runtime);
}

model CloseOrderRequest = {
  buyerAccountId: string(name='BuyerAccountId'),
  orderId: string(name='OrderId'),
  accountDomain?: string(name='AccountDomain'),
}

model CloseOrderResponse = {
  requestId: string(name='RequestId'),
  data: boolean(name='Data'),
}

async function closeOrderWithOptions(request: CloseOrderRequest, runtime: Util.RuntimeOptions): CloseOrderResponse {
  Util.validateModel(request);
  return doRequest('CloseOrder', 'HTTPS', 'POST', '2020-07-28', 'AK', null, request, runtime);
}

async function closeOrder(request: CloseOrderRequest): CloseOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return closeOrderWithOptions(request, runtime);
}

model BatchDispatchGameSlotRequest = {
  queueUserList?: string(name='QueueUserList'),
}

model BatchDispatchGameSlotResponse = {
  requestId: string(name='RequestId'),
  queueResultList: [
    {
      gameId: string(name='GameId'),
      gameSession: string(name='GameSession'),
      message: string(name='Message'),
      queueCode: integer(name='QueueCode'),
      queueState: integer(name='QueueState'),
      regionName: string(name='RegionName'),
      userId: string(name='UserId'),
    }
  ](name='QueueResultList'),
}

async function batchDispatchGameSlotWithOptions(request: BatchDispatchGameSlotRequest, runtime: Util.RuntimeOptions): BatchDispatchGameSlotResponse {
  Util.validateModel(request);
  return doRequest('BatchDispatchGameSlot', 'HTTPS', 'POST', '2020-07-28', 'AK', null, request, runtime);
}

async function batchDispatchGameSlot(request: BatchDispatchGameSlotRequest): BatchDispatchGameSlotResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchDispatchGameSlotWithOptions(request, runtime);
}

model StopGameSessionRequest = {
  gameId: string(name='GameId'),
  accessKey: string(name='AccessKey'),
  userId: string(name='UserId'),
  bizParam?: string(name='BizParam'),
  gameSession: string(name='GameSession'),
  reason?: string(name='Reason'),
}

model StopGameSessionResponse = {
  requestId: string(name='RequestId'),
  gameId: string(name='GameId'),
  gameSession: string(name='GameSession'),
  queueState: integer(name='QueueState'),
  queueCode: integer(name='QueueCode'),
  message: string(name='Message'),
  success: boolean(name='Success'),
}

async function stopGameSessionWithOptions(request: StopGameSessionRequest, runtime: Util.RuntimeOptions): StopGameSessionResponse {
  Util.validateModel(request);
  return doRequest('StopGameSession', 'HTTPS', 'POST', '2020-07-28', 'AK', null, request, runtime);
}

async function stopGameSession(request: StopGameSessionRequest): StopGameSessionResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopGameSessionWithOptions(request, runtime);
}

model DispatchGameSlotRequest = {
  gameId: string(name='GameId'),
  accessKey: string(name='AccessKey'),
  regionName?: string(name='RegionName'),
  userId: string(name='UserId'),
  bizParam?: string(name='BizParam'),
  cancel?: boolean(name='Cancel'),
  gameSession?: string(name='GameSession'),
  gameStartParam?: string(name='GameStartParam'),
  gameCommand?: string(name='GameCommand'),
  systemInfo?: string(name='SystemInfo'),
  clientIp?: string(name='ClientIp'),
  reconnect?: boolean(name='Reconnect'),
}

model DispatchGameSlotResponse = {
  requestId: string(name='RequestId'),
  gameId: string(name='GameId'),
  gameSession: string(name='GameSession'),
  queueState: integer(name='QueueState'),
  queueCode: integer(name='QueueCode'),
  message: string(name='Message'),
  regionName: string(name='RegionName'),
  userId: string(name='UserId'),
}

async function dispatchGameSlotWithOptions(request: DispatchGameSlotRequest, runtime: Util.RuntimeOptions): DispatchGameSlotResponse {
  Util.validateModel(request);
  return doRequest('DispatchGameSlot', 'HTTPS', 'POST', '2020-07-28', 'AK', null, request, runtime);
}

async function dispatchGameSlot(request: DispatchGameSlotRequest): DispatchGameSlotResponse {
  var runtime = new Util.RuntimeOptions{};
  return dispatchGameSlotWithOptions(request, runtime);
}

model GetGameCcuRequest = {
  gameId: string(name='GameId'),
  regionName?: string(name='RegionName'),
  accessKey: string(name='AccessKey'),
}

model GetGameCcuResponse = {
  requestId: string(name='RequestId'),
  dataList: [
    {
      ccu: long(name='Ccu'),
      gameId: string(name='GameId'),
      regionId: string(name='RegionId'),
    }
  ](name='DataList'),
}

async function getGameCcuWithOptions(request: GetGameCcuRequest, runtime: Util.RuntimeOptions): GetGameCcuResponse {
  Util.validateModel(request);
  return doRequest('GetGameCcu', 'HTTPS', 'POST', '2020-07-28', 'AK', null, request, runtime);
}

async function getGameCcu(request: GetGameCcuRequest): GetGameCcuResponse {
  var runtime = new Util.RuntimeOptions{};
  return getGameCcuWithOptions(request, runtime);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
