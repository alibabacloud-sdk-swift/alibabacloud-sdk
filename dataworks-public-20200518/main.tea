import Util;

import RPC;
import EndpointUtil;

extends RPC;

init(config: RPC.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-1 = 'dataworks.ap-northeast-1.aliyuncs.com',
    ap-south-1 = 'dataworks.ap-south-1.aliyuncs.com',
    ap-southeast-1 = 'dataworks.ap-southeast-1.aliyuncs.com',
    ap-southeast-2 = 'dataworks.ap-southeast-2.aliyuncs.com',
    ap-southeast-3 = 'dataworks.ap-southeast-3.aliyuncs.com',
    ap-southeast-5 = 'dataworks.ap-southeast-5.aliyuncs.com',
    cn-beijing = 'dataworks.cn-beijing.aliyuncs.com',
    cn-chengdu = 'dataworks.cn-chengdu.aliyuncs.com',
    cn-hangzhou = 'dataworks.cn-hangzhou.aliyuncs.com',
    cn-hongkong = 'dataworks.cn-hongkong.aliyuncs.com',
    cn-huhehaote = 'dataworks.aliyuncs.com',
    cn-qingdao = 'dataworks.aliyuncs.com',
    cn-shanghai = 'dataworks.cn-shanghai.aliyuncs.com',
    cn-shenzhen = 'dataworks.cn-shenzhen.aliyuncs.com',
    cn-zhangjiakou = 'dataworks.aliyuncs.com',
    eu-central-1 = 'dataworks.eu-central-1.aliyuncs.com',
    eu-west-1 = 'dataworks.eu-west-1.aliyuncs.com',
    me-east-1 = 'dataworks.me-east-1.aliyuncs.com',
    us-east-1 = 'dataworks.us-east-1.aliyuncs.com',
    us-west-1 = 'dataworks.us-west-1.aliyuncs.com',
    cn-hangzhou-finance = 'dataworks.aliyuncs.com',
    cn-shenzhen-finance-1 = 'dataworks.aliyuncs.com',
    cn-shanghai-finance-1 = 'dataworks.aliyuncs.com',
    cn-north-2-gov-1 = 'dataworks.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('dataworks-public', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

model ListQualityResultsByEntityRequest = {
  entityId: integer(name='EntityId'),
  startDate: string(name='StartDate'),
  endDate: string(name='EndDate'),
  pageSize: integer(name='PageSize'),
  pageNumber: integer(name='PageNumber'),
  projectName: string(name='ProjectName'),
}

model ListQualityResultsByEntityResponse = {
  requestId: string(name='RequestId'),
  qualityResults: {
    totalCount: long(name='TotalCount'),
    pageNumber: integer(name='PageNumber'),
    pageSize: integer(name='PageSize'),
    ruleChecks: [
      {
        id: integer(name='Id'),
        taskId: string(name='TaskId'),
        entityId: integer(name='EntityId'),
        ruleId: integer(name='RuleId'),
        property: string(name='Property'),
        bizDate: long(name='BizDate'),
        dateType: string(name='DateType'),
        actualExpression: string(name='ActualExpression'),
        matchExpression: string(name='MatchExpression'),
        blockType: integer(name='BlockType'),
        checkResult: integer(name='CheckResult'),
        checkResultStatus: integer(name='CheckResultStatus'),
        methodName: string(name='MethodName'),
        comment: string(name='Comment'),
        whereCondition: string(name='WhereCondition'),
        beginTime: long(name='BeginTime'),
        endTime: long(name='EndTime'),
        timeCost: string(name='TimeCost'),
        externalType: string(name='ExternalType'),
        externalId: string(name='ExternalId'),
        discreteCheck: boolean(name='DiscreteCheck'),
        fixedCheck: boolean(name='FixedCheck'),
        trend: string(name='Trend'),
        warningThreshold: float(name='WarningThreshold'),
        criticalThreshold: float(name='CriticalThreshold'),
        expectValue: float(name='ExpectValue'),
        op: string(name='Op'),
        projectName: string(name='ProjectName'),
        tableName: string(name='TableName'),
        templateId: integer(name='TemplateId'),
        templateName: string(name='TemplateName'),
        resultString: string(name='ResultString'),
        checkerId: integer(name='CheckerId'),
        checkerType: integer(name='CheckerType'),
        ruleName: string(name='RuleName'),
        isPrediction: boolean(name='IsPrediction'),
        upperValue: float(name='UpperValue'),
        lowerValue: float(name='LowerValue'),
        checkerName: string(name='CheckerName'),
        referenceValue: [
          {
            bizDate: long(name='BizDate'),
            discreteProperty: string(name='DiscreteProperty'),
            value: float(name='Value'),
            threshold: float(name='Threshold'),
            singleCheckResult: integer(name='SingleCheckResult'),
          }
        ](name='ReferenceValue'),
        sampleValue: [
          {
            bizDate: long(name='BizDate'),
            discreteProperty: string(name='DiscreteProperty'),
            value: float(name='Value'),
          }
        ](name='SampleValue'),
      }
    ](name='RuleChecks'),
  }(name='QualityResults'),
}

async function listQualityResultsByEntityWithOptions(request: ListQualityResultsByEntityRequest, runtime: Util.RuntimeOptions): ListQualityResultsByEntityResponse {
  Util.validateModel(request);
  return doRequest('ListQualityResultsByEntity', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listQualityResultsByEntity(request: ListQualityResultsByEntityRequest): ListQualityResultsByEntityResponse {
  var runtime = new Util.RuntimeOptions{};
  return listQualityResultsByEntityWithOptions(request, runtime);
}

model GetNodeTypeListInfoRequest = {
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  keyword?: string(name='Keyword'),
  locale?: string(name='Locale'),
}

model GetNodeTypeListInfoResponse = {
  requestId: string(name='RequestId'),
  nodeTypeInfoList: {
    pageNumber: integer(name='PageNumber'),
    pageSize: integer(name='PageSize'),
    totalCount: integer(name='TotalCount'),
    nodeTypeInfo: [
      {
        nodeType: integer(name='NodeType'),
        nodeTypeName: string(name='NodeTypeName'),
      }
    ](name='NodeTypeInfo'),
  }(name='NodeTypeInfoList'),
}

async function getNodeTypeListInfoWithOptions(request: GetNodeTypeListInfoRequest, runtime: Util.RuntimeOptions): GetNodeTypeListInfoResponse {
  Util.validateModel(request);
  return doRequest('GetNodeTypeListInfo', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getNodeTypeListInfo(request: GetNodeTypeListInfoRequest): GetNodeTypeListInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNodeTypeListInfoWithOptions(request, runtime);
}

model GetInstanceStatusCountRequest = {
  projectId: long(name='ProjectId'),
  projectEnv: string(name='ProjectEnv'),
  bizDate: string(name='BizDate'),
}

model GetInstanceStatusCountResponse = {
  requestId: string(name='RequestId'),
  statusCount: {
    totalCount: integer(name='TotalCount'),
    notRunCount: integer(name='NotRunCount'),
    waitTimeCount: integer(name='WaitTimeCount'),
    waitResCount: integer(name='WaitResCount'),
    runningCount: integer(name='RunningCount'),
    failureCount: integer(name='FailureCount'),
    successCount: integer(name='SuccessCount'),
  }(name='StatusCount'),
}

async function getInstanceStatusCountWithOptions(request: GetInstanceStatusCountRequest, runtime: Util.RuntimeOptions): GetInstanceStatusCountResponse {
  Util.validateModel(request);
  return doRequest('GetInstanceStatusCount', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getInstanceStatusCount(request: GetInstanceStatusCountRequest): GetInstanceStatusCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceStatusCountWithOptions(request, runtime);
}

model ListDataServiceFoldersRequest = {
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  projectId: long(name='ProjectId'),
  tenantId: long(name='TenantId'),
  groupId?: string(name='GroupId'),
  folderNameKeyword?: string(name='FolderNameKeyword'),
}

model ListDataServiceFoldersResponse = {
  requestId: string(name='RequestId'),
  folderPagingResult: {
    pageNumber: integer(name='PageNumber'),
    pageSize: integer(name='PageSize'),
    totalCount: integer(name='TotalCount'),
    folders: [
      {
        folderId: long(name='FolderId'),
        folderName: string(name='FolderName'),
        projectId: long(name='ProjectId'),
        tenantId: long(name='TenantId'),
        createdTime: string(name='CreatedTime'),
        modifiedTime: string(name='ModifiedTime'),
        groupId: string(name='GroupId'),
        parentId: long(name='ParentId'),
      }
    ](name='Folders'),
  }(name='FolderPagingResult'),
}

async function listDataServiceFoldersWithOptions(request: ListDataServiceFoldersRequest, runtime: Util.RuntimeOptions): ListDataServiceFoldersResponse {
  Util.validateModel(request);
  return doRequest('ListDataServiceFolders', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listDataServiceFolders(request: ListDataServiceFoldersRequest): ListDataServiceFoldersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDataServiceFoldersWithOptions(request, runtime);
}

model ListQualityResultsByRuleRequest = {
  ruleId: integer(name='RuleId'),
  startDate: string(name='StartDate'),
  endDate: string(name='EndDate'),
  pageSize: integer(name='PageSize'),
  pageNumber: integer(name='PageNumber'),
  projectName: string(name='ProjectName'),
}

model ListQualityResultsByRuleResponse = {
  requestId: string(name='RequestId'),
  qualityResults: {
    totalCount: long(name='TotalCount'),
    pageNumber: integer(name='PageNumber'),
    pageSize: integer(name='PageSize'),
    ruleChecks: [
      {
        id: integer(name='Id'),
        taskId: string(name='TaskId'),
        entityId: integer(name='EntityId'),
        ruleId: integer(name='RuleId'),
        property: string(name='Property'),
        bizDate: long(name='BizDate'),
        dateType: string(name='DateType'),
        actualExpression: string(name='ActualExpression'),
        matchExpression: string(name='MatchExpression'),
        blockType: integer(name='BlockType'),
        checkResult: integer(name='CheckResult'),
        checkResultStatus: integer(name='CheckResultStatus'),
        methodName: string(name='MethodName'),
        comment: string(name='Comment'),
        whereCondition: string(name='WhereCondition'),
        beginTime: long(name='BeginTime'),
        endTime: long(name='EndTime'),
        timeCost: string(name='TimeCost'),
        externalType: string(name='ExternalType'),
        externalId: string(name='ExternalId'),
        discreteCheck: boolean(name='DiscreteCheck'),
        fixedCheck: boolean(name='FixedCheck'),
        trend: string(name='Trend'),
        warningThreshold: float(name='WarningThreshold'),
        criticalThreshold: float(name='CriticalThreshold'),
        expectValue: float(name='ExpectValue'),
        op: string(name='Op'),
        projectName: string(name='ProjectName'),
        tableName: string(name='TableName'),
        templateId: integer(name='TemplateId'),
        templateName: string(name='TemplateName'),
        resultString: string(name='ResultString'),
        checkerId: integer(name='CheckerId'),
        checkerType: integer(name='CheckerType'),
        ruleName: string(name='RuleName'),
        isPrediction: boolean(name='IsPrediction'),
        upperValue: float(name='UpperValue'),
        lowerValue: float(name='LowerValue'),
        checkerName: string(name='CheckerName'),
        referenceValue: [
          {
            bizDate: long(name='BizDate'),
            discreteProperty: string(name='DiscreteProperty'),
            value: float(name='Value'),
            threshold: float(name='Threshold'),
            singleCheckResult: integer(name='SingleCheckResult'),
          }
        ](name='ReferenceValue'),
        sampleValue: [
          {
            bizDate: long(name='BizDate'),
            discreteProperty: string(name='DiscreteProperty'),
            value: float(name='Value'),
          }
        ](name='SampleValue'),
      }
    ](name='RuleChecks'),
  }(name='QualityResults'),
}

async function listQualityResultsByRuleWithOptions(request: ListQualityResultsByRuleRequest, runtime: Util.RuntimeOptions): ListQualityResultsByRuleResponse {
  Util.validateModel(request);
  return doRequest('ListQualityResultsByRule', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listQualityResultsByRule(request: ListQualityResultsByRuleRequest): ListQualityResultsByRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return listQualityResultsByRuleWithOptions(request, runtime);
}

model ListMetaDBRequest = {
  projectId: long(name='ProjectId'),
  dataSourceType: string(name='DataSourceType'),
}

model ListMetaDBResponse = {
  requestId: string(name='RequestId'),
  databaseInfo: {
    totalCount: long(name='TotalCount'),
    dbList: [
      {
        name: string(name='Name'),
        type: string(name='Type'),
        ownerId: string(name='OwnerId'),
        location: string(name='Location'),
        createTimeStamp: long(name='CreateTimeStamp'),
        modifiedTimeStamp: long(name='ModifiedTimeStamp'),
        UUID: string(name='UUID'),
      }
    ](name='DbList'),
  }(name='DatabaseInfo'),
}

async function listMetaDBWithOptions(request: ListMetaDBRequest, runtime: Util.RuntimeOptions): ListMetaDBResponse {
  Util.validateModel(request);
  return doRequest('ListMetaDB', 'HTTPS', 'GET', '2020-05-18', 'AK', request, null, runtime);
}

async function listMetaDB(request: ListMetaDBRequest): ListMetaDBResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMetaDBWithOptions(request, runtime);
}

model CreateTableRequest = {
  hasPart?: integer(name='HasPart'),
  columns: [
    {
      columnName: string(name='ColumnName'),
      columnNameCn?: string(name='ColumnNameCn'),
      columnType: string(name='ColumnType'),
      seqNumber?: integer(name='SeqNumber'),
      length?: integer(name='Length'),
      isPartitionCol?: integer(name='IsPartitionCol'),
      isPrimaryKey?: integer(name='IsPrimaryKey'),
      isNullable?: integer(name='IsNullable'),
      comment?: string(name='Comment'),
    }
  ](name='Columns'),
  isView?: integer(name='IsView'),
  visibility?: integer(name='Visibility'),
  lifeCycle?: integer(name='LifeCycle'),
  categoryId?: long(name='CategoryId'),
  logicalLevelId?: long(name='LogicalLevelId'),
  physicsLevelId?: long(name='PhysicsLevelId'),
  externalTableType?: string(name='ExternalTableType'),
  location?: string(name='Location'),
  projectId?: long(name='ProjectId'),
  tableName: string(name='TableName'),
  endpoint?: string(name='Endpoint'),
  envType?: integer(name='EnvType'),
  themes?: [
    {
      themeId?: long(name='ThemeId'),
      themeLevel?: integer(name='ThemeLevel'),
    }
  ](name='Themes'),
  appGuid?: string(name='AppGuid'),
}

model CreateTableResponse = {
  requestId: string(name='RequestId'),
  taskInfo: {
    taskId: string(name='TaskId'),
    content: string(name='Content'),
    status: string(name='Status'),
    nextTaskId: string(name='NextTaskId'),
  }(name='TaskInfo'),
}

async function createTableWithOptions(request: CreateTableRequest, runtime: Util.RuntimeOptions): CreateTableResponse {
  Util.validateModel(request);
  return doRequest('CreateTable', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function createTable(request: CreateTableRequest): CreateTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTableWithOptions(request, runtime);
}

model CreateTableThemeRequest = {
  projectId?: long(name='ProjectId'),
  level: integer(name='Level'),
  name: string(name='Name'),
  parentId?: long(name='ParentId'),
}

model CreateTableThemeResponse = {
  requestId: string(name='RequestId'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  success: boolean(name='Success'),
  themeId: long(name='ThemeId'),
}

async function createTableThemeWithOptions(request: CreateTableThemeRequest, runtime: Util.RuntimeOptions): CreateTableThemeResponse {
  Util.validateModel(request);
  return doRequest('CreateTableTheme', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function createTableTheme(request: CreateTableThemeRequest): CreateTableThemeResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTableThemeWithOptions(request, runtime);
}

model GetInstanceErrorRankRequest = {
  projectId: long(name='ProjectId'),
}

model GetInstanceErrorRankResponse = {
  requestId: string(name='RequestId'),
  instanceErrorRank: {
    updateTime: long(name='UpdateTime'),
    errorRank: [
      {
        nodeId: long(name='NodeId'),
        nodeName: string(name='NodeName'),
        owner: string(name='Owner'),
        count: integer(name='Count'),
        projectId: long(name='ProjectId'),
        prgType: integer(name='PrgType'),
      }
    ](name='ErrorRank'),
  }(name='InstanceErrorRank'),
}

async function getInstanceErrorRankWithOptions(request: GetInstanceErrorRankRequest, runtime: Util.RuntimeOptions): GetInstanceErrorRankResponse {
  Util.validateModel(request);
  return doRequest('GetInstanceErrorRank', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getInstanceErrorRank(request: GetInstanceErrorRankRequest): GetInstanceErrorRankResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceErrorRankWithOptions(request, runtime);
}

model GetDDLJobStatusRequest = {
  taskId: string(name='TaskId'),
}

model GetDDLJobStatusResponse = {
  requestId: string(name='RequestId'),
  data: {
    nextTaskId: string(name='NextTaskId'),
    content: string(name='Content'),
    status: string(name='Status'),
    taskId: string(name='TaskId'),
  }(name='Data'),
}

async function getDDLJobStatusWithOptions(request: GetDDLJobStatusRequest, runtime: Util.RuntimeOptions): GetDDLJobStatusResponse {
  Util.validateModel(request);
  return doRequest('GetDDLJobStatus', 'HTTPS', 'GET', '2020-05-18', 'AK', request, null, runtime);
}

async function getDDLJobStatus(request: GetDDLJobStatusRequest): GetDDLJobStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDDLJobStatusWithOptions(request, runtime);
}

model GetInstanceConsumeTimeRankRequest = {
  projectId: long(name='ProjectId'),
  bizdate: string(name='Bizdate'),
}

model GetInstanceConsumeTimeRankResponse = {
  requestId: string(name='RequestId'),
  instanceConsumeTimeRank: {
    updateTime: long(name='UpdateTime'),
    consumeTimeRank: [
      {
        nodeName: string(name='NodeName'),
        nodeId: long(name='NodeId'),
        bizdate: long(name='Bizdate'),
        owner: string(name='Owner'),
        consumed: long(name='Consumed'),
        instanceId: long(name='InstanceId'),
        prgType: integer(name='PrgType'),
      }
    ](name='ConsumeTimeRank'),
  }(name='InstanceConsumeTimeRank'),
}

async function getInstanceConsumeTimeRankWithOptions(request: GetInstanceConsumeTimeRankRequest, runtime: Util.RuntimeOptions): GetInstanceConsumeTimeRankResponse {
  Util.validateModel(request);
  return doRequest('GetInstanceConsumeTimeRank', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getInstanceConsumeTimeRank(request: GetInstanceConsumeTimeRankRequest): GetInstanceConsumeTimeRankResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceConsumeTimeRankWithOptions(request, runtime);
}

model CreateDataServiceApiAuthorityRequest = {
  tenantId: long(name='TenantId'),
  projectId: long(name='ProjectId'),
  apiId: long(name='ApiId'),
  authorizedProjectId: long(name='AuthorizedProjectId'),
  endTime: long(name='EndTime'),
}

model CreateDataServiceApiAuthorityResponse = {
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
}

async function createDataServiceApiAuthorityWithOptions(request: CreateDataServiceApiAuthorityRequest, runtime: Util.RuntimeOptions): CreateDataServiceApiAuthorityResponse {
  Util.validateModel(request);
  return doRequest('CreateDataServiceApiAuthority', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function createDataServiceApiAuthority(request: CreateDataServiceApiAuthorityRequest): CreateDataServiceApiAuthorityResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDataServiceApiAuthorityWithOptions(request, runtime);
}

model DeleteDataServiceApiAuthorityRequest = {
  tenantId: long(name='TenantId'),
  projectId: long(name='ProjectId'),
  apiId: long(name='ApiId'),
  authorizedProjectId: long(name='AuthorizedProjectId'),
}

model DeleteDataServiceApiAuthorityResponse = {
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
}

async function deleteDataServiceApiAuthorityWithOptions(request: DeleteDataServiceApiAuthorityRequest, runtime: Util.RuntimeOptions): DeleteDataServiceApiAuthorityResponse {
  Util.validateModel(request);
  return doRequest('DeleteDataServiceApiAuthority', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function deleteDataServiceApiAuthority(request: DeleteDataServiceApiAuthorityRequest): DeleteDataServiceApiAuthorityResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDataServiceApiAuthorityWithOptions(request, runtime);
}

model CreateDataServiceGroupRequest = {
  tenantId: long(name='TenantId'),
  projectId: long(name='ProjectId'),
  apiGatewayGroupId: string(name='ApiGatewayGroupId'),
  groupName: string(name='GroupName'),
  description?: string(name='Description'),
}

model CreateDataServiceGroupResponse = {
  groupId: string(name='GroupId'),
  requestId: string(name='RequestId'),
}

async function createDataServiceGroupWithOptions(request: CreateDataServiceGroupRequest, runtime: Util.RuntimeOptions): CreateDataServiceGroupResponse {
  Util.validateModel(request);
  return doRequest('CreateDataServiceGroup', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function createDataServiceGroup(request: CreateDataServiceGroupRequest): CreateDataServiceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDataServiceGroupWithOptions(request, runtime);
}

model UpdateMetaTableRequest = {
  projectId?: long(name='ProjectId'),
  tableName?: string(name='TableName'),
  envType?: integer(name='EnvType'),
  tableGuid?: string(name='TableGuid'),
  newOwnerId?: string(name='NewOwnerId'),
  addedLabels?: string(name='AddedLabels'),
  removedLabels?: string(name='RemovedLabels'),
  categoryId?: long(name='CategoryId'),
  visibility?: integer(name='Visibility'),
  caption?: string(name='Caption'),
}

model UpdateMetaTableResponse = {
  requestId: string(name='RequestId'),
  updateResult: boolean(name='UpdateResult'),
}

async function updateMetaTableWithOptions(request: UpdateMetaTableRequest, runtime: Util.RuntimeOptions): UpdateMetaTableResponse {
  Util.validateModel(request);
  return doRequest('UpdateMetaTable', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function updateMetaTable(request: UpdateMetaTableRequest): UpdateMetaTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMetaTableWithOptions(request, runtime);
}

model GetInstanceCountTrendRequest = {
  projectId: long(name='ProjectId'),
  beginDate: string(name='BeginDate'),
  endDate: string(name='EndDate'),
}

model GetInstanceCountTrendResponse = {
  requestId: string(name='RequestId'),
  instanceCounts: [
    {
      date: long(name='Date'),
      count: integer(name='Count'),
    }
  ](name='InstanceCounts'),
}

async function getInstanceCountTrendWithOptions(request: GetInstanceCountTrendRequest, runtime: Util.RuntimeOptions): GetInstanceCountTrendResponse {
  Util.validateModel(request);
  return doRequest('GetInstanceCountTrend', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getInstanceCountTrend(request: GetInstanceCountTrendRequest): GetInstanceCountTrendResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceCountTrendWithOptions(request, runtime);
}

model DeleteTableRequest = {
  projectId?: long(name='ProjectId'),
  tableName: string(name='TableName'),
  envType?: integer(name='EnvType'),
  appGuid?: string(name='AppGuid'),
}

model DeleteTableResponse = {
  requestId: string(name='RequestId'),
  taskInfo: {
    taskId: string(name='TaskId'),
    content: string(name='Content'),
    status: string(name='Status'),
    nextTaskId: string(name='NextTaskId'),
  }(name='TaskInfo'),
}

async function deleteTableWithOptions(request: DeleteTableRequest, runtime: Util.RuntimeOptions): DeleteTableResponse {
  Util.validateModel(request);
  return doRequest('DeleteTable', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function deleteTable(request: DeleteTableRequest): DeleteTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTableWithOptions(request, runtime);
}

model ListTableThemeRequest = {
  projectId?: long(name='ProjectId'),
  parentId?: long(name='ParentId'),
  pageNum?: integer(name='PageNum'),
  pageSize?: integer(name='PageSize'),
}

model ListTableThemeResponse = {
  requestId: string(name='RequestId'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  success: boolean(name='Success'),
  data: {
    totalCount: long(name='TotalCount'),
    themeList: [
      {
        themeId: long(name='ThemeId'),
        name: string(name='Name'),
        level: integer(name='Level'),
        parentId: long(name='ParentId'),
        projectId: long(name='ProjectId'),
        creator: string(name='Creator'),
        createTimeStamp: long(name='CreateTimeStamp'),
      }
    ](name='ThemeList'),
  }(name='Data'),
}

async function listTableThemeWithOptions(request: ListTableThemeRequest, runtime: Util.RuntimeOptions): ListTableThemeResponse {
  Util.validateModel(request);
  return doRequest('ListTableTheme', 'HTTPS', 'GET', '2020-05-18', 'AK', request, null, runtime);
}

async function listTableTheme(request: ListTableThemeRequest): ListTableThemeResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTableThemeWithOptions(request, runtime);
}

model GetSuccessInstanceTrendRequest = {
  projectId: long(name='ProjectId'),
}

model GetSuccessInstanceTrendResponse = {
  requestId: string(name='RequestId'),
  instanceStatusTrend: {
    todayTrend: [
      {
        count: integer(name='Count'),
        timePoint: string(name='TimePoint'),
      }
    ](name='TodayTrend'),
    yesterdayTrend: [
      {
        count: integer(name='Count'),
        timePoint: string(name='TimePoint'),
      }
    ](name='YesterdayTrend'),
    avgTrend: [
      {
        count: integer(name='Count'),
        timePoint: string(name='TimePoint'),
      }
    ](name='AvgTrend'),
  }(name='InstanceStatusTrend'),
}

async function getSuccessInstanceTrendWithOptions(request: GetSuccessInstanceTrendRequest, runtime: Util.RuntimeOptions): GetSuccessInstanceTrendResponse {
  Util.validateModel(request);
  return doRequest('GetSuccessInstanceTrend', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getSuccessInstanceTrend(request: GetSuccessInstanceTrendRequest): GetSuccessInstanceTrendResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSuccessInstanceTrendWithOptions(request, runtime);
}

model UpdateTableRequest = {
  hasPart?: integer(name='HasPart'),
  columns: [
    {
      columnName: string(name='ColumnName'),
      columnNameCn?: string(name='ColumnNameCn'),
      columnType: string(name='ColumnType'),
      seqNumber?: integer(name='SeqNumber'),
      length?: integer(name='Length'),
      isPartitionCol?: integer(name='IsPartitionCol'),
      isPrimaryKey?: integer(name='IsPrimaryKey'),
      isNullable?: integer(name='IsNullable'),
      comment?: string(name='Comment'),
    }
  ](name='Columns'),
  isView?: integer(name='IsView'),
  visibility?: integer(name='Visibility'),
  lifeCycle?: integer(name='LifeCycle'),
  categoryId?: long(name='CategoryId'),
  logicalLevelId?: long(name='LogicalLevelId'),
  physicsLevelId?: long(name='PhysicsLevelId'),
  externalTableType?: string(name='ExternalTableType'),
  location?: string(name='Location'),
  projectId?: long(name='ProjectId'),
  tableName: string(name='TableName'),
  endpoint?: string(name='Endpoint'),
  envType?: integer(name='EnvType'),
  themes?: [
    {
      themeId?: long(name='ThemeId'),
      themeLevel?: integer(name='ThemeLevel'),
    }
  ](name='Themes'),
  appGuid?: string(name='AppGuid'),
  createIfNotExists?: boolean(name='CreateIfNotExists'),
}

model UpdateTableResponse = {
  requestId: string(name='RequestId'),
  taskInfo: {
    taskId: string(name='TaskId'),
    content: string(name='Content'),
    status: string(name='Status'),
    nextTaskId: string(name='NextTaskId'),
  }(name='TaskInfo'),
}

async function updateTableWithOptions(request: UpdateTableRequest, runtime: Util.RuntimeOptions): UpdateTableResponse {
  Util.validateModel(request);
  return doRequest('UpdateTable', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function updateTable(request: UpdateTableRequest): UpdateTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTableWithOptions(request, runtime);
}

model GetDataServiceFolderRequest = {
  tenantId: long(name='TenantId'),
  projectId: long(name='ProjectId'),
  folderId: long(name='FolderId'),
}

model GetDataServiceFolderResponse = {
  requestId: string(name='RequestId'),
  folder: {
    tenantId: long(name='TenantId'),
    projectId: long(name='ProjectId'),
    folderId: long(name='FolderId'),
    folderName: string(name='FolderName'),
    createdTime: string(name='CreatedTime'),
    modifiedTime: string(name='ModifiedTime'),
    groupId: string(name='GroupId'),
    parentId: long(name='ParentId'),
  }(name='Folder'),
}

async function getDataServiceFolderWithOptions(request: GetDataServiceFolderRequest, runtime: Util.RuntimeOptions): GetDataServiceFolderResponse {
  Util.validateModel(request);
  return doRequest('GetDataServiceFolder', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getDataServiceFolder(request: GetDataServiceFolderRequest): GetDataServiceFolderResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDataServiceFolderWithOptions(request, runtime);
}

model ListTableLevelRequest = {
  projectId: long(name='ProjectId'),
  levelType: integer(name='LevelType'),
}

model ListTableLevelResponse = {
  requestId: string(name='RequestId'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  success: boolean(name='Success'),
  tableLevelInfo: {
    totalCount: long(name='TotalCount'),
    levelList: [
      {
        levelId: long(name='LevelId'),
        name: string(name='Name'),
        projectId: long(name='ProjectId'),
        levelType: integer(name='LevelType'),
        description: string(name='Description'),
      }
    ](name='LevelList'),
  }(name='TableLevelInfo'),
}

async function listTableLevelWithOptions(request: ListTableLevelRequest, runtime: Util.RuntimeOptions): ListTableLevelResponse {
  Util.validateModel(request);
  return doRequest('ListTableLevel', 'HTTPS', 'GET', '2020-05-18', 'AK', request, null, runtime);
}

async function listTableLevel(request: ListTableLevelRequest): ListTableLevelResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTableLevelWithOptions(request, runtime);
}

model ListDataServiceGroupsRequest = {
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  projectId: long(name='ProjectId'),
  tenantId: long(name='TenantId'),
  groupNameKeyword?: string(name='GroupNameKeyword'),
}

model ListDataServiceGroupsResponse = {
  requestId: string(name='RequestId'),
  groupPagingResult: {
    pageNumber: integer(name='PageNumber'),
    pageSize: integer(name='PageSize'),
    totalCount: integer(name='TotalCount'),
    groups: [
      {
        tenantId: long(name='TenantId'),
        groupId: string(name='GroupId'),
        apiGatewayGroupId: string(name='ApiGatewayGroupId'),
        groupName: string(name='GroupName'),
        description: string(name='Description'),
        createdTime: string(name='CreatedTime'),
        modifiedTime: string(name='ModifiedTime'),
        creatorId: string(name='CreatorId'),
        projectId: long(name='ProjectId'),
      }
    ](name='Groups'),
  }(name='GroupPagingResult'),
}

async function listDataServiceGroupsWithOptions(request: ListDataServiceGroupsRequest, runtime: Util.RuntimeOptions): ListDataServiceGroupsResponse {
  Util.validateModel(request);
  return doRequest('ListDataServiceGroups', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listDataServiceGroups(request: ListDataServiceGroupsRequest): ListDataServiceGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDataServiceGroupsWithOptions(request, runtime);
}

model UpdateTableThemeRequest = {
  projectId?: long(name='ProjectId'),
  name: string(name='Name'),
  themeId: long(name='ThemeId'),
}

model UpdateTableThemeResponse = {
  requestId: string(name='RequestId'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  success: boolean(name='Success'),
  updateResult: boolean(name='UpdateResult'),
}

async function updateTableThemeWithOptions(request: UpdateTableThemeRequest, runtime: Util.RuntimeOptions): UpdateTableThemeResponse {
  Util.validateModel(request);
  return doRequest('UpdateTableTheme', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function updateTableTheme(request: UpdateTableThemeRequest): UpdateTableThemeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTableThemeWithOptions(request, runtime);
}

model CreateDataServiceFolderRequest = {
  tenantId: long(name='TenantId'),
  projectId: long(name='ProjectId'),
  folderName: string(name='FolderName'),
  parentId: long(name='ParentId'),
  groupId: string(name='GroupId'),
}

model CreateDataServiceFolderResponse = {
  folderId: long(name='FolderId'),
  requestId: string(name='RequestId'),
}

async function createDataServiceFolderWithOptions(request: CreateDataServiceFolderRequest, runtime: Util.RuntimeOptions): CreateDataServiceFolderResponse {
  Util.validateModel(request);
  return doRequest('CreateDataServiceFolder', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function createDataServiceFolder(request: CreateDataServiceFolderRequest): CreateDataServiceFolderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDataServiceFolderWithOptions(request, runtime);
}

model GetDataServiceGroupRequest = {
  tenantId: long(name='TenantId'),
  projectId: long(name='ProjectId'),
  groupId: string(name='GroupId'),
}

model GetDataServiceGroupResponse = {
  requestId: string(name='RequestId'),
  group: {
    tenantId: long(name='TenantId'),
    projectId: long(name='ProjectId'),
    groupId: string(name='GroupId'),
    apiGatewayGroupId: string(name='ApiGatewayGroupId'),
    groupName: string(name='GroupName'),
    description: string(name='Description'),
    createdTime: string(name='CreatedTime'),
    modifiedTime: string(name='ModifiedTime'),
    creatorId: string(name='CreatorId'),
  }(name='Group'),
}

async function getDataServiceGroupWithOptions(request: GetDataServiceGroupRequest, runtime: Util.RuntimeOptions): GetDataServiceGroupResponse {
  Util.validateModel(request);
  return doRequest('GetDataServiceGroup', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getDataServiceGroup(request: GetDataServiceGroupRequest): GetDataServiceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDataServiceGroupWithOptions(request, runtime);
}

model CreateTableLevelRequest = {
  projectId?: long(name='ProjectId'),
  levelType: integer(name='LevelType'),
  name: string(name='Name'),
  description?: string(name='Description'),
}

model CreateTableLevelResponse = {
  requestId: string(name='RequestId'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  success: boolean(name='Success'),
  levelId: long(name='LevelId'),
}

async function createTableLevelWithOptions(request: CreateTableLevelRequest, runtime: Util.RuntimeOptions): CreateTableLevelResponse {
  Util.validateModel(request);
  return doRequest('CreateTableLevel', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function createTableLevel(request: CreateTableLevelRequest): CreateTableLevelResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTableLevelWithOptions(request, runtime);
}

model UpdateMetaTableIntroWikiRequest = {
  tableGuid: string(name='TableGuid'),
  content: string(name='Content'),
}

model UpdateMetaTableIntroWikiResponse = {
  requestId: string(name='RequestId'),
  updateResult: boolean(name='UpdateResult'),
}

async function updateMetaTableIntroWikiWithOptions(request: UpdateMetaTableIntroWikiRequest, runtime: Util.RuntimeOptions): UpdateMetaTableIntroWikiResponse {
  Util.validateModel(request);
  return doRequest('UpdateMetaTableIntroWiki', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function updateMetaTableIntroWiki(request: UpdateMetaTableIntroWikiRequest): UpdateMetaTableIntroWikiResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMetaTableIntroWikiWithOptions(request, runtime);
}

model DeleteTableLevelRequest = {
  levelId: long(name='LevelId'),
  projectId: long(name='ProjectId'),
}

model DeleteTableLevelResponse = {
  requestId: string(name='RequestId'),
  deleteResult: boolean(name='DeleteResult'),
}

async function deleteTableLevelWithOptions(request: DeleteTableLevelRequest, runtime: Util.RuntimeOptions): DeleteTableLevelResponse {
  Util.validateModel(request);
  return doRequest('DeleteTableLevel', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function deleteTableLevel(request: DeleteTableLevelRequest): DeleteTableLevelResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTableLevelWithOptions(request, runtime);
}

model UpdateTableLevelRequest = {
  projectId: long(name='ProjectId'),
  levelType?: integer(name='LevelType'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  levelId: long(name='LevelId'),
}

model UpdateTableLevelResponse = {
  requestId: string(name='RequestId'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  success: boolean(name='Success'),
  updateResult: boolean(name='UpdateResult'),
}

async function updateTableLevelWithOptions(request: UpdateTableLevelRequest, runtime: Util.RuntimeOptions): UpdateTableLevelResponse {
  Util.validateModel(request);
  return doRequest('UpdateTableLevel', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function updateTableLevel(request: UpdateTableLevelRequest): UpdateTableLevelResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTableLevelWithOptions(request, runtime);
}

model DeleteTableThemeRequest = {
  themeId: long(name='ThemeId'),
  projectId?: long(name='ProjectId'),
}

model DeleteTableThemeResponse = {
  requestId: string(name='RequestId'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  success: boolean(name='Success'),
  deleteResult: boolean(name='DeleteResult'),
}

async function deleteTableThemeWithOptions(request: DeleteTableThemeRequest, runtime: Util.RuntimeOptions): DeleteTableThemeResponse {
  Util.validateModel(request);
  return doRequest('DeleteTableTheme', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function deleteTableTheme(request: DeleteTableThemeRequest): DeleteTableThemeResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTableThemeWithOptions(request, runtime);
}

model ListProgramTypeCountRequest = {
  projectId: long(name='ProjectId'),
  projectEnv: string(name='ProjectEnv'),
}

model ListProgramTypeCountResponse = {
  requestId: string(name='RequestId'),
  programTypeAndCounts: [
    {
      programType: string(name='ProgramType'),
      count: integer(name='Count'),
    }
  ](name='ProgramTypeAndCounts'),
}

async function listProgramTypeCountWithOptions(request: ListProgramTypeCountRequest, runtime: Util.RuntimeOptions): ListProgramTypeCountResponse {
  Util.validateModel(request);
  return doRequest('ListProgramTypeCount', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listProgramTypeCount(request: ListProgramTypeCountRequest): ListProgramTypeCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProgramTypeCountWithOptions(request, runtime);
}

model UpdateTableModelInfoRequest = {
  firstLevelThemeId?: long(name='FirstLevelThemeId'),
  secondLevelThemeId?: long(name='SecondLevelThemeId'),
  levelId?: long(name='LevelId'),
  tableGuid: string(name='TableGuid'),
  levelType?: integer(name='LevelType'),
}

model UpdateTableModelInfoResponse = {
  requestId: string(name='RequestId'),
  updateResult: boolean(name='UpdateResult'),
}

async function updateTableModelInfoWithOptions(request: UpdateTableModelInfoRequest, runtime: Util.RuntimeOptions): UpdateTableModelInfoResponse {
  Util.validateModel(request);
  return doRequest('UpdateTableModelInfo', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function updateTableModelInfo(request: UpdateTableModelInfoRequest): UpdateTableModelInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTableModelInfoWithOptions(request, runtime);
}

model ListProjectsRequest = {
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model ListProjectsResponse = {
  requestId: string(name='RequestId'),
  pageResult: {
    pageNumber: integer(name='PageNumber'),
    pageSize: integer(name='PageSize'),
    totalCount: integer(name='TotalCount'),
    projectList: [
      {
        projectName: string(name='ProjectName'),
        projectIdentifier: string(name='ProjectIdentifier'),
        projectDescription: string(name='ProjectDescription'),
        projectStatus: integer(name='ProjectStatus'),
        projectId: long(name='ProjectId'),
        projectOwnerBaseId: string(name='ProjectOwnerBaseId'),
        projectStatusCode: string(name='ProjectStatusCode'),
      }
    ](name='ProjectList'),
  }(name='PageResult'),
}

async function listProjectsWithOptions(request: ListProjectsRequest, runtime: Util.RuntimeOptions): ListProjectsResponse {
  Util.validateModel(request);
  return doRequest('ListProjects', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listProjects(request: ListProjectsRequest): ListProjectsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProjectsWithOptions(request, runtime);
}

model ListProjectMembersRequest = {
  projectId: long(name='ProjectId'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model ListProjectMembersResponse = {
  requestId: string(name='RequestId'),
  data: {
    pageNumber: integer(name='PageNumber'),
    pageSize: integer(name='PageSize'),
    totalCount: integer(name='TotalCount'),
    projectMemberList: [
      {
        nick: string(name='Nick'),
        projectMemberId: string(name='ProjectMemberId'),
        projectMemberName: string(name='ProjectMemberName'),
        projectMemberType: string(name='ProjectMemberType'),
        status: string(name='Status'),
        projectRoleList: [
          {
            projectRoleCode: string(name='ProjectRoleCode'),
            projectRoleId: integer(name='ProjectRoleId'),
            projectRoleName: string(name='ProjectRoleName'),
            projectRoleType: string(name='ProjectRoleType'),
          }
        ](name='ProjectRoleList'),
      }
    ](name='ProjectMemberList'),
  }(name='Data'),
}

async function listProjectMembersWithOptions(request: ListProjectMembersRequest, runtime: Util.RuntimeOptions): ListProjectMembersResponse {
  Util.validateModel(request);
  return doRequest('ListProjectMembers', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listProjectMembers(request: ListProjectMembersRequest): ListProjectMembersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProjectMembersWithOptions(request, runtime);
}

model CreateProjectMemberRequest = {
  projectId: long(name='ProjectId'),
  userId: string(name='UserId'),
  clientToken?: string(name='ClientToken'),
  roleCode?: string(name='RoleCode'),
}

model CreateProjectMemberResponse = {
  requestId: string(name='RequestId'),
}

async function createProjectMemberWithOptions(request: CreateProjectMemberRequest, runtime: Util.RuntimeOptions): CreateProjectMemberResponse {
  Util.validateModel(request);
  return doRequest('CreateProjectMember', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function createProjectMember(request: CreateProjectMemberRequest): CreateProjectMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  return createProjectMemberWithOptions(request, runtime);
}

model ListProjectRolesRequest = {
  projectId: long(name='ProjectId'),
}

model ListProjectRolesResponse = {
  requestId: string(name='RequestId'),
  projectRoleList: [
    {
      projectRoleCode: string(name='ProjectRoleCode'),
      projectRoleId: integer(name='ProjectRoleId'),
      projectRoleName: string(name='ProjectRoleName'),
      projectRoleType: string(name='ProjectRoleType'),
    }
  ](name='ProjectRoleList'),
}

async function listProjectRolesWithOptions(request: ListProjectRolesRequest, runtime: Util.RuntimeOptions): ListProjectRolesResponse {
  Util.validateModel(request);
  return doRequest('ListProjectRoles', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listProjectRoles(request: ListProjectRolesRequest): ListProjectRolesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProjectRolesWithOptions(request, runtime);
}

model AddProjectMemberToRoleRequest = {
  projectId: long(name='ProjectId'),
  userId: string(name='UserId'),
  roleCode: string(name='RoleCode'),
  clientToken?: string(name='ClientToken'),
}

model AddProjectMemberToRoleResponse = {
  requestId: string(name='RequestId'),
}

async function addProjectMemberToRoleWithOptions(request: AddProjectMemberToRoleRequest, runtime: Util.RuntimeOptions): AddProjectMemberToRoleResponse {
  Util.validateModel(request);
  return doRequest('AddProjectMemberToRole', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function addProjectMemberToRole(request: AddProjectMemberToRoleRequest): AddProjectMemberToRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return addProjectMemberToRoleWithOptions(request, runtime);
}

model RemoveProjectMemberFromRoleRequest = {
  projectId: long(name='ProjectId'),
  userId: string(name='UserId'),
  roleCode: string(name='RoleCode'),
}

model RemoveProjectMemberFromRoleResponse = {
  requestId: string(name='RequestId'),
}

async function removeProjectMemberFromRoleWithOptions(request: RemoveProjectMemberFromRoleRequest, runtime: Util.RuntimeOptions): RemoveProjectMemberFromRoleResponse {
  Util.validateModel(request);
  return doRequest('RemoveProjectMemberFromRole', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function removeProjectMemberFromRole(request: RemoveProjectMemberFromRoleRequest): RemoveProjectMemberFromRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeProjectMemberFromRoleWithOptions(request, runtime);
}

model DeleteProjectMemberRequest = {
  projectId: long(name='ProjectId'),
  userId: string(name='UserId'),
}

model DeleteProjectMemberResponse = {
  requestId: string(name='RequestId'),
}

async function deleteProjectMemberWithOptions(request: DeleteProjectMemberRequest, runtime: Util.RuntimeOptions): DeleteProjectMemberResponse {
  Util.validateModel(request);
  return doRequest('DeleteProjectMember', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function deleteProjectMember(request: DeleteProjectMemberRequest): DeleteProjectMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteProjectMemberWithOptions(request, runtime);
}

model CreateDagComplementRequest = {
  projectEnv: string(name='ProjectEnv'),
  startBizDate: string(name='StartBizDate'),
  name: string(name='Name'),
  rootNodeId: long(name='RootNodeId'),
  includeNodeIds: string(name='IncludeNodeIds'),
  excludeNodeIds?: string(name='ExcludeNodeIds'),
  bizBeginTime?: string(name='BizBeginTime'),
  bizEndTime?: string(name='BizEndTime'),
  parallelism: boolean(name='Parallelism'),
  endBizDate: string(name='EndBizDate'),
  nodeParams?: string(name='NodeParams'),
}

model CreateDagComplementResponse = {
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  data: [ long ] (name='Data'),
}

async function createDagComplementWithOptions(request: CreateDagComplementRequest, runtime: Util.RuntimeOptions): CreateDagComplementResponse {
  Util.validateModel(request);
  return doRequest('CreateDagComplement', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function createDagComplement(request: CreateDagComplementRequest): CreateDagComplementResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDagComplementWithOptions(request, runtime);
}

model CreateDagTestRequest = {
  projectEnv: string(name='ProjectEnv'),
  bizdate: string(name='Bizdate'),
  name: string(name='Name'),
  nodeId: long(name='NodeId'),
  nodeParams?: string(name='NodeParams'),
}

model CreateDagTestResponse = {
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  data: long(name='Data'),
}

async function createDagTestWithOptions(request: CreateDagTestRequest, runtime: Util.RuntimeOptions): CreateDagTestResponse {
  Util.validateModel(request);
  return doRequest('CreateDagTest', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function createDagTest(request: CreateDagTestRequest): CreateDagTestResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDagTestWithOptions(request, runtime);
}

model ListCalcEnginesRequest = {
  projectId: long(name='ProjectId'),
  name?: string(name='Name'),
  calcEngineType: string(name='CalcEngineType'),
  envType?: string(name='EnvType'),
  pageSize?: integer(name='PageSize'),
  pageNumber?: integer(name='PageNumber'),
}

model ListCalcEnginesResponse = {
  httpStatusCode: integer(name='HttpStatusCode'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
  data: {
    pageNumber: integer(name='PageNumber'),
    pageSize: integer(name='PageSize'),
    totalCount: integer(name='TotalCount'),
    calcEngines: [
      {
        calcEngineType: string(name='CalcEngineType'),
        gmtCreate: string(name='GmtCreate'),
        dwRegion: string(name='DwRegion'),
        isDefault: boolean(name='IsDefault'),
        bindingProjectId: integer(name='BindingProjectId'),
        envType: string(name='EnvType'),
        tenantId: long(name='TenantId'),
        name: string(name='Name'),
        bindingProjectName: string(name='BindingProjectName'),
        region: string(name='Region'),
        engineId: integer(name='EngineId'),
        engineInfo: map[string]any(name='EngineInfo'),
        taskAuthType: string(name='TaskAuthType'),
      }
    ](name='CalcEngines'),
  }(name='Data'),
}

async function listCalcEnginesWithOptions(request: ListCalcEnginesRequest, runtime: Util.RuntimeOptions): ListCalcEnginesResponse {
  Util.validateModel(request);
  return doRequest('ListCalcEngines', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listCalcEngines(request: ListCalcEnginesRequest): ListCalcEnginesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCalcEnginesWithOptions(request, runtime);
}

model ListConnectionsRequest = {
  projectId: long(name='ProjectId'),
  name?: string(name='Name'),
  connectionType?: string(name='ConnectionType'),
  subType?: string(name='SubType'),
  status?: string(name='Status'),
  envType?: integer(name='EnvType'),
  pageSize?: integer(name='PageSize'),
  pageNumber?: integer(name='PageNumber'),
}

model ListConnectionsResponse = {
  httpStatusCode: integer(name='HttpStatusCode'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
  data: {
    pageNumber: integer(name='PageNumber'),
    pageSize: integer(name='PageSize'),
    totalCount: integer(name='TotalCount'),
    connections: [
      {
        shared: boolean(name='Shared'),
        gmtModified: string(name='GmtModified'),
        connectStatus: integer(name='ConnectStatus'),
        bindingCalcEngineId: integer(name='BindingCalcEngineId'),
        description: string(name='Description'),
        connectionType: string(name='ConnectionType'),
        gmtCreate: string(name='GmtCreate'),
        defaultEngine: boolean(name='DefaultEngine'),
        operator: string(name='Operator'),
        sequence: integer(name='Sequence'),
        envType: integer(name='EnvType'),
        tenantId: long(name='TenantId'),
        name: string(name='Name'),
        subType: string(name='SubType'),
        id: integer(name='Id'),
        projectId: integer(name='ProjectId'),
        status: integer(name='Status'),
        content: string(name='Content'),
      }
    ](name='Connections'),
  }(name='Data'),
}

async function listConnectionsWithOptions(request: ListConnectionsRequest, runtime: Util.RuntimeOptions): ListConnectionsResponse {
  Util.validateModel(request);
  return doRequest('ListConnections', 'HTTPS', 'GET', '2020-05-18', 'AK', request, null, runtime);
}

async function listConnections(request: ListConnectionsRequest): ListConnectionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listConnectionsWithOptions(request, runtime);
}

model UpdateConnectionRequest = {
  description?: string(name='Description'),
  envType?: integer(name='EnvType'),
  content?: string(name='Content'),
  status?: string(name='Status'),
  connectionId: long(name='ConnectionId'),
}

model UpdateConnectionResponse = {
  success: boolean(name='Success'),
  httpStatusCode: string(name='HttpStatusCode'),
  data: boolean(name='Data'),
  requestId: string(name='RequestId'),
}

async function updateConnectionWithOptions(request: UpdateConnectionRequest, runtime: Util.RuntimeOptions): UpdateConnectionResponse {
  Util.validateModel(request);
  return doRequest('UpdateConnection', 'HTTPS', 'PUT', '2020-05-18', 'AK', null, request, runtime);
}

async function updateConnection(request: UpdateConnectionRequest): UpdateConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateConnectionWithOptions(request, runtime);
}

model DeleteConnectionRequest = {
  connectionId: long(name='ConnectionId'),
}

model DeleteConnectionResponse = {
  success: boolean(name='Success'),
  httpStatusCode: string(name='HttpStatusCode'),
  data: boolean(name='Data'),
  requestId: string(name='RequestId'),
}

async function deleteConnectionWithOptions(request: DeleteConnectionRequest, runtime: Util.RuntimeOptions): DeleteConnectionResponse {
  Util.validateModel(request);
  return doRequest('DeleteConnection', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function deleteConnection(request: DeleteConnectionRequest): DeleteConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteConnectionWithOptions(request, runtime);
}

model GetProjectDetailRequest = {
  projectId: long(name='ProjectId'),
}

model GetProjectDetailResponse = {
  httpStatusCode: integer(name='HttpStatusCode'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
  data: {
    gmtModified: string(name='GmtModified'),
    defaultDiResourceGroupIdentifier: string(name='DefaultDiResourceGroupIdentifier'),
    isAllowDownload: integer(name='IsAllowDownload'),
    schedulerRetryInterval: integer(name='SchedulerRetryInterval'),
    residentArea: string(name='ResidentArea'),
    projectOwnerBaseId: string(name='ProjectOwnerBaseId'),
    projectMode: integer(name='ProjectMode'),
    gmtCreate: string(name='GmtCreate'),
    protectedMode: integer(name='ProtectedMode'),
    tenantId: long(name='TenantId'),
    projectDescription: string(name='ProjectDescription'),
    schedulerMaxRetryTimes: integer(name='SchedulerMaxRetryTimes'),
    projectName: string(name='ProjectName'),
    projectIdentifier: string(name='ProjectIdentifier'),
    projectId: integer(name='ProjectId'),
    status: integer(name='Status'),
    developmentType: integer(name='DevelopmentType'),
    envTypes: [ string ](name='EnvTypes'),
  }(name='Data'),
}

async function getProjectDetailWithOptions(request: GetProjectDetailRequest, runtime: Util.RuntimeOptions): GetProjectDetailResponse {
  Util.validateModel(request);
  return doRequest('GetProjectDetail', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getProjectDetail(request: GetProjectDetailRequest): GetProjectDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getProjectDetailWithOptions(request, runtime);
}

model ListResourceGroupsRequest = {
  resourceGroupType: integer(name='ResourceGroupType'),
  keyword?: string(name='Keyword'),
}

model ListResourceGroupsResponse = {
  httpStatusCode: integer(name='HttpStatusCode'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
  data: [
    {
      identifier: string(name='Identifier'),
      cluster: string(name='Cluster'),
      bizExtKey: string(name='BizExtKey'),
      enableKp: boolean(name='EnableKp'),
      updateTime: string(name='UpdateTime'),
      resourceGroupType: string(name='ResourceGroupType'),
      mode: string(name='Mode'),
      sequence: integer(name='Sequence'),
      isDefault: boolean(name='IsDefault'),
      createTime: string(name='CreateTime'),
      name: string(name='Name'),
      tenantId: long(name='TenantId'),
      id: long(name='Id'),
      status: integer(name='Status'),
      specs: map[string]any(name='Specs'),
    }
  ](name='Data'),
}

async function listResourceGroupsWithOptions(request: ListResourceGroupsRequest, runtime: Util.RuntimeOptions): ListResourceGroupsResponse {
  Util.validateModel(request);
  return doRequest('ListResourceGroups', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listResourceGroups(request: ListResourceGroupsRequest): ListResourceGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listResourceGroupsWithOptions(request, runtime);
}

model CreateConnectionRequest = {
  projectId: long(name='ProjectId'),
  name: string(name='Name'),
  description?: string(name='Description'),
  connectionType: string(name='ConnectionType'),
  subType?: string(name='SubType'),
  envType: integer(name='EnvType'),
  content: string(name='Content'),
}

model CreateConnectionResponse = {
  success: boolean(name='Success'),
  httpStatusCode: string(name='HttpStatusCode'),
  data: long(name='Data'),
  requestId: string(name='RequestId'),
}

async function createConnectionWithOptions(request: CreateConnectionRequest, runtime: Util.RuntimeOptions): CreateConnectionResponse {
  Util.validateModel(request);
  return doRequest('CreateConnection', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function createConnection(request: CreateConnectionRequest): CreateConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createConnectionWithOptions(request, runtime);
}

model GetDataServiceApplicationRequest = {
  tenantId: long(name='TenantId'),
  projectId: long(name='ProjectId'),
  applicationId: long(name='ApplicationId'),
}

model GetDataServiceApplicationResponse = {
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  data: {
    applicationCode: string(name='ApplicationCode'),
    applicationId: long(name='ApplicationId'),
    applicationKey: string(name='ApplicationKey'),
    applicationName: string(name='ApplicationName'),
    applicationSecret: string(name='ApplicationSecret'),
    projectId: long(name='ProjectId'),
  }(name='Data'),
}

async function getDataServiceApplicationWithOptions(request: GetDataServiceApplicationRequest, runtime: Util.RuntimeOptions): GetDataServiceApplicationResponse {
  Util.validateModel(request);
  return doRequest('GetDataServiceApplication', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getDataServiceApplication(request: GetDataServiceApplicationRequest): GetDataServiceApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDataServiceApplicationWithOptions(request, runtime);
}

model ListDataServiceApplicationsRequest = {
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  projectIdList: string(name='ProjectIdList'),
  tenantId: long(name='TenantId'),
}

model ListDataServiceApplicationsResponse = {
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  data: {
    pageNumber: integer(name='PageNumber'),
    pageSize: integer(name='PageSize'),
    totalCount: integer(name='TotalCount'),
    applications: [
      {
        applicationId: long(name='ApplicationId'),
        applicationName: string(name='ApplicationName'),
        projectId: long(name='ProjectId'),
      }
    ](name='Applications'),
  }(name='Data'),
}

async function listDataServiceApplicationsWithOptions(request: ListDataServiceApplicationsRequest, runtime: Util.RuntimeOptions): ListDataServiceApplicationsResponse {
  Util.validateModel(request);
  return doRequest('ListDataServiceApplications', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listDataServiceApplications(request: ListDataServiceApplicationsRequest): ListDataServiceApplicationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDataServiceApplicationsWithOptions(request, runtime);
}

model GetNodeOnBaselineRequest = {
  baselineId: long(name='BaselineId'),
}

model GetNodeOnBaselineResponse = {
  success: string(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  data: [
    {
      nodeId: long(name='NodeId'),
      nodeName: string(name='NodeName'),
      owner: string(name='Owner'),
      projectId: long(name='ProjectId'),
    }
  ](name='Data'),
}

async function getNodeOnBaselineWithOptions(request: GetNodeOnBaselineRequest, runtime: Util.RuntimeOptions): GetNodeOnBaselineResponse {
  Util.validateModel(request);
  return doRequest('GetNodeOnBaseline', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getNodeOnBaseline(request: GetNodeOnBaselineRequest): GetNodeOnBaselineResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNodeOnBaselineWithOptions(request, runtime);
}

model ListBaselineConfigsRequest = {
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  owner?: string(name='Owner'),
  projectId: long(name='ProjectId'),
  priority?: string(name='Priority'),
  useflag?: boolean(name='Useflag'),
  baselineTypes?: string(name='BaselineTypes'),
  searchText?: string(name='SearchText'),
}

model ListBaselineConfigsResponse = {
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  data: {
    pageNumber: integer(name='PageNumber'),
    pageSize: integer(name='PageSize'),
    totalCount: integer(name='TotalCount'),
    baselines: [
      {
        baselineId: long(name='BaselineId'),
        priority: integer(name='Priority'),
        baselineName: string(name='BaselineName'),
        owner: string(name='Owner'),
        projectId: long(name='ProjectId'),
        useFlag: boolean(name='UseFlag'),
        baselineType: string(name='BaselineType'),
        expHour: integer(name='ExpHour'),
        expMinu: integer(name='ExpMinu'),
        slaHour: integer(name='SlaHour'),
        slaMinu: integer(name='SlaMinu'),
        hourExpDetail: string(name='HourExpDetail'),
        hourSlaDetail: string(name='HourSlaDetail'),
        isDefault: boolean(name='IsDefault'),
      }
    ](name='Baselines'),
  }(name='Data'),
}

async function listBaselineConfigsWithOptions(request: ListBaselineConfigsRequest, runtime: Util.RuntimeOptions): ListBaselineConfigsResponse {
  Util.validateModel(request);
  return doRequest('ListBaselineConfigs', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listBaselineConfigs(request: ListBaselineConfigsRequest): ListBaselineConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBaselineConfigsWithOptions(request, runtime);
}

model GetMetaTableChangeLogRequest = {
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  tableGuid: string(name='TableGuid'),
  changeType?: string(name='ChangeType'),
  objectType?: string(name='ObjectType'),
  startDate?: string(name='StartDate'),
  endDate?: string(name='EndDate'),
}

model GetMetaTableChangeLogResponse = {
  requestId: string(name='RequestId'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  success: boolean(name='Success'),
  data: {
    pageNumber: integer(name='PageNumber'),
    pageSize: integer(name='PageSize'),
    totalCount: long(name='TotalCount'),
    dataEntityList: [
      {
        createTime: long(name='CreateTime'),
        modifiedTime: long(name='ModifiedTime'),
        changeType: string(name='ChangeType'),
        operator: string(name='Operator'),
        objectType: string(name='ObjectType'),
        changeContent: string(name='ChangeContent'),
      }
    ](name='DataEntityList'),
  }(name='Data'),
}

async function getMetaTableChangeLogWithOptions(request: GetMetaTableChangeLogRequest, runtime: Util.RuntimeOptions): GetMetaTableChangeLogResponse {
  Util.validateModel(request);
  return doRequest('GetMetaTableChangeLog', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getMetaTableChangeLog(request: GetMetaTableChangeLogRequest): GetMetaTableChangeLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaTableChangeLogWithOptions(request, runtime);
}

model GetMetaTableOutputRequest = {
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  tableGuid: string(name='TableGuid'),
  startDate: string(name='StartDate'),
  endDate: string(name='EndDate'),
}

model GetMetaTableOutputResponse = {
  requestId: string(name='RequestId'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  success: boolean(name='Success'),
  data: {
    pageNumber: integer(name='PageNumber'),
    pageSize: integer(name='PageSize'),
    totalCount: long(name='TotalCount'),
    dataEntityList: [
      {
        tableGuid: string(name='TableGuid'),
        taskId: string(name='TaskId'),
        startTime: string(name='StartTime'),
        endTime: string(name='EndTime'),
        waitTime: string(name='WaitTime'),
        projectId: long(name='ProjectId'),
        taskInstanceId: long(name='TaskInstanceId'),
      }
    ](name='DataEntityList'),
  }(name='Data'),
}

async function getMetaTableOutputWithOptions(request: GetMetaTableOutputRequest, runtime: Util.RuntimeOptions): GetMetaTableOutputResponse {
  Util.validateModel(request);
  return doRequest('GetMetaTableOutput', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getMetaTableOutput(request: GetMetaTableOutputRequest): GetMetaTableOutputResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaTableOutputWithOptions(request, runtime);
}

model GetMetaTablePartitionRequest = {
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  tableGuid?: string(name='TableGuid'),
  clusterId?: string(name='ClusterId'),
  databaseName?: string(name='DatabaseName'),
  tableName?: string(name='TableName'),
  dataSourceType?: string(name='DataSourceType'),
}

model GetMetaTablePartitionResponse = {
  requestId: string(name='RequestId'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  success: boolean(name='Success'),
  data: {
    pageNumber: integer(name='PageNumber'),
    pageSize: integer(name='PageSize'),
    totalCount: long(name='TotalCount'),
    dataEntityList: [
      {
        partitionGuid: string(name='PartitionGuid'),
        partitionName: string(name='PartitionName'),
        createTime: long(name='CreateTime'),
        dataSize: long(name='DataSize'),
        recordCount: long(name='RecordCount'),
        modifiedTime: long(name='ModifiedTime'),
        tableGuid: string(name='TableGuid'),
        comment: string(name='Comment'),
        partitionType: string(name='PartitionType'),
        partitionPath: string(name='PartitionPath'),
        partitionLocation: string(name='PartitionLocation'),
      }
    ](name='DataEntityList'),
  }(name='Data'),
}

async function getMetaTablePartitionWithOptions(request: GetMetaTablePartitionRequest, runtime: Util.RuntimeOptions): GetMetaTablePartitionResponse {
  Util.validateModel(request);
  return doRequest('GetMetaTablePartition', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getMetaTablePartition(request: GetMetaTablePartitionRequest): GetMetaTablePartitionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaTablePartitionWithOptions(request, runtime);
}

model GetMetaTableFullInfoRequest = {
  tableGuid?: string(name='TableGuid'),
  pageNum?: integer(name='PageNum'),
  pageSize?: integer(name='PageSize'),
  clusterId?: string(name='ClusterId'),
  databaseName?: string(name='DatabaseName'),
  tableName?: string(name='TableName'),
  dataSourceType?: string(name='DataSourceType'),
}

model GetMetaTableFullInfoResponse = {
  requestId: string(name='RequestId'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  success: boolean(name='Success'),
  data: {
    tableName: string(name='TableName'),
    tableGuid: string(name='TableGuid'),
    ownerId: string(name='OwnerId'),
    tenantId: long(name='TenantId'),
    projectId: long(name='ProjectId'),
    createTime: long(name='CreateTime'),
    lastModifyTime: long(name='LastModifyTime'),
    lifeCycle: integer(name='LifeCycle'),
    isVisible: integer(name='IsVisible'),
    projectName: string(name='ProjectName'),
    dataSize: long(name='DataSize'),
    envType: integer(name='EnvType'),
    comment: string(name='Comment'),
    totalColumnCount: long(name='TotalColumnCount'),
    lastDdlTime: long(name='LastDdlTime'),
    lastAccessTime: long(name='LastAccessTime'),
    databaseName: string(name='DatabaseName'),
    partitionKeys: string(name='PartitionKeys'),
    location: string(name='Location'),
    clusterId: string(name='ClusterId'),
    columnList: [
      {
        columnGuid: string(name='ColumnGuid'),
        columnName: string(name='ColumnName'),
        columnType: string(name='ColumnType'),
        isPrimaryKey: boolean(name='IsPrimaryKey'),
        comment: string(name='Comment'),
        isPartitionColumn: boolean(name='IsPartitionColumn'),
        isForeignKey: boolean(name='IsForeignKey'),
        caption: string(name='Caption'),
      }
    ](name='ColumnList'),
  }(name='Data'),
}

async function getMetaTableFullInfoWithOptions(request: GetMetaTableFullInfoRequest, runtime: Util.RuntimeOptions): GetMetaTableFullInfoResponse {
  Util.validateModel(request);
  return doRequest('GetMetaTableFullInfo', 'HTTPS', 'GET', '2020-05-18', 'AK', request, null, runtime);
}

async function getMetaTableFullInfo(request: GetMetaTableFullInfoRequest): GetMetaTableFullInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaTableFullInfoWithOptions(request, runtime);
}

model GetFileVersionRequest = {
  fileId: long(name='FileId'),
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  fileVersion: integer(name='FileVersion'),
}

model GetFileVersionResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  data: {
    fileVersion: integer(name='FileVersion'),
    fileContent: string(name='FileContent'),
    filePropertyContent: string(name='FilePropertyContent'),
    nodeContent: string(name='NodeContent'),
    comment: string(name='Comment'),
    nodeId: long(name='NodeId'),
    isCurrentProd: boolean(name='IsCurrentProd'),
    changeType: string(name='ChangeType'),
    status: string(name='Status'),
    fileName: string(name='FileName'),
    commitUser: string(name='CommitUser'),
    commitTime: long(name='CommitTime'),
    useType: string(name='UseType'),
  }(name='Data'),
}

async function getFileVersionWithOptions(request: GetFileVersionRequest, runtime: Util.RuntimeOptions): GetFileVersionResponse {
  Util.validateModel(request);
  return doRequest('GetFileVersion', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getFileVersion(request: GetFileVersionRequest): GetFileVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFileVersionWithOptions(request, runtime);
}

model GetMetaTableBasicInfoRequest = {
  tableGuid?: string(name='TableGuid'),
  clusterId?: string(name='ClusterId'),
  databaseName?: string(name='DatabaseName'),
  tableName?: string(name='TableName'),
  dataSourceType?: string(name='DataSourceType'),
}

model GetMetaTableBasicInfoResponse = {
  requestId: string(name='RequestId'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  success: boolean(name='Success'),
  data: {
    tableName: string(name='TableName'),
    tableGuid: string(name='TableGuid'),
    ownerId: string(name='OwnerId'),
    tenantId: long(name='TenantId'),
    projectId: long(name='ProjectId'),
    createTime: long(name='CreateTime'),
    lastModifyTime: long(name='LastModifyTime'),
    lifeCycle: integer(name='LifeCycle'),
    isVisible: integer(name='IsVisible'),
    lastDdlTime: long(name='LastDdlTime'),
    lastAccessTime: long(name='LastAccessTime'),
    envType: integer(name='EnvType'),
    dataSize: long(name='DataSize'),
    comment: string(name='Comment'),
    projectName: string(name='ProjectName'),
    databaseName: string(name='DatabaseName'),
    partitionKeys: string(name='PartitionKeys'),
    location: string(name='Location'),
    clusterId: string(name='ClusterId'),
    caption: string(name='Caption'),
  }(name='Data'),
}

async function getMetaTableBasicInfoWithOptions(request: GetMetaTableBasicInfoRequest, runtime: Util.RuntimeOptions): GetMetaTableBasicInfoResponse {
  Util.validateModel(request);
  return doRequest('GetMetaTableBasicInfo', 'HTTPS', 'GET', '2020-05-18', 'AK', request, null, runtime);
}

async function getMetaTableBasicInfo(request: GetMetaTableBasicInfoRequest): GetMetaTableBasicInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaTableBasicInfoWithOptions(request, runtime);
}

model GetMetaTableColumnRequest = {
  tableGuid?: string(name='TableGuid'),
  pageNum?: integer(name='PageNum'),
  pageSize?: integer(name='PageSize'),
  clusterId?: string(name='ClusterId'),
  databaseName?: string(name='DatabaseName'),
  tableName?: string(name='TableName'),
  dataSourceType?: string(name='DataSourceType'),
}

model GetMetaTableColumnResponse = {
  requestId: string(name='RequestId'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  success: boolean(name='Success'),
  data: {
    totalCount: long(name='TotalCount'),
    pageNum: integer(name='PageNum'),
    pageSize: integer(name='PageSize'),
    columnList: [
      {
        columnName: string(name='ColumnName'),
        columnGuid: string(name='ColumnGuid'),
        comment: string(name='Comment'),
        isPrimaryKey: boolean(name='IsPrimaryKey'),
        columnType: string(name='ColumnType'),
        isPartitionColumn: boolean(name='IsPartitionColumn'),
        isForeignKey: boolean(name='IsForeignKey'),
        caption: string(name='Caption'),
      }
    ](name='ColumnList'),
  }(name='Data'),
}

async function getMetaTableColumnWithOptions(request: GetMetaTableColumnRequest, runtime: Util.RuntimeOptions): GetMetaTableColumnResponse {
  Util.validateModel(request);
  return doRequest('GetMetaTableColumn', 'HTTPS', 'GET', '2020-05-18', 'AK', request, null, runtime);
}

async function getMetaTableColumn(request: GetMetaTableColumnRequest): GetMetaTableColumnResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaTableColumnWithOptions(request, runtime);
}

model GetMetaDBInfoRequest = {
  appGuid?: string(name='AppGuid'),
  clusterId?: string(name='ClusterId'),
  databaseName?: string(name='DatabaseName'),
  dataSourceType?: string(name='DataSourceType'),
}

model GetMetaDBInfoResponse = {
  requestId: string(name='RequestId'),
  data: {
    appGuid: string(name='AppGuid'),
    tenantId: long(name='TenantId'),
    endpoint: string(name='Endpoint'),
    projectId: long(name='ProjectId'),
    envType: integer(name='EnvType'),
    projectName: string(name='ProjectName'),
    projectNameCn: string(name='ProjectNameCn'),
    createTime: long(name='CreateTime'),
    modifyTime: long(name='ModifyTime'),
    ownerId: string(name='OwnerId'),
    ownerName: string(name='OwnerName'),
    name: string(name='Name'),
    type: string(name='Type'),
    comment: string(name='Comment'),
    location: string(name='Location'),
    clusterBizId: string(name='ClusterBizId'),
  }(name='Data'),
}

async function getMetaDBInfoWithOptions(request: GetMetaDBInfoRequest, runtime: Util.RuntimeOptions): GetMetaDBInfoResponse {
  Util.validateModel(request);
  return doRequest('GetMetaDBInfo', 'HTTPS', 'GET', '2020-05-18', 'AK', request, null, runtime);
}

async function getMetaDBInfo(request: GetMetaDBInfoRequest): GetMetaDBInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaDBInfoWithOptions(request, runtime);
}

model GetMetaCategoryRequest = {
  parentCategoryId?: long(name='ParentCategoryId'),
  pageNum?: integer(name='PageNum'),
  pageSize?: integer(name='PageSize'),
}

model GetMetaCategoryResponse = {
  requestId: string(name='RequestId'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  success: boolean(name='Success'),
  data: {
    pageNum: integer(name='PageNum'),
    pageSize: integer(name='PageSize'),
    totalCount: long(name='TotalCount'),
    dataEntityList: [
      {
        categoryId: long(name='CategoryId'),
        name: string(name='Name'),
        createTime: long(name='CreateTime'),
        modifiedTime: long(name='ModifiedTime'),
        comment: string(name='Comment'),
        ownerId: string(name='OwnerId'),
        lastOperatorId: string(name='LastOperatorId'),
        parentCategoryId: long(name='ParentCategoryId'),
        depth: integer(name='Depth'),
      }
    ](name='DataEntityList'),
  }(name='Data'),
}

async function getMetaCategoryWithOptions(request: GetMetaCategoryRequest, runtime: Util.RuntimeOptions): GetMetaCategoryResponse {
  Util.validateModel(request);
  return doRequest('GetMetaCategory', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getMetaCategory(request: GetMetaCategoryRequest): GetMetaCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaCategoryWithOptions(request, runtime);
}

model ListAlertMessagesRequest = {
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  beginTime: string(name='BeginTime'),
  endTime: string(name='EndTime'),
  remindId?: long(name='RemindId'),
  alertMethods?: string(name='AlertMethods'),
  alertUser?: string(name='AlertUser'),
  alertRuleTypes?: string(name='AlertRuleTypes'),
}

model ListAlertMessagesResponse = {
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  data: {
    pageNumber: string(name='PageNumber'),
    pageSize: string(name='PageSize'),
    totalCount: string(name='TotalCount'),
    alertMessages: [
      {
        alertId: long(name='AlertId'),
        alertTime: long(name='AlertTime'),
        source: string(name='Source'),
        remindId: long(name='RemindId'),
        remindName: string(name='RemindName'),
        alertUser: string(name='AlertUser'),
        alertMethod: string(name='AlertMethod'),
        alertMessageStatus: string(name='AlertMessageStatus'),
        content: string(name='Content'),
        instances: [
          {
            nodeId: long(name='NodeId'),
            nodeName: string(name='NodeName'),
            projectId: long(name='ProjectId'),
            status: string(name='Status'),
            instanceId: long(name='InstanceId'),
          }
        ](name='Instances'),
        topics: [
          {
            nodeId: long(name='NodeId'),
            instanceId: long(name='InstanceId'),
            topicId: long(name='TopicId'),
            topicName: string(name='TopicName'),
            topicOwner: string(name='TopicOwner'),
            topicStatus: string(name='TopicStatus'),
          }
        ](name='Topics'),
        nodes: [
          {
            nodeId: long(name='NodeId'),
            nodeName: string(name='NodeName'),
            owner: string(name='Owner'),
            projectId: long(name='ProjectId'),
          }
        ](name='Nodes'),
        slaAlert: {
          baselineId: long(name='BaselineId'),
          baselineName: string(name='BaselineName'),
          baselineOwner: string(name='BaselineOwner'),
          bizdate: long(name='Bizdate'),
          inGroupId: integer(name='InGroupId'),
          projectId: long(name='ProjectId'),
          status: string(name='Status'),
        }(name='SlaAlert'),
      }
    ](name='AlertMessages'),
  }(name='Data'),
}

async function listAlertMessagesWithOptions(request: ListAlertMessagesRequest, runtime: Util.RuntimeOptions): ListAlertMessagesResponse {
  Util.validateModel(request);
  return doRequest('ListAlertMessages', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listAlertMessages(request: ListAlertMessagesRequest): ListAlertMessagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAlertMessagesWithOptions(request, runtime);
}

model GetBaselineConfigRequest = {
  baselineId: long(name='BaselineId'),
}

model GetBaselineConfigResponse = {
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  data: {
    baselineId: long(name='BaselineId'),
    priority: integer(name='Priority'),
    baselineName: string(name='BaselineName'),
    owner: string(name='Owner'),
    projectId: long(name='ProjectId'),
    useFlag: boolean(name='UseFlag'),
    baselineType: string(name='BaselineType'),
    expHour: integer(name='ExpHour'),
    expMinu: integer(name='ExpMinu'),
    slaHour: integer(name='SlaHour'),
    slaMinu: integer(name='SlaMinu'),
    hourExpDetail: string(name='HourExpDetail'),
    hourSlaDetail: string(name='HourSlaDetail'),
    isDefault: boolean(name='IsDefault'),
  }(name='Data'),
}

async function getBaselineConfigWithOptions(request: GetBaselineConfigRequest, runtime: Util.RuntimeOptions): GetBaselineConfigResponse {
  Util.validateModel(request);
  return doRequest('GetBaselineConfig', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getBaselineConfig(request: GetBaselineConfigRequest): GetBaselineConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBaselineConfigWithOptions(request, runtime);
}

model SearchMetaTablesRequest = {
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  appGuid?: string(name='AppGuid'),
  keyword: string(name='Keyword'),
  entityType?: integer(name='EntityType'),
  clusterId?: string(name='ClusterId'),
  dataSourceType?: string(name='DataSourceType'),
}

model SearchMetaTablesResponse = {
  requestId: string(name='RequestId'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  success: boolean(name='Success'),
  data: {
    pageNumber: integer(name='PageNumber'),
    pageSize: integer(name='PageSize'),
    totalCount: long(name='TotalCount'),
    dataEntityList: [
      {
        tableName: string(name='TableName'),
        tableGuid: string(name='TableGuid'),
        ownerId: string(name='OwnerId'),
        tenantId: long(name='TenantId'),
        envType: integer(name='EnvType'),
        entityType: integer(name='EntityType'),
        projectId: long(name='ProjectId'),
        projectName: string(name='ProjectName'),
        clusterId: string(name='ClusterId'),
        databaseName: string(name='DatabaseName'),
      }
    ](name='DataEntityList'),
  }(name='Data'),
}

async function searchMetaTablesWithOptions(request: SearchMetaTablesRequest, runtime: Util.RuntimeOptions): SearchMetaTablesResponse {
  Util.validateModel(request);
  return doRequest('SearchMetaTables', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function searchMetaTables(request: SearchMetaTablesRequest): SearchMetaTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchMetaTablesWithOptions(request, runtime);
}

model GetMetaTableListByCategoryRequest = {
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  categoryId: long(name='CategoryId'),
}

model GetMetaTableListByCategoryResponse = {
  requestId: string(name='RequestId'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  success: boolean(name='Success'),
  data: {
    pageNumber: integer(name='PageNumber'),
    pageSize: integer(name='PageSize'),
    totalCount: long(name='TotalCount'),
    tableGuidList: [ string ](name='TableGuidList'),
  }(name='Data'),
}

async function getMetaTableListByCategoryWithOptions(request: GetMetaTableListByCategoryRequest, runtime: Util.RuntimeOptions): GetMetaTableListByCategoryResponse {
  Util.validateModel(request);
  return doRequest('GetMetaTableListByCategory', 'HTTPS', 'GET', '2020-05-18', 'AK', request, null, runtime);
}

async function getMetaTableListByCategory(request: GetMetaTableListByCategoryRequest): GetMetaTableListByCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaTableListByCategoryWithOptions(request, runtime);
}

model DeleteMetaCategoryRequest = {
  categoryId: long(name='CategoryId'),
}

model DeleteMetaCategoryResponse = {
  requestId: string(name='RequestId'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  success: boolean(name='Success'),
  data: boolean(name='Data'),
}

async function deleteMetaCategoryWithOptions(request: DeleteMetaCategoryRequest, runtime: Util.RuntimeOptions): DeleteMetaCategoryResponse {
  Util.validateModel(request);
  return doRequest('DeleteMetaCategory', 'HTTPS', 'GET', '2020-05-18', 'AK', request, null, runtime);
}

async function deleteMetaCategory(request: DeleteMetaCategoryRequest): DeleteMetaCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMetaCategoryWithOptions(request, runtime);
}

model UpdateMetaCategoryRequest = {
  name?: string(name='Name'),
  comment?: string(name='Comment'),
  categoryId: long(name='CategoryId'),
}

model UpdateMetaCategoryResponse = {
  requestId: string(name='RequestId'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  success: boolean(name='Success'),
  data: boolean(name='Data'),
}

async function updateMetaCategoryWithOptions(request: UpdateMetaCategoryRequest, runtime: Util.RuntimeOptions): UpdateMetaCategoryResponse {
  Util.validateModel(request);
  return doRequest('UpdateMetaCategory', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function updateMetaCategory(request: UpdateMetaCategoryRequest): UpdateMetaCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMetaCategoryWithOptions(request, runtime);
}

model ListTopicsRequest = {
  beginTime: string(name='BeginTime'),
  endTime: string(name='EndTime'),
  topicTypes?: string(name='TopicTypes'),
  topicStatuses?: string(name='TopicStatuses'),
  nodeId?: long(name='NodeId'),
  instanceId?: long(name='InstanceId'),
  owner?: string(name='Owner'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
}

model ListTopicsResponse = {
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  data: {
    pageNumber: integer(name='PageNumber'),
    pageSize: integer(name='PageSize'),
    totalCount: integer(name='TotalCount'),
    topics: [
      {
        topicId: long(name='TopicId'),
        topicName: string(name='TopicName'),
        topicStatus: string(name='TopicStatus'),
        topicType: string(name='TopicType'),
        addTime: long(name='AddTime'),
        happenTime: long(name='HappenTime'),
        fixTime: long(name='FixTime'),
        instanceId: long(name='InstanceId'),
        nodeId: long(name='NodeId'),
        nodeName: string(name='NodeName'),
        nodeOwner: string(name='NodeOwner'),
        projectId: long(name='ProjectId'),
      }
    ](name='Topics'),
  }(name='Data'),
}

async function listTopicsWithOptions(request: ListTopicsRequest, runtime: Util.RuntimeOptions): ListTopicsResponse {
  Util.validateModel(request);
  return doRequest('ListTopics', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listTopics(request: ListTopicsRequest): ListTopicsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTopicsWithOptions(request, runtime);
}

model ListFileVersionsRequest = {
  fileId: long(name='FileId'),
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model ListFileVersionsResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  data: {
    pageNumber: integer(name='PageNumber'),
    pageSize: integer(name='PageSize'),
    totalCount: integer(name='TotalCount'),
    fileVersions: [
      {
        fileVersion: integer(name='FileVersion'),
        fileContent: string(name='FileContent'),
        commitTime: long(name='CommitTime'),
        commitUser: string(name='CommitUser'),
        fileName: string(name='FileName'),
        status: string(name='Status'),
        changeType: string(name='ChangeType'),
        isCurrentProd: boolean(name='IsCurrentProd'),
        nodeId: long(name='NodeId'),
        comment: string(name='Comment'),
        nodeContent: string(name='NodeContent'),
        filePropertyContent: string(name='FilePropertyContent'),
        useType: string(name='UseType'),
      }
    ](name='FileVersions'),
  }(name='Data'),
}

async function listFileVersionsWithOptions(request: ListFileVersionsRequest, runtime: Util.RuntimeOptions): ListFileVersionsResponse {
  Util.validateModel(request);
  return doRequest('ListFileVersions', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listFileVersions(request: ListFileVersionsRequest): ListFileVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFileVersionsWithOptions(request, runtime);
}

model CreateMetaCategoryRequest = {
  name: string(name='Name'),
  comment?: string(name='Comment'),
  parentId?: long(name='ParentId'),
}

model CreateMetaCategoryResponse = {
  requestId: string(name='RequestId'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  success: boolean(name='Success'),
  data: {
    categoryId: long(name='CategoryId'),
  }(name='Data'),
}

async function createMetaCategoryWithOptions(request: CreateMetaCategoryRequest, runtime: Util.RuntimeOptions): CreateMetaCategoryResponse {
  Util.validateModel(request);
  return doRequest('CreateMetaCategory', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function createMetaCategory(request: CreateMetaCategoryRequest): CreateMetaCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMetaCategoryWithOptions(request, runtime);
}

model ListNodeIORequest = {
  nodeId: long(name='NodeId'),
  projectEnv: string(name='ProjectEnv'),
  ioType: string(name='IoType'),
}

model ListNodeIOResponse = {
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  data: [
    {
      tableName: string(name='TableName'),
      data: string(name='Data'),
    }
  ](name='Data'),
}

async function listNodeIOWithOptions(request: ListNodeIORequest, runtime: Util.RuntimeOptions): ListNodeIOResponse {
  Util.validateModel(request);
  return doRequest('ListNodeIO', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listNodeIO(request: ListNodeIORequest): ListNodeIOResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNodeIOWithOptions(request, runtime);
}

model GetTopicInfluenceRequest = {
  topicId: long(name='TopicId'),
}

model GetTopicInfluenceResponse = {
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  data: {
    topicId: long(name='TopicId'),
    influences: [
      {
        baselineId: long(name='BaselineId'),
        bizdate: long(name='Bizdate'),
        inGroupId: integer(name='InGroupId'),
        baselineName: string(name='BaselineName'),
        owner: string(name='Owner'),
        status: string(name='Status'),
        projectId: long(name='ProjectId'),
        priority: integer(name='Priority'),
        buffer: long(name='Buffer'),
      }
    ](name='Influences'),
  }(name='Data'),
}

async function getTopicInfluenceWithOptions(request: GetTopicInfluenceRequest, runtime: Util.RuntimeOptions): GetTopicInfluenceResponse {
  Util.validateModel(request);
  return doRequest('GetTopicInfluence', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getTopicInfluence(request: GetTopicInfluenceRequest): GetTopicInfluenceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTopicInfluenceWithOptions(request, runtime);
}

model GetTopicRequest = {
  topicId: long(name='TopicId'),
}

model GetTopicResponse = {
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  data: {
    topicId: long(name='TopicId'),
    topicName: string(name='TopicName'),
    topicStatus: string(name='TopicStatus'),
    topicType: string(name='TopicType'),
    addTime: long(name='AddTime'),
    alertTime: long(name='AlertTime'),
    assigner: string(name='Assigner'),
    baselineId: long(name='BaselineId'),
    baselineName: string(name='BaselineName'),
    baselineInGroupId: integer(name='BaselineInGroupId'),
    baselineStatus: string(name='BaselineStatus'),
    baselineBuffer: long(name='BaselineBuffer'),
    buffer: long(name='Buffer'),
    dealTime: long(name='DealTime'),
    dealUser: string(name='DealUser'),
    fixTime: long(name='FixTime'),
    happenTime: long(name='HappenTime'),
    instanceId: long(name='InstanceId'),
    nextAlertTime: long(name='NextAlertTime'),
    nodeId: long(name='NodeId'),
    nodeName: string(name='NodeName'),
    owner: string(name='Owner'),
    projectId: long(name='ProjectId'),
  }(name='Data'),
}

async function getTopicWithOptions(request: GetTopicRequest, runtime: Util.RuntimeOptions): GetTopicResponse {
  Util.validateModel(request);
  return doRequest('GetTopic', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getTopic(request: GetTopicRequest): GetTopicResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTopicWithOptions(request, runtime);
}

model DeleteFromMetaCategoryRequest = {
  categoryId: long(name='CategoryId'),
  tableGuid: string(name='TableGuid'),
}

model DeleteFromMetaCategoryResponse = {
  requestId: string(name='RequestId'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  success: boolean(name='Success'),
  data: boolean(name='Data'),
}

async function deleteFromMetaCategoryWithOptions(request: DeleteFromMetaCategoryRequest, runtime: Util.RuntimeOptions): DeleteFromMetaCategoryResponse {
  Util.validateModel(request);
  return doRequest('DeleteFromMetaCategory', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function deleteFromMetaCategory(request: DeleteFromMetaCategoryRequest): DeleteFromMetaCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFromMetaCategoryWithOptions(request, runtime);
}

model GetNodeRequest = {
  nodeId: long(name='NodeId'),
  projectEnv: string(name='ProjectEnv'),
}

model GetNodeResponse = {
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  data: {
    nodeId: long(name='NodeId'),
    ownerId: string(name='OwnerId'),
    description: string(name='Description'),
    resGroupName: string(name='ResGroupName'),
    nodeName: string(name='NodeName'),
    cronExpress: string(name='CronExpress'),
    repeatability: string(name='Repeatability'),
    programType: string(name='ProgramType'),
    projectId: long(name='ProjectId'),
    schedulerType: string(name='SchedulerType'),
    paramValues: string(name='ParamValues'),
  }(name='Data'),
}

async function getNodeWithOptions(request: GetNodeRequest, runtime: Util.RuntimeOptions): GetNodeResponse {
  Util.validateModel(request);
  return doRequest('GetNode', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getNode(request: GetNodeRequest): GetNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNodeWithOptions(request, runtime);
}

model ListNodesRequest = {
  owner?: string(name='Owner'),
  bizName?: string(name='BizName'),
  programType?: string(name='ProgramType'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  projectId: long(name='ProjectId'),
  projectEnv: string(name='ProjectEnv'),
  nodeName?: string(name='NodeName'),
}

model ListNodesResponse = {
  success: boolean(name='Success'),
  httpStatusCode: integer(name='HttpStatusCode'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  requestId: string(name='RequestId'),
  data: {
    pageNumber: integer(name='PageNumber'),
    pageSize: integer(name='PageSize'),
    totalCount: integer(name='TotalCount'),
    nodes: [
      {
        nodeId: long(name='NodeId'),
        nodeName: string(name='NodeName'),
        cronExpress: string(name='CronExpress'),
        schedulerType: string(name='SchedulerType'),
        programType: string(name='ProgramType'),
        ownerId: string(name='OwnerId'),
        projectId: long(name='ProjectId'),
        repeatability: boolean(name='Repeatability'),
        paramValues: string(name='ParamValues'),
        description: string(name='Description'),
        resGroupName: string(name='ResGroupName'),
      }
    ](name='Nodes'),
  }(name='Data'),
}

async function listNodesWithOptions(request: ListNodesRequest, runtime: Util.RuntimeOptions): ListNodesResponse {
  Util.validateModel(request);
  return doRequest('ListNodes', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listNodes(request: ListNodesRequest): ListNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNodesWithOptions(request, runtime);
}

model GetNodeCodeRequest = {
  nodeId: long(name='NodeId'),
  projectEnv: string(name='ProjectEnv'),
}

model GetNodeCodeResponse = {
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  data: string(name='Data'),
}

async function getNodeCodeWithOptions(request: GetNodeCodeRequest, runtime: Util.RuntimeOptions): GetNodeCodeResponse {
  Util.validateModel(request);
  return doRequest('GetNodeCode', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getNodeCode(request: GetNodeCodeRequest): GetNodeCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNodeCodeWithOptions(request, runtime);
}

model EstablishRelationTableToBusinessRequest = {
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  businessId: string(name='BusinessId'),
  tableGuid: string(name='TableGuid'),
  folderId?: string(name='FolderId'),
}

model EstablishRelationTableToBusinessResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
}

async function establishRelationTableToBusinessWithOptions(request: EstablishRelationTableToBusinessRequest, runtime: Util.RuntimeOptions): EstablishRelationTableToBusinessResponse {
  Util.validateModel(request);
  return doRequest('EstablishRelationTableToBusiness', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function establishRelationTableToBusiness(request: EstablishRelationTableToBusinessRequest): EstablishRelationTableToBusinessResponse {
  var runtime = new Util.RuntimeOptions{};
  return establishRelationTableToBusinessWithOptions(request, runtime);
}

model UpdateDataServiceApiRequest = {
  tenantId: long(name='TenantId'),
  projectId: long(name='ProjectId'),
  apiId: long(name='ApiId'),
  requestMethod: integer(name='RequestMethod'),
  responseContentType: integer(name='ResponseContentType'),
  timeout: integer(name='Timeout'),
  visibleRange: integer(name='VisibleRange'),
  protocols: string(name='Protocols'),
  wizardDetails?: string(name='WizardDetails'),
  scriptDetails?: string(name='ScriptDetails'),
  registrationDetails?: string(name='RegistrationDetails'),
  apiPath: string(name='ApiPath'),
  apiDescription: string(name='ApiDescription'),
}

model UpdateDataServiceApiResponse = {
  data: boolean(name='Data'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
}

async function updateDataServiceApiWithOptions(request: UpdateDataServiceApiRequest, runtime: Util.RuntimeOptions): UpdateDataServiceApiResponse {
  Util.validateModel(request);
  return doRequest('UpdateDataServiceApi', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function updateDataServiceApi(request: UpdateDataServiceApiRequest): UpdateDataServiceApiResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDataServiceApiWithOptions(request, runtime);
}

model UpdateUdfFileRequest = {
  fileFolderPath?: string(name='FileFolderPath'),
  projectId?: long(name='ProjectId'),
  functionType: string(name='FunctionType'),
  className: string(name='ClassName'),
  resources: string(name='Resources'),
  udfDescription?: string(name='UdfDescription'),
  cmdDescription?: string(name='CmdDescription'),
  parameterDescription?: string(name='ParameterDescription'),
  returnValue?: string(name='ReturnValue'),
  example?: string(name='Example'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  fileId: string(name='FileId'),
}

model UpdateUdfFileResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
}

async function updateUdfFileWithOptions(request: UpdateUdfFileRequest, runtime: Util.RuntimeOptions): UpdateUdfFileResponse {
  Util.validateModel(request);
  return doRequest('UpdateUdfFile', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function updateUdfFile(request: UpdateUdfFileRequest): UpdateUdfFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateUdfFileWithOptions(request, runtime);
}

model CreateUdfFileRequest = {
  fileFolderPath?: string(name='FileFolderPath'),
  projectId?: long(name='ProjectId'),
  fileName: string(name='FileName'),
  functionType: string(name='FunctionType'),
  className: string(name='ClassName'),
  resources: string(name='Resources'),
  udfDescription?: string(name='UdfDescription'),
  cmdDescription?: string(name='CmdDescription'),
  parameterDescription?: string(name='ParameterDescription'),
  returnValue?: string(name='ReturnValue'),
  example?: string(name='Example'),
  projectIdentifier?: string(name='ProjectIdentifier'),
}

model CreateUdfFileResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  data: long(name='Data'),
  httpStatusCode: integer(name='HttpStatusCode'),
}

async function createUdfFileWithOptions(request: CreateUdfFileRequest, runtime: Util.RuntimeOptions): CreateUdfFileResponse {
  Util.validateModel(request);
  return doRequest('CreateUdfFile', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function createUdfFile(request: CreateUdfFileRequest): CreateUdfFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUdfFileWithOptions(request, runtime);
}

model ListFilesRequest = {
  fileFolderPath?: string(name='FileFolderPath'),
  projectId?: long(name='ProjectId'),
  keyword?: string(name='Keyword'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  useType?: string(name='UseType'),
  fileTypes?: string(name='FileTypes'),
  owner?: string(name='Owner'),
}

model ListFilesResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  data: {
    pageNumber: integer(name='PageNumber'),
    pageSize: integer(name='PageSize'),
    totalCount: integer(name='TotalCount'),
    files: [
      {
        connectionName: string(name='ConnectionName'),
        parentId: long(name='ParentId'),
        isMaxCompute: boolean(name='IsMaxCompute'),
        createTime: long(name='CreateTime'),
        createUser: string(name='CreateUser'),
        bizId: long(name='BizId'),
        fileFolderId: string(name='FileFolderId'),
        fileName: string(name='FileName'),
        fileType: integer(name='FileType'),
        useType: string(name='UseType'),
        fileDescription: string(name='FileDescription'),
        content: string(name='Content'),
        nodeId: long(name='NodeId'),
        currentVersion: integer(name='CurrentVersion'),
        owner: string(name='Owner'),
        lastEditUser: string(name='LastEditUser'),
        lastEditTime: long(name='LastEditTime'),
        commitStatus: integer(name='CommitStatus'),
        fileId: long(name='FileId'),
      }
    ](name='Files'),
  }(name='Data'),
}

async function listFilesWithOptions(request: ListFilesRequest, runtime: Util.RuntimeOptions): ListFilesResponse {
  Util.validateModel(request);
  return doRequest('ListFiles', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listFiles(request: ListFilesRequest): ListFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFilesWithOptions(request, runtime);
}

model ListDataServiceAuthorizedApisRequest = {
  projectId: long(name='ProjectId'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  tenantId: long(name='TenantId'),
  apiNameKeyword?: string(name='ApiNameKeyword'),
}

model ListDataServiceAuthorizedApisResponse = {
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  data: {
    pageNumber: integer(name='PageNumber'),
    pageSize: integer(name='PageSize'),
    totalCount: integer(name='TotalCount'),
    apiAuthorizedList: [
      {
        apiId: long(name='ApiId'),
        apiName: string(name='ApiName'),
        apiPath: string(name='ApiPath'),
        apiStatus: integer(name='ApiStatus'),
        createdTime: string(name='CreatedTime'),
        creatorId: string(name='CreatorId'),
        grantCreatedTime: string(name='GrantCreatedTime'),
        grantEndTime: string(name='GrantEndTime'),
        grantOperatorId: string(name='GrantOperatorId'),
        groupId: string(name='GroupId'),
        modifiedTime: string(name='ModifiedTime'),
        projectId: long(name='ProjectId'),
        tenantId: long(name='TenantId'),
      }
    ](name='ApiAuthorizedList'),
  }(name='Data'),
}

async function listDataServiceAuthorizedApisWithOptions(request: ListDataServiceAuthorizedApisRequest, runtime: Util.RuntimeOptions): ListDataServiceAuthorizedApisResponse {
  Util.validateModel(request);
  return doRequest('ListDataServiceAuthorizedApis', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listDataServiceAuthorizedApis(request: ListDataServiceAuthorizedApisRequest): ListDataServiceAuthorizedApisResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDataServiceAuthorizedApisWithOptions(request, runtime);
}

model UpdateFileRequest = {
  fileFolderPath?: string(name='FileFolderPath'),
  projectId?: long(name='ProjectId'),
  fileName?: string(name='FileName'),
  fileDescription?: string(name='FileDescription'),
  content?: string(name='Content'),
  autoRerunTimes?: integer(name='AutoRerunTimes'),
  autoRerunIntervalMillis?: integer(name='AutoRerunIntervalMillis'),
  rerunMode?: string(name='RerunMode'),
  stop?: boolean(name='Stop'),
  paraValue?: string(name='ParaValue'),
  startEffectDate?: long(name='StartEffectDate'),
  endEffectDate?: long(name='EndEffectDate'),
  cronExpress?: string(name='CronExpress'),
  cycleType?: string(name='CycleType'),
  dependentType?: string(name='DependentType'),
  dependentNodeIdList?: string(name='DependentNodeIdList'),
  inputList?: string(name='InputList'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  fileId: long(name='FileId'),
  outputList?: string(name='OutputList'),
  resourceGroupIdentifier?: string(name='ResourceGroupIdentifier'),
  connectionName?: string(name='ConnectionName'),
  owner?: string(name='Owner'),
}

model UpdateFileResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
}

async function updateFileWithOptions(request: UpdateFileRequest, runtime: Util.RuntimeOptions): UpdateFileResponse {
  Util.validateModel(request);
  return doRequest('UpdateFile', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function updateFile(request: UpdateFileRequest): UpdateFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateFileWithOptions(request, runtime);
}

model DeleteFolderRequest = {
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  folderId: string(name='FolderId'),
}

model DeleteFolderResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
}

async function deleteFolderWithOptions(request: DeleteFolderRequest, runtime: Util.RuntimeOptions): DeleteFolderResponse {
  Util.validateModel(request);
  return doRequest('DeleteFolder', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function deleteFolder(request: DeleteFolderRequest): DeleteFolderResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFolderWithOptions(request, runtime);
}

model ListFoldersRequest = {
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  parentFolderPath: string(name='ParentFolderPath'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
}

model ListFoldersResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  data: {
    pageNumber: integer(name='PageNumber'),
    pageSize: integer(name='PageSize'),
    totalCount: integer(name='TotalCount'),
    folders: [
      {
        folderId: string(name='FolderId'),
        folderPath: string(name='FolderPath'),
      }
    ](name='Folders'),
  }(name='Data'),
}

async function listFoldersWithOptions(request: ListFoldersRequest, runtime: Util.RuntimeOptions): ListFoldersResponse {
  Util.validateModel(request);
  return doRequest('ListFolders', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listFolders(request: ListFoldersRequest): ListFoldersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFoldersWithOptions(request, runtime);
}

model CheckMetaPartitionRequest = {
  tableGuid?: string(name='TableGuid'),
  partition: string(name='Partition'),
  clusterId?: string(name='ClusterId'),
  databaseName?: string(name='DatabaseName'),
  tableName?: string(name='TableName'),
  dataSourceType?: string(name='DataSourceType'),
}

model CheckMetaPartitionResponse = {
  requestId: string(name='RequestId'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  success: boolean(name='Success'),
  data: boolean(name='Data'),
}

async function checkMetaPartitionWithOptions(request: CheckMetaPartitionRequest, runtime: Util.RuntimeOptions): CheckMetaPartitionResponse {
  Util.validateModel(request);
  return doRequest('CheckMetaPartition', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function checkMetaPartition(request: CheckMetaPartitionRequest): CheckMetaPartitionResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkMetaPartitionWithOptions(request, runtime);
}

model UpdateFolderRequest = {
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  folderId: string(name='FolderId'),
  folderName: string(name='FolderName'),
}

model UpdateFolderResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
}

async function updateFolderWithOptions(request: UpdateFolderRequest, runtime: Util.RuntimeOptions): UpdateFolderResponse {
  Util.validateModel(request);
  return doRequest('UpdateFolder', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function updateFolder(request: UpdateFolderRequest): UpdateFolderResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateFolderWithOptions(request, runtime);
}

model DeleteRemindRequest = {
  remindId: long(name='RemindId'),
}

model DeleteRemindResponse = {
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  data: boolean(name='Data'),
}

async function deleteRemindWithOptions(request: DeleteRemindRequest, runtime: Util.RuntimeOptions): DeleteRemindResponse {
  Util.validateModel(request);
  return doRequest('DeleteRemind', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function deleteRemind(request: DeleteRemindRequest): DeleteRemindResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRemindWithOptions(request, runtime);
}

model AddToMetaCategoryRequest = {
  categoryId: long(name='CategoryId'),
  tableGuid: string(name='TableGuid'),
}

model AddToMetaCategoryResponse = {
  requestId: string(name='RequestId'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  success: boolean(name='Success'),
  data: boolean(name='Data'),
}

async function addToMetaCategoryWithOptions(request: AddToMetaCategoryRequest, runtime: Util.RuntimeOptions): AddToMetaCategoryResponse {
  Util.validateModel(request);
  return doRequest('AddToMetaCategory', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function addToMetaCategory(request: AddToMetaCategoryRequest): AddToMetaCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return addToMetaCategoryWithOptions(request, runtime);
}

model ListInstancesRequest = {
  projectEnv: string(name='ProjectEnv'),
  nodeId?: long(name='NodeId'),
  nodeName?: string(name='NodeName'),
  owner?: string(name='Owner'),
  projectId: long(name='ProjectId'),
  bizName?: string(name='BizName'),
  programType?: string(name='ProgramType'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model ListInstancesResponse = {
  success: boolean(name='Success'),
  httpStatusCode: integer(name='HttpStatusCode'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  requestId: string(name='RequestId'),
  data: {
    pageNumber: integer(name='PageNumber'),
    pageSize: integer(name='PageSize'),
    totalCount: integer(name='TotalCount'),
    instances: [
      {
        nodeId: integer(name='NodeId'),
        instanceId: long(name='InstanceId'),
        dagId: integer(name='DagId'),
        dagType: string(name='DagType'),
        status: string(name='Status'),
        bizdate: long(name='Bizdate'),
        cycTime: long(name='CycTime'),
        createTime: long(name='CreateTime'),
        modifyTime: long(name='ModifyTime'),
        nodeName: string(name='NodeName'),
        beginWaitTimeTime: long(name='BeginWaitTimeTime'),
        beginWaitResTime: long(name='BeginWaitResTime'),
        beginRunningTime: long(name='BeginRunningTime'),
        paramValues: string(name='ParamValues'),
        finishTime: long(name='FinishTime'),
      }
    ](name='Instances'),
  }(name='Data'),
}

async function listInstancesWithOptions(request: ListInstancesRequest, runtime: Util.RuntimeOptions): ListInstancesResponse {
  Util.validateModel(request);
  return doRequest('ListInstances', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listInstances(request: ListInstancesRequest): ListInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstancesWithOptions(request, runtime);
}

model SetSuccessInstanceRequest = {
  instanceId: long(name='InstanceId'),
  projectEnv: string(name='ProjectEnv'),
}

model SetSuccessInstanceResponse = {
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  data: boolean(name='Data'),
}

async function setSuccessInstanceWithOptions(request: SetSuccessInstanceRequest, runtime: Util.RuntimeOptions): SetSuccessInstanceResponse {
  Util.validateModel(request);
  return doRequest('SetSuccessInstance', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function setSuccessInstance(request: SetSuccessInstanceRequest): SetSuccessInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return setSuccessInstanceWithOptions(request, runtime);
}

model CreateFileRequest = {
  fileFolderPath?: string(name='FileFolderPath'),
  projectId?: long(name='ProjectId'),
  fileName: string(name='FileName'),
  fileDescription?: string(name='FileDescription'),
  fileType: integer(name='FileType'),
  owner?: string(name='Owner'),
  content?: string(name='Content'),
  autoRerunTimes?: integer(name='AutoRerunTimes'),
  autoRerunIntervalMillis?: integer(name='AutoRerunIntervalMillis'),
  rerunMode?: string(name='RerunMode'),
  stop?: boolean(name='Stop'),
  paraValue?: string(name='ParaValue'),
  startEffectDate?: long(name='StartEffectDate'),
  endEffectDate?: long(name='EndEffectDate'),
  cronExpress?: string(name='CronExpress'),
  cycleType?: string(name='CycleType'),
  dependentType?: string(name='DependentType'),
  dependentNodeIdList?: string(name='DependentNodeIdList'),
  inputList: string(name='InputList'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  resourceGroupIdentifier?: string(name='ResourceGroupIdentifier'),
  resourceGroupId?: long(name='ResourceGroupId'),
  connectionName?: string(name='ConnectionName'),
}

model CreateFileResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  data: long(name='Data'),
  httpStatusCode: integer(name='HttpStatusCode'),
}

async function createFileWithOptions(request: CreateFileRequest, runtime: Util.RuntimeOptions): CreateFileResponse {
  Util.validateModel(request);
  return doRequest('CreateFile', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function createFile(request: CreateFileRequest): CreateFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFileWithOptions(request, runtime);
}

model StopInstanceRequest = {
  instanceId: long(name='InstanceId'),
  projectEnv: string(name='ProjectEnv'),
}

model StopInstanceResponse = {
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  data: boolean(name='Data'),
}

async function stopInstanceWithOptions(request: StopInstanceRequest, runtime: Util.RuntimeOptions): StopInstanceResponse {
  Util.validateModel(request);
  return doRequest('StopInstance', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function stopInstance(request: StopInstanceRequest): StopInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopInstanceWithOptions(request, runtime);
}

model ResumeInstanceRequest = {
  instanceId: long(name='InstanceId'),
  projectEnv: string(name='ProjectEnv'),
}

model ResumeInstanceResponse = {
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  data: boolean(name='Data'),
}

async function resumeInstanceWithOptions(request: ResumeInstanceRequest, runtime: Util.RuntimeOptions): ResumeInstanceResponse {
  Util.validateModel(request);
  return doRequest('ResumeInstance', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function resumeInstance(request: ResumeInstanceRequest): ResumeInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return resumeInstanceWithOptions(request, runtime);
}

model SuspendInstanceRequest = {
  instanceId: long(name='InstanceId'),
  projectEnv: string(name='ProjectEnv'),
}

model SuspendInstanceResponse = {
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  data: boolean(name='Data'),
}

async function suspendInstanceWithOptions(request: SuspendInstanceRequest, runtime: Util.RuntimeOptions): SuspendInstanceResponse {
  Util.validateModel(request);
  return doRequest('SuspendInstance', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function suspendInstance(request: SuspendInstanceRequest): SuspendInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return suspendInstanceWithOptions(request, runtime);
}

model RestartInstanceRequest = {
  instanceId: long(name='InstanceId'),
  projectEnv: string(name='ProjectEnv'),
}

model RestartInstanceResponse = {
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  data: boolean(name='Data'),
}

async function restartInstanceWithOptions(request: RestartInstanceRequest, runtime: Util.RuntimeOptions): RestartInstanceResponse {
  Util.validateModel(request);
  return doRequest('RestartInstance', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function restartInstance(request: RestartInstanceRequest): RestartInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return restartInstanceWithOptions(request, runtime);
}

model ListDataServiceApiAuthoritiesRequest = {
  projectId: long(name='ProjectId'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  tenantId: long(name='TenantId'),
  apiNameKeyword?: string(name='ApiNameKeyword'),
}

model ListDataServiceApiAuthoritiesResponse = {
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  data: {
    pageNumber: integer(name='PageNumber'),
    pageSize: integer(name='PageSize'),
    totalCount: integer(name='TotalCount'),
    apiAuthorizationList: [
      {
        apiId: long(name='ApiId'),
        apiName: string(name='ApiName'),
        apiPath: string(name='ApiPath'),
        apiStatus: integer(name='ApiStatus'),
        createdTime: string(name='CreatedTime'),
        creatorId: string(name='CreatorId'),
        groupId: string(name='GroupId'),
        modifiedTime: string(name='ModifiedTime'),
        projectId: long(name='ProjectId'),
        tenantId: long(name='TenantId'),
        authorizationRecords: [
          {
            createdTime: string(name='CreatedTime'),
            creatorId: string(name='CreatorId'),
            endTime: string(name='EndTime'),
            projectId: long(name='ProjectId'),
          }
        ](name='AuthorizationRecords'),
      }
    ](name='ApiAuthorizationList'),
  }(name='Data'),
}

async function listDataServiceApiAuthoritiesWithOptions(request: ListDataServiceApiAuthoritiesRequest, runtime: Util.RuntimeOptions): ListDataServiceApiAuthoritiesResponse {
  Util.validateModel(request);
  return doRequest('ListDataServiceApiAuthorities', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listDataServiceApiAuthorities(request: ListDataServiceApiAuthoritiesRequest): ListDataServiceApiAuthoritiesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDataServiceApiAuthoritiesWithOptions(request, runtime);
}

model ListDataServicePublishedApisRequest = {
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  projectId: long(name='ProjectId'),
  tenantId: long(name='TenantId'),
  apiNameKeyword?: string(name='ApiNameKeyword'),
  apiPathKeyword?: string(name='ApiPathKeyword'),
  creatorId?: string(name='CreatorId'),
}

model ListDataServicePublishedApisResponse = {
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  data: {
    pageNumber: integer(name='PageNumber'),
    pageSize: integer(name='PageSize'),
    totalCount: integer(name='TotalCount'),
    apis: [
      {
        apiId: long(name='ApiId'),
        apiMode: integer(name='ApiMode'),
        apiName: string(name='ApiName'),
        apiPath: string(name='ApiPath'),
        createdTime: string(name='CreatedTime'),
        creatorId: string(name='CreatorId'),
        description: string(name='Description'),
        groupId: string(name='GroupId'),
        modifiedTime: string(name='ModifiedTime'),
        operatorId: string(name='OperatorId'),
        projectId: long(name='ProjectId'),
        requestMethod: integer(name='RequestMethod'),
        responseContentType: integer(name='ResponseContentType'),
        status: integer(name='Status'),
        tenantId: long(name='TenantId'),
        timeout: integer(name='Timeout'),
        visibleRange: integer(name='VisibleRange'),
        registrationDetails: {
          failedResultSample: string(name='FailedResultSample'),
          serviceContentType: integer(name='ServiceContentType'),
          serviceHost: string(name='ServiceHost'),
          servicePath: string(name='ServicePath'),
          serviceRequestBodyDescription: string(name='ServiceRequestBodyDescription'),
          successfulResultSample: string(name='SuccessfulResultSample'),
          registrationErrorCodes: [
            {
              errorCode: string(name='ErrorCode'),
              errorMessage: string(name='ErrorMessage'),
              errorSolution: string(name='ErrorSolution'),
            }
          ](name='RegistrationErrorCodes'),
          registrationRequestParameters: [
            {
              defaultValue: string(name='DefaultValue'),
              exampleValue: string(name='ExampleValue'),
              isRequiredParameter: boolean(name='IsRequiredParameter'),
              parameterDataType: integer(name='ParameterDataType'),
              parameterDescription: string(name='ParameterDescription'),
              parameterName: string(name='ParameterName'),
              parameterOperator: integer(name='ParameterOperator'),
              parameterPosition: integer(name='ParameterPosition'),
            }
          ](name='RegistrationRequestParameters'),
        }(name='RegistrationDetails'),
        scriptDetails: {
          failedResultSample: string(name='FailedResultSample'),
          isPagedResponse: boolean(name='IsPagedResponse'),
          script: string(name='Script'),
          successfulResultSample: string(name='SuccessfulResultSample'),
          scriptErrorCodes: [
            {
              errorCode: string(name='ErrorCode'),
              errorMessage: string(name='ErrorMessage'),
              errorSolution: string(name='ErrorSolution'),
            }
          ](name='ScriptErrorCodes'),
          scriptRequestParameters: [
            {
              defaultValue: string(name='DefaultValue'),
              exampleValue: string(name='ExampleValue'),
              isRequiredParameter: boolean(name='IsRequiredParameter'),
              parameterDataType: integer(name='ParameterDataType'),
              parameterDescription: string(name='ParameterDescription'),
              parameterName: string(name='ParameterName'),
              parameterOperator: integer(name='ParameterOperator'),
              parameterPosition: integer(name='ParameterPosition'),
            }
          ](name='ScriptRequestParameters'),
          scriptResponseParameters: [
            {
              exampleValue: string(name='ExampleValue'),
              parameterDataType: integer(name='ParameterDataType'),
              parameterDescription: string(name='ParameterDescription'),
              parameterName: string(name='ParameterName'),
            }
          ](name='ScriptResponseParameters'),
          scriptConnection: {
            connectionId: long(name='ConnectionId'),
            tableName: string(name='TableName'),
          }(name='ScriptConnection'),
        }(name='ScriptDetails'),
        wizardDetails: {
          failedResultSample: string(name='FailedResultSample'),
          isPagedResponse: boolean(name='IsPagedResponse'),
          successfulResultSample: string(name='SuccessfulResultSample'),
          wizardErrorCodes: [
            {
              errorCode: string(name='ErrorCode'),
              errorMessage: string(name='ErrorMessage'),
              errorSolution: string(name='ErrorSolution'),
            }
          ](name='WizardErrorCodes'),
          wizardRequestParameters: [
            {
              defaultValue: string(name='DefaultValue'),
              exampleValue: string(name='ExampleValue'),
              isRequiredParameter: boolean(name='IsRequiredParameter'),
              parameterDataType: integer(name='ParameterDataType'),
              parameterDescription: string(name='ParameterDescription'),
              parameterName: string(name='ParameterName'),
              parameterOperator: integer(name='ParameterOperator'),
              parameterPosition: integer(name='ParameterPosition'),
            }
          ](name='WizardRequestParameters'),
          wizardResponseParameters: [
            {
              exampleValue: string(name='ExampleValue'),
              parameterDataType: integer(name='ParameterDataType'),
              parameterDescription: string(name='ParameterDescription'),
              parameterName: string(name='ParameterName'),
            }
          ](name='WizardResponseParameters'),
          wizardConnection: {
            connectionId: long(name='ConnectionId'),
            tableName: string(name='TableName'),
          }(name='WizardConnection'),
        }(name='WizardDetails'),
        protocols: [ integer ](name='Protocols'),
      }
    ](name='Apis'),
  }(name='Data'),
}

async function listDataServicePublishedApisWithOptions(request: ListDataServicePublishedApisRequest, runtime: Util.RuntimeOptions): ListDataServicePublishedApisResponse {
  Util.validateModel(request);
  return doRequest('ListDataServicePublishedApis', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listDataServicePublishedApis(request: ListDataServicePublishedApisRequest): ListDataServicePublishedApisResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDataServicePublishedApisWithOptions(request, runtime);
}

model GetInstanceLogRequest = {
  instanceId: long(name='InstanceId'),
  projectEnv: string(name='ProjectEnv'),
}

model GetInstanceLogResponse = {
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  data: string(name='Data'),
}

async function getInstanceLogWithOptions(request: GetInstanceLogRequest, runtime: Util.RuntimeOptions): GetInstanceLogResponse {
  Util.validateModel(request);
  return doRequest('GetInstanceLog', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getInstanceLog(request: GetInstanceLogRequest): GetInstanceLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceLogWithOptions(request, runtime);
}

model CreateFolderRequest = {
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  folderPath: string(name='FolderPath'),
}

model CreateFolderResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  data: string(name='Data'),
  httpStatusCode: integer(name='HttpStatusCode'),
}

async function createFolderWithOptions(request: CreateFolderRequest, runtime: Util.RuntimeOptions): CreateFolderResponse {
  Util.validateModel(request);
  return doRequest('CreateFolder', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function createFolder(request: CreateFolderRequest): CreateFolderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFolderWithOptions(request, runtime);
}

model GetBusinessRequest = {
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  businessId: long(name='BusinessId'),
}

model GetBusinessResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  data: {
    businessId: long(name='BusinessId'),
    businessName: string(name='BusinessName'),
    projectId: string(name='ProjectId'),
    owner: string(name='Owner'),
    description: string(name='Description'),
    useType: string(name='UseType'),
  }(name='Data'),
}

async function getBusinessWithOptions(request: GetBusinessRequest, runtime: Util.RuntimeOptions): GetBusinessResponse {
  Util.validateModel(request);
  return doRequest('GetBusiness', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getBusiness(request: GetBusinessRequest): GetBusinessResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBusinessWithOptions(request, runtime);
}

model GetInstanceRequest = {
  instanceId: long(name='InstanceId'),
  projectEnv: string(name='ProjectEnv'),
}

model GetInstanceResponse = {
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  data: {
    nodeId: long(name='NodeId'),
    instanceId: long(name='InstanceId'),
    dagId: long(name='DagId'),
    dagType: string(name='DagType'),
    status: string(name='Status'),
    bizdate: long(name='Bizdate'),
    paramValues: string(name='ParamValues'),
    cycTime: long(name='CycTime'),
    finishTime: long(name='FinishTime'),
    beginWaitTimeTime: long(name='BeginWaitTimeTime'),
    beginWaitResTime: long(name='BeginWaitResTime'),
    beginRunningTime: long(name='BeginRunningTime'),
    createTime: long(name='CreateTime'),
    modifyTime: long(name='ModifyTime'),
    nodeName: string(name='NodeName'),
  }(name='Data'),
}

async function getInstanceWithOptions(request: GetInstanceRequest, runtime: Util.RuntimeOptions): GetInstanceResponse {
  Util.validateModel(request);
  return doRequest('GetInstance', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getInstance(request: GetInstanceRequest): GetInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceWithOptions(request, runtime);
}

model GetFileRequest = {
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  fileId?: long(name='FileId'),
}

model GetFileResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  data: {
    file: {
      connectionName: string(name='ConnectionName'),
      parentId: long(name='ParentId'),
      isMaxCompute: boolean(name='IsMaxCompute'),
      createTime: long(name='CreateTime'),
      createUser: string(name='CreateUser'),
      bizId: long(name='BizId'),
      fileFolderId: string(name='FileFolderId'),
      fileName: string(name='FileName'),
      fileType: integer(name='FileType'),
      useType: string(name='UseType'),
      fileDescription: string(name='FileDescription'),
      content: string(name='Content'),
      nodeId: long(name='NodeId'),
      currentVersion: integer(name='CurrentVersion'),
      owner: string(name='Owner'),
      lastEditUser: string(name='LastEditUser'),
      lastEditTime: long(name='LastEditTime'),
      commitStatus: integer(name='CommitStatus'),
    }(name='File'),
    nodeConfiguration: {
      autoRerunTimes: integer(name='AutoRerunTimes'),
      autoRerunIntervalMillis: integer(name='AutoRerunIntervalMillis'),
      rerunMode: string(name='RerunMode'),
      stop: boolean(name='Stop'),
      paraValue: string(name='ParaValue'),
      startEffectDate: long(name='StartEffectDate'),
      endEffectDate: long(name='EndEffectDate'),
      cronExpress: string(name='CronExpress'),
      cycleType: string(name='CycleType'),
      dependentType: string(name='DependentType'),
      dependentNodeIdList: string(name='DependentNodeIdList'),
      resourceGroupId: long(name='ResourceGroupId'),
      inputList: [
        {
          input: string(name='Input'),
        }
      ](name='InputList'),
      outputList: [
        {
          output: string(name='Output'),
          refTableName: string(name='RefTableName'),
        }
      ](name='OutputList'),
    }(name='NodeConfiguration'),
  }(name='Data'),
}

async function getFileWithOptions(request: GetFileRequest, runtime: Util.RuntimeOptions): GetFileResponse {
  Util.validateModel(request);
  return doRequest('GetFile', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getFile(request: GetFileRequest): GetFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFileWithOptions(request, runtime);
}

model ListBusinessRequest = {
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  keyword?: string(name='Keyword'),
}

model ListBusinessResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  data: {
    pageNumber: integer(name='PageNumber'),
    pageSize: integer(name='PageSize'),
    totalCount: integer(name='TotalCount'),
    business: [
      {
        businessId: long(name='BusinessId'),
        businessName: string(name='BusinessName'),
        projectId: long(name='ProjectId'),
        owner: string(name='Owner'),
        description: string(name='Description'),
        useType: string(name='UseType'),
      }
    ](name='Business'),
  }(name='Data'),
}

async function listBusinessWithOptions(request: ListBusinessRequest, runtime: Util.RuntimeOptions): ListBusinessResponse {
  Util.validateModel(request);
  return doRequest('ListBusiness', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listBusiness(request: ListBusinessRequest): ListBusinessResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBusinessWithOptions(request, runtime);
}

model GetMetaDBTableListRequest = {
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  appGuid?: string(name='AppGuid'),
  clusterId?: string(name='ClusterId'),
  databaseName?: string(name='DatabaseName'),
  dataSourceType?: string(name='DataSourceType'),
}

model GetMetaDBTableListResponse = {
  requestId: string(name='RequestId'),
  data: {
    pageNumber: integer(name='PageNumber'),
    pageSize: integer(name='PageSize'),
    totalCount: long(name='TotalCount'),
    tableEntityList: [
      {
        tableName: string(name='TableName'),
        tableGuid: string(name='TableGuid'),
        databaseName: string(name='DatabaseName'),
      }
    ](name='TableEntityList'),
  }(name='Data'),
}

async function getMetaDBTableListWithOptions(request: GetMetaDBTableListRequest, runtime: Util.RuntimeOptions): GetMetaDBTableListResponse {
  Util.validateModel(request);
  return doRequest('GetMetaDBTableList', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getMetaDBTableList(request: GetMetaDBTableListRequest): GetMetaDBTableListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaDBTableListWithOptions(request, runtime);
}

model CheckMetaTableRequest = {
  tableGuid?: string(name='TableGuid'),
  clusterId?: string(name='ClusterId'),
  databaseName?: string(name='DatabaseName'),
  tableName?: string(name='TableName'),
  dataSourceType?: string(name='DataSourceType'),
}

model CheckMetaTableResponse = {
  requestId: string(name='RequestId'),
  data: boolean(name='Data'),
}

async function checkMetaTableWithOptions(request: CheckMetaTableRequest, runtime: Util.RuntimeOptions): CheckMetaTableResponse {
  Util.validateModel(request);
  return doRequest('CheckMetaTable', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function checkMetaTable(request: CheckMetaTableRequest): CheckMetaTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkMetaTableWithOptions(request, runtime);
}

model GetFolderRequest = {
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  folderId?: string(name='FolderId'),
  folderPath?: string(name='FolderPath'),
}

model GetFolderResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  data: {
    folderId: string(name='FolderId'),
    folderPath: string(name='FolderPath'),
  }(name='Data'),
}

async function getFolderWithOptions(request: GetFolderRequest, runtime: Util.RuntimeOptions): GetFolderResponse {
  Util.validateModel(request);
  return doRequest('GetFolder', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getFolder(request: GetFolderRequest): GetFolderResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFolderWithOptions(request, runtime);
}

model DeployFileRequest = {
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  fileId?: long(name='FileId'),
  comment?: string(name='Comment'),
  nodeId?: long(name='NodeId'),
}

model DeployFileResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  data: long(name='Data'),
  httpStatusCode: integer(name='HttpStatusCode'),
}

async function deployFileWithOptions(request: DeployFileRequest, runtime: Util.RuntimeOptions): DeployFileResponse {
  Util.validateModel(request);
  return doRequest('DeployFile', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function deployFile(request: DeployFileRequest): DeployFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return deployFileWithOptions(request, runtime);
}

model DeleteBusinessRequest = {
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  businessId: long(name='BusinessId'),
}

model DeleteBusinessResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
}

async function deleteBusinessWithOptions(request: DeleteBusinessRequest, runtime: Util.RuntimeOptions): DeleteBusinessResponse {
  Util.validateModel(request);
  return doRequest('DeleteBusiness', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function deleteBusiness(request: DeleteBusinessRequest): DeleteBusinessResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBusinessWithOptions(request, runtime);
}

model DeleteFileRequest = {
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  fileId: long(name='FileId'),
}

model DeleteFileResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
}

async function deleteFileWithOptions(request: DeleteFileRequest, runtime: Util.RuntimeOptions): DeleteFileResponse {
  Util.validateModel(request);
  return doRequest('DeleteFile', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function deleteFile(request: DeleteFileRequest): DeleteFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFileWithOptions(request, runtime);
}

model ListQualityRulesRequest = {
  projectName: string(name='ProjectName'),
  entityId: long(name='EntityId'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
}

model ListQualityRulesResponse = {
  errorCode: string(name='ErrorCode'),
  success: boolean(name='Success'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  data: {
    totalCount: long(name='TotalCount'),
    pageNumber: integer(name='PageNumber'),
    pageSize: integer(name='PageSize'),
    rules: [
      {
        projectName: string(name='ProjectName'),
        tableName: string(name='TableName'),
        id: integer(name='Id'),
        entityId: integer(name='EntityId'),
        property: string(name='Property'),
        methodId: integer(name='MethodId'),
        methodName: string(name='MethodName'),
        onDuty: string(name='OnDuty'),
        ruleType: integer(name='RuleType'),
        blockType: integer(name='BlockType'),
        templateId: integer(name='TemplateId'),
        templateName: string(name='TemplateName'),
        ruleCheckerRelationId: integer(name='RuleCheckerRelationId'),
        checkerId: integer(name='CheckerId'),
        fixCheck: boolean(name='FixCheck'),
        trend: string(name='Trend'),
        warningThreshold: string(name='WarningThreshold'),
        criticalThreshold: string(name='CriticalThreshold'),
        historyWarningThreshold: string(name='HistoryWarningThreshold'),
        historyCriticalThreshold: string(name='HistoryCriticalThreshold'),
        propertyKey: string(name='PropertyKey'),
        matchExpression: string(name='MatchExpression'),
        comment: string(name='Comment'),
        expectValue: string(name='ExpectValue'),
      }
    ](name='Rules'),
  }(name='Data'),
}

async function listQualityRulesWithOptions(request: ListQualityRulesRequest, runtime: Util.RuntimeOptions): ListQualityRulesResponse {
  Util.validateModel(request);
  return doRequest('ListQualityRules', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listQualityRules(request: ListQualityRulesRequest): ListQualityRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listQualityRulesWithOptions(request, runtime);
}

model CreateRemindRequest = {
  remindName: string(name='RemindName'),
  dndEnd?: string(name='DndEnd'),
  remindUnit: string(name='RemindUnit'),
  nodeIds?: string(name='NodeIds'),
  baselineIds?: string(name='BaselineIds'),
  projectId?: long(name='ProjectId'),
  bizProcessIds?: string(name='BizProcessIds'),
  remindType: string(name='RemindType'),
  maxAlertTimes?: integer(name='MaxAlertTimes'),
  alertInterval?: integer(name='AlertInterval'),
  detail?: string(name='Detail'),
  alertUnit: string(name='AlertUnit'),
  alertMethods?: string(name='AlertMethods'),
  alertTargets?: string(name='AlertTargets'),
  robotUrls?: string(name='RobotUrls'),
}

model CreateRemindResponse = {
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  data: long(name='Data'),
}

async function createRemindWithOptions(request: CreateRemindRequest, runtime: Util.RuntimeOptions): CreateRemindResponse {
  Util.validateModel(request);
  return doRequest('CreateRemind', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function createRemind(request: CreateRemindRequest): CreateRemindResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRemindWithOptions(request, runtime);
}

model GetQualityRuleRequest = {
  ruleId: long(name='RuleId'),
  projectName: string(name='ProjectName'),
}

model GetQualityRuleResponse = {
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  data: {
    id: long(name='Id'),
    entityId: long(name='EntityId'),
    property: string(name='Property'),
    methodId: integer(name='MethodId'),
    methodName: string(name='MethodName'),
    whereCondition: string(name='WhereCondition'),
    onDuty: string(name='OnDuty'),
    ruleType: integer(name='RuleType'),
    blockType: integer(name='BlockType'),
    templateId: integer(name='TemplateId'),
    templateName: string(name='TemplateName'),
    comment: string(name='Comment'),
    ruleName: string(name='RuleName'),
    predictType: integer(name='PredictType'),
    warningThreshold: string(name='WarningThreshold'),
    criticalThreshold: string(name='CriticalThreshold'),
    operator: string(name='Operator'),
    expectValue: string(name='ExpectValue'),
    trend: string(name='Trend'),
    checkerName: string(name='CheckerName'),
    checker: integer(name='Checker'),
    fixCheck: boolean(name='FixCheck'),
  }(name='Data'),
}

async function getQualityRuleWithOptions(request: GetQualityRuleRequest, runtime: Util.RuntimeOptions): GetQualityRuleResponse {
  Util.validateModel(request);
  return doRequest('GetQualityRule', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getQualityRule(request: GetQualityRuleRequest): GetQualityRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return getQualityRuleWithOptions(request, runtime);
}

model GetDeploymentRequest = {
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  deploymentId: long(name='DeploymentId'),
}

model GetDeploymentResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  data: {
    deployment: {
      name: string(name='Name'),
      creatorId: string(name='CreatorId'),
      handlerId: string(name='HandlerId'),
      createTime: long(name='CreateTime'),
      executeTime: long(name='ExecuteTime'),
      status: integer(name='Status'),
      fromEnvironment: integer(name='FromEnvironment'),
      toEnvironment: integer(name='ToEnvironment'),
      errorMessage: string(name='ErrorMessage'),
    }(name='Deployment'),
  }(name='Data'),
}

async function getDeploymentWithOptions(request: GetDeploymentRequest, runtime: Util.RuntimeOptions): GetDeploymentResponse {
  Util.validateModel(request);
  return doRequest('GetDeployment', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getDeployment(request: GetDeploymentRequest): GetDeploymentResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDeploymentWithOptions(request, runtime);
}

model UpdateRemindRequest = {
  remindId: long(name='RemindId'),
  remindName?: string(name='RemindName'),
  dndEnd?: string(name='DndEnd'),
  remindUnit?: string(name='RemindUnit'),
  nodeIds?: string(name='NodeIds'),
  baselineIds?: string(name='BaselineIds'),
  projectId?: long(name='ProjectId'),
  bizProcessIds?: string(name='BizProcessIds'),
  remindType?: string(name='RemindType'),
  maxAlertTimes?: integer(name='MaxAlertTimes'),
  alertInterval?: integer(name='AlertInterval'),
  detail?: string(name='Detail'),
  alertUnit?: string(name='AlertUnit'),
  alertMethods?: string(name='AlertMethods'),
  alertTargets?: string(name='AlertTargets'),
  useFlag?: boolean(name='UseFlag'),
  robotUrls?: string(name='RobotUrls'),
}

model UpdateRemindResponse = {
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  data: boolean(name='Data'),
}

async function updateRemindWithOptions(request: UpdateRemindRequest, runtime: Util.RuntimeOptions): UpdateRemindResponse {
  Util.validateModel(request);
  return doRequest('UpdateRemind', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function updateRemind(request: UpdateRemindRequest): UpdateRemindResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateRemindWithOptions(request, runtime);
}

model GetMetaColumnLineageRequest = {
  columnGuid?: string(name='ColumnGuid'),
  direction: string(name='Direction'),
  pageNum?: integer(name='PageNum'),
  pageSize?: integer(name='PageSize'),
  clusterId?: string(name='ClusterId'),
  databaseName?: string(name='DatabaseName'),
  tableName?: string(name='TableName'),
  columnName?: string(name='ColumnName'),
  dataSourceType?: string(name='DataSourceType'),
}

model GetMetaColumnLineageResponse = {
  requestId: string(name='RequestId'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  success: boolean(name='Success'),
  data: {
    totalCount: long(name='TotalCount'),
    pageNum: integer(name='PageNum'),
    pageSize: integer(name='PageSize'),
    dataEntityList: [
      {
        columnName: string(name='ColumnName'),
        columnGuid: string(name='ColumnGuid'),
        clusterId: string(name='ClusterId'),
        databaseName: string(name='DatabaseName'),
        tableName: string(name='TableName'),
      }
    ](name='DataEntityList'),
  }(name='Data'),
}

async function getMetaColumnLineageWithOptions(request: GetMetaColumnLineageRequest, runtime: Util.RuntimeOptions): GetMetaColumnLineageResponse {
  Util.validateModel(request);
  return doRequest('GetMetaColumnLineage', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getMetaColumnLineage(request: GetMetaColumnLineageRequest): GetMetaColumnLineageResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaColumnLineageWithOptions(request, runtime);
}

model UpdateBusinessRequest = {
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  businessName?: string(name='BusinessName'),
  description?: string(name='Description'),
  owner?: string(name='Owner'),
  businessId: long(name='BusinessId'),
}

model UpdateBusinessResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
}

async function updateBusinessWithOptions(request: UpdateBusinessRequest, runtime: Util.RuntimeOptions): UpdateBusinessResponse {
  Util.validateModel(request);
  return doRequest('UpdateBusiness', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function updateBusiness(request: UpdateBusinessRequest): UpdateBusinessResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateBusinessWithOptions(request, runtime);
}

model UpdateQualityRuleRequest = {
  blockType?: integer(name='BlockType'),
  entityId?: long(name='EntityId'),
  comment?: string(name='Comment'),
  checker?: integer(name='Checker'),
  expectValue?: string(name='ExpectValue'),
  id: long(name='Id'),
  trend?: string(name='Trend'),
  methodName?: string(name='MethodName'),
  operator?: string(name='Operator'),
  projectName: string(name='ProjectName'),
  property?: string(name='Property'),
  propertyType?: string(name='PropertyType'),
  ruleType?: integer(name='RuleType'),
  whereCondition?: string(name='WhereCondition'),
  criticalThreshold?: string(name='CriticalThreshold'),
  warningThreshold?: string(name='WarningThreshold'),
  templateId?: integer(name='TemplateId'),
  ruleName?: string(name='RuleName'),
  predictType?: integer(name='PredictType'),
}

model UpdateQualityRuleResponse = {
  errorCode: string(name='ErrorCode'),
  data: boolean(name='Data'),
  success: boolean(name='Success'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
}

async function updateQualityRuleWithOptions(request: UpdateQualityRuleRequest, runtime: Util.RuntimeOptions): UpdateQualityRuleResponse {
  Util.validateModel(request);
  return doRequest('UpdateQualityRule', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function updateQualityRule(request: UpdateQualityRuleRequest): UpdateQualityRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateQualityRuleWithOptions(request, runtime);
}

model DeleteQualityRuleRequest = {
  projectName: string(name='ProjectName'),
  ruleId: long(name='RuleId'),
}

model DeleteQualityRuleResponse = {
  errorCode: string(name='ErrorCode'),
  data: boolean(name='Data'),
  errorMessage: string(name='ErrorMessage'),
  success: boolean(name='Success'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
}

async function deleteQualityRuleWithOptions(request: DeleteQualityRuleRequest, runtime: Util.RuntimeOptions): DeleteQualityRuleResponse {
  Util.validateModel(request);
  return doRequest('DeleteQualityRule', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function deleteQualityRule(request: DeleteQualityRuleRequest): DeleteQualityRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteQualityRuleWithOptions(request, runtime);
}

model SubmitFileRequest = {
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  fileId: long(name='FileId'),
  comment?: string(name='Comment'),
}

model SubmitFileResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  data: long(name='Data'),
  httpStatusCode: integer(name='HttpStatusCode'),
}

async function submitFileWithOptions(request: SubmitFileRequest, runtime: Util.RuntimeOptions): SubmitFileResponse {
  Util.validateModel(request);
  return doRequest('SubmitFile', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function submitFile(request: SubmitFileRequest): SubmitFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitFileWithOptions(request, runtime);
}

model GetDataServiceApiRequest = {
  tenantId: long(name='TenantId'),
  projectId: long(name='ProjectId'),
  apiId: long(name='ApiId'),
}

model GetDataServiceApiResponse = {
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  data: {
    apiId: long(name='ApiId'),
    apiMode: integer(name='ApiMode'),
    apiName: string(name='ApiName'),
    apiPath: string(name='ApiPath'),
    createdTime: string(name='CreatedTime'),
    creatorId: string(name='CreatorId'),
    description: string(name='Description'),
    groupId: string(name='GroupId'),
    modifiedTime: string(name='ModifiedTime'),
    operatorId: string(name='OperatorId'),
    projectId: long(name='ProjectId'),
    requestMethod: integer(name='RequestMethod'),
    responseContentType: integer(name='ResponseContentType'),
    status: integer(name='Status'),
    tenantId: long(name='TenantId'),
    timeout: integer(name='Timeout'),
    visibleRange: integer(name='VisibleRange'),
    folderId: long(name='FolderId'),
    registrationDetails: {
      failedResultSample: string(name='FailedResultSample'),
      serviceContentType: integer(name='ServiceContentType'),
      serviceHost: string(name='ServiceHost'),
      servicePath: string(name='ServicePath'),
      serviceRequestBodyDescription: string(name='ServiceRequestBodyDescription'),
      successfulResultSample: string(name='SuccessfulResultSample'),
      registrationErrorCodes: [
        {
          errorCode: string(name='ErrorCode'),
          errorMessage: string(name='ErrorMessage'),
          errorSolution: string(name='ErrorSolution'),
        }
      ](name='RegistrationErrorCodes'),
      registrationRequestParameters: [
        {
          columnName: string(name='ColumnName'),
          defaultValue: string(name='DefaultValue'),
          exampleValue: string(name='ExampleValue'),
          isRequiredParameter: boolean(name='IsRequiredParameter'),
          parameterDataType: integer(name='ParameterDataType'),
          parameterDescription: string(name='ParameterDescription'),
          parameterName: string(name='ParameterName'),
          parameterOperator: integer(name='ParameterOperator'),
          parameterPosition: integer(name='ParameterPosition'),
        }
      ](name='RegistrationRequestParameters'),
    }(name='RegistrationDetails'),
    scriptDetails: {
      isPagedResponse: boolean(name='IsPagedResponse'),
      script: string(name='Script'),
      scriptRequestParameters: [
        {
          columnName: string(name='ColumnName'),
          defaultValue: string(name='DefaultValue'),
          exampleValue: string(name='ExampleValue'),
          isRequiredParameter: boolean(name='IsRequiredParameter'),
          parameterDataType: integer(name='ParameterDataType'),
          parameterDescription: string(name='ParameterDescription'),
          parameterName: string(name='ParameterName'),
          parameterOperator: integer(name='ParameterOperator'),
          parameterPosition: integer(name='ParameterPosition'),
        }
      ](name='ScriptRequestParameters'),
      scriptResponseParameters: [
        {
          columnName: string(name='ColumnName'),
          exampleValue: string(name='ExampleValue'),
          parameterDataType: integer(name='ParameterDataType'),
          parameterDescription: string(name='ParameterDescription'),
          parameterName: string(name='ParameterName'),
        }
      ](name='ScriptResponseParameters'),
      scriptConnection: {
        connectionId: long(name='ConnectionId'),
        tableName: string(name='TableName'),
      }(name='ScriptConnection'),
    }(name='ScriptDetails'),
    wizardDetails: {
      isPagedResponse: boolean(name='IsPagedResponse'),
      wizardRequestParameters: [
        {
          columnName: string(name='ColumnName'),
          defaultValue: string(name='DefaultValue'),
          exampleValue: string(name='ExampleValue'),
          isRequiredParameter: boolean(name='IsRequiredParameter'),
          parameterDataType: integer(name='ParameterDataType'),
          parameterDescription: string(name='ParameterDescription'),
          parameterName: string(name='ParameterName'),
          parameterOperator: integer(name='ParameterOperator'),
          parameterPosition: integer(name='ParameterPosition'),
        }
      ](name='WizardRequestParameters'),
      wizardResponseParameters: [
        {
          columnName: string(name='ColumnName'),
          exampleValue: string(name='ExampleValue'),
          parameterDataType: integer(name='ParameterDataType'),
          parameterDescription: string(name='ParameterDescription'),
          parameterName: string(name='ParameterName'),
        }
      ](name='WizardResponseParameters'),
      wizardConnection: {
        connectionId: long(name='ConnectionId'),
        tableName: string(name='TableName'),
      }(name='WizardConnection'),
    }(name='WizardDetails'),
    protocols: [ integer ](name='Protocols'),
  }(name='Data'),
}

async function getDataServiceApiWithOptions(request: GetDataServiceApiRequest, runtime: Util.RuntimeOptions): GetDataServiceApiResponse {
  Util.validateModel(request);
  return doRequest('GetDataServiceApi', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getDataServiceApi(request: GetDataServiceApiRequest): GetDataServiceApiResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDataServiceApiWithOptions(request, runtime);
}

model ListDataServiceApisRequest = {
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  projectId: long(name='ProjectId'),
  tenantId: long(name='TenantId'),
  apiNameKeyword?: string(name='ApiNameKeyword'),
  apiPathKeyword?: string(name='ApiPathKeyword'),
  creatorId?: string(name='CreatorId'),
}

model ListDataServiceApisResponse = {
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  data: {
    pageNumber: integer(name='PageNumber'),
    pageSize: integer(name='PageSize'),
    totalCount: integer(name='TotalCount'),
    apis: [
      {
        apiId: long(name='ApiId'),
        apiMode: integer(name='ApiMode'),
        apiName: string(name='ApiName'),
        apiPath: string(name='ApiPath'),
        createdTime: string(name='CreatedTime'),
        creatorId: string(name='CreatorId'),
        description: string(name='Description'),
        groupId: string(name='GroupId'),
        modifiedTime: string(name='ModifiedTime'),
        operatorId: string(name='OperatorId'),
        projectId: long(name='ProjectId'),
        requestMethod: integer(name='RequestMethod'),
        responseContentType: integer(name='ResponseContentType'),
        status: integer(name='Status'),
        tenantId: long(name='TenantId'),
        timeout: integer(name='Timeout'),
        visibleRange: integer(name='VisibleRange'),
        folderId: long(name='FolderId'),
        registrationDetails: {
          failedResultSample: string(name='FailedResultSample'),
          serviceContentType: integer(name='ServiceContentType'),
          serviceHost: string(name='ServiceHost'),
          servicePath: string(name='ServicePath'),
          serviceRequestBodyDescription: string(name='ServiceRequestBodyDescription'),
          successfulResultSample: string(name='SuccessfulResultSample'),
          registrationErrorCodes: [
            {
              errorCode: string(name='ErrorCode'),
              errorMessage: string(name='ErrorMessage'),
              errorSolution: string(name='ErrorSolution'),
            }
          ](name='RegistrationErrorCodes'),
          registrationRequestParameters: [
            {
              columnName: string(name='ColumnName'),
              defaultValue: string(name='DefaultValue'),
              exampleValue: string(name='ExampleValue'),
              isRequiredParameter: boolean(name='IsRequiredParameter'),
              parameterDataType: integer(name='ParameterDataType'),
              parameterDescription: string(name='ParameterDescription'),
              parameterName: string(name='ParameterName'),
              parameterOperator: integer(name='ParameterOperator'),
              parameterPosition: integer(name='ParameterPosition'),
            }
          ](name='RegistrationRequestParameters'),
        }(name='RegistrationDetails'),
        scriptDetails: {
          isPagedResponse: boolean(name='IsPagedResponse'),
          script: string(name='Script'),
          scriptRequestParameters: [
            {
              columnName: string(name='ColumnName'),
              defaultValue: string(name='DefaultValue'),
              exampleValue: string(name='ExampleValue'),
              isRequiredParameter: boolean(name='IsRequiredParameter'),
              parameterDataType: integer(name='ParameterDataType'),
              parameterDescription: string(name='ParameterDescription'),
              parameterName: string(name='ParameterName'),
              parameterOperator: integer(name='ParameterOperator'),
              parameterPosition: integer(name='ParameterPosition'),
            }
          ](name='ScriptRequestParameters'),
          scriptResponseParameters: [
            {
              columnName: string(name='ColumnName'),
              exampleValue: string(name='ExampleValue'),
              parameterDataType: integer(name='ParameterDataType'),
              parameterDescription: string(name='ParameterDescription'),
              parameterName: string(name='ParameterName'),
            }
          ](name='ScriptResponseParameters'),
          scriptConnection: {
            connectionId: long(name='ConnectionId'),
            tableName: string(name='TableName'),
          }(name='ScriptConnection'),
        }(name='ScriptDetails'),
        wizardDetails: {
          isPagedResponse: boolean(name='IsPagedResponse'),
          wizardRequestParameters: [
            {
              columnName: string(name='ColumnName'),
              defaultValue: string(name='DefaultValue'),
              exampleValue: string(name='ExampleValue'),
              isRequiredParameter: boolean(name='IsRequiredParameter'),
              parameterDataType: integer(name='ParameterDataType'),
              parameterDescription: string(name='ParameterDescription'),
              parameterName: string(name='ParameterName'),
              parameterOperator: integer(name='ParameterOperator'),
              parameterPosition: integer(name='ParameterPosition'),
            }
          ](name='WizardRequestParameters'),
          wizardResponseParameters: [
            {
              columnName: string(name='ColumnName'),
              exampleValue: string(name='ExampleValue'),
              parameterDataType: integer(name='ParameterDataType'),
              parameterDescription: string(name='ParameterDescription'),
              parameterName: string(name='ParameterName'),
            }
          ](name='WizardResponseParameters'),
          wizardConnection: {
            connectionId: long(name='ConnectionId'),
            tableName: string(name='TableName'),
          }(name='WizardConnection'),
        }(name='WizardDetails'),
        protocols: [ integer ](name='Protocols'),
      }
    ](name='Apis'),
  }(name='Data'),
}

async function listDataServiceApisWithOptions(request: ListDataServiceApisRequest, runtime: Util.RuntimeOptions): ListDataServiceApisResponse {
  Util.validateModel(request);
  return doRequest('ListDataServiceApis', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listDataServiceApis(request: ListDataServiceApisRequest): ListDataServiceApisResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDataServiceApisWithOptions(request, runtime);
}

model GetDataServicePublishedApiRequest = {
  projectId: long(name='ProjectId'),
  tenantId: long(name='TenantId'),
  apiId: long(name='ApiId'),
}

model GetDataServicePublishedApiResponse = {
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  data: {
    apiId: long(name='ApiId'),
    apiMode: integer(name='ApiMode'),
    apiName: string(name='ApiName'),
    apiPath: string(name='ApiPath'),
    createdTime: string(name='CreatedTime'),
    creatorId: string(name='CreatorId'),
    description: string(name='Description'),
    groupId: string(name='GroupId'),
    modifiedTime: string(name='ModifiedTime'),
    operatorId: string(name='OperatorId'),
    projectId: long(name='ProjectId'),
    requestMethod: integer(name='RequestMethod'),
    responseContentType: integer(name='ResponseContentType'),
    status: integer(name='Status'),
    tenantId: long(name='TenantId'),
    timeout: integer(name='Timeout'),
    visibleRange: integer(name='VisibleRange'),
    registrationDetails: {
      failedResultSample: string(name='FailedResultSample'),
      serviceContentType: integer(name='ServiceContentType'),
      serviceHost: string(name='ServiceHost'),
      servicePath: string(name='ServicePath'),
      serviceRequestBodyDescription: string(name='ServiceRequestBodyDescription'),
      successfulResultSample: string(name='SuccessfulResultSample'),
      registrationErrorCodes: [
        {
          errorCode: string(name='ErrorCode'),
          errorMessage: string(name='ErrorMessage'),
          errorSolution: string(name='ErrorSolution'),
        }
      ](name='RegistrationErrorCodes'),
      registrationRequestParameters: [
        {
          defaultValue: string(name='DefaultValue'),
          exampleValue: string(name='ExampleValue'),
          isRequiredParameter: boolean(name='IsRequiredParameter'),
          parameterDataType: integer(name='ParameterDataType'),
          parameterDescription: string(name='ParameterDescription'),
          parameterName: string(name='ParameterName'),
          parameterOperator: integer(name='ParameterOperator'),
          parameterPosition: integer(name='ParameterPosition'),
        }
      ](name='RegistrationRequestParameters'),
    }(name='RegistrationDetails'),
    scriptDetails: {
      failedResultSample: string(name='FailedResultSample'),
      isPagedResponse: boolean(name='IsPagedResponse'),
      script: string(name='Script'),
      successfulResultSample: string(name='SuccessfulResultSample'),
      scriptErrorCodes: [
        {
          errorCode: string(name='ErrorCode'),
          errorMessage: string(name='ErrorMessage'),
          errorSolution: string(name='ErrorSolution'),
        }
      ](name='ScriptErrorCodes'),
      scriptRequestParameters: [
        {
          defaultValue: string(name='DefaultValue'),
          exampleValue: string(name='ExampleValue'),
          isRequiredParameter: boolean(name='IsRequiredParameter'),
          parameterDataType: integer(name='ParameterDataType'),
          parameterDescription: string(name='ParameterDescription'),
          parameterName: string(name='ParameterName'),
          parameterOperator: integer(name='ParameterOperator'),
          parameterPosition: integer(name='ParameterPosition'),
        }
      ](name='ScriptRequestParameters'),
      scriptResponseParameters: [
        {
          exampleValue: string(name='ExampleValue'),
          parameterDataType: integer(name='ParameterDataType'),
          parameterDescription: string(name='ParameterDescription'),
          parameterName: string(name='ParameterName'),
        }
      ](name='ScriptResponseParameters'),
      scriptConnection: {
        connectionId: long(name='ConnectionId'),
        tableName: string(name='TableName'),
      }(name='ScriptConnection'),
    }(name='ScriptDetails'),
    wizardDetails: {
      failedResultSample: string(name='FailedResultSample'),
      isPagedResponse: boolean(name='IsPagedResponse'),
      successfulResultSample: string(name='SuccessfulResultSample'),
      wizardErrorCodes: [
        {
          errorCode: string(name='ErrorCode'),
          errorMessage: string(name='ErrorMessage'),
          errorSolution: string(name='ErrorSolution'),
        }
      ](name='WizardErrorCodes'),
      wizardRequestParameters: [
        {
          defaultValue: string(name='DefaultValue'),
          exampleValue: string(name='ExampleValue'),
          isRequiredParameter: boolean(name='IsRequiredParameter'),
          parameterDataType: integer(name='ParameterDataType'),
          parameterDescription: string(name='ParameterDescription'),
          parameterName: string(name='ParameterName'),
          parameterOperator: integer(name='ParameterOperator'),
          parameterPosition: integer(name='ParameterPosition'),
        }
      ](name='WizardRequestParameters'),
      wizardResponseParameters: [
        {
          exampleValue: string(name='ExampleValue'),
          parameterDataType: integer(name='ParameterDataType'),
          parameterDescription: string(name='ParameterDescription'),
          parameterName: string(name='ParameterName'),
        }
      ](name='WizardResponseParameters'),
      wizardConnection: {
        connectionId: long(name='ConnectionId'),
        tableName: string(name='TableName'),
      }(name='WizardConnection'),
    }(name='WizardDetails'),
    protocols: [ integer ](name='Protocols'),
  }(name='Data'),
}

async function getDataServicePublishedApiWithOptions(request: GetDataServicePublishedApiRequest, runtime: Util.RuntimeOptions): GetDataServicePublishedApiResponse {
  Util.validateModel(request);
  return doRequest('GetDataServicePublishedApi', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getDataServicePublishedApi(request: GetDataServicePublishedApiRequest): GetDataServicePublishedApiResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDataServicePublishedApiWithOptions(request, runtime);
}

model GetBaselineKeyPathRequest = {
  baselineId: long(name='BaselineId'),
  bizdate: string(name='Bizdate'),
  inGroupId: integer(name='InGroupId'),
}

model GetBaselineKeyPathResponse = {
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  data: [
    {
      instanceId: long(name='InstanceId'),
      projectId: long(name='ProjectId'),
      nodeId: long(name='NodeId'),
      nodeName: string(name='NodeName'),
      bizdate: long(name='Bizdate'),
      inGroupId: integer(name='InGroupId'),
      owner: string(name='Owner'),
      prgType: integer(name='PrgType'),
      runs: [
        {
          absTime: long(name='AbsTime'),
          beginCast: long(name='BeginCast'),
          beginRunningTime: long(name='BeginRunningTime'),
          beginWaitResTime: long(name='BeginWaitResTime'),
          beginWaitTimeTime: long(name='BeginWaitTimeTime'),
          bizdate: long(name='Bizdate'),
          cycTime: long(name='CycTime'),
          endCast: long(name='EndCast'),
          finishTime: long(name='FinishTime'),
          inGroupId: integer(name='InGroupId'),
          instanceId: long(name='InstanceId'),
          nodeId: long(name='NodeId'),
          nodeName: string(name='NodeName'),
          owner: string(name='Owner'),
          projectId: long(name='ProjectId'),
          status: string(name='Status'),
        }
      ](name='Runs'),
      topics: [
        {
          instanceId: long(name='InstanceId'),
          topicId: long(name='TopicId'),
          topicName: long(name='TopicName'),
          addTime: long(name='AddTime'),
        }
      ](name='Topics'),
    }
  ](name='Data'),
}

async function getBaselineKeyPathWithOptions(request: GetBaselineKeyPathRequest, runtime: Util.RuntimeOptions): GetBaselineKeyPathResponse {
  Util.validateModel(request);
  return doRequest('GetBaselineKeyPath', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getBaselineKeyPath(request: GetBaselineKeyPathRequest): GetBaselineKeyPathResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBaselineKeyPathWithOptions(request, runtime);
}

model GetRemindRequest = {
  remindId: long(name='RemindId'),
}

model GetRemindResponse = {
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  data: {
    remindId: long(name='RemindId'),
    remindName: string(name='RemindName'),
    dndStart: string(name='DndStart'),
    dndEnd: string(name='DndEnd'),
    remindUnit: string(name='RemindUnit'),
    remindType: string(name='RemindType'),
    alertUnit: string(name='AlertUnit'),
    useflag: boolean(name='Useflag'),
    founder: string(name='Founder'),
    alertInterval: integer(name='AlertInterval'),
    detail: string(name='Detail'),
    maxAlertTimes: integer(name='MaxAlertTimes'),
    robots: [
      {
        webUrl: string(name='WebUrl'),
        atAll: boolean(name='AtAll'),
      }
    ](name='Robots'),
    nodes: [
      {
        nodeId: long(name='NodeId'),
        nodeName: string(name='NodeName'),
        owner: string(name='Owner'),
        projectId: long(name='ProjectId'),
      }
    ](name='Nodes'),
    baselines: [
      {
        baselineId: long(name='BaselineId'),
        baselineName: string(name='BaselineName'),
      }
    ](name='Baselines'),
    projects: [
      {
        projectId: long(name='ProjectId'),
      }
    ](name='Projects'),
    bizProcesses: [
      {
        bizId: long(name='BizId'),
        bizProcessName: string(name='BizProcessName'),
      }
    ](name='BizProcesses'),
    alertMethods: [ string ](name='AlertMethods'),
    alertTargets: [ string ](name='AlertTargets'),
  }(name='Data'),
}

async function getRemindWithOptions(request: GetRemindRequest, runtime: Util.RuntimeOptions): GetRemindResponse {
  Util.validateModel(request);
  return doRequest('GetRemind', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getRemind(request: GetRemindRequest): GetRemindResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRemindWithOptions(request, runtime);
}

model GetMetaTableIntroWikiRequest = {
  tableGuid: string(name='TableGuid'),
  wikiVersion?: long(name='WikiVersion'),
}

model GetMetaTableIntroWikiResponse = {
  requestId: string(name='RequestId'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  success: boolean(name='Success'),
  data: {
    createTime: long(name='CreateTime'),
    modifiedTime: long(name='ModifiedTime'),
    creator: string(name='Creator'),
    version: long(name='Version'),
    creatorName: string(name='CreatorName'),
    content: string(name='Content'),
  }(name='Data'),
}

async function getMetaTableIntroWikiWithOptions(request: GetMetaTableIntroWikiRequest, runtime: Util.RuntimeOptions): GetMetaTableIntroWikiResponse {
  Util.validateModel(request);
  return doRequest('GetMetaTableIntroWiki', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getMetaTableIntroWiki(request: GetMetaTableIntroWikiRequest): GetMetaTableIntroWikiResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaTableIntroWikiWithOptions(request, runtime);
}

model GetBaselineStatusRequest = {
  baselineId: long(name='BaselineId'),
  bizdate: string(name='Bizdate'),
  inGroupId: integer(name='InGroupId'),
}

model GetBaselineStatusResponse = {
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  data: {
    baselineName: string(name='BaselineName'),
    baselineId: long(name='BaselineId'),
    bizdate: long(name='Bizdate'),
    owner: string(name='Owner'),
    expTime: long(name='ExpTime'),
    finishTime: long(name='FinishTime'),
    endCast: long(name='EndCast'),
    slaTime: long(name='SlaTime'),
    priority: integer(name='Priority'),
    projectId: long(name='ProjectId'),
    buffer: float(name='Buffer'),
    status: string(name='Status'),
    finishStatus: string(name='FinishStatus'),
    inGroupId: integer(name='InGroupId'),
    lastInstance: {
      instanceId: long(name='InstanceId'),
      status: string(name='Status'),
      projectId: long(name='ProjectId'),
      owner: string(name='Owner'),
      nodeId: long(name='NodeId'),
      finishTime: long(name='FinishTime'),
      endCast: long(name='EndCast'),
      nodeName: string(name='NodeName'),
    }(name='LastInstance'),
    blockInstance: {
      instanceId: long(name='InstanceId'),
      status: string(name='Status'),
      projectId: long(name='ProjectId'),
      owner: string(name='Owner'),
      nodeId: long(name='NodeId'),
      finishTime: long(name='FinishTime'),
      endCast: long(name='EndCast'),
      nodeName: string(name='NodeName'),
    }(name='BlockInstance'),
  }(name='Data'),
}

async function getBaselineStatusWithOptions(request: GetBaselineStatusRequest, runtime: Util.RuntimeOptions): GetBaselineStatusResponse {
  Util.validateModel(request);
  return doRequest('GetBaselineStatus', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getBaselineStatus(request: GetBaselineStatusRequest): GetBaselineStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBaselineStatusWithOptions(request, runtime);
}

model DeleteDataServiceApiRequest = {
  tenantId: long(name='TenantId'),
  projectId: long(name='ProjectId'),
  apiId: long(name='ApiId'),
}

model DeleteDataServiceApiResponse = {
  data: boolean(name='Data'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
}

async function deleteDataServiceApiWithOptions(request: DeleteDataServiceApiRequest, runtime: Util.RuntimeOptions): DeleteDataServiceApiResponse {
  Util.validateModel(request);
  return doRequest('DeleteDataServiceApi', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function deleteDataServiceApi(request: DeleteDataServiceApiRequest): DeleteDataServiceApiResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDataServiceApiWithOptions(request, runtime);
}

model PublishDataServiceApiRequest = {
  tenantId: long(name='TenantId'),
  projectId: long(name='ProjectId'),
  apiId: long(name='ApiId'),
}

model PublishDataServiceApiResponse = {
  data: boolean(name='Data'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
}

async function publishDataServiceApiWithOptions(request: PublishDataServiceApiRequest, runtime: Util.RuntimeOptions): PublishDataServiceApiResponse {
  Util.validateModel(request);
  return doRequest('PublishDataServiceApi', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function publishDataServiceApi(request: PublishDataServiceApiRequest): PublishDataServiceApiResponse {
  var runtime = new Util.RuntimeOptions{};
  return publishDataServiceApiWithOptions(request, runtime);
}

model GetMetaTableLineageRequest = {
  tableGuid?: string(name='TableGuid'),
  direction: string(name='Direction'),
  nextPrimaryKey?: string(name='NextPrimaryKey'),
  pageSize?: integer(name='PageSize'),
  clusterId?: string(name='ClusterId'),
  databaseName?: string(name='DatabaseName'),
  tableName?: string(name='TableName'),
  dataSourceType?: string(name='DataSourceType'),
}

model GetMetaTableLineageResponse = {
  requestId: string(name='RequestId'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  success: boolean(name='Success'),
  data: {
    hasNext: boolean(name='HasNext'),
    nextPrimaryKey: string(name='NextPrimaryKey'),
    dataEntityList: [
      {
        tableName: string(name='TableName'),
        tableGuid: string(name='TableGuid'),
      }
    ](name='DataEntityList'),
  }(name='Data'),
}

async function getMetaTableLineageWithOptions(request: GetMetaTableLineageRequest, runtime: Util.RuntimeOptions): GetMetaTableLineageResponse {
  Util.validateModel(request);
  return doRequest('GetMetaTableLineage', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getMetaTableLineage(request: GetMetaTableLineageRequest): GetMetaTableLineageResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaTableLineageWithOptions(request, runtime);
}

model ListBaselineStatusesRequest = {
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  bizdate: string(name='Bizdate'),
  priority?: string(name='Priority'),
  searchText?: string(name='SearchText'),
  owner?: string(name='Owner'),
  topicId?: long(name='TopicId'),
  finishStatus?: string(name='FinishStatus'),
  status?: string(name='Status'),
  baselineTypes?: string(name='BaselineTypes'),
}

model ListBaselineStatusesResponse = {
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  data: {
    pageNumber: integer(name='PageNumber'),
    pageSize: integer(name='PageSize'),
    totalCount: integer(name='TotalCount'),
    baselineStatuses: [
      {
        baselineName: string(name='BaselineName'),
        baselineId: long(name='BaselineId'),
        bizdate: long(name='Bizdate'),
        owner: string(name='Owner'),
        expTime: long(name='ExpTime'),
        finishTime: long(name='FinishTime'),
        endCast: long(name='EndCast'),
        slaTime: long(name='SlaTime'),
        priority: integer(name='Priority'),
        projectId: long(name='ProjectId'),
        buffer: long(name='Buffer'),
        status: string(name='Status'),
        finishStatus: string(name='FinishStatus'),
        inGroupId: integer(name='InGroupId'),
      }
    ](name='BaselineStatuses'),
  }(name='Data'),
}

async function listBaselineStatusesWithOptions(request: ListBaselineStatusesRequest, runtime: Util.RuntimeOptions): ListBaselineStatusesResponse {
  Util.validateModel(request);
  return doRequest('ListBaselineStatuses', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listBaselineStatuses(request: ListBaselineStatusesRequest): ListBaselineStatusesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBaselineStatusesWithOptions(request, runtime);
}

model ListRemindsRequest = {
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  founder?: string(name='Founder'),
  nodeId?: long(name='NodeId'),
  remindTypes?: string(name='RemindTypes'),
  alertTarget?: string(name='AlertTarget'),
  searchText?: string(name='SearchText'),
}

model ListRemindsResponse = {
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  data: {
    pageNumber: integer(name='PageNumber'),
    pageSize: integer(name='PageSize'),
    totalCount: integer(name='TotalCount'),
    reminds: [
      {
        remindId: long(name='RemindId'),
        remindName: string(name='RemindName'),
        dndStart: string(name='DndStart'),
        dndEnd: string(name='DndEnd'),
        remindUnit: string(name='RemindUnit'),
        remindType: string(name='RemindType'),
        alertUnit: string(name='AlertUnit'),
        useflag: boolean(name='Useflag'),
        founder: string(name='Founder'),
        nodeIds: [ long ](name='NodeIds'),
        baselineIds: [ long ](name='BaselineIds'),
        projectIds: [ long ](name='ProjectIds'),
        bizProcessIds: [ long ](name='BizProcessIds'),
        alertMethods: [ string ](name='AlertMethods'),
        alertTargets: [ string ](name='AlertTargets'),
      }
    ](name='Reminds'),
  }(name='Data'),
}

async function listRemindsWithOptions(request: ListRemindsRequest, runtime: Util.RuntimeOptions): ListRemindsResponse {
  Util.validateModel(request);
  return doRequest('ListReminds', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function listReminds(request: ListRemindsRequest): ListRemindsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRemindsWithOptions(request, runtime);
}

model DeleteQualityEntityRequest = {
  entityId: long(name='EntityId'),
  projectName: string(name='ProjectName'),
  envType: string(name='EnvType'),
}

model DeleteQualityEntityResponse = {
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  data: boolean(name='Data'),
  requestId: string(name='RequestId'),
}

async function deleteQualityEntityWithOptions(request: DeleteQualityEntityRequest, runtime: Util.RuntimeOptions): DeleteQualityEntityResponse {
  Util.validateModel(request);
  return doRequest('DeleteQualityEntity', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function deleteQualityEntity(request: DeleteQualityEntityRequest): DeleteQualityEntityResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteQualityEntityWithOptions(request, runtime);
}

model CreateQualityFollowerRequest = {
  projectName: string(name='ProjectName'),
  follower: string(name='Follower'),
  alarmMode: integer(name='AlarmMode'),
  entityId: long(name='EntityId'),
}

model CreateQualityFollowerResponse = {
  errorCode: string(name='ErrorCode'),
  data: integer(name='Data'),
  success: boolean(name='Success'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
}

async function createQualityFollowerWithOptions(request: CreateQualityFollowerRequest, runtime: Util.RuntimeOptions): CreateQualityFollowerResponse {
  Util.validateModel(request);
  return doRequest('CreateQualityFollower', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function createQualityFollower(request: CreateQualityFollowerRequest): CreateQualityFollowerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createQualityFollowerWithOptions(request, runtime);
}

model CreateDataServiceApiRequest = {
  tenantId: long(name='TenantId'),
  projectId: long(name='ProjectId'),
  apiName: string(name='ApiName'),
  groupId: string(name='GroupId'),
  apiMode: integer(name='ApiMode'),
  requestMethod: integer(name='RequestMethod'),
  responseContentType: integer(name='ResponseContentType'),
  timeout: integer(name='Timeout'),
  visibleRange: integer(name='VisibleRange'),
  protocols: string(name='Protocols'),
  wizardDetails?: string(name='WizardDetails'),
  scriptDetails?: string(name='ScriptDetails'),
  registrationDetails?: string(name='RegistrationDetails'),
  apiPath: string(name='ApiPath'),
  apiDescription: string(name='ApiDescription'),
  folderId?: long(name='FolderId'),
}

model CreateDataServiceApiResponse = {
  data: long(name='Data'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  success: boolean(name='Success'),
  requestId: string(name='RequestId'),
}

async function createDataServiceApiWithOptions(request: CreateDataServiceApiRequest, runtime: Util.RuntimeOptions): CreateDataServiceApiResponse {
  Util.validateModel(request);
  return doRequest('CreateDataServiceApi', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function createDataServiceApi(request: CreateDataServiceApiRequest): CreateDataServiceApiResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDataServiceApiWithOptions(request, runtime);
}

model AbolishDataServiceApiRequest = {
  tenantId: long(name='TenantId'),
  projectId: long(name='ProjectId'),
  apiId: long(name='ApiId'),
}

model AbolishDataServiceApiResponse = {
  data: boolean(name='Data'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
}

async function abolishDataServiceApiWithOptions(request: AbolishDataServiceApiRequest, runtime: Util.RuntimeOptions): AbolishDataServiceApiResponse {
  Util.validateModel(request);
  return doRequest('AbolishDataServiceApi', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function abolishDataServiceApi(request: AbolishDataServiceApiRequest): AbolishDataServiceApiResponse {
  var runtime = new Util.RuntimeOptions{};
  return abolishDataServiceApiWithOptions(request, runtime);
}

model GetQualityEntityRequest = {
  projectName: string(name='ProjectName'),
  tableName: string(name='TableName'),
  envType: string(name='EnvType'),
  matchExpression?: string(name='MatchExpression'),
}

model GetQualityEntityResponse = {
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  data: [
    {
      id: long(name='Id'),
      projectName: string(name='ProjectName'),
      tableName: string(name='TableName'),
      envType: string(name='EnvType'),
      matchExpression: string(name='MatchExpression'),
      entityLevel: integer(name='EntityLevel'),
      onDuty: string(name='OnDuty'),
      modifyUser: string(name='ModifyUser'),
      createTime: long(name='CreateTime'),
      modifyTime: long(name='ModifyTime'),
      sql: integer(name='Sql'),
      task: integer(name='Task'),
      followers: string(name='Followers'),
      hasRelativeNode: boolean(name='HasRelativeNode'),
      relativeNode: string(name='RelativeNode'),
    }
  ](name='Data'),
}

async function getQualityEntityWithOptions(request: GetQualityEntityRequest, runtime: Util.RuntimeOptions): GetQualityEntityResponse {
  Util.validateModel(request);
  return doRequest('GetQualityEntity', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getQualityEntity(request: GetQualityEntityRequest): GetQualityEntityResponse {
  var runtime = new Util.RuntimeOptions{};
  return getQualityEntityWithOptions(request, runtime);
}

model GetQualityFollowerRequest = {
  projectName: string(name='ProjectName'),
  entityId: long(name='EntityId'),
}

model GetQualityFollowerResponse = {
  errorCode: string(name='ErrorCode'),
  success: boolean(name='Success'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
  data: [
    {
      projectName: string(name='ProjectName'),
      tableName: string(name='TableName'),
      id: long(name='Id'),
      entityId: string(name='EntityId'),
      follower: string(name='Follower'),
      alarmMode: integer(name='AlarmMode'),
    }
  ](name='Data'),
}

async function getQualityFollowerWithOptions(request: GetQualityFollowerRequest, runtime: Util.RuntimeOptions): GetQualityFollowerResponse {
  Util.validateModel(request);
  return doRequest('GetQualityFollower', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function getQualityFollower(request: GetQualityFollowerRequest): GetQualityFollowerResponse {
  var runtime = new Util.RuntimeOptions{};
  return getQualityFollowerWithOptions(request, runtime);
}

model DeleteQualityFollowerRequest = {
  projectName: string(name='ProjectName'),
  followerId: long(name='FollowerId'),
}

model DeleteQualityFollowerResponse = {
  errorCode: string(name='ErrorCode'),
  data: boolean(name='Data'),
  success: boolean(name='Success'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
}

async function deleteQualityFollowerWithOptions(request: DeleteQualityFollowerRequest, runtime: Util.RuntimeOptions): DeleteQualityFollowerResponse {
  Util.validateModel(request);
  return doRequest('DeleteQualityFollower', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function deleteQualityFollower(request: DeleteQualityFollowerRequest): DeleteQualityFollowerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteQualityFollowerWithOptions(request, runtime);
}

model CreateQualityEntityRequest = {
  projectName: string(name='ProjectName'),
  tableName: string(name='TableName'),
  envType: string(name='EnvType'),
  matchExpression: string(name='MatchExpression'),
  entityLevel: integer(name='EntityLevel'),
}

model CreateQualityEntityResponse = {
  success: boolean(name='Success'),
  data: integer(name='Data'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
}

async function createQualityEntityWithOptions(request: CreateQualityEntityRequest, runtime: Util.RuntimeOptions): CreateQualityEntityResponse {
  Util.validateModel(request);
  return doRequest('CreateQualityEntity', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function createQualityEntity(request: CreateQualityEntityRequest): CreateQualityEntityResponse {
  var runtime = new Util.RuntimeOptions{};
  return createQualityEntityWithOptions(request, runtime);
}

model CreateQualityRuleRequest = {
  blockType: integer(name='BlockType'),
  entityId: long(name='EntityId'),
  comment?: string(name='Comment'),
  checker?: integer(name='Checker'),
  expectValue?: string(name='ExpectValue'),
  trend?: string(name='Trend'),
  methodName?: string(name='MethodName'),
  operator?: string(name='Operator'),
  projectName: string(name='ProjectName'),
  property?: string(name='Property'),
  propertyType?: string(name='PropertyType'),
  ruleType: integer(name='RuleType'),
  whereCondition?: string(name='WhereCondition'),
  criticalThreshold?: string(name='CriticalThreshold'),
  warningThreshold?: string(name='WarningThreshold'),
  templateId?: integer(name='TemplateId'),
  ruleName: string(name='RuleName'),
  predictType: integer(name='PredictType'),
}

model CreateQualityRuleResponse = {
  errorCode: string(name='ErrorCode'),
  data: string(name='Data'),
  success: boolean(name='Success'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
}

async function createQualityRuleWithOptions(request: CreateQualityRuleRequest, runtime: Util.RuntimeOptions): CreateQualityRuleResponse {
  Util.validateModel(request);
  return doRequest('CreateQualityRule', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function createQualityRule(request: CreateQualityRuleRequest): CreateQualityRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createQualityRuleWithOptions(request, runtime);
}

model UpdateQualityFollowerRequest = {
  projectName: string(name='ProjectName'),
  followerId: long(name='FollowerId'),
  follower: string(name='Follower'),
  alarmMode: integer(name='AlarmMode'),
}

model UpdateQualityFollowerResponse = {
  errorCode: string(name='ErrorCode'),
  data: boolean(name='Data'),
  success: boolean(name='Success'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  requestId: string(name='RequestId'),
}

async function updateQualityFollowerWithOptions(request: UpdateQualityFollowerRequest, runtime: Util.RuntimeOptions): UpdateQualityFollowerResponse {
  Util.validateModel(request);
  return doRequest('UpdateQualityFollower', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function updateQualityFollower(request: UpdateQualityFollowerRequest): UpdateQualityFollowerResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateQualityFollowerWithOptions(request, runtime);
}

model CreateQualityRelativeNodeRequest = {
  envType: string(name='EnvType'),
  matchExpression: string(name='MatchExpression'),
  nodeId: long(name='NodeId'),
  projectId: long(name='ProjectId'),
  targetNodeProjectName: string(name='TargetNodeProjectName'),
  projectName: string(name='ProjectName'),
  tableName: string(name='TableName'),
  targetNodeProjectId: long(name='TargetNodeProjectId'),
}

model CreateQualityRelativeNodeResponse = {
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  data: boolean(name='Data'),
  requestId: string(name='RequestId'),
}

async function createQualityRelativeNodeWithOptions(request: CreateQualityRelativeNodeRequest, runtime: Util.RuntimeOptions): CreateQualityRelativeNodeResponse {
  Util.validateModel(request);
  return doRequest('CreateQualityRelativeNode', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function createQualityRelativeNode(request: CreateQualityRelativeNodeRequest): CreateQualityRelativeNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return createQualityRelativeNodeWithOptions(request, runtime);
}

model DeleteQualityRelativeNodeRequest = {
  envType: string(name='EnvType'),
  matchExpression: string(name='MatchExpression'),
  nodeId: long(name='NodeId'),
  projectId: long(name='ProjectId'),
  targetNodeProjectName: string(name='TargetNodeProjectName'),
  projectName: string(name='ProjectName'),
  tableName: string(name='TableName'),
  targetNodeProjectId: long(name='TargetNodeProjectId'),
}

model DeleteQualityRelativeNodeResponse = {
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  httpStatusCode: integer(name='HttpStatusCode'),
  data: boolean(name='Data'),
  requestId: string(name='RequestId'),
}

async function deleteQualityRelativeNodeWithOptions(request: DeleteQualityRelativeNodeRequest, runtime: Util.RuntimeOptions): DeleteQualityRelativeNodeResponse {
  Util.validateModel(request);
  return doRequest('DeleteQualityRelativeNode', 'HTTPS', 'POST', '2020-05-18', 'AK', null, request, runtime);
}

async function deleteQualityRelativeNode(request: DeleteQualityRelativeNodeRequest): DeleteQualityRelativeNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteQualityRelativeNodeWithOptions(request, runtime);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
