import Util;
import RPC;
import EndpointUtil;

extends RPC;

init(config: RPC.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('emas-devops', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

model DescribePluginDetailRequest = {
  pluginName: string(name='PluginName'),
  pluginVersion?: string(name='PluginVersion'),
}

model DescribePluginDetailResponse = {
  requestId: string(name='RequestId'),
  result: string(name='Result'),
}

async function describePluginDetailWithOptions(request: DescribePluginDetailRequest, runtime: Util.RuntimeOptions): DescribePluginDetailResponse {
  Util.validateModel(request);
  return doRequest('DescribePluginDetail', 'HTTPS', 'POST', '2019-12-04', 'AK', null, request, runtime);
}

async function describePluginDetail(request: DescribePluginDetailRequest): DescribePluginDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePluginDetailWithOptions(request, runtime);
}

model DescribeBuildTaskDetailRequest = {
  appKey?: string(name='AppKey'),
  bid?: string(name='Bid'),
}

model DescribeBuildTaskDetailResponse = {
  requestId: string(name='RequestId'),
  buildTaskBid: string(name='BuildTaskBid'),
  codeAddress: string(name='CodeAddress'),
  branch: string(name='Branch'),
  gitCommit: string(name='GitCommit'),
  buildStartTime: long(name='BuildStartTime'),
  buildTaskStatus: string(name='BuildTaskStatus'),
  templateName: string(name='TemplateName'),
  templateType: string(name='TemplateType'),
  buildEndTime: long(name='BuildEndTime'),
  productFileInfos: [
    {
      fileName: string(name='FileName'),
      fileSignUrl: string(name='FileSignUrl'),
      fileType: string(name='FileType'),
      size: string(name='Size'),
    }
  ](name='ProductFileInfos'),
  creator: {
    uid: string(name='Uid'),
    username: string(name='Username'),
    displayName: string(name='DisplayName'),
    email: string(name='Email'),
  }(name='Creator'),
}

async function describeBuildTaskDetailWithOptions(request: DescribeBuildTaskDetailRequest, runtime: Util.RuntimeOptions): DescribeBuildTaskDetailResponse {
  Util.validateModel(request);
  return doRequest('DescribeBuildTaskDetail', 'HTTPS', 'POST', '2019-12-04', 'AK', null, request, runtime);
}

async function describeBuildTaskDetail(request: DescribeBuildTaskDetailRequest): DescribeBuildTaskDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBuildTaskDetailWithOptions(request, runtime);
}

model GetScmRsaPubKeyRequest = {
}

model GetScmRsaPubKeyResponse = {
  requestId: string(name='RequestId'),
  identifier: string(name='Identifier'),
  rsaPub: string(name='RsaPub'),
}

async function getScmRsaPubKeyWithOptions(request: GetScmRsaPubKeyRequest, runtime: Util.RuntimeOptions): GetScmRsaPubKeyResponse {
  Util.validateModel(request);
  return doRequest('GetScmRsaPubKey', 'HTTPS', 'POST', '2019-12-04', 'AK', null, request, runtime);
}

async function getScmRsaPubKey(request: GetScmRsaPubKeyRequest): GetScmRsaPubKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return getScmRsaPubKeyWithOptions(request, runtime);
}

model CreateBuildTaskRequest = {
  iterationBid: string(name='IterationBid'),
  buildConfigBid: string(name='BuildConfigBid'),
  appKey: string(name='AppKey'),
  codeAddress: string(name='CodeAddress'),
  branch: string(name='Branch'),
  triggerType: string(name='TriggerType'),
  versionName?: string(name='VersionName'),
  versionCode?: string(name='VersionCode'),
}

model CreateBuildTaskResponse = {
  requestId: string(name='RequestId'),
  buildTaskBid: string(name='BuildTaskBid'),
}

async function createBuildTaskWithOptions(request: CreateBuildTaskRequest, runtime: Util.RuntimeOptions): CreateBuildTaskResponse {
  Util.validateModel(request);
  return doRequest('CreateBuildTask', 'HTTPS', 'POST', '2019-12-04', 'AK', null, request, runtime);
}

async function createBuildTask(request: CreateBuildTaskRequest): CreateBuildTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBuildTaskWithOptions(request, runtime);
}

model ListBuildTasksRequest = {
  appKey: string(name='AppKey'),
  iterationBid: string(name='IterationBid'),
  buildTaskKeyWord?: string(name='BuildTaskKeyWord'),
  templateType?: string(name='TemplateType'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
}

model ListBuildTasksResponse = {
  requestId: string(name='RequestId'),
  pageNumber: long(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  total: long(name='Total'),
  items: [
    {
      buildTaskBid: string(name='BuildTaskBid'),
      templateName: string(name='TemplateName'),
      templateType: string(name='TemplateType'),
      branch: string(name='Branch'),
      buildTaskStatus: string(name='BuildTaskStatus'),
      buildStartTime: long(name='BuildStartTime'),
      buildEndTime: long(name='BuildEndTime'),
      gitCommit: string(name='GitCommit'),
      buildConfigBid: string(name='BuildConfigBid'),
      productFileInfos: [
        {
          fileName: string(name='FileName'),
          fileSignUrl: string(name='FileSignUrl'),
          fileType: string(name='FileType'),
          size: long(name='Size'),
          buildTaskBid: string(name='BuildTaskBid'),
          fileKey: string(name='FileKey'),
          md5: string(name='Md5'),
        }
      ](name='ProductFileInfos'),
      accountInfo: {
        uid: string(name='Uid'),
        username: string(name='Username'),
        displayName: string(name='DisplayName'),
        email: string(name='Email'),
      }(name='AccountInfo'),
    }
  ](name='Items'),
}

async function listBuildTasksWithOptions(request: ListBuildTasksRequest, runtime: Util.RuntimeOptions): ListBuildTasksResponse {
  Util.validateModel(request);
  return doRequest('ListBuildTasks', 'HTTPS', 'POST', '2019-12-04', 'AK', null, request, runtime);
}

async function listBuildTasks(request: ListBuildTasksRequest): ListBuildTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBuildTasksWithOptions(request, runtime);
}

model ListBuildPhasesRequest = {
  appKey: string(name='AppKey'),
  bid: string(name='Bid'),
}

model ListBuildPhasesResponse = {
  requestId: string(name='RequestId'),
  items: [
    {
      buildPhase: string(name='BuildPhase'),
      buildPhaseStatus: string(name='BuildPhaseStatus'),
      startTime: long(name='StartTime'),
      endTime: long(name='EndTime'),
      logFileSignUrl: string(name='LogFileSignUrl'),
      emasError: {
        description: string(name='Description'),
        code: integer(name='Code'),
      }(name='EmasError'),
    }
  ](name='Items'),
}

async function listBuildPhasesWithOptions(request: ListBuildPhasesRequest, runtime: Util.RuntimeOptions): ListBuildPhasesResponse {
  Util.validateModel(request);
  return doRequest('ListBuildPhases', 'HTTPS', 'POST', '2019-12-04', 'AK', null, request, runtime);
}

async function listBuildPhases(request: ListBuildPhasesRequest): ListBuildPhasesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBuildPhasesWithOptions(request, runtime);
}

model CancelBuildTaskRequest = {
  appKey: string(name='AppKey'),
  bid: string(name='Bid'),
}

model CancelBuildTaskResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
}

async function cancelBuildTaskWithOptions(request: CancelBuildTaskRequest, runtime: Util.RuntimeOptions): CancelBuildTaskResponse {
  Util.validateModel(request);
  return doRequest('CancelBuildTask', 'HTTPS', 'POST', '2019-12-04', 'AK', null, request, runtime);
}

async function cancelBuildTask(request: CancelBuildTaskRequest): CancelBuildTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelBuildTaskWithOptions(request, runtime);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
