import Util;

import RPC;
import EndpointUtil;

extends RPC;

init(config: RPC.Config){
  super(config);
  @endpointRule = 'central';
  
  checkConfig(config);
  @endpoint = getEndpoint('ims', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

model GetUserSsoSettingsRequest = {
}

model GetUserSsoSettingsResponse = {
  requestId: string(name='RequestId'),
  userSsoSettings: {
    ssoEnabled: boolean(name='SsoEnabled'),
    metadataDocument: string(name='MetadataDocument'),
    auxiliaryDomain: string(name='AuxiliaryDomain'),
  }(name='UserSsoSettings'),
}

async function getUserSsoSettingsWithOptions(request: GetUserSsoSettingsRequest, runtime: Util.RuntimeOptions): GetUserSsoSettingsResponse {
  Util.validateModel(request);
  return doRequest('GetUserSsoSettings', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function getUserSsoSettings(request: GetUserSsoSettingsRequest): GetUserSsoSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserSsoSettingsWithOptions(request, runtime);
}

model SetUserSsoSettingsRequest = {
  metadataDocument?: string(name='MetadataDocument'),
  ssoEnabled?: boolean(name='SsoEnabled'),
  auxiliaryDomain?: string(name='AuxiliaryDomain'),
}

model SetUserSsoSettingsResponse = {
  requestId: string(name='RequestId'),
  userSsoSettings: {
    ssoEnabled: boolean(name='SsoEnabled'),
    metadataDocument: string(name='MetadataDocument'),
    auxiliaryDomain: string(name='AuxiliaryDomain'),
  }(name='UserSsoSettings'),
}

async function setUserSsoSettingsWithOptions(request: SetUserSsoSettingsRequest, runtime: Util.RuntimeOptions): SetUserSsoSettingsResponse {
  Util.validateModel(request);
  return doRequest('SetUserSsoSettings', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function setUserSsoSettings(request: SetUserSsoSettingsRequest): SetUserSsoSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return setUserSsoSettingsWithOptions(request, runtime);
}

model SetDefaultDomainRequest = {
  defaultDomainName: string(name='DefaultDomainName'),
}

model SetDefaultDomainResponse = {
  requestId: string(name='RequestId'),
  defaultDomainName: string(name='DefaultDomainName'),
}

async function setDefaultDomainWithOptions(request: SetDefaultDomainRequest, runtime: Util.RuntimeOptions): SetDefaultDomainResponse {
  Util.validateModel(request);
  return doRequest('SetDefaultDomain', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function setDefaultDomain(request: SetDefaultDomainRequest): SetDefaultDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDefaultDomainWithOptions(request, runtime);
}

model ListUserBasicInfosRequest = {
  marker?: string(name='Marker'),
  maxItems?: integer(name='MaxItems'),
}

model ListUserBasicInfosResponse = {
  requestId: string(name='RequestId'),
  marker: string(name='Marker'),
  isTruncated: boolean(name='IsTruncated'),
  userBasicInfos: {
    userBasicInfo: [
      {
        userId: string(name='UserId'),
        userPrincipalName: string(name='UserPrincipalName'),
        displayName: string(name='DisplayName'),
      }
    ](name='UserBasicInfo'),
  }(name='UserBasicInfos'),
}

async function listUserBasicInfosWithOptions(request: ListUserBasicInfosRequest, runtime: Util.RuntimeOptions): ListUserBasicInfosResponse {
  Util.validateModel(request);
  return doRequest('ListUserBasicInfos', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function listUserBasicInfos(request: ListUserBasicInfosRequest): ListUserBasicInfosResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUserBasicInfosWithOptions(request, runtime);
}

model UpdateApplicationRequest = {
  appId: string(name='AppId'),
  newDisplayName?: string(name='NewDisplayName'),
  newRedirectUris?: string(name='NewRedirectUris'),
  newPredefinedScopes?: string(name='NewPredefinedScopes'),
  newSecretRequired?: boolean(name='NewSecretRequired'),
  newAccessTokenValidity?: integer(name='NewAccessTokenValidity'),
  newRefreshTokenValidity?: integer(name='NewRefreshTokenValidity'),
  newIsMultiTenant?: boolean(name='NewIsMultiTenant'),
}

model UpdateApplicationResponse = {
  requestId: string(name='RequestId'),
  application: {
    appId: string(name='AppId'),
    displayName: string(name='DisplayName'),
    appType: string(name='AppType'),
    secretRequired: boolean(name='SecretRequired'),
    accessTokenValidity: integer(name='AccessTokenValidity'),
    refreshTokenValidity: integer(name='RefreshTokenValidity'),
    isMultiTenant: boolean(name='IsMultiTenant'),
    createDate: string(name='CreateDate'),
    updateDate: string(name='UpdateDate'),
    appName: string(name='AppName'),
    accountId: string(name='AccountId'),
    delegatedScope: {
      predefinedScopes: {
        predefinedScope: [
          {
            name: string(name='Name'),
            description: string(name='Description'),
          }
        ](name='PredefinedScope'),
      }(name='PredefinedScopes'),
    }(name='DelegatedScope'),
    redirectUris: {
      redirectUri: [ string ](name='RedirectUri', description='RedirectUri'),
    }(name='RedirectUris'),
  }(name='Application'),
}

async function updateApplicationWithOptions(request: UpdateApplicationRequest, runtime: Util.RuntimeOptions): UpdateApplicationResponse {
  Util.validateModel(request);
  return doRequest('UpdateApplication', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function updateApplication(request: UpdateApplicationRequest): UpdateApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateApplicationWithOptions(request, runtime);
}

model ListApplicationsRequest = {
}

model ListApplicationsResponse = {
  requestId: string(name='RequestId'),
  applications: {
    application: [
      {
        appId: string(name='AppId'),
        displayName: string(name='DisplayName'),
        appType: string(name='AppType'),
        secretRequired: boolean(name='SecretRequired'),
        accessTokenValidity: integer(name='AccessTokenValidity'),
        refreshTokenValidity: integer(name='RefreshTokenValidity'),
        isMultiTenant: boolean(name='IsMultiTenant'),
        createDate: string(name='CreateDate'),
        updateDate: string(name='UpdateDate'),
        appName: string(name='AppName'),
        accountId: string(name='AccountId'),
        delegatedScope: {
          predefinedScopes: {
            predefinedScope: [
              {
                name: string(name='Name'),
                description: string(name='Description'),
              }
            ](name='PredefinedScope'),
          }(name='PredefinedScopes'),
        }(name='DelegatedScope'),
        redirectUris: {
          redirectUri: [ string ](name='RedirectUri', description='RedirectUri'),
        }(name='RedirectUris'),
      }
    ](name='Application'),
  }(name='Applications'),
}

async function listApplicationsWithOptions(request: ListApplicationsRequest, runtime: Util.RuntimeOptions): ListApplicationsResponse {
  Util.validateModel(request);
  return doRequest('ListApplications', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function listApplications(request: ListApplicationsRequest): ListApplicationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listApplicationsWithOptions(request, runtime);
}

model GetApplicationRequest = {
  appId: string(name='AppId'),
}

model GetApplicationResponse = {
  requestId: string(name='RequestId'),
  application: {
    appId: string(name='AppId'),
    displayName: string(name='DisplayName'),
    appType: string(name='AppType'),
    secretRequired: boolean(name='SecretRequired'),
    accessTokenValidity: integer(name='AccessTokenValidity'),
    refreshTokenValidity: integer(name='RefreshTokenValidity'),
    isMultiTenant: boolean(name='IsMultiTenant'),
    createDate: string(name='CreateDate'),
    updateDate: string(name='UpdateDate'),
    appName: string(name='AppName'),
    accountId: string(name='AccountId'),
    delegatedScope: {
      predefinedScopes: {
        predefinedScope: [
          {
            name: string(name='Name'),
            description: string(name='Description'),
          }
        ](name='PredefinedScope'),
      }(name='PredefinedScopes'),
    }(name='DelegatedScope'),
    redirectUris: {
      redirectUri: [ string ](name='RedirectUri', description='RedirectUri'),
    }(name='RedirectUris'),
  }(name='Application'),
}

async function getApplicationWithOptions(request: GetApplicationRequest, runtime: Util.RuntimeOptions): GetApplicationResponse {
  Util.validateModel(request);
  return doRequest('GetApplication', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function getApplication(request: GetApplicationRequest): GetApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return getApplicationWithOptions(request, runtime);
}

model DeleteApplicationRequest = {
  appId: string(name='AppId'),
}

model DeleteApplicationResponse = {
  requestId: string(name='RequestId'),
}

async function deleteApplicationWithOptions(request: DeleteApplicationRequest, runtime: Util.RuntimeOptions): DeleteApplicationResponse {
  Util.validateModel(request);
  return doRequest('DeleteApplication', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function deleteApplication(request: DeleteApplicationRequest): DeleteApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteApplicationWithOptions(request, runtime);
}

model GetAppSecretRequest = {
  appId: string(name='AppId'),
  appSecretId: string(name='AppSecretId'),
}

model GetAppSecretResponse = {
  requestId: string(name='RequestId'),
  appSecret: {
    appId: string(name='AppId'),
    appSecretId: string(name='AppSecretId'),
    appSecretValue: string(name='AppSecretValue'),
    createDate: string(name='CreateDate'),
  }(name='AppSecret'),
}

async function getAppSecretWithOptions(request: GetAppSecretRequest, runtime: Util.RuntimeOptions): GetAppSecretResponse {
  Util.validateModel(request);
  return doRequest('GetAppSecret', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function getAppSecret(request: GetAppSecretRequest): GetAppSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAppSecretWithOptions(request, runtime);
}

model CreateAppSecretRequest = {
  appId: string(name='AppId'),
}

model CreateAppSecretResponse = {
  requestId: string(name='RequestId'),
  appSecret: {
    appId: string(name='AppId'),
    appSecretId: string(name='AppSecretId'),
    appSecretValue: string(name='AppSecretValue'),
    createDate: string(name='CreateDate'),
  }(name='AppSecret'),
}

async function createAppSecretWithOptions(request: CreateAppSecretRequest, runtime: Util.RuntimeOptions): CreateAppSecretResponse {
  Util.validateModel(request);
  return doRequest('CreateAppSecret', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function createAppSecret(request: CreateAppSecretRequest): CreateAppSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAppSecretWithOptions(request, runtime);
}

model ListPredefinedScopesRequest = {
  appType?: string(name='AppType'),
}

model ListPredefinedScopesResponse = {
  requestId: string(name='RequestId'),
  predefinedScopes: {
    predefinedScope: [
      {
        name: string(name='Name'),
        description: string(name='Description'),
      }
    ](name='PredefinedScope'),
  }(name='PredefinedScopes'),
}

async function listPredefinedScopesWithOptions(request: ListPredefinedScopesRequest, runtime: Util.RuntimeOptions): ListPredefinedScopesResponse {
  Util.validateModel(request);
  return doRequest('ListPredefinedScopes', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function listPredefinedScopes(request: ListPredefinedScopesRequest): ListPredefinedScopesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPredefinedScopesWithOptions(request, runtime);
}

model CreateApplicationRequest = {
  displayName: string(name='DisplayName'),
  appType: string(name='AppType'),
  redirectUris?: string(name='RedirectUris'),
  secretRequired?: boolean(name='SecretRequired'),
  accessTokenValidity?: integer(name='AccessTokenValidity'),
  refreshTokenValidity?: integer(name='RefreshTokenValidity'),
  predefinedScopes?: string(name='PredefinedScopes'),
  isMultiTenant?: boolean(name='IsMultiTenant'),
  appName?: string(name='AppName'),
}

model CreateApplicationResponse = {
  requestId: string(name='RequestId'),
  application: {
    appId: string(name='AppId'),
    displayName: string(name='DisplayName'),
    appType: string(name='AppType'),
    secretRequired: boolean(name='SecretRequired'),
    accessTokenValidity: integer(name='AccessTokenValidity'),
    refreshTokenValidity: integer(name='RefreshTokenValidity'),
    isMultiTenant: boolean(name='IsMultiTenant'),
    createDate: string(name='CreateDate'),
    updateDate: string(name='UpdateDate'),
    appName: string(name='AppName'),
    accountId: string(name='AccountId'),
    delegatedScope: {
      predefinedScopes: {
        predefinedScope: [
          {
            name: string(name='Name'),
            description: string(name='Description'),
          }
        ](name='PredefinedScope'),
      }(name='PredefinedScopes'),
    }(name='DelegatedScope'),
    redirectUris: {
      redirectUri: [ string ](name='RedirectUri', description='RedirectUri'),
    }(name='RedirectUris'),
  }(name='Application'),
}

async function createApplicationWithOptions(request: CreateApplicationRequest, runtime: Util.RuntimeOptions): CreateApplicationResponse {
  Util.validateModel(request);
  return doRequest('CreateApplication', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function createApplication(request: CreateApplicationRequest): CreateApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createApplicationWithOptions(request, runtime);
}

model DeleteAppSecretRequest = {
  appId: string(name='AppId'),
  appSecretId: string(name='AppSecretId'),
}

model DeleteAppSecretResponse = {
  requestId: string(name='RequestId'),
}

async function deleteAppSecretWithOptions(request: DeleteAppSecretRequest, runtime: Util.RuntimeOptions): DeleteAppSecretResponse {
  Util.validateModel(request);
  return doRequest('DeleteAppSecret', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function deleteAppSecret(request: DeleteAppSecretRequest): DeleteAppSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAppSecretWithOptions(request, runtime);
}

model ListAppSecretIdsRequest = {
  appId: string(name='AppId'),
}

model ListAppSecretIdsResponse = {
  requestId: string(name='RequestId'),
  appSecrets: {
    appSecret: [
      {
        appId: string(name='AppId'),
        appSecretId: string(name='AppSecretId'),
        createDate: string(name='CreateDate'),
      }
    ](name='AppSecret'),
  }(name='AppSecrets'),
}

async function listAppSecretIdsWithOptions(request: ListAppSecretIdsRequest, runtime: Util.RuntimeOptions): ListAppSecretIdsResponse {
  Util.validateModel(request);
  return doRequest('ListAppSecretIds', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function listAppSecretIds(request: ListAppSecretIdsRequest): ListAppSecretIdsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAppSecretIdsWithOptions(request, runtime);
}

model GenerateCredentialReportRequest = {
}

model GenerateCredentialReportResponse = {
  requestId: string(name='RequestId'),
  state: string(name='State'),
}

async function generateCredentialReportWithOptions(request: GenerateCredentialReportRequest, runtime: Util.RuntimeOptions): GenerateCredentialReportResponse {
  Util.validateModel(request);
  return doRequest('GenerateCredentialReport', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function generateCredentialReport(request: GenerateCredentialReportRequest): GenerateCredentialReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateCredentialReportWithOptions(request, runtime);
}

model GetCredentialReportRequest = {
}

model GetCredentialReportResponse = {
  requestId: string(name='RequestId'),
  content: string(name='Content'),
  generatedTime: string(name='GeneratedTime'),
}

async function getCredentialReportWithOptions(request: GetCredentialReportRequest, runtime: Util.RuntimeOptions): GetCredentialReportResponse {
  Util.validateModel(request);
  return doRequest('GetCredentialReport', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function getCredentialReport(request: GetCredentialReportRequest): GetCredentialReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCredentialReportWithOptions(request, runtime);
}

model UpdateUserRequest = {
  userPrincipalName?: string(name='UserPrincipalName'),
  userId?: string(name='UserId'),
  newUserPrincipalName?: string(name='NewUserPrincipalName'),
  newDisplayName?: string(name='NewDisplayName'),
  newMobilePhone?: string(name='NewMobilePhone'),
  newEmail?: string(name='NewEmail'),
  newComments?: string(name='NewComments'),
}

model UpdateUserResponse = {
  requestId: string(name='RequestId'),
  user: {
    userId: string(name='UserId'),
    userPrincipalName: string(name='UserPrincipalName'),
    displayName: string(name='DisplayName'),
    comments: string(name='Comments'),
    createDate: string(name='CreateDate'),
    updateDate: string(name='UpdateDate'),
    lastLoginDate: string(name='LastLoginDate'),
    mobilePhone: string(name='MobilePhone'),
    email: string(name='Email'),
  }(name='User'),
}

async function updateUserWithOptions(request: UpdateUserRequest, runtime: Util.RuntimeOptions): UpdateUserResponse {
  Util.validateModel(request);
  return doRequest('UpdateUser', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function updateUser(request: UpdateUserRequest): UpdateUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateUserWithOptions(request, runtime);
}

model UpdateSAMLProviderRequest = {
  SAMLProviderName: string(name='SAMLProviderName'),
  newDescription?: string(name='NewDescription'),
  newEncodedSAMLMetadataDocument?: string(name='NewEncodedSAMLMetadataDocument'),
}

model UpdateSAMLProviderResponse = {
  requestId: string(name='RequestId'),
  SAMLProvider: {
    SAMLProviderName: string(name='SAMLProviderName'),
    arn: string(name='Arn'),
    description: string(name='Description'),
    createDate: string(name='CreateDate'),
    updateDate: string(name='UpdateDate'),
  }(name='SAMLProvider'),
}

async function updateSAMLProviderWithOptions(request: UpdateSAMLProviderRequest, runtime: Util.RuntimeOptions): UpdateSAMLProviderResponse {
  Util.validateModel(request);
  return doRequest('UpdateSAMLProvider', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function updateSAMLProvider(request: UpdateSAMLProviderRequest): UpdateSAMLProviderResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSAMLProviderWithOptions(request, runtime);
}

model UpdateLoginProfileRequest = {
  userPrincipalName: string(name='UserPrincipalName'),
  password?: string(name='Password'),
  passwordResetRequired?: boolean(name='PasswordResetRequired'),
  MFABindRequired?: boolean(name='MFABindRequired'),
  status?: string(name='Status'),
}

model UpdateLoginProfileResponse = {
  requestId: string(name='RequestId'),
  loginProfile: {
    userPrincipalName: string(name='UserPrincipalName'),
    passwordResetRequired: boolean(name='PasswordResetRequired'),
    MFABindRequired: boolean(name='MFABindRequired'),
    updateDate: string(name='UpdateDate'),
    status: string(name='Status'),
  }(name='LoginProfile'),
}

async function updateLoginProfileWithOptions(request: UpdateLoginProfileRequest, runtime: Util.RuntimeOptions): UpdateLoginProfileResponse {
  Util.validateModel(request);
  return doRequest('UpdateLoginProfile', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function updateLoginProfile(request: UpdateLoginProfileRequest): UpdateLoginProfileResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateLoginProfileWithOptions(request, runtime);
}

model UpdateGroupRequest = {
  newComments?: string(name='NewComments'),
  newDisplayName?: string(name='NewDisplayName'),
  newGroupName?: string(name='NewGroupName'),
  groupName?: string(name='GroupName'),
}

model UpdateGroupResponse = {
  requestId: string(name='RequestId'),
  group: {
    displayName: string(name='DisplayName'),
    comments: string(name='Comments'),
    createDate: string(name='CreateDate'),
    updateDate: string(name='UpdateDate'),
    groupName: string(name='GroupName'),
    groupId: string(name='GroupId'),
  }(name='Group'),
}

async function updateGroupWithOptions(request: UpdateGroupRequest, runtime: Util.RuntimeOptions): UpdateGroupResponse {
  Util.validateModel(request);
  return doRequest('UpdateGroup', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function updateGroup(request: UpdateGroupRequest): UpdateGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGroupWithOptions(request, runtime);
}

model UpdateAccessKeyRequest = {
  userPrincipalName?: string(name='UserPrincipalName'),
  userAccessKeyId: string(name='UserAccessKeyId'),
  status: string(name='Status'),
}

model UpdateAccessKeyResponse = {
  requestId: string(name='RequestId'),
}

async function updateAccessKeyWithOptions(request: UpdateAccessKeyRequest, runtime: Util.RuntimeOptions): UpdateAccessKeyResponse {
  Util.validateModel(request);
  return doRequest('UpdateAccessKey', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function updateAccessKey(request: UpdateAccessKeyRequest): UpdateAccessKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAccessKeyWithOptions(request, runtime);
}

model UnbindMFADeviceRequest = {
  userPrincipalName: string(name='UserPrincipalName'),
}

model UnbindMFADeviceResponse = {
  requestId: string(name='RequestId'),
  MFADevice: {
    serialNumber: string(name='SerialNumber'),
  }(name='MFADevice'),
}

async function unbindMFADeviceWithOptions(request: UnbindMFADeviceRequest, runtime: Util.RuntimeOptions): UnbindMFADeviceResponse {
  Util.validateModel(request);
  return doRequest('UnbindMFADevice', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function unbindMFADevice(request: UnbindMFADeviceRequest): UnbindMFADeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return unbindMFADeviceWithOptions(request, runtime);
}

model SetSecurityPreferenceRequest = {
  enableSaveMFATicket?: boolean(name='EnableSaveMFATicket'),
  allowUserToChangePassword?: boolean(name='AllowUserToChangePassword'),
  allowUserToManageAccessKeys?: boolean(name='AllowUserToManageAccessKeys'),
  allowUserToManageMFADevices?: boolean(name='AllowUserToManageMFADevices'),
  loginSessionDuration?: integer(name='LoginSessionDuration'),
  loginNetworkMasks?: string(name='LoginNetworkMasks'),
}

model SetSecurityPreferenceResponse = {
  requestId: string(name='RequestId'),
  securityPreference: {
    loginProfilePreference: {
      enableSaveMFATicket: boolean(name='EnableSaveMFATicket'),
      allowUserToChangePassword: boolean(name='AllowUserToChangePassword'),
      loginSessionDuration: integer(name='LoginSessionDuration'),
      loginNetworkMasks: string(name='LoginNetworkMasks'),
    }(name='LoginProfilePreference'),
    accessKeyPreference: {
      allowUserToManageAccessKeys: boolean(name='AllowUserToManageAccessKeys'),
    }(name='AccessKeyPreference'),
    MFAPreference: {
      allowUserToManageMFADevices: boolean(name='AllowUserToManageMFADevices'),
    }(name='MFAPreference'),
  }(name='SecurityPreference'),
}

async function setSecurityPreferenceWithOptions(request: SetSecurityPreferenceRequest, runtime: Util.RuntimeOptions): SetSecurityPreferenceResponse {
  Util.validateModel(request);
  return doRequest('SetSecurityPreference', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function setSecurityPreference(request: SetSecurityPreferenceRequest): SetSecurityPreferenceResponse {
  var runtime = new Util.RuntimeOptions{};
  return setSecurityPreferenceWithOptions(request, runtime);
}

model SetPasswordPolicyRequest = {
  minimumPasswordLength?: integer(name='MinimumPasswordLength'),
  requireLowercaseCharacters?: boolean(name='RequireLowercaseCharacters'),
  requireUppercaseCharacters?: boolean(name='RequireUppercaseCharacters'),
  requireNumbers?: boolean(name='RequireNumbers'),
  requireSymbols?: boolean(name='RequireSymbols'),
  hardExpire?: boolean(name='HardExpire'),
  maxLoginAttemps?: integer(name='MaxLoginAttemps'),
  passwordReusePrevention?: integer(name='PasswordReusePrevention'),
  maxPasswordAge?: integer(name='MaxPasswordAge'),
  minimumPasswordDifferentCharacter?: integer(name='MinimumPasswordDifferentCharacter'),
  passwordNotContainUserName?: boolean(name='PasswordNotContainUserName'),
}

model SetPasswordPolicyResponse = {
  requestId: string(name='RequestId'),
  passwordPolicy: {
    minimumPasswordLength: integer(name='MinimumPasswordLength'),
    requireLowercaseCharacters: boolean(name='RequireLowercaseCharacters'),
    requireUppercaseCharacters: boolean(name='RequireUppercaseCharacters'),
    requireNumbers: boolean(name='RequireNumbers'),
    requireSymbols: boolean(name='RequireSymbols'),
    hardExpire: boolean(name='HardExpire'),
    maxLoginAttemps: integer(name='MaxLoginAttemps'),
    passwordReusePrevention: integer(name='PasswordReusePrevention'),
    maxPasswordAge: integer(name='MaxPasswordAge'),
    minimumPasswordDifferentCharacter: integer(name='MinimumPasswordDifferentCharacter'),
    passwordNotContainUserName: boolean(name='PasswordNotContainUserName'),
  }(name='PasswordPolicy'),
}

async function setPasswordPolicyWithOptions(request: SetPasswordPolicyRequest, runtime: Util.RuntimeOptions): SetPasswordPolicyResponse {
  Util.validateModel(request);
  return doRequest('SetPasswordPolicy', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function setPasswordPolicy(request: SetPasswordPolicyRequest): SetPasswordPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return setPasswordPolicyWithOptions(request, runtime);
}

model RemoveUserFromGroupRequest = {
  userPrincipalName: string(name='UserPrincipalName'),
  groupName?: string(name='GroupName'),
}

model RemoveUserFromGroupResponse = {
  requestId: string(name='RequestId'),
}

async function removeUserFromGroupWithOptions(request: RemoveUserFromGroupRequest, runtime: Util.RuntimeOptions): RemoveUserFromGroupResponse {
  Util.validateModel(request);
  return doRequest('RemoveUserFromGroup', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function removeUserFromGroup(request: RemoveUserFromGroupRequest): RemoveUserFromGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeUserFromGroupWithOptions(request, runtime);
}

model ListVirtualMFADevicesRequest = {
  marker?: string(name='Marker'),
  maxItems?: integer(name='MaxItems'),
}

model ListVirtualMFADevicesResponse = {
  requestId: string(name='RequestId'),
  isTruncated: boolean(name='IsTruncated'),
  marker: string(name='Marker'),
  virtualMFADevices: {
    virtualMFADevice: [
      {
        serialNumber: string(name='SerialNumber'),
        activateDate: string(name='ActivateDate'),
        user: {
          userPrincipalName: string(name='UserPrincipalName'),
          userId: string(name='UserId'),
          displayName: string(name='DisplayName'),
        }(name='User'),
      }
    ](name='VirtualMFADevice'),
  }(name='VirtualMFADevices'),
}

async function listVirtualMFADevicesWithOptions(request: ListVirtualMFADevicesRequest, runtime: Util.RuntimeOptions): ListVirtualMFADevicesResponse {
  Util.validateModel(request);
  return doRequest('ListVirtualMFADevices', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function listVirtualMFADevices(request: ListVirtualMFADevicesRequest): ListVirtualMFADevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVirtualMFADevicesWithOptions(request, runtime);
}

model ListUsersForGroupRequest = {
  groupName?: string(name='GroupName'),
  marker?: string(name='Marker'),
  maxItems?: integer(name='MaxItems'),
}

model ListUsersForGroupResponse = {
  requestId: string(name='RequestId'),
  marker: string(name='Marker'),
  isTruncated: boolean(name='IsTruncated'),
  users: {
    user: [
      {
        userId: string(name='UserId'),
        userPrincipalName: string(name='UserPrincipalName'),
        displayName: string(name='DisplayName'),
        joinDate: string(name='JoinDate'),
      }
    ](name='User'),
  }(name='Users'),
}

async function listUsersForGroupWithOptions(request: ListUsersForGroupRequest, runtime: Util.RuntimeOptions): ListUsersForGroupResponse {
  Util.validateModel(request);
  return doRequest('ListUsersForGroup', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function listUsersForGroup(request: ListUsersForGroupRequest): ListUsersForGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUsersForGroupWithOptions(request, runtime);
}

model ListUsersRequest = {
  marker?: string(name='Marker'),
  maxItems?: integer(name='MaxItems'),
}

model ListUsersResponse = {
  requestId: string(name='RequestId'),
  marker: string(name='Marker'),
  isTruncated: boolean(name='IsTruncated'),
  users: {
    user: [
      {
        userId: string(name='UserId'),
        userPrincipalName: string(name='UserPrincipalName'),
        displayName: string(name='DisplayName'),
        comments: string(name='Comments'),
        createDate: string(name='CreateDate'),
        updateDate: string(name='UpdateDate'),
        lastLoginDate: string(name='LastLoginDate'),
        mobilePhone: string(name='MobilePhone'),
        email: string(name='Email'),
      }
    ](name='User'),
  }(name='Users'),
}

async function listUsersWithOptions(request: ListUsersRequest, runtime: Util.RuntimeOptions): ListUsersResponse {
  Util.validateModel(request);
  return doRequest('ListUsers', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function listUsers(request: ListUsersRequest): ListUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUsersWithOptions(request, runtime);
}

model ListSAMLProvidersRequest = {
  marker?: string(name='Marker'),
  maxItems?: integer(name='MaxItems'),
}

model ListSAMLProvidersResponse = {
  requestId: string(name='RequestId'),
  isTruncated: boolean(name='IsTruncated'),
  marker: string(name='Marker'),
  SAMLProviders: {
    SAMLProvider: [
      {
        SAMLProviderName: string(name='SAMLProviderName'),
        arn: string(name='Arn'),
        description: string(name='Description'),
        createDate: string(name='CreateDate'),
        updateDate: string(name='UpdateDate'),
      }
    ](name='SAMLProvider'),
  }(name='SAMLProviders'),
}

async function listSAMLProvidersWithOptions(request: ListSAMLProvidersRequest, runtime: Util.RuntimeOptions): ListSAMLProvidersResponse {
  Util.validateModel(request);
  return doRequest('ListSAMLProviders', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function listSAMLProviders(request: ListSAMLProvidersRequest): ListSAMLProvidersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSAMLProvidersWithOptions(request, runtime);
}

model ListGroupsForUserRequest = {
  userPrincipalName: string(name='UserPrincipalName'),
}

model ListGroupsForUserResponse = {
  requestId: string(name='RequestId'),
  groups: {
    group: [
      {
        displayName: string(name='DisplayName'),
        comments: string(name='Comments'),
        joinDate: string(name='JoinDate'),
        groupName: string(name='GroupName'),
        groupId: string(name='GroupId'),
      }
    ](name='Group'),
  }(name='Groups'),
}

async function listGroupsForUserWithOptions(request: ListGroupsForUserRequest, runtime: Util.RuntimeOptions): ListGroupsForUserResponse {
  Util.validateModel(request);
  return doRequest('ListGroupsForUser', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function listGroupsForUser(request: ListGroupsForUserRequest): ListGroupsForUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return listGroupsForUserWithOptions(request, runtime);
}

model ListGroupsRequest = {
  marker?: string(name='Marker'),
  maxItems?: integer(name='MaxItems'),
}

model ListGroupsResponse = {
  requestId: string(name='RequestId'),
  isTruncated: boolean(name='IsTruncated'),
  marker: string(name='Marker'),
  groups: {
    group: [
      {
        displayName: string(name='DisplayName'),
        comments: string(name='Comments'),
        createDate: string(name='CreateDate'),
        updateDate: string(name='UpdateDate'),
        groupName: string(name='GroupName'),
        groupId: string(name='GroupId'),
      }
    ](name='Group'),
  }(name='Groups'),
}

async function listGroupsWithOptions(request: ListGroupsRequest, runtime: Util.RuntimeOptions): ListGroupsResponse {
  Util.validateModel(request);
  return doRequest('ListGroups', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function listGroups(request: ListGroupsRequest): ListGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listGroupsWithOptions(request, runtime);
}

model ListAccessKeysRequest = {
  userPrincipalName?: string(name='UserPrincipalName'),
}

model ListAccessKeysResponse = {
  requestId: string(name='RequestId'),
  accessKeys: {
    accessKey: [
      {
        accessKeyId: string(name='AccessKeyId'),
        createDate: string(name='CreateDate'),
        updateDate: string(name='UpdateDate'),
        status: string(name='Status'),
      }
    ](name='AccessKey'),
  }(name='AccessKeys'),
}

async function listAccessKeysWithOptions(request: ListAccessKeysRequest, runtime: Util.RuntimeOptions): ListAccessKeysResponse {
  Util.validateModel(request);
  return doRequest('ListAccessKeys', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function listAccessKeys(request: ListAccessKeysRequest): ListAccessKeysResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAccessKeysWithOptions(request, runtime);
}

model GetUserMFAInfoRequest = {
  userPrincipalName?: string(name='UserPrincipalName'),
}

model GetUserMFAInfoResponse = {
  requestId: string(name='RequestId'),
  isMFAEnable: boolean(name='IsMFAEnable'),
  MFADevice: {
    serialNumber: string(name='SerialNumber'),
  }(name='MFADevice'),
}

async function getUserMFAInfoWithOptions(request: GetUserMFAInfoRequest, runtime: Util.RuntimeOptions): GetUserMFAInfoResponse {
  Util.validateModel(request);
  return doRequest('GetUserMFAInfo', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function getUserMFAInfo(request: GetUserMFAInfoRequest): GetUserMFAInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserMFAInfoWithOptions(request, runtime);
}

model GetUserRequest = {
  userPrincipalName?: string(name='UserPrincipalName'),
  userId?: string(name='UserId'),
  userAccessKeyId?: string(name='UserAccessKeyId'),
}

model GetUserResponse = {
  requestId: string(name='RequestId'),
  user: {
    userId: string(name='UserId'),
    userPrincipalName: string(name='UserPrincipalName'),
    displayName: string(name='DisplayName'),
    comments: string(name='Comments'),
    createDate: string(name='CreateDate'),
    updateDate: string(name='UpdateDate'),
    lastLoginDate: string(name='LastLoginDate'),
    mobilePhone: string(name='MobilePhone'),
    email: string(name='Email'),
  }(name='User'),
}

async function getUserWithOptions(request: GetUserRequest, runtime: Util.RuntimeOptions): GetUserResponse {
  Util.validateModel(request);
  return doRequest('GetUser', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function getUser(request: GetUserRequest): GetUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserWithOptions(request, runtime);
}

model GetSecurityPreferenceRequest = {
}

model GetSecurityPreferenceResponse = {
  requestId: string(name='RequestId'),
  securityPreference: {
    loginProfilePreference: {
      enableSaveMFATicket: boolean(name='EnableSaveMFATicket'),
      allowUserToChangePassword: boolean(name='AllowUserToChangePassword'),
      loginSessionDuration: integer(name='LoginSessionDuration'),
      loginNetworkMasks: string(name='LoginNetworkMasks'),
    }(name='LoginProfilePreference'),
    accessKeyPreference: {
      allowUserToManageAccessKeys: boolean(name='AllowUserToManageAccessKeys'),
    }(name='AccessKeyPreference'),
    MFAPreference: {
      allowUserToManageMFADevices: boolean(name='AllowUserToManageMFADevices'),
    }(name='MFAPreference'),
  }(name='SecurityPreference'),
}

async function getSecurityPreferenceWithOptions(request: GetSecurityPreferenceRequest, runtime: Util.RuntimeOptions): GetSecurityPreferenceResponse {
  Util.validateModel(request);
  return doRequest('GetSecurityPreference', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function getSecurityPreference(request: GetSecurityPreferenceRequest): GetSecurityPreferenceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSecurityPreferenceWithOptions(request, runtime);
}

model GetSAMLProviderRequest = {
  SAMLProviderName: string(name='SAMLProviderName'),
}

model GetSAMLProviderResponse = {
  requestId: string(name='RequestId'),
  SAMLProvider: {
    SAMLProviderName: string(name='SAMLProviderName'),
    arn: string(name='Arn'),
    description: string(name='Description'),
    createDate: string(name='CreateDate'),
    updateDate: string(name='UpdateDate'),
    encodedSAMLMetadataDocument: string(name='EncodedSAMLMetadataDocument'),
  }(name='SAMLProvider'),
}

async function getSAMLProviderWithOptions(request: GetSAMLProviderRequest, runtime: Util.RuntimeOptions): GetSAMLProviderResponse {
  Util.validateModel(request);
  return doRequest('GetSAMLProvider', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function getSAMLProvider(request: GetSAMLProviderRequest): GetSAMLProviderResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSAMLProviderWithOptions(request, runtime);
}

model GetPasswordPolicyRequest = {
}

model GetPasswordPolicyResponse = {
  requestId: string(name='RequestId'),
  passwordPolicy: {
    minimumPasswordLength: integer(name='MinimumPasswordLength'),
    requireLowercaseCharacters: boolean(name='RequireLowercaseCharacters'),
    requireUppercaseCharacters: boolean(name='RequireUppercaseCharacters'),
    requireNumbers: boolean(name='RequireNumbers'),
    requireSymbols: boolean(name='RequireSymbols'),
    hardExpire: boolean(name='HardExpire'),
    maxLoginAttemps: integer(name='MaxLoginAttemps'),
    passwordReusePrevention: integer(name='PasswordReusePrevention'),
    maxPasswordAge: integer(name='MaxPasswordAge'),
    minimumPasswordDifferentCharacter: integer(name='MinimumPasswordDifferentCharacter'),
    passwordNotContainUserName: boolean(name='PasswordNotContainUserName'),
  }(name='PasswordPolicy'),
}

async function getPasswordPolicyWithOptions(request: GetPasswordPolicyRequest, runtime: Util.RuntimeOptions): GetPasswordPolicyResponse {
  Util.validateModel(request);
  return doRequest('GetPasswordPolicy', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function getPasswordPolicy(request: GetPasswordPolicyRequest): GetPasswordPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPasswordPolicyWithOptions(request, runtime);
}

model GetLoginProfileRequest = {
  userPrincipalName: string(name='UserPrincipalName'),
}

model GetLoginProfileResponse = {
  requestId: string(name='RequestId'),
  loginProfile: {
    userPrincipalName: string(name='UserPrincipalName'),
    passwordResetRequired: boolean(name='PasswordResetRequired'),
    MFABindRequired: boolean(name='MFABindRequired'),
    updateDate: string(name='UpdateDate'),
    lastLoginTime: string(name='LastLoginTime'),
    status: string(name='Status'),
  }(name='LoginProfile'),
}

async function getLoginProfileWithOptions(request: GetLoginProfileRequest, runtime: Util.RuntimeOptions): GetLoginProfileResponse {
  Util.validateModel(request);
  return doRequest('GetLoginProfile', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function getLoginProfile(request: GetLoginProfileRequest): GetLoginProfileResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLoginProfileWithOptions(request, runtime);
}

model GetGroupRequest = {
  groupName?: string(name='GroupName'),
}

model GetGroupResponse = {
  requestId: string(name='RequestId'),
  group: {
    displayName: string(name='DisplayName'),
    comments: string(name='Comments'),
    createDate: string(name='CreateDate'),
    updateDate: string(name='UpdateDate'),
    groupName: string(name='GroupName'),
    groupId: string(name='GroupId'),
  }(name='Group'),
}

async function getGroupWithOptions(request: GetGroupRequest, runtime: Util.RuntimeOptions): GetGroupResponse {
  Util.validateModel(request);
  return doRequest('GetGroup', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function getGroup(request: GetGroupRequest): GetGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return getGroupWithOptions(request, runtime);
}

model GetDefaultDomainRequest = {
}

model GetDefaultDomainResponse = {
  requestId: string(name='RequestId'),
  defaultDomainName: string(name='DefaultDomainName'),
}

async function getDefaultDomainWithOptions(request: GetDefaultDomainRequest, runtime: Util.RuntimeOptions): GetDefaultDomainResponse {
  Util.validateModel(request);
  return doRequest('GetDefaultDomain', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function getDefaultDomain(request: GetDefaultDomainRequest): GetDefaultDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDefaultDomainWithOptions(request, runtime);
}

model GetAccountSummaryRequest = {
}

model GetAccountSummaryResponse = {
  requestId: string(name='RequestId'),
  summaryMap: {
    usersQuota: integer(name='UsersQuota'),
    users: integer(name='Users'),
    accessKeysPerUserQuota: integer(name='AccessKeysPerUserQuota'),
    virtualMFADevicesQuota: integer(name='VirtualMFADevicesQuota'),
    MFADevices: integer(name='MFADevices'),
    MFADevicesInUse: integer(name='MFADevicesInUse'),
    groupsQuota: integer(name='GroupsQuota'),
    groups: integer(name='Groups'),
    groupsPerUserQuota: integer(name='GroupsPerUserQuota'),
    rolesQuota: integer(name='RolesQuota'),
    roles: integer(name='Roles'),
    policiesQuota: integer(name='PoliciesQuota'),
    policies: integer(name='Policies'),
    policySizeQuota: integer(name='PolicySizeQuota'),
    versionsPerPolicyQuota: integer(name='VersionsPerPolicyQuota'),
    attachedPoliciesPerUserQuota: integer(name='AttachedPoliciesPerUserQuota'),
    attachedPoliciesPerGroupQuota: integer(name='AttachedPoliciesPerGroupQuota'),
    attachedPoliciesPerRoleQuota: integer(name='AttachedPoliciesPerRoleQuota'),
    attachedSystemPoliciesPerUserQuota: integer(name='AttachedSystemPoliciesPerUserQuota'),
    attachedSystemPoliciesPerGroupQuota: integer(name='AttachedSystemPoliciesPerGroupQuota'),
    attachedSystemPoliciesPerRoleQuota: integer(name='AttachedSystemPoliciesPerRoleQuota'),
  }(name='SummaryMap'),
}

async function getAccountSummaryWithOptions(request: GetAccountSummaryRequest, runtime: Util.RuntimeOptions): GetAccountSummaryResponse {
  Util.validateModel(request);
  return doRequest('GetAccountSummary', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function getAccountSummary(request: GetAccountSummaryRequest): GetAccountSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAccountSummaryWithOptions(request, runtime);
}

model GetAccountSecurityPracticeReportRequest = {
}

model GetAccountSecurityPracticeReportResponse = {
  requestId: string(name='RequestId'),
  accountSecurityPracticeInfo: {
    score: integer(name='Score'),
    accountSecurityPracticeUserInfo: {
      bindMfa: boolean(name='BindMfa'),
      subUserPwdLevel: string(name='SubUserPwdLevel'),
      rootWithAccessKey: integer(name='RootWithAccessKey'),
      oldAkNum: integer(name='OldAkNum'),
      unusedAkNum: integer(name='UnusedAkNum'),
      subUser: integer(name='SubUser'),
      subUserBindMfa: integer(name='SubUserBindMfa'),
      subUserWithOldAccessKey: integer(name='SubUserWithOldAccessKey'),
      subUserWithUnusedAccessKey: integer(name='SubUserWithUnusedAccessKey'),
    }(name='AccountSecurityPracticeUserInfo'),
  }(name='AccountSecurityPracticeInfo'),
}

async function getAccountSecurityPracticeReportWithOptions(request: GetAccountSecurityPracticeReportRequest, runtime: Util.RuntimeOptions): GetAccountSecurityPracticeReportResponse {
  Util.validateModel(request);
  return doRequest('GetAccountSecurityPracticeReport', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function getAccountSecurityPracticeReport(request: GetAccountSecurityPracticeReportRequest): GetAccountSecurityPracticeReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAccountSecurityPracticeReportWithOptions(request, runtime);
}

model GetAccountMFAInfoRequest = {
}

model GetAccountMFAInfoResponse = {
  requestId: string(name='RequestId'),
  isMFAEnable: boolean(name='IsMFAEnable'),
}

async function getAccountMFAInfoWithOptions(request: GetAccountMFAInfoRequest, runtime: Util.RuntimeOptions): GetAccountMFAInfoResponse {
  Util.validateModel(request);
  return doRequest('GetAccountMFAInfo', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function getAccountMFAInfo(request: GetAccountMFAInfoRequest): GetAccountMFAInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAccountMFAInfoWithOptions(request, runtime);
}

model GetAccessKeyLastUsedRequest = {
  userPrincipalName?: string(name='UserPrincipalName'),
  userAccessKeyId: string(name='UserAccessKeyId'),
}

model GetAccessKeyLastUsedResponse = {
  requestId: string(name='RequestId'),
  accessKeyLastUsed: {
    lastUsedDate: string(name='LastUsedDate'),
  }(name='AccessKeyLastUsed'),
}

async function getAccessKeyLastUsedWithOptions(request: GetAccessKeyLastUsedRequest, runtime: Util.RuntimeOptions): GetAccessKeyLastUsedResponse {
  Util.validateModel(request);
  return doRequest('GetAccessKeyLastUsed', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function getAccessKeyLastUsed(request: GetAccessKeyLastUsedRequest): GetAccessKeyLastUsedResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAccessKeyLastUsedWithOptions(request, runtime);
}

model DisableVirtualMFARequest = {
  userPrincipalName: string(name='UserPrincipalName'),
}

model DisableVirtualMFAResponse = {
  requestId: string(name='RequestId'),
}

async function disableVirtualMFAWithOptions(request: DisableVirtualMFARequest, runtime: Util.RuntimeOptions): DisableVirtualMFAResponse {
  Util.validateModel(request);
  return doRequest('DisableVirtualMFA', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function disableVirtualMFA(request: DisableVirtualMFARequest): DisableVirtualMFAResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableVirtualMFAWithOptions(request, runtime);
}

model DeleteVirtualMFADeviceRequest = {
  serialNumber: string(name='SerialNumber'),
}

model DeleteVirtualMFADeviceResponse = {
  requestId: string(name='RequestId'),
}

async function deleteVirtualMFADeviceWithOptions(request: DeleteVirtualMFADeviceRequest, runtime: Util.RuntimeOptions): DeleteVirtualMFADeviceResponse {
  Util.validateModel(request);
  return doRequest('DeleteVirtualMFADevice', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function deleteVirtualMFADevice(request: DeleteVirtualMFADeviceRequest): DeleteVirtualMFADeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVirtualMFADeviceWithOptions(request, runtime);
}

model DeleteUserRequest = {
  userPrincipalName?: string(name='UserPrincipalName'),
  userId?: string(name='UserId'),
}

model DeleteUserResponse = {
  requestId: string(name='RequestId'),
}

async function deleteUserWithOptions(request: DeleteUserRequest, runtime: Util.RuntimeOptions): DeleteUserResponse {
  Util.validateModel(request);
  return doRequest('DeleteUser', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function deleteUser(request: DeleteUserRequest): DeleteUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUserWithOptions(request, runtime);
}

model DeleteSAMLProviderRequest = {
  SAMLProviderName: string(name='SAMLProviderName'),
}

model DeleteSAMLProviderResponse = {
  requestId: string(name='RequestId'),
}

async function deleteSAMLProviderWithOptions(request: DeleteSAMLProviderRequest, runtime: Util.RuntimeOptions): DeleteSAMLProviderResponse {
  Util.validateModel(request);
  return doRequest('DeleteSAMLProvider', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function deleteSAMLProvider(request: DeleteSAMLProviderRequest): DeleteSAMLProviderResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSAMLProviderWithOptions(request, runtime);
}

model DeleteLoginProfileRequest = {
  userPrincipalName: string(name='UserPrincipalName'),
}

model DeleteLoginProfileResponse = {
  requestId: string(name='RequestId'),
}

async function deleteLoginProfileWithOptions(request: DeleteLoginProfileRequest, runtime: Util.RuntimeOptions): DeleteLoginProfileResponse {
  Util.validateModel(request);
  return doRequest('DeleteLoginProfile', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function deleteLoginProfile(request: DeleteLoginProfileRequest): DeleteLoginProfileResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLoginProfileWithOptions(request, runtime);
}

model DeleteGroupRequest = {
  groupName?: string(name='GroupName'),
}

model DeleteGroupResponse = {
  requestId: string(name='RequestId'),
}

async function deleteGroupWithOptions(request: DeleteGroupRequest, runtime: Util.RuntimeOptions): DeleteGroupResponse {
  Util.validateModel(request);
  return doRequest('DeleteGroup', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function deleteGroup(request: DeleteGroupRequest): DeleteGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGroupWithOptions(request, runtime);
}

model DeleteAccessKeyRequest = {
  userAccessKeyId: string(name='UserAccessKeyId'),
  userPrincipalName?: string(name='UserPrincipalName'),
}

model DeleteAccessKeyResponse = {
  requestId: string(name='RequestId'),
}

async function deleteAccessKeyWithOptions(request: DeleteAccessKeyRequest, runtime: Util.RuntimeOptions): DeleteAccessKeyResponse {
  Util.validateModel(request);
  return doRequest('DeleteAccessKey', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function deleteAccessKey(request: DeleteAccessKeyRequest): DeleteAccessKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAccessKeyWithOptions(request, runtime);
}

model CreateVirtualMFADeviceRequest = {
  virtualMFADeviceName: string(name='VirtualMFADeviceName'),
}

model CreateVirtualMFADeviceResponse = {
  requestId: string(name='RequestId'),
  virtualMFADevice: {
    serialNumber: string(name='SerialNumber'),
    base32StringSeed: string(name='Base32StringSeed'),
    QRCodePNG: string(name='QRCodePNG'),
  }(name='VirtualMFADevice'),
}

async function createVirtualMFADeviceWithOptions(request: CreateVirtualMFADeviceRequest, runtime: Util.RuntimeOptions): CreateVirtualMFADeviceResponse {
  Util.validateModel(request);
  return doRequest('CreateVirtualMFADevice', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function createVirtualMFADevice(request: CreateVirtualMFADeviceRequest): CreateVirtualMFADeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVirtualMFADeviceWithOptions(request, runtime);
}

model CreateUserRequest = {
  userPrincipalName: string(name='UserPrincipalName'),
  displayName: string(name='DisplayName'),
  mobilePhone?: string(name='MobilePhone'),
  email?: string(name='Email'),
  comments?: string(name='Comments'),
}

model CreateUserResponse = {
  requestId: string(name='RequestId'),
  user: {
    userId: string(name='UserId'),
    userPrincipalName: string(name='UserPrincipalName'),
    displayName: string(name='DisplayName'),
    comments: string(name='Comments'),
    createDate: string(name='CreateDate'),
    updateDate: string(name='UpdateDate'),
    lastLoginDate: string(name='LastLoginDate'),
    mobilePhone: string(name='MobilePhone'),
    email: string(name='Email'),
  }(name='User'),
}

async function createUserWithOptions(request: CreateUserRequest, runtime: Util.RuntimeOptions): CreateUserResponse {
  Util.validateModel(request);
  return doRequest('CreateUser', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function createUser(request: CreateUserRequest): CreateUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUserWithOptions(request, runtime);
}

model CreateSAMLProviderRequest = {
  SAMLProviderName: string(name='SAMLProviderName'),
  description?: string(name='Description'),
  encodedSAMLMetadataDocument?: string(name='EncodedSAMLMetadataDocument'),
}

model CreateSAMLProviderResponse = {
  requestId: string(name='RequestId'),
  SAMLProvider: {
    SAMLProviderName: string(name='SAMLProviderName'),
    arn: string(name='Arn'),
    description: string(name='Description'),
    createDate: string(name='CreateDate'),
    updateDate: string(name='UpdateDate'),
  }(name='SAMLProvider'),
}

async function createSAMLProviderWithOptions(request: CreateSAMLProviderRequest, runtime: Util.RuntimeOptions): CreateSAMLProviderResponse {
  Util.validateModel(request);
  return doRequest('CreateSAMLProvider', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function createSAMLProvider(request: CreateSAMLProviderRequest): CreateSAMLProviderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSAMLProviderWithOptions(request, runtime);
}

model CreateLoginProfileRequest = {
  userPrincipalName: string(name='UserPrincipalName'),
  password?: string(name='Password'),
  passwordResetRequired?: boolean(name='PasswordResetRequired'),
  MFABindRequired?: boolean(name='MFABindRequired'),
  status?: string(name='Status'),
}

model CreateLoginProfileResponse = {
  requestId: string(name='RequestId'),
  loginProfile: {
    userPrincipalName: string(name='UserPrincipalName'),
    passwordResetRequired: boolean(name='PasswordResetRequired'),
    MFABindRequired: boolean(name='MFABindRequired'),
    updateDate: string(name='UpdateDate'),
    status: string(name='Status'),
  }(name='LoginProfile'),
}

async function createLoginProfileWithOptions(request: CreateLoginProfileRequest, runtime: Util.RuntimeOptions): CreateLoginProfileResponse {
  Util.validateModel(request);
  return doRequest('CreateLoginProfile', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function createLoginProfile(request: CreateLoginProfileRequest): CreateLoginProfileResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLoginProfileWithOptions(request, runtime);
}

model CreateGroupRequest = {
  displayName?: string(name='DisplayName'),
  comments?: string(name='Comments'),
  groupName?: string(name='GroupName'),
}

model CreateGroupResponse = {
  requestId: string(name='RequestId'),
  group: {
    displayName: string(name='DisplayName'),
    comments: string(name='Comments'),
    createDate: string(name='CreateDate'),
    updateDate: string(name='UpdateDate'),
    groupName: string(name='GroupName'),
    groupId: string(name='GroupId'),
  }(name='Group'),
}

async function createGroupWithOptions(request: CreateGroupRequest, runtime: Util.RuntimeOptions): CreateGroupResponse {
  Util.validateModel(request);
  return doRequest('CreateGroup', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function createGroup(request: CreateGroupRequest): CreateGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGroupWithOptions(request, runtime);
}

model CreateAccessKeyRequest = {
  userPrincipalName?: string(name='UserPrincipalName'),
}

model CreateAccessKeyResponse = {
  requestId: string(name='RequestId'),
  accessKey: {
    accessKeyId: string(name='AccessKeyId'),
    accessKeySecret: string(name='AccessKeySecret'),
    createDate: string(name='CreateDate'),
    status: string(name='Status'),
  }(name='AccessKey'),
}

async function createAccessKeyWithOptions(request: CreateAccessKeyRequest, runtime: Util.RuntimeOptions): CreateAccessKeyResponse {
  Util.validateModel(request);
  return doRequest('CreateAccessKey', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function createAccessKey(request: CreateAccessKeyRequest): CreateAccessKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAccessKeyWithOptions(request, runtime);
}

model ChangePasswordRequest = {
  oldPassword: string(name='OldPassword'),
  newPassword: string(name='NewPassword'),
}

model ChangePasswordResponse = {
  requestId: string(name='RequestId'),
}

async function changePasswordWithOptions(request: ChangePasswordRequest, runtime: Util.RuntimeOptions): ChangePasswordResponse {
  Util.validateModel(request);
  return doRequest('ChangePassword', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function changePassword(request: ChangePasswordRequest): ChangePasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return changePasswordWithOptions(request, runtime);
}

model BindMFADeviceRequest = {
  serialNumber: string(name='SerialNumber'),
  userPrincipalName: string(name='UserPrincipalName'),
  authenticationCode1: string(name='AuthenticationCode1'),
  authenticationCode2: string(name='AuthenticationCode2'),
}

model BindMFADeviceResponse = {
  requestId: string(name='RequestId'),
}

async function bindMFADeviceWithOptions(request: BindMFADeviceRequest, runtime: Util.RuntimeOptions): BindMFADeviceResponse {
  Util.validateModel(request);
  return doRequest('BindMFADevice', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function bindMFADevice(request: BindMFADeviceRequest): BindMFADeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindMFADeviceWithOptions(request, runtime);
}

model AddUserToGroupRequest = {
  userPrincipalName: string(name='UserPrincipalName'),
  groupName?: string(name='GroupName'),
}

model AddUserToGroupResponse = {
  requestId: string(name='RequestId'),
}

async function addUserToGroupWithOptions(request: AddUserToGroupRequest, runtime: Util.RuntimeOptions): AddUserToGroupResponse {
  Util.validateModel(request);
  return doRequest('AddUserToGroup', 'HTTPS', 'POST', '2019-08-15', 'AK,BearerToken', null, request, runtime);
}

async function addUserToGroup(request: AddUserToGroupRequest): AddUserToGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return addUserToGroupWithOptions(request, runtime);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
