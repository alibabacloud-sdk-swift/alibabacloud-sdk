import Util;

import RPC;
import EndpointUtil;

extends RPC;

init(config: RPC.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    cn-qingdao = 'rds.aliyuncs.com',
    cn-beijing = 'rds.aliyuncs.com',
    cn-hangzhou = 'rds.aliyuncs.com',
    cn-shanghai = 'rds.aliyuncs.com',
    cn-shenzhen = 'rds.aliyuncs.com',
    cn-hongkong = 'rds.aliyuncs.com',
    ap-southeast-1 = 'rds.aliyuncs.com',
    us-west-1 = 'rds.aliyuncs.com',
    us-east-1 = 'rds.aliyuncs.com',
    cn-shanghai-finance-1 = 'rds.aliyuncs.com',
    cn-shenzhen-finance-1 = 'rds.aliyuncs.com',
    cn-north-2-gov-1 = 'rds.aliyuncs.com',
    ap-northeast-2-pop = 'rds.ap-northeast-1.aliyuncs.com',
    cn-beijing-finance-1 = 'rds.aliyuncs.com',
    cn-beijing-finance-pop = 'rds.aliyuncs.com',
    cn-beijing-gov-1 = 'rds.aliyuncs.com',
    cn-beijing-nu16-b01 = 'rds.aliyuncs.com',
    cn-edge-1 = 'rds.aliyuncs.com',
    cn-fujian = 'rds.aliyuncs.com',
    cn-haidian-cm12-c01 = 'rds.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'rds.aliyuncs.com',
    cn-hangzhou-finance = 'rds.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'rds.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'rds.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'rds.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'rds.aliyuncs.com',
    cn-hangzhou-test-306 = 'rds.aliyuncs.com',
    cn-hongkong-finance-pop = 'rds.aliyuncs.com',
    cn-qingdao-nebula = 'rds.aliyuncs.com',
    cn-shanghai-et15-b01 = 'rds.aliyuncs.com',
    cn-shanghai-et2-b01 = 'rds.aliyuncs.com',
    cn-shanghai-inner = 'rds.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'rds.aliyuncs.com',
    cn-shenzhen-inner = 'rds.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'rds.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'rds.aliyuncs.com',
    cn-wuhan = 'rds.aliyuncs.com',
    cn-yushanfang = 'rds.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'rds.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'rds.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'rds.aliyuncs.com',
    eu-west-1-oxs = 'rds.ap-northeast-1.aliyuncs.com',
    rus-west-1-pop = 'rds.ap-northeast-1.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('rds', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

model GetDbProxyInstanceSslRequest = {
  regionId?: string(name='RegionId'),
  dbInstanceId: string(name='DbInstanceId'),
}

model GetDbProxyInstanceSslResponse = {
  requestId: string(name='RequestId'),
  dbProxyCertListItems: {
    dbProxyCertListItems: [
      {
        dbInstanceName: string(name='DbInstanceName'),
        endpointName: string(name='EndpointName'),
        endpointType: string(name='EndpointType'),
        certCommonName: string(name='CertCommonName'),
        sslExpiredTime: string(name='SslExpiredTime'),
      }
    ](name='DbProxyCertListItems'),
  }(name='DbProxyCertListItems'),
}

async function getDbProxyInstanceSslWithOptions(request: GetDbProxyInstanceSslRequest, runtime: Util.RuntimeOptions): GetDbProxyInstanceSslResponse {
  Util.validateModel(request);
  return doRequest('GetDbProxyInstanceSsl', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function getDbProxyInstanceSsl(request: GetDbProxyInstanceSslRequest): GetDbProxyInstanceSslResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDbProxyInstanceSslWithOptions(request, runtime);
}

model ModifyDbProxyInstanceSslRequest = {
  regionId?: string(name='RegionId'),
  dbInstanceId: string(name='DbInstanceId'),
  dbProxyEndpointId: string(name='DbProxyEndpointId'),
  dbProxyConnectString: string(name='DbProxyConnectString'),
  dbProxySslEnabled: string(name='DbProxySslEnabled'),
}

model ModifyDbProxyInstanceSslResponse = {
  requestId: string(name='RequestId'),
}

async function modifyDbProxyInstanceSslWithOptions(request: ModifyDbProxyInstanceSslRequest, runtime: Util.RuntimeOptions): ModifyDbProxyInstanceSslResponse {
  Util.validateModel(request);
  return doRequest('ModifyDbProxyInstanceSsl', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifyDbProxyInstanceSsl(request: ModifyDbProxyInstanceSslRequest): ModifyDbProxyInstanceSslResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDbProxyInstanceSslWithOptions(request, runtime);
}

model MigrateConnectionToOtherZoneRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  connectionString: string(name='ConnectionString'),
  zoneId: string(name='ZoneId'),
}

model MigrateConnectionToOtherZoneResponse = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
}

async function migrateConnectionToOtherZoneWithOptions(request: MigrateConnectionToOtherZoneRequest, runtime: Util.RuntimeOptions): MigrateConnectionToOtherZoneResponse {
  Util.validateModel(request);
  return doRequest('MigrateConnectionToOtherZone', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function migrateConnectionToOtherZone(request: MigrateConnectionToOtherZoneRequest): MigrateConnectionToOtherZoneResponse {
  var runtime = new Util.RuntimeOptions{};
  return migrateConnectionToOtherZoneWithOptions(request, runtime);
}

model GetDBInstanceTopologyRequest = {
  DBInstanceId: string(name='DBInstanceId'),
}

model GetDBInstanceTopologyResponse = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    DBInstanceName: string(name='DBInstanceName'),
    connections: [
      {
        netType: string(name='NetType'),
        connectionString: string(name='ConnectionString'),
        zoneId: string(name='ZoneId'),
      }
    ](name='Connections'),
    nodes: [
      {
        role: string(name='Role'),
        dedicatedHostId: string(name='DedicatedHostId'),
        zoneId: string(name='ZoneId'),
        dedicatedHostGroupId: string(name='DedicatedHostGroupId'),
      }
    ](name='Nodes'),
  }(name='Data'),
}

async function getDBInstanceTopologyWithOptions(request: GetDBInstanceTopologyRequest, runtime: Util.RuntimeOptions): GetDBInstanceTopologyResponse {
  Util.validateModel(request);
  return doRequest('GetDBInstanceTopology', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function getDBInstanceTopology(request: GetDBInstanceTopologyRequest): GetDBInstanceTopologyResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDBInstanceTopologyWithOptions(request, runtime);
}

model CheckRegionSupportBackupEncryptionRequest = {
  regionId: string(name='RegionId'),
  DBInstanceID?: string(name='DBInstanceID'),
}

model CheckRegionSupportBackupEncryptionResponse = {
  requestId: string(name='RequestId'),
  supportBackupEncryption: boolean(name='SupportBackupEncryption'),
}

async function checkRegionSupportBackupEncryptionWithOptions(request: CheckRegionSupportBackupEncryptionRequest, runtime: Util.RuntimeOptions): CheckRegionSupportBackupEncryptionResponse {
  Util.validateModel(request);
  return doRequest('CheckRegionSupportBackupEncryption', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function checkRegionSupportBackupEncryption(request: CheckRegionSupportBackupEncryptionRequest): CheckRegionSupportBackupEncryptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkRegionSupportBackupEncryptionWithOptions(request, runtime);
}

model DescribeDBInstanceDetailRequest = {
  clientToken?: string(name='ClientToken'),
  DBInstanceId: string(name='DBInstanceId'),
}

model DescribeDBInstanceDetailResponse = {
  requestId: string(name='RequestId'),
  DBInstanceId: string(name='DBInstanceId'),
  regionId: string(name='RegionId'),
  licenseType: string(name='LicenseType'),
  activationState: string(name='ActivationState'),
}

async function describeDBInstanceDetailWithOptions(request: DescribeDBInstanceDetailRequest, runtime: Util.RuntimeOptions): DescribeDBInstanceDetailResponse {
  Util.validateModel(request);
  return doRequest('DescribeDBInstanceDetail', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeDBInstanceDetail(request: DescribeDBInstanceDetailRequest): DescribeDBInstanceDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstanceDetailWithOptions(request, runtime);
}

model ModifyLicenseInfoRequest = {
  clientToken?: string(name='ClientToken'),
  DBInstanceId: string(name='DBInstanceId'),
  license: string(name='License'),
}

model ModifyLicenseInfoResponse = {
  requestId: string(name='RequestId'),
}

async function modifyLicenseInfoWithOptions(request: ModifyLicenseInfoRequest, runtime: Util.RuntimeOptions): ModifyLicenseInfoResponse {
  Util.validateModel(request);
  return doRequest('ModifyLicenseInfo', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifyLicenseInfo(request: ModifyLicenseInfoRequest): ModifyLicenseInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyLicenseInfoWithOptions(request, runtime);
}

model DeleteDBProxyEndpointAddressRequest = {
  regionId?: string(name='RegionId'),
  DBInstanceId: string(name='DBInstanceId'),
  DBProxyEndpointId: string(name='DBProxyEndpointId'),
  DBProxyConnectStringNetType: string(name='DBProxyConnectStringNetType'),
}

model DeleteDBProxyEndpointAddressResponse = {
  requestId: string(name='RequestId'),
}

async function deleteDBProxyEndpointAddressWithOptions(request: DeleteDBProxyEndpointAddressRequest, runtime: Util.RuntimeOptions): DeleteDBProxyEndpointAddressResponse {
  Util.validateModel(request);
  return doRequest('DeleteDBProxyEndpointAddress', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function deleteDBProxyEndpointAddress(request: DeleteDBProxyEndpointAddressRequest): DeleteDBProxyEndpointAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDBProxyEndpointAddressWithOptions(request, runtime);
}

model CreateDBProxyEndpointAddressRequest = {
  regionId?: string(name='RegionId'),
  DBInstanceId: string(name='DBInstanceId'),
  DBProxyEndpointId: string(name='DBProxyEndpointId'),
  connectionStringPrefix: string(name='ConnectionStringPrefix'),
  DBProxyNewConnectStringPort?: string(name='DBProxyNewConnectStringPort'),
  DBProxyConnectStringNetType: string(name='DBProxyConnectStringNetType'),
  VPCId?: string(name='VPCId'),
  vSwitchId?: string(name='VSwitchId'),
}

model CreateDBProxyEndpointAddressResponse = {
  requestId: string(name='RequestId'),
}

async function createDBProxyEndpointAddressWithOptions(request: CreateDBProxyEndpointAddressRequest, runtime: Util.RuntimeOptions): CreateDBProxyEndpointAddressResponse {
  Util.validateModel(request);
  return doRequest('CreateDBProxyEndpointAddress', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function createDBProxyEndpointAddress(request: CreateDBProxyEndpointAddressRequest): CreateDBProxyEndpointAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDBProxyEndpointAddressWithOptions(request, runtime);
}

model DescribeDasInstanceConfigRequest = {
  clientToken?: string(name='ClientToken'),
  DBInstanceId: string(name='DBInstanceId'),
}

model DescribeDasInstanceConfigResponse = {
  requestId: string(name='RequestId'),
  data: string(name='Data'),
  storageUpperBound: integer(name='StorageUpperBound'),
  maxStorageUpperBound: integer(name='MaxStorageUpperBound'),
  DBInstanceId: string(name='DBInstanceId'),
  storageThreshold: integer(name='StorageThreshold'),
  storageAutoScale: boolean(name='StorageAutoScale'),
  DBType: string(name='DBType'),
}

async function describeDasInstanceConfigWithOptions(request: DescribeDasInstanceConfigRequest, runtime: Util.RuntimeOptions): DescribeDasInstanceConfigResponse {
  Util.validateModel(request);
  return doRequest('DescribeDasInstanceConfig', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeDasInstanceConfig(request: DescribeDasInstanceConfigRequest): DescribeDasInstanceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDasInstanceConfigWithOptions(request, runtime);
}

model ModifyDasInstanceConfigRequest = {
  clientToken?: string(name='ClientToken'),
  DBInstanceId: string(name='DBInstanceId'),
  storageAutoScale: string(name='StorageAutoScale'),
  storageThreshold?: integer(name='StorageThreshold'),
  storageUpperBound?: integer(name='StorageUpperBound'),
}

model ModifyDasInstanceConfigResponse = {
  requestId: string(name='RequestId'),
}

async function modifyDasInstanceConfigWithOptions(request: ModifyDasInstanceConfigRequest, runtime: Util.RuntimeOptions): ModifyDasInstanceConfigResponse {
  Util.validateModel(request);
  return doRequest('ModifyDasInstanceConfig', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifyDasInstanceConfig(request: ModifyDasInstanceConfigRequest): ModifyDasInstanceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDasInstanceConfigWithOptions(request, runtime);
}

model DescribeRdsResourceSettingsRequest = {
  resourceNiche: string(name='ResourceNiche'),
}

model DescribeRdsResourceSettingsResponse = {
  requestId: string(name='RequestId'),
  rdsInstanceResourceSettings: {
    rdsInstanceResourceSetting: [
      {
        startDate: string(name='StartDate'),
        endDate: string(name='EndDate'),
        resourceNiche: string(name='ResourceNiche'),
        noticeBarContent: string(name='NoticeBarContent'),
        poppedUpButtonText: string(name='PoppedUpButtonText'),
        poppedUpButtonType: string(name='PoppedUpButtonType'),
        poppedUpButtonUrl: string(name='PoppedUpButtonUrl'),
        poppedUpContent: string(name='PoppedUpContent'),
        isTop: string(name='IsTop'),
      }
    ](name='RdsInstanceResourceSetting'),
  }(name='RdsInstanceResourceSettings'),
}

async function describeRdsResourceSettingsWithOptions(request: DescribeRdsResourceSettingsRequest, runtime: Util.RuntimeOptions): DescribeRdsResourceSettingsResponse {
  Util.validateModel(request);
  return doRequest('DescribeRdsResourceSettings', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeRdsResourceSettings(request: DescribeRdsResourceSettingsRequest): DescribeRdsResourceSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRdsResourceSettingsWithOptions(request, runtime);
}

model DeleteHostAccountRequest = {
  clientToken?: string(name='ClientToken'),
  DBInstanceId: string(name='DBInstanceId'),
  accountName: string(name='AccountName'),
}

model DeleteHostAccountResponse = {
  requestId: string(name='RequestId'),
}

async function deleteHostAccountWithOptions(request: DeleteHostAccountRequest, runtime: Util.RuntimeOptions): DeleteHostAccountResponse {
  Util.validateModel(request);
  return doRequest('DeleteHostAccount', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function deleteHostAccount(request: DeleteHostAccountRequest): DeleteHostAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHostAccountWithOptions(request, runtime);
}

model DescribeHostAccountsRequest = {
  clientToken?: string(name='ClientToken'),
  DBInstanceId: string(name='DBInstanceId'),
}

model DescribeHostAccountsResponse = {
  requestId: string(name='RequestId'),
  accounts: {
    accounts: [
      {
        accountName: string(name='AccountName'),
        accountType: string(name='AccountType'),
        accountDescription: string(name='AccountDescription'),
        accountStatus: string(name='AccountStatus'),
        DBInstanceId: string(name='DBInstanceId'),
      }
    ](name='Accounts'),
  }(name='Accounts'),
}

async function describeHostAccountsWithOptions(request: DescribeHostAccountsRequest, runtime: Util.RuntimeOptions): DescribeHostAccountsResponse {
  Util.validateModel(request);
  return doRequest('DescribeHostAccounts', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeHostAccounts(request: DescribeHostAccountsRequest): DescribeHostAccountsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHostAccountsWithOptions(request, runtime);
}

model ResetHostAccountPasswordRequest = {
  clientToken?: string(name='ClientToken'),
  DBInstanceId: string(name='DBInstanceId'),
  accountName: string(name='AccountName'),
  accountPassword: string(name='AccountPassword'),
}

model ResetHostAccountPasswordResponse = {
  requestId: string(name='RequestId'),
}

async function resetHostAccountPasswordWithOptions(request: ResetHostAccountPasswordRequest, runtime: Util.RuntimeOptions): ResetHostAccountPasswordResponse {
  Util.validateModel(request);
  return doRequest('ResetHostAccountPassword', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function resetHostAccountPassword(request: ResetHostAccountPasswordRequest): ResetHostAccountPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetHostAccountPasswordWithOptions(request, runtime);
}

model CreateHostAccountRequest = {
  clientToken?: string(name='ClientToken'),
  DBInstanceId: string(name='DBInstanceId'),
  accountName: string(name='AccountName'),
  accountType?: string(name='AccountType'),
  accountPassword: string(name='AccountPassword'),
  accountDescription?: string(name='AccountDescription'),
}

model CreateHostAccountResponse = {
  requestId: string(name='RequestId'),
}

async function createHostAccountWithOptions(request: CreateHostAccountRequest, runtime: Util.RuntimeOptions): CreateHostAccountResponse {
  Util.validateModel(request);
  return doRequest('CreateHostAccount', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function createHostAccount(request: CreateHostAccountRequest): CreateHostAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHostAccountWithOptions(request, runtime);
}

model DescribeDedicatedHostImageCategoriesRequest = {
  regionId: string(name='RegionId'),
  hostGroup: string(name='HostGroup'),
}

model DescribeDedicatedHostImageCategoriesResponse = {
  requestId: string(name='RequestId'),
  images: {
    images: [
      {
        imageName: string(name='ImageName'),
        imageCode: string(name='ImageCode'),
      }
    ](name='Images'),
  }(name='Images'),
}

async function describeDedicatedHostImageCategoriesWithOptions(request: DescribeDedicatedHostImageCategoriesRequest, runtime: Util.RuntimeOptions): DescribeDedicatedHostImageCategoriesResponse {
  Util.validateModel(request);
  return doRequest('DescribeDedicatedHostImageCategories', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeDedicatedHostImageCategories(request: DescribeDedicatedHostImageCategoriesRequest): DescribeDedicatedHostImageCategoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDedicatedHostImageCategoriesWithOptions(request, runtime);
}

model DescribeCrossBackupMetaListRequest = {
  backupSetId: string(name='BackupSetId'),
  getDbName?: string(name='GetDbName'),
  pattern?: string(name='Pattern'),
  pageSize?: string(name='PageSize'),
  pageIndex?: string(name='PageIndex'),
  region?: string(name='Region'),
}

model DescribeCrossBackupMetaListResponse = {
  requestId: string(name='RequestId'),
  DBInstanceName: string(name='DBInstanceName'),
  pageNumber: integer(name='PageNumber'),
  pageRecordCount: integer(name='PageRecordCount'),
  totalRecordCount: integer(name='TotalRecordCount'),
  totalPageCount: integer(name='TotalPageCount'),
  items: {
    meta: [
      {
        database: string(name='Database'),
        tables: string(name='Tables'),
        size: string(name='Size'),
      }
    ](name='Meta'),
  }(name='Items'),
}

async function describeCrossBackupMetaListWithOptions(request: DescribeCrossBackupMetaListRequest, runtime: Util.RuntimeOptions): DescribeCrossBackupMetaListResponse {
  Util.validateModel(request);
  return doRequest('DescribeCrossBackupMetaList', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeCrossBackupMetaList(request: DescribeCrossBackupMetaListRequest): DescribeCrossBackupMetaListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCrossBackupMetaListWithOptions(request, runtime);
}

model RestoreDdrTableRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  restoreType: string(name='RestoreType'),
  backupId?: string(name='BackupId'),
  restoreTime?: string(name='RestoreTime'),
  sourceRegion?: string(name='SourceRegion'),
  sourceDBInstanceName?: string(name='SourceDBInstanceName'),
  tableMeta?: string(name='TableMeta'),
}

model RestoreDdrTableResponse = {
  requestId: string(name='RequestId'),
}

async function restoreDdrTableWithOptions(request: RestoreDdrTableRequest, runtime: Util.RuntimeOptions): RestoreDdrTableResponse {
  Util.validateModel(request);
  return doRequest('RestoreDdrTable', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function restoreDdrTable(request: RestoreDdrTableRequest): RestoreDdrTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return restoreDdrTableWithOptions(request, runtime);
}

model ModifyDBProxyEndpointAddressRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  DBProxyEndpointId: string(name='DBProxyEndpointId'),
  DBProxyNewConnectString?: string(name='DBProxyNewConnectString'),
  DBProxyNewConnectStringPort?: string(name='DBProxyNewConnectStringPort'),
  DBProxyConnectStringNetType?: string(name='DBProxyConnectStringNetType'),
}

model ModifyDBProxyEndpointAddressResponse = {
  requestId: string(name='RequestId'),
}

async function modifyDBProxyEndpointAddressWithOptions(request: ModifyDBProxyEndpointAddressRequest, runtime: Util.RuntimeOptions): ModifyDBProxyEndpointAddressResponse {
  Util.validateModel(request);
  return doRequest('ModifyDBProxyEndpointAddress', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifyDBProxyEndpointAddress(request: ModifyDBProxyEndpointAddressRequest): ModifyDBProxyEndpointAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBProxyEndpointAddressWithOptions(request, runtime);
}

model TerminateMigrateTaskRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  migrateTaskId: string(name='MigrateTaskId'),
}

model TerminateMigrateTaskResponse = {
  requestId: string(name='RequestId'),
}

async function terminateMigrateTaskWithOptions(request: TerminateMigrateTaskRequest, runtime: Util.RuntimeOptions): TerminateMigrateTaskResponse {
  Util.validateModel(request);
  return doRequest('TerminateMigrateTask', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function terminateMigrateTask(request: TerminateMigrateTaskRequest): TerminateMigrateTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return terminateMigrateTaskWithOptions(request, runtime);
}

model DescribeLocalAvailableRecoveryTimeRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  region?: string(name='Region'),
}

model DescribeLocalAvailableRecoveryTimeResponse = {
  requestId: string(name='RequestId'),
  DBInstanceId: string(name='DBInstanceId'),
  recoveryBeginTime: string(name='RecoveryBeginTime'),
  recoveryEndTime: string(name='RecoveryEndTime'),
}

async function describeLocalAvailableRecoveryTimeWithOptions(request: DescribeLocalAvailableRecoveryTimeRequest, runtime: Util.RuntimeOptions): DescribeLocalAvailableRecoveryTimeResponse {
  Util.validateModel(request);
  return doRequest('DescribeLocalAvailableRecoveryTime', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeLocalAvailableRecoveryTime(request: DescribeLocalAvailableRecoveryTimeRequest): DescribeLocalAvailableRecoveryTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLocalAvailableRecoveryTimeWithOptions(request, runtime);
}

model DescribeAvailableZonesRequest = {
  regionId: string(name='RegionId'),
  engine: string(name='Engine'),
  zoneId?: string(name='ZoneId'),
  engineVersion?: string(name='EngineVersion'),
  instanceChargeType?: string(name='InstanceChargeType'),
  commodityCode?: string(name='CommodityCode'),
  dispenseMode?: string(name='DispenseMode'),
}

model DescribeAvailableZonesResponse = {
  requestId: string(name='RequestId'),
  availableZones: [
    {
      regionId: string(name='RegionId'),
      zoneId: string(name='ZoneId'),
      networkTypes: string(name='NetworkTypes'),
      supportedEngines: [
        {
          engine: string(name='Engine'),
          supportedEngineVersions: [
            {
              version: string(name='Version'),
              supportedCategorys: [
                {
                  category: string(name='Category'),
                  supportedStorageTypes: [
                    {
                      storageType: string(name='StorageType'),
                    }
                  ](name='SupportedStorageTypes'),
                }
              ](name='SupportedCategorys'),
            }
          ](name='SupportedEngineVersions'),
        }
      ](name='SupportedEngines'),
    }
  ](name='AvailableZones'),
}

async function describeAvailableZonesWithOptions(request: DescribeAvailableZonesRequest, runtime: Util.RuntimeOptions): DescribeAvailableZonesResponse {
  Util.validateModel(request);
  return doRequest('DescribeAvailableZones', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeAvailableZones(request: DescribeAvailableZonesRequest): DescribeAvailableZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAvailableZonesWithOptions(request, runtime);
}

model DescribeAvailableClassesRequest = {
  regionId: string(name='RegionId'),
  zoneId: string(name='ZoneId'),
  instanceChargeType?: string(name='InstanceChargeType'),
  engine: string(name='Engine'),
  engineVersion: string(name='EngineVersion'),
  DBInstanceId?: string(name='DBInstanceId'),
  orderType?: string(name='OrderType'),
  DBInstanceStorageType: string(name='DBInstanceStorageType'),
  category: string(name='Category'),
  commodityCode?: string(name='CommodityCode'),
  dispenseMode?: string(name='DispenseMode'),
}

model DescribeAvailableClassesResponse = {
  requestId: string(name='RequestId'),
  DBInstanceClasses: [
    {
      DBInstanceClass: string(name='DBInstanceClass'),
      storageRange: string(name='StorageRange'),
      DBInstanceStorageRange: {
        maxValue: integer(name='MaxValue'),
        minValue: integer(name='MinValue'),
        step: integer(name='Step'),
      }(name='DBInstanceStorageRange'),
    }
  ](name='DBInstanceClasses'),
}

async function describeAvailableClassesWithOptions(request: DescribeAvailableClassesRequest, runtime: Util.RuntimeOptions): DescribeAvailableClassesResponse {
  Util.validateModel(request);
  return doRequest('DescribeAvailableClasses', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeAvailableClasses(request: DescribeAvailableClassesRequest): DescribeAvailableClassesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAvailableClassesWithOptions(request, runtime);
}

model CreateDedicatedHostAccountRequest = {
  dedicatedHostId: string(name='DedicatedHostId'),
  accountName: string(name='AccountName'),
  accountPassword: string(name='AccountPassword'),
  regionId?: string(name='RegionId'),
}

model CreateDedicatedHostAccountResponse = {
  requestId: string(name='RequestId'),
}

async function createDedicatedHostAccountWithOptions(request: CreateDedicatedHostAccountRequest, runtime: Util.RuntimeOptions): CreateDedicatedHostAccountResponse {
  Util.validateModel(request);
  return doRequest('CreateDedicatedHostAccount', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function createDedicatedHostAccount(request: CreateDedicatedHostAccountRequest): CreateDedicatedHostAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDedicatedHostAccountWithOptions(request, runtime);
}

model DeleteDedicatedHostAccountRequest = {
  dedicatedHostId: string(name='DedicatedHostId'),
  accountName: string(name='AccountName'),
  regionId?: string(name='RegionId'),
}

model DeleteDedicatedHostAccountResponse = {
  requestId: string(name='RequestId'),
}

async function deleteDedicatedHostAccountWithOptions(request: DeleteDedicatedHostAccountRequest, runtime: Util.RuntimeOptions): DeleteDedicatedHostAccountResponse {
  Util.validateModel(request);
  return doRequest('DeleteDedicatedHostAccount', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function deleteDedicatedHostAccount(request: DeleteDedicatedHostAccountRequest): DeleteDedicatedHostAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDedicatedHostAccountWithOptions(request, runtime);
}

model ModifyDedicatedHostAccountRequest = {
  dedicatedHostId: string(name='DedicatedHostId'),
  accountName: string(name='AccountName'),
  accountPassword: string(name='AccountPassword'),
  regionId?: string(name='RegionId'),
}

model ModifyDedicatedHostAccountResponse = {
  requestId: string(name='RequestId'),
}

async function modifyDedicatedHostAccountWithOptions(request: ModifyDedicatedHostAccountRequest, runtime: Util.RuntimeOptions): ModifyDedicatedHostAccountResponse {
  Util.validateModel(request);
  return doRequest('ModifyDedicatedHostAccount', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifyDedicatedHostAccount(request: ModifyDedicatedHostAccountRequest): ModifyDedicatedHostAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDedicatedHostAccountWithOptions(request, runtime);
}

model TransformDBInstancePayTypeRequest = {
  clientToken?: string(name='ClientToken'),
  DBInstanceId: string(name='DBInstanceId'),
  usedTime?: integer(name='UsedTime'),
  payType: string(name='PayType'),
  period?: string(name='Period'),
  businessInfo?: string(name='BusinessInfo'),
}

model TransformDBInstancePayTypeResponse = {
  requestId: string(name='RequestId'),
  orderId: long(name='OrderId'),
  chargeType: string(name='ChargeType'),
  expiredTime: string(name='ExpiredTime'),
  DBInstanceId: string(name='DBInstanceId'),
}

async function transformDBInstancePayTypeWithOptions(request: TransformDBInstancePayTypeRequest, runtime: Util.RuntimeOptions): TransformDBInstancePayTypeResponse {
  Util.validateModel(request);
  return doRequest('TransformDBInstancePayType', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function transformDBInstancePayType(request: TransformDBInstancePayTypeRequest): TransformDBInstancePayTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return transformDBInstancePayTypeWithOptions(request, runtime);
}

model CreateDedicatedHostUserRequest = {
  dedicatedHostName: string(name='DedicatedHostName'),
  userName: string(name='UserName'),
  userPassword: string(name='UserPassword'),
  regionId?: string(name='RegionId'),
}

model CreateDedicatedHostUserResponse = {
  requestId: string(name='RequestId'),
}

async function createDedicatedHostUserWithOptions(request: CreateDedicatedHostUserRequest, runtime: Util.RuntimeOptions): CreateDedicatedHostUserResponse {
  Util.validateModel(request);
  return doRequest('CreateDedicatedHostUser', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function createDedicatedHostUser(request: CreateDedicatedHostUserRequest): CreateDedicatedHostUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDedicatedHostUserWithOptions(request, runtime);
}

model ModifyDedicatedHostUserRequest = {
  dedicatedHostName: string(name='DedicatedHostName'),
  userName: string(name='UserName'),
  oldPassword: string(name='OldPassword'),
  newPassword: string(name='NewPassword'),
  regionId?: string(name='RegionId'),
}

model ModifyDedicatedHostUserResponse = {
  requestId: string(name='RequestId'),
}

async function modifyDedicatedHostUserWithOptions(request: ModifyDedicatedHostUserRequest, runtime: Util.RuntimeOptions): ModifyDedicatedHostUserResponse {
  Util.validateModel(request);
  return doRequest('ModifyDedicatedHostUser', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifyDedicatedHostUser(request: ModifyDedicatedHostUserRequest): ModifyDedicatedHostUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDedicatedHostUserWithOptions(request, runtime);
}

model DropDedicatedHostUserRequest = {
  dedicatedHostName: string(name='DedicatedHostName'),
  userName: string(name='UserName'),
  regionId?: string(name='RegionId'),
}

model DropDedicatedHostUserResponse = {
  requestId: string(name='RequestId'),
}

async function dropDedicatedHostUserWithOptions(request: DropDedicatedHostUserRequest, runtime: Util.RuntimeOptions): DropDedicatedHostUserResponse {
  Util.validateModel(request);
  return doRequest('DropDedicatedHostUser', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function dropDedicatedHostUser(request: DropDedicatedHostUserRequest): DropDedicatedHostUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return dropDedicatedHostUserWithOptions(request, runtime);
}

model UpgradeDBProxyInstanceKernelVersionRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  upgradeTime?: string(name='UpgradeTime'),
  switchTime?: string(name='SwitchTime'),
}

model UpgradeDBProxyInstanceKernelVersionResponse = {
  requestId: string(name='RequestId'),
  DBInstanceName: string(name='DBInstanceName'),
  taskId: string(name='TaskId'),
  targetMinorVersion: string(name='TargetMinorVersion'),
}

async function upgradeDBProxyInstanceKernelVersionWithOptions(request: UpgradeDBProxyInstanceKernelVersionRequest, runtime: Util.RuntimeOptions): UpgradeDBProxyInstanceKernelVersionResponse {
  Util.validateModel(request);
  return doRequest('UpgradeDBProxyInstanceKernelVersion', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function upgradeDBProxyInstanceKernelVersion(request: UpgradeDBProxyInstanceKernelVersionRequest): UpgradeDBProxyInstanceKernelVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeDBProxyInstanceKernelVersionWithOptions(request, runtime);
}

model StopDBInstanceRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  regionId: string(name='RegionId'),
}

model StopDBInstanceResponse = {
  requestId: string(name='RequestId'),
}

async function stopDBInstanceWithOptions(request: StopDBInstanceRequest, runtime: Util.RuntimeOptions): StopDBInstanceResponse {
  Util.validateModel(request);
  return doRequest('StopDBInstance', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function stopDBInstance(request: StopDBInstanceRequest): StopDBInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopDBInstanceWithOptions(request, runtime);
}

model StartDBInstanceRequest = {
  regionId?: string(name='RegionId'),
  dedicatedHostGroupId: string(name='DedicatedHostGroupId'),
  DBInstanceId: string(name='DBInstanceId'),
  targetDedicatedHostIdForMaster?: string(name='TargetDedicatedHostIdForMaster'),
  targetDedicatedHostIdForSlave?: string(name='TargetDedicatedHostIdForSlave'),
  targetDedicatedHostIdForLog?: string(name='TargetDedicatedHostIdForLog'),
  effectiveTime?: string(name='EffectiveTime'),
  specifiedTime?: string(name='SpecifiedTime'),
  targetDBInstanceClass?: string(name='TargetDBInstanceClass'),
  engineVersion?: string(name='EngineVersion'),
  DBInstanceTransType?: integer(name='DBInstanceTransType'),
  storage?: integer(name='Storage'),
  vSwitchId?: string(name='VSwitchId'),
  zoneId?: string(name='ZoneId'),
}

model StartDBInstanceResponse = {
  requestId: string(name='RequestId'),
  taskId: integer(name='TaskId'),
  migrationId: integer(name='MigrationId'),
}

async function startDBInstanceWithOptions(request: StartDBInstanceRequest, runtime: Util.RuntimeOptions): StartDBInstanceResponse {
  Util.validateModel(request);
  return doRequest('StartDBInstance', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function startDBInstance(request: StartDBInstanceRequest): StartDBInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return startDBInstanceWithOptions(request, runtime);
}

model DescribeSignedEventActionsRequest = {
  regionId: string(name='RegionId'),
  beginEventId?: integer(name='BeginEventId'),
  pageSize?: integer(name='PageSize'),
}

model DescribeSignedEventActionsResponse = {
  requestId: string(name='RequestId'),
  nextPageEventId: integer(name='NextPageEventId'),
  pageRecordCount: integer(name='PageRecordCount'),
  fromBegin: boolean(name='FromBegin'),
  toEnd: boolean(name='ToEnd'),
  eventItems: {
    eventItems: [
      {
        eventId: integer(name='EventId'),
        eventContent: string(name='EventContent'),
        eventSig: string(name='EventSig'),
        eventRcpt: string(name='EventRcpt'),
      }
    ](name='EventItems'),
  }(name='EventItems'),
}

async function describeSignedEventActionsWithOptions(request: DescribeSignedEventActionsRequest, runtime: Util.RuntimeOptions): DescribeSignedEventActionsResponse {
  Util.validateModel(request);
  return doRequest('DescribeSignedEventActions', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeSignedEventActions(request: DescribeSignedEventActionsRequest): DescribeSignedEventActionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSignedEventActionsWithOptions(request, runtime);
}

model SignEventActionRequest = {
  regionId: string(name='RegionId'),
  eventId: integer(name='EventId'),
  eventSig: string(name='EventSig'),
}

model SignEventActionResponse = {
  requestId: string(name='RequestId'),
  eventId: string(name='EventId'),
  eventRcpt: string(name='EventRcpt'),
}

async function signEventActionWithOptions(request: SignEventActionRequest, runtime: Util.RuntimeOptions): SignEventActionResponse {
  Util.validateModel(request);
  return doRequest('SignEventAction', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function signEventAction(request: SignEventActionRequest): SignEventActionResponse {
  var runtime = new Util.RuntimeOptions{};
  return signEventActionWithOptions(request, runtime);
}

model DescribeNextEventForSignRequest = {
  regionId: string(name='RegionId'),
}

model DescribeNextEventForSignResponse = {
  requestId: string(name='RequestId'),
  eventItems: {
    eventItems: [
      {
        eventId: integer(name='EventId'),
        eventContent: string(name='EventContent'),
      }
    ](name='EventItems'),
  }(name='EventItems'),
}

async function describeNextEventForSignWithOptions(request: DescribeNextEventForSignRequest, runtime: Util.RuntimeOptions): DescribeNextEventForSignResponse {
  Util.validateModel(request);
  return doRequest('DescribeNextEventForSign', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeNextEventForSign(request: DescribeNextEventForSignRequest): DescribeNextEventForSignResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNextEventForSignWithOptions(request, runtime);
}

model ModifyActionEventVerifyPolicyRequest = {
  regionId: string(name='RegionId'),
  userPublicKey: string(name='UserPublicKey'),
}

model ModifyActionEventVerifyPolicyResponse = {
  requestId: string(name='RequestId'),
  regionId: string(name='RegionId'),
  serverPublicKey: string(name='ServerPublicKey'),
}

async function modifyActionEventVerifyPolicyWithOptions(request: ModifyActionEventVerifyPolicyRequest, runtime: Util.RuntimeOptions): ModifyActionEventVerifyPolicyResponse {
  Util.validateModel(request);
  return doRequest('ModifyActionEventVerifyPolicy', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifyActionEventVerifyPolicy(request: ModifyActionEventVerifyPolicyRequest): ModifyActionEventVerifyPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyActionEventVerifyPolicyWithOptions(request, runtime);
}

model DescribeDBInstancesOverviewRequest = {
  clientToken?: string(name='ClientToken'),
  proxyId?: string(name='ProxyId'),
  engine?: string(name='Engine'),
  zoneId?: string(name='ZoneId'),
  expired?: string(name='Expired'),
  DBInstanceId?: string(name='DBInstanceId'),
  regionId: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeDBInstancesOverviewResponse = {
  requestId: string(name='RequestId'),
  regions: {
    regionModel: [
      {
        region: string(name='Region'),
        engineCount: string(name='EngineCount'),
        totalCount: integer(name='TotalCount'),
        typeModels: {
          typeModel: [
            {
              instanceDateType: string(name='InstanceDateType'),
              count: integer(name='Count'),
              instanceModels: {
                instanceModel: [
                  {
                    DBInstanceId: string(name='DBInstanceId'),
                    region: string(name='Region'),
                    zoneId: string(name='ZoneId'),
                    engine: string(name='Engine'),
                    payType: string(name='PayType'),
                    createdTime: string(name='CreatedTime'),
                    expireTime: string(name='ExpireTime'),
                    lockMode: string(name='LockMode'),
                    DBInstanceStatus: string(name='DBInstanceStatus'),
                  }
                ](name='InstanceModel'),
              }(name='InstanceModels'),
            }
          ](name='TypeModel'),
        }(name='TypeModels'),
      }
    ](name='RegionModel'),
  }(name='Regions'),
}

async function describeDBInstancesOverviewWithOptions(request: DescribeDBInstancesOverviewRequest, runtime: Util.RuntimeOptions): DescribeDBInstancesOverviewResponse {
  Util.validateModel(request);
  return doRequest('DescribeDBInstancesOverview', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeDBInstancesOverview(request: DescribeDBInstancesOverviewRequest): DescribeDBInstancesOverviewResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstancesOverviewWithOptions(request, runtime);
}

model DescribeMigrateTaskByIdRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  migrateTaskId: string(name='MigrateTaskId'),
}

model DescribeMigrateTaskByIdResponse = {
  requestId: string(name='RequestId'),
  DBInstanceName: string(name='DBInstanceName'),
  DBName: string(name='DBName'),
  migrateTaskId: string(name='MigrateTaskId'),
  createTime: string(name='CreateTime'),
  endTime: string(name='EndTime'),
  backupMode: string(name='BackupMode'),
  status: string(name='Status'),
  isDBReplaced: string(name='IsDBReplaced'),
  description: string(name='Description'),
}

async function describeMigrateTaskByIdWithOptions(request: DescribeMigrateTaskByIdRequest, runtime: Util.RuntimeOptions): DescribeMigrateTaskByIdResponse {
  Util.validateModel(request);
  return doRequest('DescribeMigrateTaskById', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeMigrateTaskById(request: DescribeMigrateTaskByIdRequest): DescribeMigrateTaskByIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMigrateTaskByIdWithOptions(request, runtime);
}

model DeleteBackupFileRequest = {
  regionId?: string(name='RegionId'),
  DBInstanceId: string(name='DBInstanceId'),
  backupId?: string(name='BackupId'),
  DBName?: string(name='DBName'),
  backupTime?: string(name='BackupTime'),
}

model DeleteBackupFileResponse = {
  requestId: string(name='RequestId'),
  deletedBaksetIds: {
    deletedBaksetIds: [ integer ](name='DeletedBaksetIds'),
  }(name='DeletedBaksetIds'),
}

async function deleteBackupFileWithOptions(request: DeleteBackupFileRequest, runtime: Util.RuntimeOptions): DeleteBackupFileResponse {
  Util.validateModel(request);
  return doRequest('DeleteBackupFile', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function deleteBackupFile(request: DeleteBackupFileRequest): DeleteBackupFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBackupFileWithOptions(request, runtime);
}

model DescribeDetachedBackupsRequest = {
  DBInstanceId?: string(name='DBInstanceId'),
  backupId?: string(name='BackupId'),
  backupStatus?: string(name='BackupStatus'),
  backupMode?: string(name='BackupMode'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
  pageSize?: integer(name='PageSize'),
  pageNumber?: integer(name='PageNumber'),
  region: string(name='Region'),
}

model DescribeDetachedBackupsResponse = {
  requestId: string(name='RequestId'),
  totalRecordCount: string(name='TotalRecordCount'),
  pageNumber: string(name='PageNumber'),
  pageRecordCount: string(name='PageRecordCount'),
  totalBackupSize: long(name='TotalBackupSize'),
  items: {
    backup: [
      {
        backupId: string(name='BackupId'),
        DBInstanceId: string(name='DBInstanceId'),
        backupStatus: string(name='BackupStatus'),
        backupStartTime: string(name='BackupStartTime'),
        backupEndTime: string(name='BackupEndTime'),
        backupType: string(name='BackupType'),
        backupMode: string(name='BackupMode'),
        backupMethod: string(name='BackupMethod'),
        backupDownloadURL: string(name='BackupDownloadURL'),
        backupIntranetDownloadURL: string(name='BackupIntranetDownloadURL'),
        backupLocation: string(name='BackupLocation'),
        backupExtractionStatus: string(name='BackupExtractionStatus'),
        backupScale: string(name='BackupScale'),
        backupDBNames: string(name='BackupDBNames'),
        totalBackupSize: long(name='TotalBackupSize'),
        backupSize: long(name='BackupSize'),
        hostInstanceID: string(name='HostInstanceID'),
        storeStatus: string(name='StoreStatus'),
        metaStatus: string(name='MetaStatus'),
        slaveStatus: string(name='SlaveStatus'),
        consistentTime: long(name='ConsistentTime'),
        isAvail: integer(name='IsAvail'),
      }
    ](name='Backup'),
  }(name='Items'),
}

async function describeDetachedBackupsWithOptions(request: DescribeDetachedBackupsRequest, runtime: Util.RuntimeOptions): DescribeDetachedBackupsResponse {
  Util.validateModel(request);
  return doRequest('DescribeDetachedBackups', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeDetachedBackups(request: DescribeDetachedBackupsRequest): DescribeDetachedBackupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDetachedBackupsWithOptions(request, runtime);
}

model EvaluateDedicatedHostInstanceResourceRequest = {
  regionId: string(name='RegionId'),
  dedicatedHostGroupId: string(name='DedicatedHostGroupId'),
  diskType?: string(name='DiskType'),
  diskSize?: string(name='DiskSize'),
  instanceClassNames: string(name='InstanceClassNames'),
  engine: string(name='Engine'),
  engineVersion: string(name='EngineVersion'),
}

model EvaluateDedicatedHostInstanceResourceResponse = {
  requestId: string(name='RequestId'),
  DBInstanceClass: string(name='DBInstanceClass'),
  available: integer(name='Available'),
}

async function evaluateDedicatedHostInstanceResourceWithOptions(request: EvaluateDedicatedHostInstanceResourceRequest, runtime: Util.RuntimeOptions): EvaluateDedicatedHostInstanceResourceResponse {
  Util.validateModel(request);
  return doRequest('EvaluateDedicatedHostInstanceResource', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function evaluateDedicatedHostInstanceResource(request: EvaluateDedicatedHostInstanceResourceRequest): EvaluateDedicatedHostInstanceResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return evaluateDedicatedHostInstanceResourceWithOptions(request, runtime);
}

model DescribeAvailableDedicatedHostClassesRequest = {
  regionId: string(name='RegionId'),
  zoneId: string(name='ZoneId'),
  storageType?: string(name='StorageType'),
}

model DescribeAvailableDedicatedHostClassesResponse = {
  requestId: string(name='RequestId'),
  hostClasses: {
    hostClasses: [
      {
        hostClassName: string(name='HostClassName'),
        description: string(name='Description'),
      }
    ](name='HostClasses'),
  }(name='HostClasses'),
}

async function describeAvailableDedicatedHostClassesWithOptions(request: DescribeAvailableDedicatedHostClassesRequest, runtime: Util.RuntimeOptions): DescribeAvailableDedicatedHostClassesResponse {
  Util.validateModel(request);
  return doRequest('DescribeAvailableDedicatedHostClasses', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeAvailableDedicatedHostClasses(request: DescribeAvailableDedicatedHostClassesRequest): DescribeAvailableDedicatedHostClassesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAvailableDedicatedHostClassesWithOptions(request, runtime);
}

model DescribeAvailableDedicatedHostZonesRequest = {
  regionId: string(name='RegionId'),
}

model DescribeAvailableDedicatedHostZonesResponse = {
  requestId: string(name='RequestId'),
  zones: {
    dedicatedHostZones: [
      {
        zoneId: string(name='ZoneId'),
        description: string(name='Description'),
      }
    ](name='DedicatedHostZones'),
  }(name='Zones'),
}

async function describeAvailableDedicatedHostZonesWithOptions(request: DescribeAvailableDedicatedHostZonesRequest, runtime: Util.RuntimeOptions): DescribeAvailableDedicatedHostZonesResponse {
  Util.validateModel(request);
  return doRequest('DescribeAvailableDedicatedHostZones', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeAvailableDedicatedHostZones(request: DescribeAvailableDedicatedHostZonesRequest): DescribeAvailableDedicatedHostZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAvailableDedicatedHostZonesWithOptions(request, runtime);
}

model ReleaseInstanceConnectionRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  currentConnectionString: string(name='CurrentConnectionString'),
  instanceNetworkType: string(name='InstanceNetworkType'),
}

model ReleaseInstanceConnectionResponse = {
  requestId: string(name='RequestId'),
}

async function releaseInstanceConnectionWithOptions(request: ReleaseInstanceConnectionRequest, runtime: Util.RuntimeOptions): ReleaseInstanceConnectionResponse {
  Util.validateModel(request);
  return doRequest('ReleaseInstanceConnection', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function releaseInstanceConnection(request: ReleaseInstanceConnectionRequest): ReleaseInstanceConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return releaseInstanceConnectionWithOptions(request, runtime);
}

model UnlockAccountRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  accountName: string(name='AccountName'),
}

model UnlockAccountResponse = {
  requestId: string(name='RequestId'),
}

async function unlockAccountWithOptions(request: UnlockAccountRequest, runtime: Util.RuntimeOptions): UnlockAccountResponse {
  Util.validateModel(request);
  return doRequest('UnlockAccount', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function unlockAccount(request: UnlockAccountRequest): UnlockAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return unlockAccountWithOptions(request, runtime);
}

model LockAccountRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  accountName: string(name='AccountName'),
}

model LockAccountResponse = {
  requestId: string(name='RequestId'),
}

async function lockAccountWithOptions(request: LockAccountRequest, runtime: Util.RuntimeOptions): LockAccountResponse {
  Util.validateModel(request);
  return doRequest('LockAccount', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function lockAccount(request: LockAccountRequest): LockAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return lockAccountWithOptions(request, runtime);
}

model ListTagResourcesRequest = {
  regionId: string(name='RegionId'),
  resourceType: string(name='ResourceType'),
  nextToken?: string(name='NextToken'),
  resourceId?: [ string ](name='ResourceId'),
  tag?: [
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model ListTagResourcesResponse = {
  requestId: string(name='RequestId'),
  nextToken: string(name='NextToken'),
  tagResources: {
    tagResource: [
      {
        tagKey: string(name='TagKey'),
        tagValue: string(name='TagValue'),
        resourceType: string(name='ResourceType'),
        resourceId: string(name='ResourceId'),
      }
    ](name='TagResource'),
  }(name='TagResources'),
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  return doRequest('ListTagResources', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model TagResourcesRequest = {
  regionId: string(name='RegionId'),
  resourceType: string(name='ResourceType'),
  resourceId: [ string ](name='ResourceId'),
  tag?: [
    {
      key: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model TagResourcesResponse = {
  requestId: string(name='RequestId'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  return doRequest('TagResources', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model UntagResourcesRequest = {
  regionId: string(name='RegionId'),
  resourceType: string(name='ResourceType'),
  all?: boolean(name='All'),
  resourceId: [ string ](name='ResourceId'),
  tagKey?: [ string ](name='TagKey'),
}

model UntagResourcesResponse = {
  requestId: string(name='RequestId'),
}

async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  return doRequest('UntagResources', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model DescribeDedicatedHostGroupsRequest = {
  regionId: string(name='RegionId'),
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
  imageCategory?: string(name='ImageCategory'),
}

model DescribeDedicatedHostGroupsResponse = {
  requestId: string(name='RequestId'),
  dedicatedHostGroups: {
    dedicatedHostGroups: [
      {
        dedicatedHostGroupId: string(name='DedicatedHostGroupId'),
        dedicatedHostGroupDesc: string(name='DedicatedHostGroupDesc'),
        cpuAllocationRatio: integer(name='CpuAllocationRatio'),
        memAllocationRatio: integer(name='MemAllocationRatio'),
        diskAllocationRatio: integer(name='DiskAllocationRatio'),
        allocationPolicy: string(name='AllocationPolicy'),
        hostReplacePolicy: string(name='HostReplacePolicy'),
        createTime: string(name='CreateTime'),
        VPCId: string(name='VPCId'),
        hostNumber: integer(name='HostNumber'),
        instanceNumber: integer(name='InstanceNumber'),
        engine: string(name='Engine'),
        text: string(name='Text'),
        dedicatedHostCountGroupByHostType: map[string]any(name='DedicatedHostCountGroupByHostType'),
        bastionInstanceId: string(name='BastionInstanceId'),
        openPermission: string(name='OpenPermission'),
        memUtility: float(name='MemUtility'),
        memUsedAmount: float(name='MemUsedAmount'),
        diskUtility: float(name='DiskUtility'),
        diskUsedAmount: float(name='DiskUsedAmount'),
        cpuAllocateRation: float(name='CpuAllocateRation'),
        cpuAllocatedAmount: float(name='CpuAllocatedAmount'),
        memAllocateRation: float(name='MemAllocateRation'),
        memAllocatedAmount: float(name='MemAllocatedAmount'),
        diskAllocateRation: float(name='DiskAllocateRation'),
        diskAllocatedAmount: float(name='DiskAllocatedAmount'),
        zoneIDList: {
          zoneIDList: [ string ](name='ZoneIDList', description='ZoneIDList'),
        }(name='ZoneIDList'),
      }
    ](name='DedicatedHostGroups'),
  }(name='DedicatedHostGroups'),
}

async function describeDedicatedHostGroupsWithOptions(request: DescribeDedicatedHostGroupsRequest, runtime: Util.RuntimeOptions): DescribeDedicatedHostGroupsResponse {
  Util.validateModel(request);
  return doRequest('DescribeDedicatedHostGroups', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeDedicatedHostGroups(request: DescribeDedicatedHostGroupsRequest): DescribeDedicatedHostGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDedicatedHostGroupsWithOptions(request, runtime);
}

model CreateDedicatedHostGroupRequest = {
  regionId: string(name='RegionId'),
  engine: string(name='Engine'),
  cpuAllocationRatio?: integer(name='CpuAllocationRatio'),
  memAllocationRatio?: integer(name='MemAllocationRatio'),
  diskAllocationRatio?: integer(name='DiskAllocationRatio'),
  allocationPolicy?: string(name='AllocationPolicy'),
  VPCId: string(name='VPCId'),
  hostReplacePolicy?: string(name='HostReplacePolicy'),
  clientToken: string(name='ClientToken'),
  openPermission?: integer(name='OpenPermission'),
}

model CreateDedicatedHostGroupResponse = {
  requestId: string(name='RequestId'),
  dedicatedHostGroupId: string(name='DedicatedHostGroupId'),
}

async function createDedicatedHostGroupWithOptions(request: CreateDedicatedHostGroupRequest, runtime: Util.RuntimeOptions): CreateDedicatedHostGroupResponse {
  Util.validateModel(request);
  return doRequest('CreateDedicatedHostGroup', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function createDedicatedHostGroup(request: CreateDedicatedHostGroupRequest): CreateDedicatedHostGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDedicatedHostGroupWithOptions(request, runtime);
}

model DeleteDedicatedHostGroupRequest = {
  dedicatedHostGroupId: string(name='DedicatedHostGroupId'),
  regionId?: string(name='RegionId'),
}

model DeleteDedicatedHostGroupResponse = {
  requestId: string(name='RequestId'),
}

async function deleteDedicatedHostGroupWithOptions(request: DeleteDedicatedHostGroupRequest, runtime: Util.RuntimeOptions): DeleteDedicatedHostGroupResponse {
  Util.validateModel(request);
  return doRequest('DeleteDedicatedHostGroup', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function deleteDedicatedHostGroup(request: DeleteDedicatedHostGroupRequest): DeleteDedicatedHostGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDedicatedHostGroupWithOptions(request, runtime);
}

model ModifyDedicatedHostGroupAttributeRequest = {
  regionId?: string(name='RegionId'),
  dedicatedHostGroupId: string(name='DedicatedHostGroupId'),
  dedicatedHostGroupDesc?: string(name='DedicatedHostGroupDesc'),
  cpuAllocationRatio?: integer(name='CpuAllocationRatio'),
  memAllocationRatio?: integer(name='MemAllocationRatio'),
  diskAllocationRatio?: integer(name='DiskAllocationRatio'),
  allocationPolicy?: string(name='AllocationPolicy'),
  hostReplacePolicy?: string(name='HostReplacePolicy'),
}

model ModifyDedicatedHostGroupAttributeResponse = {
  requestId: string(name='RequestId'),
}

async function modifyDedicatedHostGroupAttributeWithOptions(request: ModifyDedicatedHostGroupAttributeRequest, runtime: Util.RuntimeOptions): ModifyDedicatedHostGroupAttributeResponse {
  Util.validateModel(request);
  return doRequest('ModifyDedicatedHostGroupAttribute', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifyDedicatedHostGroupAttribute(request: ModifyDedicatedHostGroupAttributeRequest): ModifyDedicatedHostGroupAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDedicatedHostGroupAttributeWithOptions(request, runtime);
}

model RestartDedicatedHostRequest = {
  regionId?: string(name='RegionId'),
  dedicatedHostId: string(name='DedicatedHostId'),
  failoverMode: string(name='FailoverMode'),
}

model RestartDedicatedHostResponse = {
  requestId: string(name='RequestId'),
  taskId: integer(name='TaskId'),
  dedicatedHostId: string(name='DedicatedHostId'),
}

async function restartDedicatedHostWithOptions(request: RestartDedicatedHostRequest, runtime: Util.RuntimeOptions): RestartDedicatedHostResponse {
  Util.validateModel(request);
  return doRequest('RestartDedicatedHost', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function restartDedicatedHost(request: RestartDedicatedHostRequest): RestartDedicatedHostResponse {
  var runtime = new Util.RuntimeOptions{};
  return restartDedicatedHostWithOptions(request, runtime);
}

model ReplaceDedicatedHostRequest = {
  regionId?: string(name='RegionId'),
  dedicatedHostId: string(name='DedicatedHostId'),
  failoverMode: string(name='FailoverMode'),
}

model ReplaceDedicatedHostResponse = {
  requestId: string(name='RequestId'),
  taskId: integer(name='TaskId'),
  dedicatedHostId: string(name='DedicatedHostId'),
}

async function replaceDedicatedHostWithOptions(request: ReplaceDedicatedHostRequest, runtime: Util.RuntimeOptions): ReplaceDedicatedHostResponse {
  Util.validateModel(request);
  return doRequest('ReplaceDedicatedHost', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function replaceDedicatedHost(request: ReplaceDedicatedHostRequest): ReplaceDedicatedHostResponse {
  var runtime = new Util.RuntimeOptions{};
  return replaceDedicatedHostWithOptions(request, runtime);
}

model DescribeDedicatedHostsRequest = {
  regionId?: string(name='RegionId'),
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
  orderId?: long(name='OrderId'),
  hostType?: string(name='HostType'),
  hostStatus?: string(name='HostStatus'),
  allocationStatus?: string(name='AllocationStatus'),
  zoneId?: string(name='ZoneId'),
  dedicatedHostId?: string(name='DedicatedHostId'),
}

model DescribeDedicatedHostsResponse = {
  requestId: string(name='RequestId'),
  dedicatedHostGroupId: string(name='DedicatedHostGroupId'),
  dedicatedHosts: {
    dedicatedHosts: [
      {
        hostName: string(name='HostName'),
        hostStatus: string(name='HostStatus'),
        instanceNumber: string(name='InstanceNumber'),
        CPUAllocationRatio: string(name='CPUAllocationRatio'),
        memAllocationRatio: string(name='MemAllocationRatio'),
        diskAllocationRatio: string(name='DiskAllocationRatio'),
        VPCId: string(name='VPCId'),
        vSwitchId: string(name='VSwitchId'),
        zoneId: string(name='ZoneId'),
        IPAddress: string(name='IPAddress'),
        hostClass: string(name='HostClass'),
        createdTime: string(name='CreatedTime'),
        dedicatedHostId: string(name='DedicatedHostId'),
        allocationStatus: string(name='AllocationStatus'),
        endTime: string(name='EndTime'),
        hostType: string(name='HostType'),
        bastionInstanceId: string(name='BastionInstanceId'),
        openPermission: string(name='OpenPermission'),
        accountName: string(name='AccountName'),
        hostCPU: string(name='HostCPU'),
        hostMem: string(name='HostMem'),
        hostStorage: string(name='HostStorage'),
        cpuUsed: string(name='CpuUsed'),
        memoryUsed: string(name='MemoryUsed'),
        storageUsed: string(name='StorageUsed'),
        imageCategory: string(name='ImageCategory'),
        dedicatedHostGroupId: string(name='DedicatedHostGroupId'),
        engine: string(name='Engine'),
      }
    ](name='DedicatedHosts'),
  }(name='DedicatedHosts'),
}

async function describeDedicatedHostsWithOptions(request: DescribeDedicatedHostsRequest, runtime: Util.RuntimeOptions): DescribeDedicatedHostsResponse {
  Util.validateModel(request);
  return doRequest('DescribeDedicatedHosts', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeDedicatedHosts(request: DescribeDedicatedHostsRequest): DescribeDedicatedHostsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDedicatedHostsWithOptions(request, runtime);
}

model DescribeDedicatedHostAttributeRequest = {
  regionId?: string(name='RegionId'),
  dedicatedHostId: string(name='DedicatedHostId'),
  dedicatedHostGroupId: string(name='DedicatedHostGroupId'),
}

model DescribeDedicatedHostAttributeResponse = {
  requestId: string(name='RequestId'),
  dedicatedHostGroupId: string(name='DedicatedHostGroupId'),
  dedicatedHostId: string(name='DedicatedHostId'),
  regionId: string(name='RegionId'),
  zoneId: string(name='ZoneId'),
  VPCId: string(name='VPCId'),
  vSwitchId: string(name='VSwitchId'),
  IPAddress: string(name='IPAddress'),
  hostName: string(name='HostName'),
  hostStatus: string(name='HostStatus'),
  hostClass: string(name='HostClass'),
  hostCPU: integer(name='HostCPU'),
  hostMem: integer(name='HostMem'),
  hostStorage: integer(name='HostStorage'),
  CPUAllocationRatio: string(name='CPUAllocationRatio'),
  memAllocationRatio: string(name='MemAllocationRatio'),
  diskAllocationRatio: string(name='DiskAllocationRatio'),
  instanceNumber: integer(name='InstanceNumber'),
  instanceNumberMaster: integer(name='InstanceNumberMaster'),
  instanceNumberSlave: integer(name='InstanceNumberSlave'),
  instanceNumberROMaster: integer(name='InstanceNumberROMaster'),
  instanceNumberROSlave: integer(name='InstanceNumberROSlave'),
  createdTime: string(name='CreatedTime'),
  expiredTime: string(name='ExpiredTime'),
  autoRenew: string(name='AutoRenew'),
  allocationStatus: string(name='AllocationStatus'),
  cpuUsed: string(name='CpuUsed'),
  memoryUsed: string(name='MemoryUsed'),
  storageUsed: string(name='StorageUsed'),
  hostType: string(name='HostType'),
  accountName: string(name='AccountName'),
  openPermission: string(name='OpenPermission'),
  imageCategory: string(name='ImageCategory'),
}

async function describeDedicatedHostAttributeWithOptions(request: DescribeDedicatedHostAttributeRequest, runtime: Util.RuntimeOptions): DescribeDedicatedHostAttributeResponse {
  Util.validateModel(request);
  return doRequest('DescribeDedicatedHostAttribute', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeDedicatedHostAttribute(request: DescribeDedicatedHostAttributeRequest): DescribeDedicatedHostAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDedicatedHostAttributeWithOptions(request, runtime);
}

model ClearDedicatedHostRequest = {
  regionId?: string(name='RegionId'),
  dedicatedHostId: string(name='DedicatedHostId'),
  failoverMode: string(name='FailoverMode'),
}

model ClearDedicatedHostResponse = {
  requestId: string(name='RequestId'),
  taskId: string(name='TaskId'),
  dedicatedHostId: string(name='DedicatedHostId'),
}

async function clearDedicatedHostWithOptions(request: ClearDedicatedHostRequest, runtime: Util.RuntimeOptions): ClearDedicatedHostResponse {
  Util.validateModel(request);
  return doRequest('ClearDedicatedHost', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function clearDedicatedHost(request: ClearDedicatedHostRequest): ClearDedicatedHostResponse {
  var runtime = new Util.RuntimeOptions{};
  return clearDedicatedHostWithOptions(request, runtime);
}

model ModifyDedicatedHostAttributeRequest = {
  regionId?: string(name='RegionId'),
  dedicatedHostId: string(name='DedicatedHostId'),
  hostName?: string(name='HostName'),
  allocationStatus?: string(name='AllocationStatus'),
}

model ModifyDedicatedHostAttributeResponse = {
  requestId: string(name='RequestId'),
}

async function modifyDedicatedHostAttributeWithOptions(request: ModifyDedicatedHostAttributeRequest, runtime: Util.RuntimeOptions): ModifyDedicatedHostAttributeResponse {
  Util.validateModel(request);
  return doRequest('ModifyDedicatedHostAttribute', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifyDedicatedHostAttribute(request: ModifyDedicatedHostAttributeRequest): ModifyDedicatedHostAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDedicatedHostAttributeWithOptions(request, runtime);
}

model MigrateDBInstanceRequest = {
  regionId?: string(name='RegionId'),
  dedicatedHostGroupId: string(name='DedicatedHostGroupId'),
  DBInstanceId: string(name='DBInstanceId'),
  targetDedicatedHostIdForMaster?: string(name='TargetDedicatedHostIdForMaster'),
  targetDedicatedHostIdForSlave?: string(name='TargetDedicatedHostIdForSlave'),
  effectiveTime?: string(name='EffectiveTime'),
  specifiedTime?: string(name='SpecifiedTime'),
  zoneIdForLog?: string(name='ZoneIdForLog'),
  zoneIdForFollower?: string(name='ZoneIdForFollower'),
}

model MigrateDBInstanceResponse = {
  requestId: string(name='RequestId'),
  taskId: integer(name='TaskId'),
  migrationId: integer(name='MigrationId'),
}

async function migrateDBInstanceWithOptions(request: MigrateDBInstanceRequest, runtime: Util.RuntimeOptions): MigrateDBInstanceResponse {
  Util.validateModel(request);
  return doRequest('MigrateDBInstance', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function migrateDBInstance(request: MigrateDBInstanceRequest): MigrateDBInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return migrateDBInstanceWithOptions(request, runtime);
}

model CreateDedicatedHostRequest = {
  regionId?: string(name='RegionId'),
  dedicatedHostGroupId: string(name='DedicatedHostGroupId'),
  hostName?: string(name='HostName'),
  zoneId: string(name='ZoneId'),
  vSwitchId: string(name='VSwitchId'),
  hostClass: string(name='HostClass'),
  payType: string(name='PayType'),
  period?: string(name='Period'),
  usedTime?: string(name='UsedTime'),
  clientToken: string(name='ClientToken'),
  autoRenew: string(name='AutoRenew'),
}

model CreateDedicatedHostResponse = {
  requestId: string(name='RequestId'),
  orderId: long(name='OrderId'),
  dedicateHostList: {
    dedicateHostList: [
      {
        dedicatedHostId: string(name='DedicatedHostId'),
      }
    ](name='DedicateHostList'),
  }(name='DedicateHostList'),
}

async function createDedicatedHostWithOptions(request: CreateDedicatedHostRequest, runtime: Util.RuntimeOptions): CreateDedicatedHostResponse {
  Util.validateModel(request);
  return doRequest('CreateDedicatedHost', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function createDedicatedHost(request: CreateDedicatedHostRequest): CreateDedicatedHostResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDedicatedHostWithOptions(request, runtime);
}

model RebuildDBInstanceRequest = {
  regionId?: string(name='RegionId'),
  dedicatedHostGroupId: string(name='DedicatedHostGroupId'),
  DBInstanceId: string(name='DBInstanceId'),
  dedicatedHostId?: string(name='DedicatedHostId'),
  rebuildNodeType?: string(name='RebuildNodeType'),
}

model RebuildDBInstanceResponse = {
  requestId: string(name='RequestId'),
  taskId: integer(name='TaskId'),
  migrationId: integer(name='MigrationId'),
}

async function rebuildDBInstanceWithOptions(request: RebuildDBInstanceRequest, runtime: Util.RuntimeOptions): RebuildDBInstanceResponse {
  Util.validateModel(request);
  return doRequest('RebuildDBInstance', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function rebuildDBInstance(request: RebuildDBInstanceRequest): RebuildDBInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return rebuildDBInstanceWithOptions(request, runtime);
}

model DescribeDBProxyEndpointRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  DBProxyEndpointId?: string(name='DBProxyEndpointId'),
  DBProxyConnectString?: string(name='DBProxyConnectString'),
  regionId: string(name='RegionId'),
}

model DescribeDBProxyEndpointResponse = {
  requestId: string(name='RequestId'),
  DBProxyEndpointId: string(name='DBProxyEndpointId'),
  DBProxyConnectString: string(name='DBProxyConnectString'),
  DBProxyConnectStringPort: string(name='DBProxyConnectStringPort'),
  DBProxyConnectStringNetType: string(name='DBProxyConnectStringNetType'),
  DBProxyFeatures: string(name='DBProxyFeatures'),
  readOnlyInstanceMaxDelayTime: string(name='ReadOnlyInstanceMaxDelayTime'),
  readOnlyInstanceDistributionType: string(name='ReadOnlyInstanceDistributionType'),
  readOnlyInstanceWeight: string(name='ReadOnlyInstanceWeight'),
}

async function describeDBProxyEndpointWithOptions(request: DescribeDBProxyEndpointRequest, runtime: Util.RuntimeOptions): DescribeDBProxyEndpointResponse {
  Util.validateModel(request);
  return doRequest('DescribeDBProxyEndpoint', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeDBProxyEndpoint(request: DescribeDBProxyEndpointRequest): DescribeDBProxyEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBProxyEndpointWithOptions(request, runtime);
}

model DescribeDBProxyPerformanceRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  DBProxyInstanceType?: string(name='DBProxyInstanceType'),
  startTime: string(name='StartTime'),
  endTime: string(name='EndTime'),
  regionId: string(name='RegionId'),
  metricsName: string(name='MetricsName'),
}

model DescribeDBProxyPerformanceResponse = {
  requestId: string(name='RequestId'),
  DBInstanceId: string(name='DBInstanceId'),
  startTime: string(name='StartTime'),
  endTime: string(name='EndTime'),
  performanceKeys: {
    performanceKey: [
      {
        key: string(name='Key'),
        valueFormat: string(name='ValueFormat'),
        values: {
          performanceValue: [
            {
              value: string(name='Value'),
              date: string(name='Date'),
            }
          ](name='PerformanceValue'),
        }(name='Values'),
      }
    ](name='PerformanceKey'),
  }(name='PerformanceKeys'),
}

async function describeDBProxyPerformanceWithOptions(request: DescribeDBProxyPerformanceRequest, runtime: Util.RuntimeOptions): DescribeDBProxyPerformanceResponse {
  Util.validateModel(request);
  return doRequest('DescribeDBProxyPerformance', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeDBProxyPerformance(request: DescribeDBProxyPerformanceRequest): DescribeDBProxyPerformanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBProxyPerformanceWithOptions(request, runtime);
}

model DescribeDBProxyRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  regionId?: string(name='RegionId'),
}

model DescribeDBProxyResponse = {
  requestId: string(name='RequestId'),
  DBProxyServiceStatus: string(name='DBProxyServiceStatus'),
  DBProxyInstanceType: string(name='DBProxyInstanceType'),
  DBProxyInstanceNum: integer(name='DBProxyInstanceNum'),
  DBProxyInstanceStatus: string(name='DBProxyInstanceStatus'),
  DBProxyInstanceCurrentMinorVersion: string(name='DBProxyInstanceCurrentMinorVersion'),
  DBProxyInstanceLatestMinorVersion: string(name='DBProxyInstanceLatestMinorVersion'),
  DBProxyInstanceName: string(name='DBProxyInstanceName'),
  DBProxyConnectStringItems: {
    DBProxyConnectStringItems: [
      {
        DBProxyEndpointId: string(name='DBProxyEndpointId'),
        DBProxyConnectString: string(name='DBProxyConnectString'),
        DBProxyConnectStringPort: string(name='DBProxyConnectStringPort'),
        DBProxyConnectStringNetType: string(name='DBProxyConnectStringNetType'),
        DBProxyVpcInstanceId: string(name='DBProxyVpcInstanceId'),
        DBProxyEndpointName: string(name='DBProxyEndpointName'),
        DBProxyConnectStringNetWorkType: string(name='DBProxyConnectStringNetWorkType'),
      }
    ](name='DBProxyConnectStringItems'),
  }(name='DBProxyConnectStringItems'),
}

async function describeDBProxyWithOptions(request: DescribeDBProxyRequest, runtime: Util.RuntimeOptions): DescribeDBProxyResponse {
  Util.validateModel(request);
  return doRequest('DescribeDBProxy', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeDBProxy(request: DescribeDBProxyRequest): DescribeDBProxyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBProxyWithOptions(request, runtime);
}

model ModifyDBProxyEndpointRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  DBProxyEndpointId: string(name='DBProxyEndpointId'),
  configDBProxyFeatures?: string(name='ConfigDBProxyFeatures'),
  regionId?: string(name='RegionId'),
  readOnlyInstanceMaxDelayTime?: string(name='ReadOnlyInstanceMaxDelayTime'),
  readOnlyInstanceDistributionType?: string(name='ReadOnlyInstanceDistributionType'),
  readOnlyInstanceWeight?: string(name='ReadOnlyInstanceWeight'),
}

model ModifyDBProxyEndpointResponse = {
  requestId: string(name='RequestId'),
}

async function modifyDBProxyEndpointWithOptions(request: ModifyDBProxyEndpointRequest, runtime: Util.RuntimeOptions): ModifyDBProxyEndpointResponse {
  Util.validateModel(request);
  return doRequest('ModifyDBProxyEndpoint', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifyDBProxyEndpoint(request: ModifyDBProxyEndpointRequest): ModifyDBProxyEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBProxyEndpointWithOptions(request, runtime);
}

model ModifyDBProxyInstanceRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  DBProxyInstanceType: string(name='DBProxyInstanceType'),
  DBProxyInstanceNum: string(name='DBProxyInstanceNum'),
  effectiveTime?: string(name='EffectiveTime'),
  effectiveSpecificTime?: string(name='EffectiveSpecificTime'),
  regionId?: string(name='RegionId'),
}

model ModifyDBProxyInstanceResponse = {
  requestId: string(name='RequestId'),
}

async function modifyDBProxyInstanceWithOptions(request: ModifyDBProxyInstanceRequest, runtime: Util.RuntimeOptions): ModifyDBProxyInstanceResponse {
  Util.validateModel(request);
  return doRequest('ModifyDBProxyInstance', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifyDBProxyInstance(request: ModifyDBProxyInstanceRequest): ModifyDBProxyInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBProxyInstanceWithOptions(request, runtime);
}

model ModifyDBProxyRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  configDBProxyService: string(name='ConfigDBProxyService'),
  DBProxyInstanceNum?: string(name='DBProxyInstanceNum'),
  regionId?: string(name='RegionId'),
  instanceNetworkType?: string(name='InstanceNetworkType'),
  VPCId?: string(name='VPCId'),
  vSwitchId?: string(name='VSwitchId'),
}

model ModifyDBProxyResponse = {
  requestId: string(name='RequestId'),
}

async function modifyDBProxyWithOptions(request: ModifyDBProxyRequest, runtime: Util.RuntimeOptions): ModifyDBProxyResponse {
  Util.validateModel(request);
  return doRequest('ModifyDBProxy', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifyDBProxy(request: ModifyDBProxyRequest): ModifyDBProxyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBProxyWithOptions(request, runtime);
}

model ModifyHASwitchConfigRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  HAConfig?: string(name='HAConfig'),
  manualHATime?: string(name='ManualHATime'),
  regionId: string(name='RegionId'),
}

model ModifyHASwitchConfigResponse = {
  requestId: string(name='RequestId'),
}

async function modifyHASwitchConfigWithOptions(request: ModifyHASwitchConfigRequest, runtime: Util.RuntimeOptions): ModifyHASwitchConfigResponse {
  Util.validateModel(request);
  return doRequest('ModifyHASwitchConfig', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifyHASwitchConfig(request: ModifyHASwitchConfigRequest): ModifyHASwitchConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyHASwitchConfigWithOptions(request, runtime);
}

model DescribeHASwitchConfigRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  regionId: string(name='RegionId'),
}

model DescribeHASwitchConfigResponse = {
  requestId: string(name='RequestId'),
  HAConfig: string(name='HAConfig'),
  manualHATime: string(name='ManualHATime'),
}

async function describeHASwitchConfigWithOptions(request: DescribeHASwitchConfigRequest, runtime: Util.RuntimeOptions): DescribeHASwitchConfigResponse {
  Util.validateModel(request);
  return doRequest('DescribeHASwitchConfig', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeHASwitchConfig(request: DescribeHASwitchConfigRequest): DescribeHASwitchConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHASwitchConfigWithOptions(request, runtime);
}

model ModifyActionEventPolicyRequest = {
  regionId: string(name='RegionId'),
  enableEventLog: string(name='EnableEventLog'),
}

model ModifyActionEventPolicyResponse = {
  requestId: string(name='RequestId'),
  regionId: string(name='RegionId'),
  enableEventLog: string(name='EnableEventLog'),
}

async function modifyActionEventPolicyWithOptions(request: ModifyActionEventPolicyRequest, runtime: Util.RuntimeOptions): ModifyActionEventPolicyResponse {
  Util.validateModel(request);
  return doRequest('ModifyActionEventPolicy', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifyActionEventPolicy(request: ModifyActionEventPolicyRequest): ModifyActionEventPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyActionEventPolicyWithOptions(request, runtime);
}

model DescribeActionEventPolicyRequest = {
  regionId: string(name='RegionId'),
}

model DescribeActionEventPolicyResponse = {
  requestId: string(name='RequestId'),
  regionId: string(name='RegionId'),
  enableEventLog: string(name='EnableEventLog'),
}

async function describeActionEventPolicyWithOptions(request: DescribeActionEventPolicyRequest, runtime: Util.RuntimeOptions): DescribeActionEventPolicyResponse {
  Util.validateModel(request);
  return doRequest('DescribeActionEventPolicy', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeActionEventPolicy(request: DescribeActionEventPolicyRequest): DescribeActionEventPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeActionEventPolicyWithOptions(request, runtime);
}

model DescribeEventsRequest = {
  regionId: string(name='RegionId'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
  pageSize?: integer(name='PageSize'),
  pageNumber?: integer(name='PageNumber'),
}

model DescribeEventsResponse = {
  requestId: string(name='RequestId'),
  totalRecordCount: integer(name='TotalRecordCount'),
  pageSize: integer(name='PageSize'),
  pageNumber: integer(name='PageNumber'),
  eventItems: {
    eventItems: [
      {
        eventId: integer(name='EventId'),
        eventType: string(name='EventType'),
        eventName: string(name='EventName'),
        eventTime: string(name='EventTime'),
        resourceType: string(name='ResourceType'),
        resourceName: string(name='ResourceName'),
        regionId: string(name='RegionId'),
        eventUserType: string(name='EventUserType'),
        eventReason: string(name='EventReason'),
        eventPayload: string(name='EventPayload'),
        eventRecordTime: string(name='EventRecordTime'),
      }
    ](name='EventItems'),
  }(name='EventItems'),
}

async function describeEventsWithOptions(request: DescribeEventsRequest, runtime: Util.RuntimeOptions): DescribeEventsResponse {
  Util.validateModel(request);
  return doRequest('DescribeEvents', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeEvents(request: DescribeEventsRequest): DescribeEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEventsWithOptions(request, runtime);
}

model DescribeDBInstancesForCloneRequest = {
  clientToken?: string(name='ClientToken'),
  proxyId?: string(name='proxyId'),
  engine?: string(name='Engine'),
  zoneId?: string(name='ZoneId'),
  DBInstanceStatus?: string(name='DBInstanceStatus'),
  expired?: string(name='Expired'),
  searchKey?: string(name='SearchKey'),
  DBInstanceId?: string(name='DBInstanceId'),
  DBInstanceType?: string(name='DBInstanceType'),
  regionId: string(name='RegionId'),
  pageSize?: integer(name='PageSize'),
  pageNumber?: integer(name='PageNumber'),
  instanceNetworkType?: string(name='InstanceNetworkType'),
  vpcId?: string(name='VpcId'),
  vSwitchId?: string(name='VSwitchId'),
  DBInstanceClass?: string(name='DBInstanceClass'),
  engineVersion?: string(name='EngineVersion'),
  nodeType?: string(name='NodeType'),
  payType?: string(name='PayType'),
  connectionMode?: string(name='ConnectionMode'),
  currentInstanceId?: string(name='CurrentInstanceId'),
}

model DescribeDBInstancesForCloneResponse = {
  requestId: string(name='RequestId'),
  pageNumber: integer(name='PageNumber'),
  totalRecordCount: integer(name='TotalRecordCount'),
  pageRecordCount: integer(name='PageRecordCount'),
  items: {
    DBInstance: [
      {
        insId: integer(name='InsId'),
        DBInstanceId: string(name='DBInstanceId'),
        DBInstanceDescription: string(name='DBInstanceDescription'),
        payType: string(name='PayType'),
        DBInstanceType: string(name='DBInstanceType'),
        regionId: string(name='RegionId'),
        expireTime: string(name='ExpireTime'),
        destroyTime: string(name='DestroyTime'),
        DBInstanceStatus: string(name='DBInstanceStatus'),
        engine: string(name='Engine'),
        DBInstanceNetType: string(name='DBInstanceNetType'),
        connectionMode: string(name='ConnectionMode'),
        lockMode: string(name='LockMode'),
        category: string(name='Category'),
        DBInstanceStorageType: string(name='DBInstanceStorageType'),
        DBInstanceClass: string(name='DBInstanceClass'),
        instanceNetworkType: string(name='InstanceNetworkType'),
        vpcCloudInstanceId: string(name='VpcCloudInstanceId'),
        lockReason: string(name='LockReason'),
        zoneId: string(name='ZoneId'),
        mutriORsignle: boolean(name='MutriORsignle'),
        createTime: string(name='CreateTime'),
        engineVersion: string(name='EngineVersion'),
        guardDBInstanceId: string(name='GuardDBInstanceId'),
        tempDBInstanceId: string(name='TempDBInstanceId'),
        masterInstanceId: string(name='MasterInstanceId'),
        vpcId: string(name='VpcId'),
        vSwitchId: string(name='VSwitchId'),
        replicateId: string(name='ReplicateId'),
        resourceGroupId: string(name='ResourceGroupId'),
        readOnlyDBInstanceIds: {
          readOnlyDBInstanceId: [
            {
              DBInstanceId: string(name='DBInstanceId'),
            }
          ](name='ReadOnlyDBInstanceId'),
        }(name='ReadOnlyDBInstanceIds'),
      }
    ](name='DBInstance'),
  }(name='Items'),
}

async function describeDBInstancesForCloneWithOptions(request: DescribeDBInstancesForCloneRequest, runtime: Util.RuntimeOptions): DescribeDBInstancesForCloneResponse {
  Util.validateModel(request);
  return doRequest('DescribeDBInstancesForClone', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeDBInstancesForClone(request: DescribeDBInstancesForCloneRequest): DescribeDBInstancesForCloneResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstancesForCloneWithOptions(request, runtime);
}

model DescribeDTCSecurityIpHostsForSQLServerRequest = {
  securityToken?: string(name='SecurityToken'),
  DBInstanceId: string(name='DBInstanceId', description='description: 实例ID。; '),
  regionId: string(name='RegionId', description='description: 地域ID，可以通过接口[DescribeRegions](~~26243~~)查看。; '),
}

model DescribeDTCSecurityIpHostsForSQLServerResponse = {
  requestId: string(name='RequestId', description='description: 请求ID。; '),
  DBInstanceId: string(name='DBInstanceId', description='description: 实例ID。; '),
  ipHostPairNum: string(name='IpHostPairNum', description='description: 分布式事务白名单条目数。; '),
  items: {
    whiteListGroups: [
      {
        securityIpHosts: string(name='SecurityIpHosts', description='description: ECS实例的IP地址和Windows系统的计算机名。格式：ip,hostname。多个实例之间以英文分号（;）隔开。; '),
        whitelistGroupName: string(name='WhitelistGroupName', description='description: 分布式事务白名单分组名称。; '),
      }
    ](name='WhiteListGroups'),
  }(name='Items', description='description: 分布式事务白名单分组列表。'),
}

/**
 * DescribeDTCSecurityIpHostsForSQLServer 调用DescribeDTCSecurityIpHostsForSQLServer接口查询RDS实例的分布式事务白名单信息。
  * request demo:   * ```
  * http(s)://rds.aliyuncs.com/?Action=DescribeDTCSecurityIpHostsForSQLServer
  * &DBInstanceId=rm-uf6wjk5xxxxxxx
  * &RegionId=cn-hangzhou
  * &<公共请求参数>
  * ```
  * description:   * 关于分布式事务白名单请参见[设置分布式事务白名单](~~124321~~)。
  * 仅适用于如下版本实例：
  * * SQL Server 2012/2016企业版高可用版
  * * SQL Server 2012/2016标准版

 */
async function describeDTCSecurityIpHostsForSQLServerWithOptions(request: DescribeDTCSecurityIpHostsForSQLServerRequest, runtime: Util.RuntimeOptions): DescribeDTCSecurityIpHostsForSQLServerResponse {
  Util.validateModel(request);
  return doRequest('DescribeDTCSecurityIpHostsForSQLServer', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

/**
 * DescribeDTCSecurityIpHostsForSQLServer 调用DescribeDTCSecurityIpHostsForSQLServer接口查询RDS实例的分布式事务白名单信息。
  * request demo:   * ```
  * http(s)://rds.aliyuncs.com/?Action=DescribeDTCSecurityIpHostsForSQLServer
  * &DBInstanceId=rm-uf6wjk5xxxxxxx
  * &RegionId=cn-hangzhou
  * &<公共请求参数>
  * ```
  * description:   * 关于分布式事务白名单请参见[设置分布式事务白名单](~~124321~~)。
  * 仅适用于如下版本实例：
  * * SQL Server 2012/2016企业版高可用版
  * * SQL Server 2012/2016标准版

 */
async function describeDTCSecurityIpHostsForSQLServer(request: DescribeDTCSecurityIpHostsForSQLServerRequest): DescribeDTCSecurityIpHostsForSQLServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDTCSecurityIpHostsForSQLServerWithOptions(request, runtime);
}

model ModifyDTCSecurityIpHostsForSQLServerRequest = {
  securityToken?: string(name='SecurityToken'),
  DBInstanceId: string(name='DBInstanceId', description='description: RDS实例ID。; '),
  securityIpHosts: string(name='SecurityIpHosts', description='description: ECS实例的IP地址和Windows系统的计算机名。格式：ip,hostname。多个实例之间以英文分号（;）隔开。>计算机名查看方式请参见[设置分布式事务白名单](~~124321~~)。; '),
  whiteListGroupName: string(name='WhiteListGroupName', description='description: 白名单分组名称。; '),
  regionId: string(name='RegionId', description='description: RDS实例的地域ID，可以通过接口[DescribeRegions](~~26243~~)查看。; '),
}

model ModifyDTCSecurityIpHostsForSQLServerResponse = {
  requestId: string(name='RequestId', description='description: 请求ID。; '),
  DBInstanceId: string(name='DBInstanceId', description='description: RDS实例ID。; '),
  DTCSetResult: string(name='DTCSetResult', description='description: 设置白名单的结果，取值：* **Success**：设置成功；* **Fail**：设置失败。; '),
  taskId: string(name='TaskId', description='description: 设置任务ID。; '),
}

/**
 * ModifyDTCSecurityIpHostsForSQLServer 调用ModifyDTCSecurityIpHostsForSQLServer接口设置分布式事务白名单。
  * request demo:   * ```
  * http(s)://rds.aliyuncs.com/?Action=ModifyDTCSecurityIpHostsForSQLServer
  * &DBInstanceId=rm-uf6wjk5xxxxxxx
  * &RegionId=cn-hangzhou
  * &SecurityIpHosts=192.168.1.100,k3ecstest
  * &WhiteListGroupName=test1
  * &<公共请求参数>
  * ```
  * description:   * 分布式事务白名单可以让ECS实例和RDS实例之间支持分布式事务。详情请参见[设置分布式事务白名单](~~124321~~)。
  * 仅适用于如下版本实例：
  * * SQL Server 2012/2016企业版高可用版
  * * SQL Server 2012/2016标准版

 */
async function modifyDTCSecurityIpHostsForSQLServerWithOptions(request: ModifyDTCSecurityIpHostsForSQLServerRequest, runtime: Util.RuntimeOptions): ModifyDTCSecurityIpHostsForSQLServerResponse {
  Util.validateModel(request);
  return doRequest('ModifyDTCSecurityIpHostsForSQLServer', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

/**
 * ModifyDTCSecurityIpHostsForSQLServer 调用ModifyDTCSecurityIpHostsForSQLServer接口设置分布式事务白名单。
  * request demo:   * ```
  * http(s)://rds.aliyuncs.com/?Action=ModifyDTCSecurityIpHostsForSQLServer
  * &DBInstanceId=rm-uf6wjk5xxxxxxx
  * &RegionId=cn-hangzhou
  * &SecurityIpHosts=192.168.1.100,k3ecstest
  * &WhiteListGroupName=test1
  * &<公共请求参数>
  * ```
  * description:   * 分布式事务白名单可以让ECS实例和RDS实例之间支持分布式事务。详情请参见[设置分布式事务白名单](~~124321~~)。
  * 仅适用于如下版本实例：
  * * SQL Server 2012/2016企业版高可用版
  * * SQL Server 2012/2016标准版

 */
async function modifyDTCSecurityIpHostsForSQLServer(request: ModifyDTCSecurityIpHostsForSQLServerRequest): ModifyDTCSecurityIpHostsForSQLServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDTCSecurityIpHostsForSQLServerWithOptions(request, runtime);
}

model DescribeDBInstanceIpHostnameRequest = {
  securityToken?: string(name='SecurityToken'),
  DBInstanceId: string(name='DBInstanceId', description='description: RDS实例ID。; '),
  regionId: string(name='RegionId', description='description: RDS实例的地域ID，可以通过接口[DescribeRegions](~~26243~~)查看。; '),
}

model DescribeDBInstanceIpHostnameResponse = {
  requestId: string(name='RequestId', description='description: 请求ID。; '),
  DBInstanceId: string(name='DBInstanceId', description='description: 实例ID。; '),
  ipHostnameInfos: string(name='IpHostnameInfos', description='description: RDS实例所在ECS实例的内网IP和ECS主机名，包含主备实例。格式：ip1,hostname1;ip2,hostname2。; '),
}

/**
 * DescribeDBInstanceIpHostname 调用DescribeDBInstanceIpHostname接口查询RDS实例的底层ECS实例的hostname。
  * request demo:   * ```
  * http(s)://rds.aliyuncs.com/?Action=DescribeDBInstanceIpHostname
  * &DBInstanceId=rm-uf6wjk5xxxxxxx	
  * &RegionId=cn-hangzhou
  * &<公共请求参数>
  * ```
  * description:   * RDS实例是基于ECS实例搭建的，本接口用于[设置分布式事务白名单](~~124321~~)时查询RDS实例的底层ECS实例的hostname。
  * 仅适用于如下版本实例：
  * * SQL Server 2012/2016企业版高可用版
  * * SQL Server 2012/2016标准版

 */
async function describeDBInstanceIpHostnameWithOptions(request: DescribeDBInstanceIpHostnameRequest, runtime: Util.RuntimeOptions): DescribeDBInstanceIpHostnameResponse {
  Util.validateModel(request);
  return doRequest('DescribeDBInstanceIpHostname', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

/**
 * DescribeDBInstanceIpHostname 调用DescribeDBInstanceIpHostname接口查询RDS实例的底层ECS实例的hostname。
  * request demo:   * ```
  * http(s)://rds.aliyuncs.com/?Action=DescribeDBInstanceIpHostname
  * &DBInstanceId=rm-uf6wjk5xxxxxxx	
  * &RegionId=cn-hangzhou
  * &<公共请求参数>
  * ```
  * description:   * RDS实例是基于ECS实例搭建的，本接口用于[设置分布式事务白名单](~~124321~~)时查询RDS实例的底层ECS实例的hostname。
  * 仅适用于如下版本实例：
  * * SQL Server 2012/2016企业版高可用版
  * * SQL Server 2012/2016标准版

 */
async function describeDBInstanceIpHostname(request: DescribeDBInstanceIpHostnameRequest): DescribeDBInstanceIpHostnameResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstanceIpHostnameWithOptions(request, runtime);
}

model ModifyDBInstanceAutoUpgradeMinorVersionRequest = {
  clientToken?: string(name='ClientToken'),
  DBInstanceId: string(name='DBInstanceId'),
  autoUpgradeMinorVersion: string(name='AutoUpgradeMinorVersion'),
}

model ModifyDBInstanceAutoUpgradeMinorVersionResponse = {
  requestId: string(name='RequestId'),
}

async function modifyDBInstanceAutoUpgradeMinorVersionWithOptions(request: ModifyDBInstanceAutoUpgradeMinorVersionRequest, runtime: Util.RuntimeOptions): ModifyDBInstanceAutoUpgradeMinorVersionResponse {
  Util.validateModel(request);
  return doRequest('ModifyDBInstanceAutoUpgradeMinorVersion', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifyDBInstanceAutoUpgradeMinorVersion(request: ModifyDBInstanceAutoUpgradeMinorVersionRequest): ModifyDBInstanceAutoUpgradeMinorVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstanceAutoUpgradeMinorVersionWithOptions(request, runtime);
}

model DescribeAvailableCrossRegionRequest = {
  regionId: string(name='RegionId', description='description: 地域ID。可以通过接口[DescribeRegions](~~26243~~)查看地域ID。; '),
}

model DescribeAvailableCrossRegionResponse = {
  requestId: string(name='RequestId', description='description: 请求ID。; '),
  regions: {
    region: [ string ](name='Region'),
  }(name='Regions'),
}

/**
 * DescribeAvailableCrossRegion 调用DescribeAvailableCrossRegion接口查询所选地域当前可以进行跨地域备份的目的地域。
  * request demo:   * ```
  * http(s)://rds.aliyuncs.com/?Action=DescribeAvailableCrossRegion
  * &RegionId=cn-hangzhou
  * &<公共请求参数>
  * ```
  * description: 
 */
async function describeAvailableCrossRegionWithOptions(request: DescribeAvailableCrossRegionRequest, runtime: Util.RuntimeOptions): DescribeAvailableCrossRegionResponse {
  Util.validateModel(request);
  return doRequest('DescribeAvailableCrossRegion', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

/**
 * DescribeAvailableCrossRegion 调用DescribeAvailableCrossRegion接口查询所选地域当前可以进行跨地域备份的目的地域。
  * request demo:   * ```
  * http(s)://rds.aliyuncs.com/?Action=DescribeAvailableCrossRegion
  * &RegionId=cn-hangzhou
  * &<公共请求参数>
  * ```
  * description: 
 */
async function describeAvailableCrossRegion(request: DescribeAvailableCrossRegionRequest): DescribeAvailableCrossRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAvailableCrossRegionWithOptions(request, runtime);
}

model CheckCreateDdrDBInstanceRequest = {
  regionId: string(name='RegionId'),
  engine: string(name='Engine'),
  engineVersion: string(name='EngineVersion'),
  DBInstanceClass: string(name='DBInstanceClass'),
  DBInstanceStorage: integer(name='DBInstanceStorage'),
  restoreType: string(name='RestoreType'),
  backupSetId?: string(name='BackupSetId'),
  restoreTime?: string(name='RestoreTime'),
  sourceRegion?: string(name='SourceRegion'),
  sourceDBInstanceName?: string(name='SourceDBInstanceName'),
  binlogName?: string(name='BinlogName'),
  binlogPosition?: string(name='BinlogPosition'),
  binlogRole?: string(name='BinlogRole'),
}

model CheckCreateDdrDBInstanceResponse = {
  requestId: string(name='RequestId'),
  isValid: string(name='IsValid'),
}

async function checkCreateDdrDBInstanceWithOptions(request: CheckCreateDdrDBInstanceRequest, runtime: Util.RuntimeOptions): CheckCreateDdrDBInstanceResponse {
  Util.validateModel(request);
  return doRequest('CheckCreateDdrDBInstance', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function checkCreateDdrDBInstance(request: CheckCreateDdrDBInstanceRequest): CheckCreateDdrDBInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkCreateDdrDBInstanceWithOptions(request, runtime);
}

model DescribeAvailableRecoveryTimeRequest = {
  crossBackupId: integer(name='CrossBackupId', description='description: 跨地域备份文件ID。可以通过接口[DescribeCrossRegionBackups](~~121733~~)查看备份集ID。; '),
  regionId?: string(name='RegionId', description='description: 地域ID。; '),
}

model DescribeAvailableRecoveryTimeResponse = {
  requestId: string(name='RequestId', description='description: 请求ID。; '),
  recoveryBeginTime: string(name='RecoveryBeginTime', description='description: 跨地域备份文件可恢复的起始时间。格式：<i>yyyy-MM-dd</i>T<i>HH:mm:ss</i>Z（UTC时间）。; '),
  recoveryEndTime: string(name='RecoveryEndTime', description='description: 跨地域备份文件可恢复的结束时间。格式：<i>yyyy-MM-dd</i>T<i>HH:mm:ss</i>Z（UTC时间）。; '),
  DBInstanceId: string(name='DBInstanceId'),
  regionId: string(name='RegionId', description='description: 源实例所在地域ID。; '),
  crossBackupId: integer(name='CrossBackupId', description='description: 跨地域备份文件ID。; '),
}

/**
 * DescribeAvailableRecoveryTime 调用DescribeAvailableRecoveryTime接口查询某跨地域备份文件可恢复哪个时间段的数据。
  * request demo:   * ```
  * http(s)://rds.aliyuncs.com/?Action=DescribeAvailableRecoveryTime
  * &CrossBackupId=14377
  * &<公共请求参数>
  * ```
  * description:   * 查看普通备份文件可恢复哪个时间段的数据请参见[DescribeBackups](~~26273~~)。
  * 仅适用于如下实例：
  * * MySQL 5.7高可用本地SSD盘版
  * * MySQL 5.6

 */
async function describeAvailableRecoveryTimeWithOptions(request: DescribeAvailableRecoveryTimeRequest, runtime: Util.RuntimeOptions): DescribeAvailableRecoveryTimeResponse {
  Util.validateModel(request);
  return doRequest('DescribeAvailableRecoveryTime', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

/**
 * DescribeAvailableRecoveryTime 调用DescribeAvailableRecoveryTime接口查询某跨地域备份文件可恢复哪个时间段的数据。
  * request demo:   * ```
  * http(s)://rds.aliyuncs.com/?Action=DescribeAvailableRecoveryTime
  * &CrossBackupId=14377
  * &<公共请求参数>
  * ```
  * description:   * 查看普通备份文件可恢复哪个时间段的数据请参见[DescribeBackups](~~26273~~)。
  * 仅适用于如下实例：
  * * MySQL 5.7高可用本地SSD盘版
  * * MySQL 5.6

 */
async function describeAvailableRecoveryTime(request: DescribeAvailableRecoveryTimeRequest): DescribeAvailableRecoveryTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAvailableRecoveryTimeWithOptions(request, runtime);
}

model DescribeCrossRegionLogBackupFilesRequest = {
  DBInstanceId: string(name='DBInstanceId', description='description: 实例ID。; '),
  regionId: string(name='RegionId', description='description: 实例所在地域ID。可以通过接口[DescribeRegions](~~26243~~)查看地域ID。; '),
  crossBackupRegion?: string(name='CrossBackupRegion', description='description: 跨地域备份目的地域ID。可以通过接口[DescribeCrossRegionBackupDBInstance](~~121737~~)查看地域ID。; '),
  startTime: string(name='StartTime', description='description: 查询开始时间。格式：<i>yyyy-MM-dd</i>T<i>HH:mm</i>Z（UTC时间）。; '),
  endTime: string(name='EndTime', description='description: 查询结束时间。格式：<i>yyyy-MM-dd</i>T<i>HH:mm</i>Z（UTC时间）。; '),
  pageSize?: integer(name='PageSize', description='description: 每页记录数，取值：* **30**；* **50**；* **100**。默认值：30。; '),
  pageNumber?: integer(name='PageNumber', description='description: 页码，取值：大于0且不超过Integer的最大值。默认值：**1**。; '),
}

model DescribeCrossRegionLogBackupFilesResponse = {
  requestId: string(name='RequestId', description='description: 请求ID。; '),
  regionId: string(name='RegionId', description='description: 实例所在地域ID。; '),
  DBInstanceId: string(name='DBInstanceId', description='description: 实例ID。; '),
  startTime: string(name='StartTime', description='description: 查询开始时间。格式：<i>yyyy-MM-dd</i>T<i>HH:mm</i>Z（UTC时间）。; '),
  endTime: string(name='EndTime', description='description: 查询结束时间。格式：<i>yyyy-MM-dd</i>T<i>HH:mm</i>Z（UTC时间）。; '),
  totalRecordCount: integer(name='TotalRecordCount', description='description: 总记录数。; '),
  pageRecordCount: integer(name='PageRecordCount', description='description: 本页备份文件个数。; '),
  pageNumber: integer(name='PageNumber', description='description: 页码，取值：大于0且不超过Integer的最大值。默认值：**1**。; '),
  items: {
    item: [
      {
        crossLogBackupId: integer(name='CrossLogBackupId', description='description: 跨地域日志备份文件ID。; '),
        crossBackupRegion: string(name='CrossBackupRegion', description='description: 跨地域备份目的地域ID。; '),
        crossLogBackupSize: long(name='CrossLogBackupSize', description='description: 跨地域日志备份文件大小，单位：Byte。; '),
        logBeginTime: string(name='LogBeginTime', description='description: 跨地域日志备份文件记录的开始时间。格式：<i>yyyy-MM-dd</i>T<i>HH:mm</i>Z（UTC时间）。; '),
        logEndTime: string(name='LogEndTime', description='description: 跨地域日志备份文件记录的结束时间。格式：<i>yyyy-MM-dd</i>T<i>HH:mm</i>Z（UTC时间）。; '),
        crossDownloadLink: string(name='CrossDownloadLink', description='description: 跨地域日志备份外网下载链接。; '),
        crossIntranetDownloadLink: string(name='CrossIntranetDownloadLink', description='description: 跨地域日志备份内网下载链接。; '),
        linkExpiredTime: string(name='LinkExpiredTime', description='description: 下载链接过期时间。格式：<i>yyyy-MM-dd</i>T<i>HH:mm:ss</i>Z（UTC时间）。; '),
        logFileName: string(name='LogFileName', description='description: 跨地域日志备份文件名称。; '),
        instanceId: integer(name='InstanceId', description='description: 实例编号。; '),
      }
    ](name='Item'),
  }(name='Items', description='description: 跨地域日志备份列表。'),
}

/**
 * DescribeCrossRegionLogBackupFiles 调用DescribeCrossRegionLogBackupFiles接口查看跨地域日志备份文件列表。
  * request demo:   * ```
  * http(s)://rds.aliyuncs.com/?Action=DescribeCrossRegionLogBackupFiles
  * &DBInstanceId=rm-uf6wjk5xxxxxxxxxx
  * &StartTime=2019-05-30T12:10Z
  * &EndTime=2019-06-15T12:10Z
  * &<公共请求参数>
  * ```
  * description:   * 查看数据备份文件请参见[DescribeCrossRegionBackups](~~121733~~)。
  * 仅适用于如下实例：
  * * MySQL 5.7高可用本地SSD盘版
  * * MySQL 5.6

 */
async function describeCrossRegionLogBackupFilesWithOptions(request: DescribeCrossRegionLogBackupFilesRequest, runtime: Util.RuntimeOptions): DescribeCrossRegionLogBackupFilesResponse {
  Util.validateModel(request);
  return doRequest('DescribeCrossRegionLogBackupFiles', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

/**
 * DescribeCrossRegionLogBackupFiles 调用DescribeCrossRegionLogBackupFiles接口查看跨地域日志备份文件列表。
  * request demo:   * ```
  * http(s)://rds.aliyuncs.com/?Action=DescribeCrossRegionLogBackupFiles
  * &DBInstanceId=rm-uf6wjk5xxxxxxxxxx
  * &StartTime=2019-05-30T12:10Z
  * &EndTime=2019-06-15T12:10Z
  * &<公共请求参数>
  * ```
  * description:   * 查看数据备份文件请参见[DescribeCrossRegionBackups](~~121733~~)。
  * 仅适用于如下实例：
  * * MySQL 5.7高可用本地SSD盘版
  * * MySQL 5.6

 */
async function describeCrossRegionLogBackupFiles(request: DescribeCrossRegionLogBackupFilesRequest): DescribeCrossRegionLogBackupFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCrossRegionLogBackupFilesWithOptions(request, runtime);
}

model ModifyInstanceCrossBackupPolicyRequest = {
  DBInstanceId: string(name='DBInstanceId', description='description: 实例ID。; '),
  regionId: string(name='RegionId', description='description: 源实例地域ID，可以通过接口[DescribeRegions](~~26243~~)查看地域ID。; '),
  crossBackupType?: string(name='CrossBackupType', description='description: 跨地域备份保存类型。默认值：**1**，表示每个备份都保存。; '),
  logBackupEnabled?: string(name='LogBackupEnabled', description='description: 跨地域日志备份开关，取值：* **0**：关闭；* **1**：开启。; '),
  backupEnabled?: string(name='BackupEnabled', description='description: 跨地域备份总开关（数据备份+日志备份），取值：* **0**：关闭；* **1**：开启。; '),
  crossBackupRegion?: string(name='CrossBackupRegion', description='description: 跨地域备份的目的地域ID。; '),
  retentType?: integer(name='RetentType', description='description: 跨地域备份保留方式。默认值：**1**，表示按时长保留。; '),
  retention?: integer(name='Retention', description='description: 跨地域备份保留天数，取值：**7~1825**。; '),
}

model ModifyInstanceCrossBackupPolicyResponse = {
  requestId: string(name='RequestId', description='description: 请求ID。; '),
  DBInstanceId: string(name='DBInstanceId', description='description: 实例ID。; '),
  regionId: string(name='RegionId', description='description: 源实例地域ID，可以通过接口[DescribeRegions](~~26243~~)查看地域ID。; '),
  crossBackupRegion: string(name='CrossBackupRegion', description='description: 跨地域备份的目的地域ID。; '),
  crossBackupType: string(name='CrossBackupType', description='description: 跨地域备份保存类型。默认值：**1**，表示每个备份都保存。; '),
  backupEnabled: string(name='BackupEnabled', description='description: 跨地域备份总开关，取值：* **0**：关闭；* **1**：开启。; '),
  logBackupEnabled: string(name='LogBackupEnabled', description='description: 跨地域日志备份开关，取值：* **0**：关闭；* **1**：开启。; '),
  storageOwner: string(name='StorageOwner'),
  storageType: string(name='StorageType'),
  endpoint: string(name='Endpoint'),
  retentType: integer(name='RetentType', description='description: 跨地域备份保留方式。默认值：**1**，表示按时长保留。; '),
  retention: integer(name='Retention', description='description: 跨地域备份保留天数，取值：**7~1825**。; '),
}

/**
 * ModifyInstanceCrossBackupPolicy 调用ModifyInstanceCrossBackupPolicy接口修改RDS跨地域备份设置。
  * request demo:   * ```
  * http(s)://rds.aliyuncs.com/?Action=ModifyInstanceCrossBackupPolicy
  * &DBInstanceId=rm-uf6wjk5xxxxxxxxxx
  * &RegionId=cn-hangzhou
  * &<公共请求参数>
  * ```
  * description:   * 仅适用于如下实例：
  * * MySQL 5.7高可用本地SSD盘版
  * * MySQL 5.6

 */
async function modifyInstanceCrossBackupPolicyWithOptions(request: ModifyInstanceCrossBackupPolicyRequest, runtime: Util.RuntimeOptions): ModifyInstanceCrossBackupPolicyResponse {
  Util.validateModel(request);
  return doRequest('ModifyInstanceCrossBackupPolicy', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

/**
 * ModifyInstanceCrossBackupPolicy 调用ModifyInstanceCrossBackupPolicy接口修改RDS跨地域备份设置。
  * request demo:   * ```
  * http(s)://rds.aliyuncs.com/?Action=ModifyInstanceCrossBackupPolicy
  * &DBInstanceId=rm-uf6wjk5xxxxxxxxxx
  * &RegionId=cn-hangzhou
  * &<公共请求参数>
  * ```
  * description:   * 仅适用于如下实例：
  * * MySQL 5.7高可用本地SSD盘版
  * * MySQL 5.6

 */
async function modifyInstanceCrossBackupPolicy(request: ModifyInstanceCrossBackupPolicyRequest): ModifyInstanceCrossBackupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyInstanceCrossBackupPolicyWithOptions(request, runtime);
}

model CreateDdrInstanceRequest = {
  regionId: string(name='RegionId', description='description: 目的地域ID，可以通过接口[DescribeRegions](~~26243~~)查看地域ID。; '),
  engine: string(name='Engine', description='description: 目的数据库类型，取值：**MySQL**。; '),
  engineVersion: string(name='EngineVersion', description='description: 目的数据库版本，取值：* **5.6**；* **5.7**。; '),
  DBInstanceClass: string(name='DBInstanceClass', description='description: 目的实例规格，详见[实例规格表](~~26312~~)。; '),
  DBInstanceStorage: integer(name='DBInstanceStorage', description='description: 目的实例存储空间，取值： **5~2000**。每5G进行递增，单位：GB。详见[实例规格表](~~26312~~)。; '),
  systemDBCharset?: string(name='SystemDBCharset', description='description: 目的实例的字符集，取值：* **utf8**；* **gbk**；* **latin1**；* **utf8mb4**。; '),
  DBInstanceNetType: string(name='DBInstanceNetType', description='description: 目的实例的网络连接类型，取值：* **Internet**：公网连接；* **Intranet**：内网连接。; '),
  DBInstanceDescription?: string(name='DBInstanceDescription', description='description: 目的实例名称，长度为2~256个字符。以中文、英文字母开头，可以包含数字、中文、英文、下划线（_）、短横线（-）。>不能以 http:// 和 https:// 开头。; '),
  securityIPList: string(name='SecurityIPList', description='description: 目的实例的[IP白名单](~~43185~~)，多个IP地址请以英文逗号（,）隔开，不可重复，最多1000个。支持如下两种格式：* IP地址形式，例如：10.23.12.24；* CIDR形式，例如：10.23.12.24/24（无类域间路由，24表示了地址中前缀的长度，范围为1~32）。; '),
  clientToken?: string(name='ClientToken', description='description: 用于保证请求的幂等性，防止重复提交请求。由客户端生成该参数值，要保证在不同请求间唯一，最大值不超过64个ASCII字符，且该参数值中不能包含非ASCII字符。; '),
  payType: string(name='PayType', description='description: 目的实例的付费类型，取值：* **Postpaid**：后付费（按量付费）；* **Prepaid**：预付费（包年包月）。; '),
  zoneId?: string(name='ZoneId', description='description: 目的实例的可用区ID。多可用区用英文冒号（:）分隔。> 指定了VPC和交换机时，为匹配交换机对应的可用区，该参数必填。; '),
  instanceNetworkType?: string(name='InstanceNetworkType', description='description: 目的实例的网络类型，取值：* **VPC**：VPC网络；* **Classic**：经典网络。默认创建经典网络类型的实例。>当本参数值为 **VPC**时，还需要传入参数**VpcId**、**VSwitchId**。; '),
  connectionMode?: string(name='ConnectionMode', description='description: 目的实例的访问模式，取值：* **Standard**：标准访问模式；* **Safe**：数据库代理模式。默认值：**Standard**。; '),
  VPCId?: string(name='VPCId', description='description: 目的实例的VPC ID。当**InstanceNetworkType**=**VPC**时，本参数可用。>如果传入此参数，您还需要传入参数**ZoneId**。; '),
  vSwitchId?: string(name='VSwitchId', description='description: 目的实例的VSwitch ID，多个值用英文逗号（,）隔开。当**InstanceNetworkType**=**VPC**时，本参数可用。>如果传入此参数，您还需要传入参数**ZoneId**。; '),
  privateIpAddress?: string(name='PrivateIpAddress', description='description: 设置目的实例的内网IP，需要在指定交换机的IP地址范围内。系统默认通过**VPCId**和**VSwitchId**自动分配。; '),
  usedTime?: string(name='UsedTime', description='description: 指定购买时长，取值：* 当参数**Period**为**Year**时，UsedTime取值为**1~3**；* 当参数**Period**为**Month**时，UsedTime取值为**1~9**。> 若付费类型为**Prepaid**则该参数必须传入。; '),
  period?: string(name='Period', description='description: 指定预付费目的实例为包年或者包月类型，取值：* **Year**：包年；* **Month**：包月。> 若付费类型为**Prepaid**则该参数必须传入。; '),
  resourceGroupId?: string(name='ResourceGroupId', description='description: 资源组ID。; '),
  restoreType: string(name='RestoreType', description='description: 恢复方式，取值：* **0**：基于备份集恢复，您还需要传入参数**BackupSetID**；* **1**：基于时间点恢复，您还需要传入参数**RestoreTime**、**SourceRegion**、**SourceDBInstanceName**。; '),
  backupSetId?: string(name='BackupSetId', description='description: 基于备份集恢复时，使用的备份集的ID。可以通过接口[DescribeCrossRegionBackups](~~121733~~)查看备份集ID。>**RestoreTyp**e=**0**时必传。; '),
  restoreTime?: string(name='RestoreTime', description='description: 基于时间点恢复时，要恢复的时间节点，需要早于当前时间。格式：<i>yyyy-MM-dd</i>T<i>HH:mm:ss</i>Z（UTC时间）。>**RestoreType**=**1**时必传 。; '),
  sourceRegion?: string(name='SourceRegion', description='description: 基于时间点恢复时，源地域的ID。>**RestoreType**=**1**时必传。; '),
  sourceDBInstanceName?: string(name='SourceDBInstanceName', description='description: 基于时间点恢复时，源实例的ID。>**RestoreType**=**1**时必传。; '),
  DBInstanceStorageType?: string(name='DBInstanceStorageType', description='description: 目的实例存储类型，当前仅支持SSD本地盘，默认值：**local_ssd**。; '),
  binlogName?: string(name='BinlogName'),
  binlogPosition?: string(name='BinlogPosition'),
  binlogRole?: string(name='BinlogRole'),
}

model CreateDdrInstanceResponse = {
  requestId: string(name='RequestId', description='description: 请求ID。; '),
  DBInstanceId: string(name='DBInstanceId', description='description: 新实例ID。; '),
  orderId: string(name='OrderId', description='description: 订单ID。; '),
  connectionString: string(name='ConnectionString', description='description: 新实例连接地址。>参数**DBInstanceNetType**决定该地址为内网或外网。; '),
  port: string(name='Port', description='description: 新实例连接端口。>参数**DBInstanceNetType**决定该端口为内网端口或外网端口。; '),
}

/**
 * CreateDdrInstance 调用CreateDdrInstance接口跨地域恢复数据到新实例。
  * request demo:   * ```
  * http(s)://rds.aliyuncs.com/?Action==CreateDdrInstance
  * &RegionId=cn-hangzhou
  * &Engine=MySQL
  * &EngineVersion=5.6
  * &DBInstanceClass=rds.mysql.s1.small
  * &DBInstanceStorage=20
  * &DBInstanceNetType=Intranet
  * &PayType=Prepaid
  * &RestoreType=0
  * &SecurityIPList=127.0.0.1
  * &BackupSetId=14358
  * &<公共请求参数>
  * ```
  * description:   * 恢复前可以调用[CheckCreateDdrDBInstance](~~121721~~)接口预检查某RDS实例是否可以用跨地域备份集进行跨地域恢复。
  * 仅适用于如下实例：
  * * MySQL 5.7高可用本地SSD盘版
  * * MySQL 5.6

 */
async function createDdrInstanceWithOptions(request: CreateDdrInstanceRequest, runtime: Util.RuntimeOptions): CreateDdrInstanceResponse {
  Util.validateModel(request);
  return doRequest('CreateDdrInstance', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

/**
 * CreateDdrInstance 调用CreateDdrInstance接口跨地域恢复数据到新实例。
  * request demo:   * ```
  * http(s)://rds.aliyuncs.com/?Action==CreateDdrInstance
  * &RegionId=cn-hangzhou
  * &Engine=MySQL
  * &EngineVersion=5.6
  * &DBInstanceClass=rds.mysql.s1.small
  * &DBInstanceStorage=20
  * &DBInstanceNetType=Intranet
  * &PayType=Prepaid
  * &RestoreType=0
  * &SecurityIPList=127.0.0.1
  * &BackupSetId=14358
  * &<公共请求参数>
  * ```
  * description:   * 恢复前可以调用[CheckCreateDdrDBInstance](~~121721~~)接口预检查某RDS实例是否可以用跨地域备份集进行跨地域恢复。
  * 仅适用于如下实例：
  * * MySQL 5.7高可用本地SSD盘版
  * * MySQL 5.6

 */
async function createDdrInstance(request: CreateDdrInstanceRequest): CreateDdrInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDdrInstanceWithOptions(request, runtime);
}

model DescribeCrossRegionBackupDBInstanceRequest = {
  regionId: string(name='RegionId'),
  DBInstanceId?: string(name='DBInstanceId'),
  pageSize?: integer(name='PageSize'),
  pageNumber?: integer(name='PageNumber'),
}

model DescribeCrossRegionBackupDBInstanceResponse = {
  requestId: string(name='RequestId'),
  regionId: string(name='RegionId'),
  totalRecords: integer(name='TotalRecords'),
  pageSize: integer(name='PageSize'),
  pageNumber: integer(name='PageNumber'),
  itemsNumbers: integer(name='ItemsNumbers'),
  items: {
    item: [
      {
        DBInstanceId: string(name='DBInstanceId'),
        DBInstanceDescription: string(name='DBInstanceDescription'),
        DBInstanceStatus: string(name='DBInstanceStatus'),
        DBInstanceStatusDesc: string(name='DBInstanceStatusDesc'),
        engine: string(name='Engine'),
        engineVersion: string(name='EngineVersion'),
        crossBackupRegion: string(name='CrossBackupRegion'),
        crossBackupType: string(name='CrossBackupType'),
        backupEnabled: string(name='BackupEnabled'),
        logBackupEnabled: string(name='LogBackupEnabled'),
        logBackupEnabledTime: string(name='LogBackupEnabledTime'),
        backupEnabledTime: string(name='BackupEnabledTime'),
        retentType: integer(name='RetentType'),
        retention: integer(name='Retention'),
        lockMode: string(name='LockMode'),
        relService: string(name='RelService'),
        relServiceId: string(name='RelServiceId'),
      }
    ](name='Item'),
  }(name='Items'),
}

async function describeCrossRegionBackupDBInstanceWithOptions(request: DescribeCrossRegionBackupDBInstanceRequest, runtime: Util.RuntimeOptions): DescribeCrossRegionBackupDBInstanceResponse {
  Util.validateModel(request);
  return doRequest('DescribeCrossRegionBackupDBInstance', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeCrossRegionBackupDBInstance(request: DescribeCrossRegionBackupDBInstanceRequest): DescribeCrossRegionBackupDBInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCrossRegionBackupDBInstanceWithOptions(request, runtime);
}

model DescribeInstanceCrossBackupPolicyRequest = {
  DBInstanceId: string(name='DBInstanceId', description='description: 实例ID。; '),
  regionId: string(name='RegionId', description='description: 地域ID，可以通过接口[DescribeRegions](~~26243~~)查看地域ID。; '),
}

model DescribeInstanceCrossBackupPolicyResponse = {
  requestId: string(name='RequestId', description='description: 请求ID。; '),
  DBInstanceId: string(name='DBInstanceId', description='description: 实例ID。; '),
  DBInstanceDescription: string(name='DBInstanceDescription', description='description: 实例名称，长度为2~256个字符。以中文、英文字母开头，可以包含数字、中文、英文、下划线（_）、短横线（-）。>不能以 http:// 和 https:// 开头。; '),
  DBInstanceStatus: string(name='DBInstanceStatus', description='description: 实例状态。详情请参见[实例状态表](~~26315~~)。; '),
  DBInstanceStatusDesc: string(name='DBInstanceStatusDesc'),
  engine: string(name='Engine', description='description: 数据库类型。; '),
  engineVersion: string(name='EngineVersion', description='description: 数据库版本。; '),
  regionId: string(name='RegionId', description='description: 实例所在地域ID。; '),
  crossBackupRegion: string(name='CrossBackupRegion', description='description: 跨地域备份的目的地域ID。; '),
  crossBackupType: string(name='CrossBackupType', description='description: 跨地域备份保存类型。默认值：**1**，表示每个备份都保存。; '),
  backupEnabledTime: string(name='BackupEnabledTime', description='description: 跨地域备份开启时间。格式：<i>yyyy-MM-dd</i>T<i>HH:mm:ss</i>Z（UTC时间）。; '),
  backupEnabled: string(name='BackupEnabled', description='description: 跨地域备份总开关，取值：* **Disable**：关闭；* **Enable**：开启。; '),
  logBackupEnabled: string(name='LogBackupEnabled', description='description: 跨地域日志备份开关，取值：* **Disable**：关闭；* **Enable**：开启。; '),
  logBackupEnabledTime: string(name='LogBackupEnabledTime', description='description: 跨地域日志备份开启时间。格式：<i>yyyy-MM-dd</i>T<i>HH:mm:ss</i>Z（UTC时间）。; '),
  storageOwner: string(name='StorageOwner'),
  storageType: string(name='StorageType'),
  endpoint: string(name='Endpoint'),
  retentType: integer(name='RetentType', description='description: 跨地域备份保留方式。默认值：**1**，表示按时长保留。; '),
  retention: integer(name='Retention', description='description: 跨地域备份保留天数，取值：**7~1825**。; '),
  lockMode: string(name='LockMode', description='description: 实例锁定状态，取值：* **Unlock**：正常，没有锁定；* **ManualLock**：手动触发锁定；* **LockByExpiration**：实例过期自动锁定；* **LockByRestoration**：实例回滚前的自动锁定；* **LockByDiskQuota**：实例空间满自动锁定，不可访问实例。; '),
  relService: string(name='RelService'),
  relServiceId: string(name='RelServiceId'),
}

/**
 * DescribeInstanceCrossBackupPolicy 调用DescribeInstanceCrossBackupPolicy接口查询跨地域备份设置。
  * request demo:   * ```
  * http(s)://rds.aliyuncs.com/?Action=DescribeInstanceCrossBackupPolicy
  * &DBInstanceId=rm-uf6wjk5xxxxxxxxxx
  * &<公共请求参数>
  * ```
  * description:   * 仅适用于如下实例：
  * * MySQL 5.7高可用本地SSD盘版
  * * MySQL 5.6

 */
async function describeInstanceCrossBackupPolicyWithOptions(request: DescribeInstanceCrossBackupPolicyRequest, runtime: Util.RuntimeOptions): DescribeInstanceCrossBackupPolicyResponse {
  Util.validateModel(request);
  return doRequest('DescribeInstanceCrossBackupPolicy', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

/**
 * DescribeInstanceCrossBackupPolicy 调用DescribeInstanceCrossBackupPolicy接口查询跨地域备份设置。
  * request demo:   * ```
  * http(s)://rds.aliyuncs.com/?Action=DescribeInstanceCrossBackupPolicy
  * &DBInstanceId=rm-uf6wjk5xxxxxxxxxx
  * &<公共请求参数>
  * ```
  * description:   * 仅适用于如下实例：
  * * MySQL 5.7高可用本地SSD盘版
  * * MySQL 5.6

 */
async function describeInstanceCrossBackupPolicy(request: DescribeInstanceCrossBackupPolicyRequest): DescribeInstanceCrossBackupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceCrossBackupPolicyWithOptions(request, runtime);
}

model DescribeCrossRegionBackupsRequest = {
  DBInstanceId: string(name='DBInstanceId', description='description: 实例ID。; '),
  regionId: string(name='RegionId', description='description: 实例所在地域ID。; '),
  crossBackupRegion?: string(name='CrossBackupRegion', description='description: 跨地域备份目的地域ID。; '),
  crossBackupId?: integer(name='CrossBackupId', description='description: 跨地域备份文件ID。>**CrossBackupId**和起止时间参数（**StartTime**、**EndTime**）必须传入其中一组。; '),
  startTime?: string(name='StartTime', description='description: 查询开始时间。格式：<i>yyyy-MM-dd</i>T<i>HH:mm</i>Z（UTC时间）。; '),
  endTime?: string(name='EndTime', description='description: 查询结束时间。格式：<i>yyyy-MM-dd</i>T<i>HH:mm</i>Z（UTC时间）。; '),
  pageSize?: integer(name='PageSize', description='description: 每页记录数，取值：* **30**；* **50**；* **100**。默认值：30。; '),
  pageNumber?: integer(name='PageNumber', description='description: 页码，取值：大于0且不超过Integer的最大值。默认值：**1**。; '),
  backupId?: integer(name='BackupId'),
}

model DescribeCrossRegionBackupsResponse = {
  requestId: string(name='RequestId', description='description: 请求ID。; '),
  regionId: string(name='RegionId', description='description: 实例所在地域ID。; '),
  startTime: string(name='StartTime', description='description: 查询开始时间。格式：<i>yyyy-MM-dd</i>T<i>HH:mm</i>Z（UTC时间）。; '),
  endTime: string(name='EndTime', description='description: 查询结束时间。格式：<i>yyyy-MM-dd</i>T<i>HH:mm</i>Z（UTC时间）。; '),
  totalRecordCount: integer(name='TotalRecordCount', description='description: 总记录数。; '),
  pageRecordCount: integer(name='PageRecordCount', description='description: 本页备份文件个数。; '),
  pageNumber: integer(name='PageNumber', description='description: 页码，取值：大于0且不超过Integer的最大值。默认值：**1**。; '),
  items: {
    item: [
      {
        crossBackupId: integer(name='CrossBackupId', description='description: 跨地域备份文件ID。; '),
        crossBackupRegion: string(name='CrossBackupRegion', description='description: 跨地域备份的目的地域ID。; '),
        backupSetStatus: integer(name='BackupSetStatus', description='description: 备份文件状态，取值：* **0**：完成备份；* **1**：备份失败。; '),
        backupStartTime: string(name='BackupStartTime', description='description: 跨地域备份开始时间。格式：<i>yyyy-MM-dd</i>T<i>HH:mm</i>Z（UTC时间）。; '),
        backupEndTime: string(name='BackupEndTime', description='description: 跨地域备份结束时间。格式：<i>yyyy-MM-dd</i>T<i>HH:mm</i>Z（UTC时间）。; '),
        backupType: string(name='BackupType', description='description: 跨地域备份类型，取值：* **F**：全量；* **I**：增量。; '),
        backupMethod: string(name='BackupMethod', description='description: 跨地域备份方式，取值：* **L**：逻辑备份；* **P**：物理备份。; '),
        crossBackupSetSize: long(name='CrossBackupSetSize', description='description: 跨地域备份文件大小，单位：Byte。; '),
        crossBackupSetFile: string(name='CrossBackupSetFile', description='description: 跨地域备份文件压缩包名称。; '),
        crossBackupDownloadLink: string(name='CrossBackupDownloadLink', description='description: 跨地域备份文件外网下载链接。; '),
        engine: string(name='Engine', description='description: 数据库类型。; '),
        engineVersion: string(name='EngineVersion', description='description: 数据库版本。; '),
        crossBackupSetLocation: string(name='CrossBackupSetLocation', description='description: 备份文件存储位置。; '),
        backupSetScale: integer(name='BackupSetScale', description='description: 备份文件的备份策略，取值：* **0**：实例备份；* **1**：单库备份。; '),
        instanceId: integer(name='InstanceId', description='description: 实例编号。用于区分该备份集产生于主实例或备实例。; '),
        DBInstanceStorageType: string(name='DBInstanceStorageType', description='description: 存储类型。; '),
        category: string(name='Category', description='description: 实例系列，取值：* **Basic**：基础版；* **HighAvailability**：高可用版；* **Finance**：金融版（仅中国站支持）。; '),
        consistentTime: string(name='ConsistentTime', description='description: 备份文件里数据的时间点。; '),
        hasBackupTableMeta: string(name='HasBackupTableMeta'),
        restoreRegions: {
          restoreRegion: [ string ](name='RestoreRegion', description='RestoreRegion'),
        }(name='RestoreRegions'),
      }
    ](name='Item'),
  }(name='Items', description='description: 跨地域备份列表。'),
}

/**
 * DescribeCrossRegionBackups 调用DescribeCrossRegionBackups接口查看某RDS实例跨地域数据备份文件列表。
  * request demo:   * ```
  * http(s)://rds.aliyuncs.com/?Action=DescribeCrossRegionBackups
  * &DBInstanceId=rm-uf6wjk5xxxxxxxxxx
  * &CrossBackupId=14562
  * &<公共请求参数>
  * ```
  * description:   * 查看日志备份文件请参见[DescribeCrossRegionLogBackupFiles](~~121734~~)。
  * 仅适用于如下实例：
  * * MySQL 5.7高可用本地SSD盘版
  * * MySQL 5.6

 */
async function describeCrossRegionBackupsWithOptions(request: DescribeCrossRegionBackupsRequest, runtime: Util.RuntimeOptions): DescribeCrossRegionBackupsResponse {
  Util.validateModel(request);
  return doRequest('DescribeCrossRegionBackups', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

/**
 * DescribeCrossRegionBackups 调用DescribeCrossRegionBackups接口查看某RDS实例跨地域数据备份文件列表。
  * request demo:   * ```
  * http(s)://rds.aliyuncs.com/?Action=DescribeCrossRegionBackups
  * &DBInstanceId=rm-uf6wjk5xxxxxxxxxx
  * &CrossBackupId=14562
  * &<公共请求参数>
  * ```
  * description:   * 查看日志备份文件请参见[DescribeCrossRegionLogBackupFiles](~~121734~~)。
  * 仅适用于如下实例：
  * * MySQL 5.7高可用本地SSD盘版
  * * MySQL 5.6

 */
async function describeCrossRegionBackups(request: DescribeCrossRegionBackupsRequest): DescribeCrossRegionBackupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCrossRegionBackupsWithOptions(request, runtime);
}

model CheckCloudResourceAuthorizedRequest = {
  securityToken?: string(name='SecurityToken'),
  regionId?: string(name='RegionId'),
  DBInstanceId?: string(name='DBInstanceId'),
  targetRegionId?: string(name='TargetRegionId'),
}

model CheckCloudResourceAuthorizedResponse = {
  requestId: string(name='RequestId'),
  authorizationState: integer(name='AuthorizationState'),
  roleArn: string(name='RoleArn'),
}

async function checkCloudResourceAuthorizedWithOptions(request: CheckCloudResourceAuthorizedRequest, runtime: Util.RuntimeOptions): CheckCloudResourceAuthorizedResponse {
  Util.validateModel(request);
  return doRequest('CheckCloudResourceAuthorized', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function checkCloudResourceAuthorized(request: CheckCloudResourceAuthorizedRequest): CheckCloudResourceAuthorizedResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkCloudResourceAuthorizedWithOptions(request, runtime);
}

model DescribeReadDBInstanceDelayRequest = {
  securityToken?: string(name='SecurityToken'),
  DBInstanceId: string(name='DBInstanceId'),
  readInstanceId: string(name='ReadInstanceId'),
}

model DescribeReadDBInstanceDelayResponse = {
  requestId: string(name='RequestId'),
  DBInstanceId: string(name='DBInstanceId'),
  readDBInstanceId: string(name='ReadDBInstanceId'),
  delayTime: integer(name='DelayTime'),
  items: {
    items: [
      {
        DBInstanceId: string(name='DBInstanceId'),
        readonlyInstanceDelay: {
          readonlyInstanceDelay: [
            {
              replayLatency: string(name='ReplayLatency'),
              flushLag: string(name='FlushLag'),
              flushLatency: string(name='FlushLatency'),
              sendLatency: string(name='SendLatency'),
              writeLag: string(name='WriteLag'),
              replayLag: string(name='ReplayLag'),
              writeLatency: string(name='WriteLatency'),
              readDBInstanceName: string(name='ReadDBInstanceName'),
            }
          ](name='ReadonlyInstanceDelay'),
        }(name='ReadonlyInstanceDelay'),
        readDBInstanceNames: {
          readDBInstanceName: [ string ](name='ReadDBInstanceName', description='ReadDBInstanceName'),
        }(name='ReadDBInstanceNames'),
        readDelayTimes: {
          readDelayTime: [ string ](name='ReadDelayTime', description='ReadDelayTime'),
        }(name='ReadDelayTimes'),
      }
    ](name='Items'),
  }(name='Items'),
}

async function describeReadDBInstanceDelayWithOptions(request: DescribeReadDBInstanceDelayRequest, runtime: Util.RuntimeOptions): DescribeReadDBInstanceDelayResponse {
  Util.validateModel(request);
  return doRequest('DescribeReadDBInstanceDelay', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeReadDBInstanceDelay(request: DescribeReadDBInstanceDelayRequest): DescribeReadDBInstanceDelayResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeReadDBInstanceDelayWithOptions(request, runtime);
}

model RestoreTableRequest = {
  clientToken?: string(name='ClientToken'),
  DBInstanceId: string(name='DBInstanceId'),
  backupId?: string(name='BackupId'),
  restoreTime?: string(name='RestoreTime'),
  tableMeta: string(name='TableMeta'),
}

model RestoreTableResponse = {
  requestId: string(name='RequestId'),
}

async function restoreTableWithOptions(request: RestoreTableRequest, runtime: Util.RuntimeOptions): RestoreTableResponse {
  Util.validateModel(request);
  return doRequest('RestoreTable', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function restoreTable(request: RestoreTableRequest): RestoreTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return restoreTableWithOptions(request, runtime);
}

model CreateParameterGroupRequest = {
  regionId: string(name='RegionId'),
  parameterGroupName: string(name='ParameterGroupName'),
  engine: string(name='Engine'),
  engineVersion: string(name='EngineVersion'),
  parameters: string(name='Parameters'),
  parameterGroupDesc?: string(name='ParameterGroupDesc'),
}

model CreateParameterGroupResponse = {
  requestId: string(name='RequestId'),
}

async function createParameterGroupWithOptions(request: CreateParameterGroupRequest, runtime: Util.RuntimeOptions): CreateParameterGroupResponse {
  Util.validateModel(request);
  return doRequest('CreateParameterGroup', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function createParameterGroup(request: CreateParameterGroupRequest): CreateParameterGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createParameterGroupWithOptions(request, runtime);
}

model DescribeParameterGroupsRequest = {
  regionId: string(name='RegionId'),
}

model DescribeParameterGroupsResponse = {
  requestId: string(name='RequestId'),
  signalForOptimizeParams: boolean(name='SignalForOptimizeParams'),
  parameterGroups: {
    parameterGroup: [
      {
        parameterGroupType: integer(name='ParameterGroupType'),
        parameterGroupName: string(name='ParameterGroupName'),
        paramCounts: integer(name='ParamCounts'),
        parameterGroupDesc: string(name='ParameterGroupDesc'),
        forceRestart: integer(name='ForceRestart'),
        engine: string(name='Engine'),
        engineVersion: string(name='EngineVersion'),
        createTime: string(name='CreateTime'),
        updateTime: string(name='UpdateTime'),
        parameterGroupId: string(name='ParameterGroupId'),
      }
    ](name='ParameterGroup'),
  }(name='ParameterGroups'),
}

async function describeParameterGroupsWithOptions(request: DescribeParameterGroupsRequest, runtime: Util.RuntimeOptions): DescribeParameterGroupsResponse {
  Util.validateModel(request);
  return doRequest('DescribeParameterGroups', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeParameterGroups(request: DescribeParameterGroupsRequest): DescribeParameterGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeParameterGroupsWithOptions(request, runtime);
}

model CloneParameterGroupRequest = {
  regionId: string(name='RegionId'),
  targetRegionId: string(name='TargetRegionId'),
  parameterGroupId: string(name='ParameterGroupId'),
  parameterGroupName: string(name='ParameterGroupName'),
  parameterGroupDesc?: string(name='ParameterGroupDesc'),
}

model CloneParameterGroupResponse = {
  requestId: string(name='RequestId'),
}

async function cloneParameterGroupWithOptions(request: CloneParameterGroupRequest, runtime: Util.RuntimeOptions): CloneParameterGroupResponse {
  Util.validateModel(request);
  return doRequest('CloneParameterGroup', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function cloneParameterGroup(request: CloneParameterGroupRequest): CloneParameterGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return cloneParameterGroupWithOptions(request, runtime);
}

model DescribeParameterGroupRequest = {
  parameterGroupId: string(name='ParameterGroupId'),
  regionId: string(name='RegionId'),
}

model DescribeParameterGroupResponse = {
  requestId: string(name='RequestId'),
  paramGroup: {
    parameterGroup: [
      {
        parameterGroupType: integer(name='ParameterGroupType'),
        parameterGroupName: string(name='ParameterGroupName'),
        paramCounts: integer(name='ParamCounts'),
        parameterGroupDesc: string(name='ParameterGroupDesc'),
        forceRestart: integer(name='ForceRestart'),
        engine: string(name='Engine'),
        engineVersion: string(name='EngineVersion'),
        parameterGroupId: string(name='ParameterGroupId'),
        createTime: string(name='CreateTime'),
        updateTime: string(name='UpdateTime'),
        paramDetail: {
          parameterDetail: [
            {
              paramName: string(name='ParamName'),
              paramValue: string(name='ParamValue'),
            }
          ](name='ParameterDetail'),
        }(name='ParamDetail'),
      }
    ](name='ParameterGroup'),
  }(name='ParamGroup'),
}

async function describeParameterGroupWithOptions(request: DescribeParameterGroupRequest, runtime: Util.RuntimeOptions): DescribeParameterGroupResponse {
  Util.validateModel(request);
  return doRequest('DescribeParameterGroup', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeParameterGroup(request: DescribeParameterGroupRequest): DescribeParameterGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeParameterGroupWithOptions(request, runtime);
}

model ModifyParameterGroupRequest = {
  parameterGroupId: string(name='ParameterGroupId'),
  parameterGroupName?: string(name='ParameterGroupName'),
  parameterGroupDesc?: string(name='ParameterGroupDesc'),
  parameters?: string(name='Parameters'),
  regionId: string(name='RegionId'),
}

model ModifyParameterGroupResponse = {
  requestId: string(name='RequestId'),
}

async function modifyParameterGroupWithOptions(request: ModifyParameterGroupRequest, runtime: Util.RuntimeOptions): ModifyParameterGroupResponse {
  Util.validateModel(request);
  return doRequest('ModifyParameterGroup', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifyParameterGroup(request: ModifyParameterGroupRequest): ModifyParameterGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyParameterGroupWithOptions(request, runtime);
}

model DeleteParameterGroupRequest = {
  regionId: string(name='RegionId'),
  parameterGroupId: string(name='ParameterGroupId'),
}

model DeleteParameterGroupResponse = {
  requestId: string(name='RequestId'),
}

async function deleteParameterGroupWithOptions(request: DeleteParameterGroupRequest, runtime: Util.RuntimeOptions): DeleteParameterGroupResponse {
  Util.validateModel(request);
  return doRequest('DeleteParameterGroup', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function deleteParameterGroup(request: DeleteParameterGroupRequest): DeleteParameterGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteParameterGroupWithOptions(request, runtime);
}

model ModifySQLCollectorRetentionRequest = {
  securityToken?: string(name='SecurityToken'),
  DBInstanceId: string(name='DBInstanceId'),
  configValue: string(name='ConfigValue'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ModifySQLCollectorRetentionResponse = {
  requestId: string(name='RequestId'),
}

async function modifySQLCollectorRetentionWithOptions(request: ModifySQLCollectorRetentionRequest, runtime: Util.RuntimeOptions): ModifySQLCollectorRetentionResponse {
  Util.validateModel(request);
  return doRequest('ModifySQLCollectorRetention', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifySQLCollectorRetention(request: ModifySQLCollectorRetentionRequest): ModifySQLCollectorRetentionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySQLCollectorRetentionWithOptions(request, runtime);
}

model DescribeSQLCollectorRetentionRequest = {
  securityToken?: string(name='SecurityToken'),
  DBInstanceId: string(name='DBInstanceId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeSQLCollectorRetentionResponse = {
  requestId: string(name='RequestId'),
  configValue: string(name='ConfigValue'),
}

async function describeSQLCollectorRetentionWithOptions(request: DescribeSQLCollectorRetentionRequest, runtime: Util.RuntimeOptions): DescribeSQLCollectorRetentionResponse {
  Util.validateModel(request);
  return doRequest('DescribeSQLCollectorRetention', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeSQLCollectorRetention(request: DescribeSQLCollectorRetentionRequest): DescribeSQLCollectorRetentionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSQLCollectorRetentionWithOptions(request, runtime);
}

model CheckInstanceExistRequest = {
  DBInstanceId: string(name='DBInstanceId'),
}

model CheckInstanceExistResponse = {
  requestId: string(name='RequestId'),
  isExistInstance: boolean(name='IsExistInstance'),
}

async function checkInstanceExistWithOptions(request: CheckInstanceExistRequest, runtime: Util.RuntimeOptions): CheckInstanceExistResponse {
  Util.validateModel(request);
  return doRequest('CheckInstanceExist', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function checkInstanceExist(request: CheckInstanceExistRequest): CheckInstanceExistResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkInstanceExistWithOptions(request, runtime);
}

model DescribeLogBackupFilesRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  startTime: string(name='StartTime'),
  endTime: string(name='EndTime'),
  pageSize?: integer(name='PageSize'),
  pageNumber?: integer(name='PageNumber'),
}

model DescribeLogBackupFilesResponse = {
  requestId: string(name='RequestId'),
  totalRecordCount: integer(name='TotalRecordCount'),
  pageNumber: integer(name='PageNumber'),
  pageRecordCount: integer(name='PageRecordCount'),
  totalFileSize: long(name='TotalFileSize'),
  items: {
    binLogFile: [
      {
        fileSize: long(name='FileSize'),
        logBeginTime: string(name='LogBeginTime'),
        logEndTime: string(name='LogEndTime'),
        downloadLink: string(name='DownloadLink'),
        intranetDownloadLink: string(name='IntranetDownloadLink'),
        linkExpiredTime: string(name='LinkExpiredTime'),
      }
    ](name='BinLogFile'),
  }(name='Items'),
}

async function describeLogBackupFilesWithOptions(request: DescribeLogBackupFilesRequest, runtime: Util.RuntimeOptions): DescribeLogBackupFilesResponse {
  Util.validateModel(request);
  return doRequest('DescribeLogBackupFiles', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeLogBackupFiles(request: DescribeLogBackupFilesRequest): DescribeLogBackupFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLogBackupFilesWithOptions(request, runtime);
}

model MigrateSecurityIPModeRequest = {
  DBInstanceId: string(name='DBInstanceId', description='description: The ID of the instance. ; '),
}

model MigrateSecurityIPModeResponse = {
  requestId: string(name='RequestId', description='description: The ID of the request. ; '),
  DBInstanceId: string(name='DBInstanceId', description='description: The ID of the instance. ; '),
  securityIPMode: string(name='SecurityIPMode', description='description: The mode of the whitelist after the switch. Valid values:**safety**.; '),
}

/**
 * MigrateSecurityIPMode You can call this operation to switch a whitelist from normal mode to safe mode.
  * request demo:   * http(s)://rds.aliyuncs.com/? Action=MigrateSecurityIPMode
  * &DBInstanceId=rm-uf6wjk5xxxxxxx
  * &<Common request parameters>
  * description:   * * In normal mode, IP addresses in the whitelist apply to both classic networks and VPCs. In case of security risks, we recommend that you switch to safe mode.
  * * In safe mode, IP addresses in the whitelist are divided into VPC IP addresses and the IP addresses of classic networks and public networks.
  * > 
  * * Safe mode cannot be switched to normal mode.
  * * This operation is not applicable to SQL Server and MariaDB instances. 

 */
async function migrateSecurityIPModeWithOptions(request: MigrateSecurityIPModeRequest, runtime: Util.RuntimeOptions): MigrateSecurityIPModeResponse {
  Util.validateModel(request);
  return doRequest('MigrateSecurityIPMode', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

/**
 * MigrateSecurityIPMode You can call this operation to switch a whitelist from normal mode to safe mode.
  * request demo:   * http(s)://rds.aliyuncs.com/? Action=MigrateSecurityIPMode
  * &DBInstanceId=rm-uf6wjk5xxxxxxx
  * &<Common request parameters>
  * description:   * * In normal mode, IP addresses in the whitelist apply to both classic networks and VPCs. In case of security risks, we recommend that you switch to safe mode.
  * * In safe mode, IP addresses in the whitelist are divided into VPC IP addresses and the IP addresses of classic networks and public networks.
  * > 
  * * Safe mode cannot be switched to normal mode.
  * * This operation is not applicable to SQL Server and MariaDB instances. 

 */
async function migrateSecurityIPMode(request: MigrateSecurityIPModeRequest): MigrateSecurityIPModeResponse {
  var runtime = new Util.RuntimeOptions{};
  return migrateSecurityIPModeWithOptions(request, runtime);
}

model SwitchDBInstanceVpcRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  VPCId?: string(name='VPCId'),
  vSwitchId?: string(name='VSwitchId'),
  privateIpAddress?: string(name='PrivateIpAddress'),
}

model SwitchDBInstanceVpcResponse = {
  requestId: string(name='RequestId'),
}

async function switchDBInstanceVpcWithOptions(request: SwitchDBInstanceVpcRequest, runtime: Util.RuntimeOptions): SwitchDBInstanceVpcResponse {
  Util.validateModel(request);
  return doRequest('SwitchDBInstanceVpc', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function switchDBInstanceVpc(request: SwitchDBInstanceVpcRequest): SwitchDBInstanceVpcResponse {
  var runtime = new Util.RuntimeOptions{};
  return switchDBInstanceVpcWithOptions(request, runtime);
}

model DescribeCollationTimeZonesRequest = {
}

model DescribeCollationTimeZonesResponse = {
  requestId: string(name='RequestId'),
  collationTimeZones: {
    collationTimeZone: [
      {
        timeZone: string(name='TimeZone'),
        standardTimeOffset: string(name='StandardTimeOffset'),
        description: string(name='Description'),
      }
    ](name='CollationTimeZone'),
  }(name='CollationTimeZones'),
}

async function describeCollationTimeZonesWithOptions(request: DescribeCollationTimeZonesRequest, runtime: Util.RuntimeOptions): DescribeCollationTimeZonesResponse {
  Util.validateModel(request);
  return doRequest('DescribeCollationTimeZones', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeCollationTimeZones(request: DescribeCollationTimeZonesRequest): DescribeCollationTimeZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCollationTimeZonesWithOptions(request, runtime);
}

model DescribeInstanceKeywordsRequest = {
  key?: string(name='Key'),
}

model DescribeInstanceKeywordsResponse = {
  requestId: string(name='RequestId'),
  key: string(name='Key'),
  words: {
    word: [ string ](name='word'),
  }(name='Words'),
}

async function describeInstanceKeywordsWithOptions(request: DescribeInstanceKeywordsRequest, runtime: Util.RuntimeOptions): DescribeInstanceKeywordsResponse {
  Util.validateModel(request);
  return doRequest('DescribeInstanceKeywords', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeInstanceKeywords(request: DescribeInstanceKeywordsRequest): DescribeInstanceKeywordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceKeywordsWithOptions(request, runtime);
}

model ModifyCollationTimeZoneRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  collation?: string(name='Collation'),
  timezone?: string(name='Timezone'),
}

model ModifyCollationTimeZoneResponse = {
  requestId: string(name='RequestId'),
  DBInstanceId: string(name='DBInstanceId'),
  taskId: string(name='TaskId'),
  timezone: string(name='Timezone'),
  collation: string(name='Collation'),
}

async function modifyCollationTimeZoneWithOptions(request: ModifyCollationTimeZoneRequest, runtime: Util.RuntimeOptions): ModifyCollationTimeZoneResponse {
  Util.validateModel(request);
  return doRequest('ModifyCollationTimeZone', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifyCollationTimeZone(request: ModifyCollationTimeZoneRequest): ModifyCollationTimeZoneResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyCollationTimeZoneWithOptions(request, runtime);
}

model DescribeBackupDatabaseRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  backupId?: string(name='BackupId'),
}

model DescribeBackupDatabaseResponse = {
  requestId: string(name='RequestId'),
  databaseNames: string(name='DatabaseNames'),
}

async function describeBackupDatabaseWithOptions(request: DescribeBackupDatabaseRequest, runtime: Util.RuntimeOptions): DescribeBackupDatabaseResponse {
  Util.validateModel(request);
  return doRequest('DescribeBackupDatabase', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeBackupDatabase(request: DescribeBackupDatabaseRequest): DescribeBackupDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupDatabaseWithOptions(request, runtime);
}

model CopyDatabaseBetweenInstancesRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  targetDBInstanceId: string(name='TargetDBInstanceId'),
  dbNames: string(name='DbNames'),
  backupId?: string(name='BackupId'),
  restoreTime?: string(name='RestoreTime'),
  syncUserPrivilege?: string(name='SyncUserPrivilege'),
}

model CopyDatabaseBetweenInstancesResponse = {
  requestId: string(name='RequestId'),
  DBInstanceId: string(name='DBInstanceId'),
}

async function copyDatabaseBetweenInstancesWithOptions(request: CopyDatabaseBetweenInstancesRequest, runtime: Util.RuntimeOptions): CopyDatabaseBetweenInstancesResponse {
  Util.validateModel(request);
  return doRequest('CopyDatabaseBetweenInstances', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function copyDatabaseBetweenInstances(request: CopyDatabaseBetweenInstancesRequest): CopyDatabaseBetweenInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return copyDatabaseBetweenInstancesWithOptions(request, runtime);
}

model RecoveryDBInstanceRequest = {
  DBInstanceClass?: string(name='DBInstanceClass'),
  DBInstanceStorage?: integer(name='DBInstanceStorage'),
  payType?: string(name='PayType'),
  instanceNetworkType?: string(name='InstanceNetworkType'),
  DBInstanceId?: string(name='DBInstanceId'),
  targetDBInstanceId?: string(name='TargetDBInstanceId'),
  dbNames: string(name='DbNames'),
  backupId?: string(name='BackupId'),
  restoreTime?: string(name='RestoreTime'),
  VPCId?: string(name='VPCId'),
  vSwitchId?: string(name='VSwitchId'),
  privateIpAddress?: string(name='PrivateIpAddress'),
  usedTime?: string(name='UsedTime'),
  period?: string(name='Period'),
  DBInstanceStorageType?: string(name='DBInstanceStorageType'),
}

model RecoveryDBInstanceResponse = {
  requestId: string(name='RequestId'),
  DBInstanceId: string(name='DBInstanceId'),
  orderId: string(name='OrderId'),
}

async function recoveryDBInstanceWithOptions(request: RecoveryDBInstanceRequest, runtime: Util.RuntimeOptions): RecoveryDBInstanceResponse {
  Util.validateModel(request);
  return doRequest('RecoveryDBInstance', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function recoveryDBInstance(request: RecoveryDBInstanceRequest): RecoveryDBInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return recoveryDBInstanceWithOptions(request, runtime);
}

model DescribeAvailableResourceRequest = {
  regionId?: string(name='RegionId'),
  zoneId?: string(name='ZoneId'),
  instanceChargeType: string(name='InstanceChargeType'),
  engine?: string(name='Engine'),
  engineVersion?: string(name='EngineVersion'),
  DBInstanceClass?: string(name='DBInstanceClass'),
  orderType?: string(name='OrderType'),
  DBInstanceStorageType?: string(name='DBInstanceStorageType'),
  category?: string(name='Category'),
  dispenseMode?: integer(name='DispenseMode'),
}

model DescribeAvailableResourceResponse = {
  requestId: string(name='RequestId'),
  availableZones: {
    availableZone: [
      {
        regionId: string(name='RegionId'),
        zoneId: string(name='ZoneId'),
        status: string(name='Status'),
        networkTypes: string(name='NetworkTypes'),
        supportedEngines: {
          supportedEngine: [
            {
              engine: string(name='Engine'),
              supportedEngineVersions: {
                supportedEngineVersion: [
                  {
                    version: string(name='Version'),
                    supportedCategorys: {
                      supportedCategory: [
                        {
                          category: string(name='Category'),
                          supportedStorageTypes: {
                            supportedStorageType: [
                              {
                                storageType: string(name='StorageType'),
                                availableResources: {
                                  availableResource: [
                                    {
                                      DBInstanceClass: string(name='DBInstanceClass'),
                                      storageRange: string(name='StorageRange'),
                                      DBInstanceStorageRange: {
                                        max: integer(name='Max'),
                                        min: integer(name='Min'),
                                        step: integer(name='Step'),
                                      }(name='DBInstanceStorageRange'),
                                    }
                                  ](name='AvailableResource'),
                                }(name='AvailableResources'),
                              }
                            ](name='SupportedStorageType'),
                          }(name='SupportedStorageTypes'),
                        }
                      ](name='SupportedCategory'),
                    }(name='SupportedCategorys'),
                  }
                ](name='SupportedEngineVersion'),
              }(name='SupportedEngineVersions'),
            }
          ](name='SupportedEngine'),
        }(name='SupportedEngines'),
      }
    ](name='AvailableZone'),
  }(name='AvailableZones'),
}

async function describeAvailableResourceWithOptions(request: DescribeAvailableResourceRequest, runtime: Util.RuntimeOptions): DescribeAvailableResourceResponse {
  Util.validateModel(request);
  return doRequest('DescribeAvailableResource', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeAvailableResource(request: DescribeAvailableResourceRequest): DescribeAvailableResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAvailableResourceWithOptions(request, runtime);
}

model DestroyDBInstanceRequest = {
  clientToken?: string(name='ClientToken'),
  DBInstanceId: string(name='DBInstanceId'),
}

model DestroyDBInstanceResponse = {
  requestId: string(name='RequestId'),
}

async function destroyDBInstanceWithOptions(request: DestroyDBInstanceRequest, runtime: Util.RuntimeOptions): DestroyDBInstanceResponse {
  Util.validateModel(request);
  return doRequest('DestroyDBInstance', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function destroyDBInstance(request: DestroyDBInstanceRequest): DestroyDBInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return destroyDBInstanceWithOptions(request, runtime);
}

model ModifyReadonlyInstanceDelayReplicationTimeRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  readSQLReplicationTime: string(name='ReadSQLReplicationTime'),
}

model ModifyReadonlyInstanceDelayReplicationTimeResponse = {
  requestId: string(name='RequestId'),
  DBInstanceId: string(name='DBInstanceId'),
  readSQLReplicationTime: string(name='ReadSQLReplicationTime'),
  taskId: string(name='TaskId'),
}

async function modifyReadonlyInstanceDelayReplicationTimeWithOptions(request: ModifyReadonlyInstanceDelayReplicationTimeRequest, runtime: Util.RuntimeOptions): ModifyReadonlyInstanceDelayReplicationTimeResponse {
  Util.validateModel(request);
  return doRequest('ModifyReadonlyInstanceDelayReplicationTime', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifyReadonlyInstanceDelayReplicationTime(request: ModifyReadonlyInstanceDelayReplicationTimeRequest): ModifyReadonlyInstanceDelayReplicationTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyReadonlyInstanceDelayReplicationTimeWithOptions(request, runtime);
}

model DescribeDBInstanceProxyConfigurationRequest = {
  DBInstanceId: string(name='DBInstanceId'),
}

model DescribeDBInstanceProxyConfigurationResponse = {
  requestId: string(name='RequestId'),
  transparentSwitchConfiguration: string(name='TransparentSwitchConfiguration'),
  persistentConnectionsConfiguration: string(name='PersistentConnectionsConfiguration'),
  attacksProtectionConfiguration: string(name='AttacksProtectionConfiguration'),
}

async function describeDBInstanceProxyConfigurationWithOptions(request: DescribeDBInstanceProxyConfigurationRequest, runtime: Util.RuntimeOptions): DescribeDBInstanceProxyConfigurationResponse {
  Util.validateModel(request);
  return doRequest('DescribeDBInstanceProxyConfiguration', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeDBInstanceProxyConfiguration(request: DescribeDBInstanceProxyConfigurationRequest): DescribeDBInstanceProxyConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstanceProxyConfigurationWithOptions(request, runtime);
}

model CreateOnlineDatabaseTaskRequest = {
  clientToken?: string(name='ClientToken'),
  DBInstanceId: string(name='DBInstanceId'),
  DBName: string(name='DBName'),
  migrateTaskId: string(name='MigrateTaskId'),
  checkDBMode: string(name='CheckDBMode'),
}

model CreateOnlineDatabaseTaskResponse = {
  requestId: string(name='RequestId'),
}

async function createOnlineDatabaseTaskWithOptions(request: CreateOnlineDatabaseTaskRequest, runtime: Util.RuntimeOptions): CreateOnlineDatabaseTaskResponse {
  Util.validateModel(request);
  return doRequest('CreateOnlineDatabaseTask', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function createOnlineDatabaseTask(request: CreateOnlineDatabaseTaskRequest): CreateOnlineDatabaseTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOnlineDatabaseTaskWithOptions(request, runtime);
}

model UpgradeDBInstanceKernelVersionRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  upgradeTime?: string(name='UpgradeTime'),
  switchTime?: string(name='SwitchTime'),
  targetMinorVersion?: string(name='TargetMinorVersion'),
}

model UpgradeDBInstanceKernelVersionResponse = {
  requestId: string(name='RequestId'),
  DBInstanceName: string(name='DBInstanceName'),
  taskId: string(name='TaskId'),
  targetMinorVersion: string(name='TargetMinorVersion'),
}

async function upgradeDBInstanceKernelVersionWithOptions(request: UpgradeDBInstanceKernelVersionRequest, runtime: Util.RuntimeOptions): UpgradeDBInstanceKernelVersionResponse {
  Util.validateModel(request);
  return doRequest('UpgradeDBInstanceKernelVersion', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function upgradeDBInstanceKernelVersion(request: UpgradeDBInstanceKernelVersionRequest): UpgradeDBInstanceKernelVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeDBInstanceKernelVersionWithOptions(request, runtime);
}

model ModifyDBInstanceProxyConfigurationRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  proxyConfigurationKey: string(name='ProxyConfigurationKey'),
  proxyConfigurationValue: string(name='ProxyConfigurationValue'),
}

model ModifyDBInstanceProxyConfigurationResponse = {
  requestId: string(name='RequestId'),
}

async function modifyDBInstanceProxyConfigurationWithOptions(request: ModifyDBInstanceProxyConfigurationRequest, runtime: Util.RuntimeOptions): ModifyDBInstanceProxyConfigurationResponse {
  Util.validateModel(request);
  return doRequest('ModifyDBInstanceProxyConfiguration', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifyDBInstanceProxyConfiguration(request: ModifyDBInstanceProxyConfigurationRequest): ModifyDBInstanceProxyConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstanceProxyConfigurationWithOptions(request, runtime);
}

model DescribeSecurityGroupConfigurationRequest = {
  DBInstanceId: string(name='DBInstanceId'),
}

model DescribeSecurityGroupConfigurationResponse = {
  requestId: string(name='RequestId'),
  DBInstanceName: string(name='DBInstanceName'),
  items: {
    ecsSecurityGroupRelation: [
      {
        regionId: string(name='RegionId'),
        securityGroupId: string(name='SecurityGroupId'),
        networkType: string(name='NetworkType'),
      }
    ](name='EcsSecurityGroupRelation'),
  }(name='Items'),
}

async function describeSecurityGroupConfigurationWithOptions(request: DescribeSecurityGroupConfigurationRequest, runtime: Util.RuntimeOptions): DescribeSecurityGroupConfigurationResponse {
  Util.validateModel(request);
  return doRequest('DescribeSecurityGroupConfiguration', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeSecurityGroupConfiguration(request: DescribeSecurityGroupConfigurationRequest): DescribeSecurityGroupConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSecurityGroupConfigurationWithOptions(request, runtime);
}

model ModifySecurityGroupConfigurationRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  securityGroupId: string(name='SecurityGroupId'),
}

model ModifySecurityGroupConfigurationResponse = {
  requestId: string(name='RequestId'),
  DBInstanceName: string(name='DBInstanceName'),
  items: {
    ecsSecurityGroupRelation: [
      {
        regionId: string(name='RegionId'),
        securityGroupId: string(name='SecurityGroupId'),
        networkType: string(name='NetworkType'),
      }
    ](name='EcsSecurityGroupRelation'),
  }(name='Items'),
}

async function modifySecurityGroupConfigurationWithOptions(request: ModifySecurityGroupConfigurationRequest, runtime: Util.RuntimeOptions): ModifySecurityGroupConfigurationResponse {
  Util.validateModel(request);
  return doRequest('ModifySecurityGroupConfiguration', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifySecurityGroupConfiguration(request: ModifySecurityGroupConfigurationRequest): ModifySecurityGroupConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySecurityGroupConfigurationWithOptions(request, runtime);
}

model DescribeOssDownloadsForSQLServerRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  migrateTaskId: string(name='MigrateTaskId'),
}

model DescribeOssDownloadsForSQLServerResponse = {
  requestId: string(name='RequestId'),
  DBInstanceName: string(name='DBInstanceName'),
  migrateIaskId: string(name='MigrateIaskId'),
  items: {
    ossDownload: [
      {
        fileName: string(name='FileName'),
        createTime: string(name='CreateTime'),
        bakType: string(name='BakType'),
        fileSize: string(name='FileSize'),
        status: string(name='Status'),
        isAvail: string(name='IsAvail'),
        desc: string(name='Desc'),
      }
    ](name='OssDownload'),
  }(name='Items'),
}

async function describeOssDownloadsForSQLServerWithOptions(request: DescribeOssDownloadsForSQLServerRequest, runtime: Util.RuntimeOptions): DescribeOssDownloadsForSQLServerResponse {
  Util.validateModel(request);
  return doRequest('DescribeOssDownloadsForSQLServer', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeOssDownloadsForSQLServer(request: DescribeOssDownloadsForSQLServerRequest): DescribeOssDownloadsForSQLServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeOssDownloadsForSQLServerWithOptions(request, runtime);
}

model DescribeMigrateTasksForSQLServerRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  startTime: string(name='StartTime'),
  endTime: string(name='EndTime'),
  pageSize?: integer(name='PageSize'),
  pageNumber?: integer(name='PageNumber'),
}

model DescribeMigrateTasksForSQLServerResponse = {
  requestId: string(name='RequestId'),
  DBInstanceID: string(name='DBInstanceID'),
  DBInstanceName: string(name='DBInstanceName'),
  startTime: string(name='StartTime'),
  endTime: string(name='EndTime'),
  totalRecordCount: integer(name='TotalRecordCount'),
  pageNumber: integer(name='PageNumber'),
  pageRecordCount: integer(name='PageRecordCount'),
  items: {
    migrateTask: [
      {
        DBName: string(name='DBName'),
        migrateIaskId: string(name='MigrateIaskId'),
        createTime: string(name='CreateTime'),
        endTime: string(name='EndTime'),
        taskType: string(name='TaskType'),
        status: string(name='Status'),
        isDBReplaced: string(name='IsDBReplaced'),
        desc: string(name='Desc'),
      }
    ](name='MigrateTask'),
  }(name='Items'),
}

async function describeMigrateTasksForSQLServerWithOptions(request: DescribeMigrateTasksForSQLServerRequest, runtime: Util.RuntimeOptions): DescribeMigrateTasksForSQLServerResponse {
  Util.validateModel(request);
  return doRequest('DescribeMigrateTasksForSQLServer', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeMigrateTasksForSQLServer(request: DescribeMigrateTasksForSQLServerRequest): DescribeMigrateTasksForSQLServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMigrateTasksForSQLServerWithOptions(request, runtime);
}

model CreateMigrateTaskForSQLServerRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  DBName: string(name='DBName'),
  taskType: string(name='TaskType'),
  isOnlineDB: string(name='IsOnlineDB'),
  OSSUrls: string(name='OSSUrls'),
}

model CreateMigrateTaskForSQLServerResponse = {
  requestId: string(name='RequestId'),
  DBInstanceId: string(name='DBInstanceId'),
  DBInstanceName: string(name='DBInstanceName'),
  taskId: string(name='TaskId'),
  DBName: string(name='DBName'),
  migrateIaskId: string(name='MigrateIaskId'),
  taskType: string(name='TaskType'),
}

async function createMigrateTaskForSQLServerWithOptions(request: CreateMigrateTaskForSQLServerRequest, runtime: Util.RuntimeOptions): CreateMigrateTaskForSQLServerResponse {
  Util.validateModel(request);
  return doRequest('CreateMigrateTaskForSQLServer', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function createMigrateTaskForSQLServer(request: CreateMigrateTaskForSQLServerRequest): CreateMigrateTaskForSQLServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMigrateTaskForSQLServerWithOptions(request, runtime);
}

model CreateMigrateTaskRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  DBName: string(name='DBName'),
  backupMode: string(name='BackupMode'),
  isOnlineDB: string(name='IsOnlineDB'),
  checkDBMode?: string(name='CheckDBMode'),
  ossObjectPositions?: string(name='OssObjectPositions'),
  OSSUrls?: string(name='OSSUrls'),
  migrateTaskId?: string(name='MigrateTaskId'),
}

model CreateMigrateTaskResponse = {
  requestId: string(name='RequestId'),
  DBInstanceId: string(name='DBInstanceId'),
  taskId: string(name='TaskId'),
  DBName: string(name='DBName'),
  migrateTaskId: string(name='MigrateTaskId'),
  backupMode: string(name='BackupMode'),
}

async function createMigrateTaskWithOptions(request: CreateMigrateTaskRequest, runtime: Util.RuntimeOptions): CreateMigrateTaskResponse {
  Util.validateModel(request);
  return doRequest('CreateMigrateTask', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function createMigrateTask(request: CreateMigrateTaskRequest): CreateMigrateTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMigrateTaskWithOptions(request, runtime);
}

model DescribeOssDownloadsRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  migrateTaskId: string(name='MigrateTaskId'),
}

model DescribeOssDownloadsResponse = {
  requestId: string(name='RequestId'),
  DBInstanceId: string(name='DBInstanceId'),
  migrateTaskId: string(name='MigrateTaskId'),
  items: {
    ossDownload: [
      {
        fileName: string(name='FileName'),
        createTime: string(name='CreateTime'),
        endTime: string(name='EndTime'),
        backupMode: string(name='BackupMode'),
        fileSize: string(name='FileSize'),
        status: string(name='Status'),
        isAvailable: string(name='IsAvailable'),
        description: string(name='Description'),
      }
    ](name='OssDownload'),
  }(name='Items'),
}

async function describeOssDownloadsWithOptions(request: DescribeOssDownloadsRequest, runtime: Util.RuntimeOptions): DescribeOssDownloadsResponse {
  Util.validateModel(request);
  return doRequest('DescribeOssDownloads', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeOssDownloads(request: DescribeOssDownloadsRequest): DescribeOssDownloadsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeOssDownloadsWithOptions(request, runtime);
}

model DescribeMigrateTasksRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  startTime: string(name='StartTime'),
  endTime: string(name='EndTime'),
  pageSize?: integer(name='PageSize'),
  pageNumber?: integer(name='PageNumber'),
}

model DescribeMigrateTasksResponse = {
  requestId: string(name='RequestId'),
  DBInstanceId: string(name='DBInstanceId'),
  totalRecordCount: integer(name='TotalRecordCount'),
  pageNumber: integer(name='PageNumber'),
  pageRecordCount: integer(name='PageRecordCount'),
  items: {
    migrateTask: [
      {
        DBName: string(name='DBName'),
        migrateTaskId: string(name='MigrateTaskId'),
        createTime: string(name='CreateTime'),
        endTime: string(name='EndTime'),
        backupMode: string(name='BackupMode'),
        status: string(name='Status'),
        isDBReplaced: string(name='IsDBReplaced'),
        description: string(name='Description'),
      }
    ](name='MigrateTask'),
  }(name='Items'),
}

async function describeMigrateTasksWithOptions(request: DescribeMigrateTasksRequest, runtime: Util.RuntimeOptions): DescribeMigrateTasksResponse {
  Util.validateModel(request);
  return doRequest('DescribeMigrateTasks', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeMigrateTasks(request: DescribeMigrateTasksRequest): DescribeMigrateTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMigrateTasksWithOptions(request, runtime);
}

model CopyDatabaseRequest = {
}

model CopyDatabaseResponse = {
  DBName: string(name='DBName'),
  DBStatus: string(name='DBStatus'),
  taskId: string(name='TaskId'),
}

async function copyDatabaseWithOptions(request: CopyDatabaseRequest, runtime: Util.RuntimeOptions): CopyDatabaseResponse {
  Util.validateModel(request);
  return doRequest('CopyDatabase', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function copyDatabase(request: CopyDatabaseRequest): CopyDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return copyDatabaseWithOptions(request, runtime);
}

model ResetAccountRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  accountName: string(name='AccountName'),
  accountPassword: string(name='AccountPassword'),
}

model ResetAccountResponse = {
  requestId: string(name='RequestId'),
}

async function resetAccountWithOptions(request: ResetAccountRequest, runtime: Util.RuntimeOptions): ResetAccountResponse {
  Util.validateModel(request);
  return doRequest('ResetAccount', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function resetAccount(request: ResetAccountRequest): ResetAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetAccountWithOptions(request, runtime);
}

model DescribeDBInstancesAsCsvRequest = {
  regionId: string(name='RegionId'),
  DBInstanceId?: string(name='DBInstanceId'),
}

model DescribeDBInstancesAsCsvResponse = {
  requestId: string(name='RequestId'),
  items: {
    DBInstanceAttribute: [
      {
        DBInstanceId: string(name='DBInstanceId'),
        payType: string(name='PayType'),
        DBInstanceClassType: string(name='DBInstanceClassType'),
        DBInstanceType: string(name='DBInstanceType'),
        regionId: string(name='RegionId'),
        connectionString: string(name='ConnectionString'),
        port: string(name='Port'),
        engine: string(name='Engine'),
        engineVersion: string(name='EngineVersion'),
        DBInstanceClass: string(name='DBInstanceClass'),
        DBInstanceMemory: long(name='DBInstanceMemory'),
        DBInstanceStorage: integer(name='DBInstanceStorage'),
        DBInstanceNetType: string(name='DBInstanceNetType'),
        DBInstanceStatus: string(name='DBInstanceStatus'),
        DBInstanceDescription: string(name='DBInstanceDescription'),
        lockMode: string(name='LockMode'),
        lockReason: string(name='LockReason'),
        readDelayTime: string(name='ReadDelayTime'),
        DBMaxQuantity: integer(name='DBMaxQuantity'),
        accountMaxQuantity: integer(name='AccountMaxQuantity'),
        creationTime: string(name='CreationTime'),
        expireTime: string(name='ExpireTime'),
        maintainTime: string(name='MaintainTime'),
        availabilityValue: string(name='AvailabilityValue'),
        maxIOPS: integer(name='MaxIOPS'),
        maxConnections: integer(name='MaxConnections'),
        masterInstanceId: string(name='MasterInstanceId'),
        DBInstanceCPU: string(name='DBInstanceCPU'),
        incrementSourceDBInstanceId: string(name='IncrementSourceDBInstanceId'),
        guardDBInstanceId: string(name='GuardDBInstanceId'),
        tempDBInstanceId: string(name='TempDBInstanceId'),
        securityIPList: string(name='SecurityIPList'),
        zoneId: string(name='ZoneId'),
        instanceNetworkType: string(name='InstanceNetworkType'),
        category: string(name='Category'),
        accountType: string(name='AccountType'),
        supportUpgradeAccountType: string(name='SupportUpgradeAccountType'),
        vpcId: string(name='VpcId'),
        vSwitchId: string(name='VSwitchId'),
        connectionMode: string(name='ConnectionMode'),
        tags: string(name='Tags'),
      }
    ](name='DBInstanceAttribute'),
  }(name='Items'),
}

async function describeDBInstancesAsCsvWithOptions(request: DescribeDBInstancesAsCsvRequest, runtime: Util.RuntimeOptions): DescribeDBInstancesAsCsvResponse {
  Util.validateModel(request);
  return doRequest('DescribeDBInstancesAsCsv', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeDBInstancesAsCsv(request: DescribeDBInstancesAsCsvRequest): DescribeDBInstancesAsCsvResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstancesAsCsvWithOptions(request, runtime);
}

model ModifyDBInstanceNetworkExpireTimeRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  connectionString: string(name='ConnectionString'),
  classicExpiredDays: integer(name='ClassicExpiredDays'),
}

model ModifyDBInstanceNetworkExpireTimeResponse = {
  requestId: string(name='RequestId'),
}

async function modifyDBInstanceNetworkExpireTimeWithOptions(request: ModifyDBInstanceNetworkExpireTimeRequest, runtime: Util.RuntimeOptions): ModifyDBInstanceNetworkExpireTimeResponse {
  Util.validateModel(request);
  return doRequest('ModifyDBInstanceNetworkExpireTime', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifyDBInstanceNetworkExpireTime(request: ModifyDBInstanceNetworkExpireTimeRequest): ModifyDBInstanceNetworkExpireTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstanceNetworkExpireTimeWithOptions(request, runtime);
}

model ModifyResourceGroupRequest = {
  clientToken?: string(name='ClientToken'),
  DBInstanceId: string(name='DBInstanceId'),
  resourceGroupId: string(name='ResourceGroupId'),
}

model ModifyResourceGroupResponse = {
  requestId: string(name='RequestId'),
}

async function modifyResourceGroupWithOptions(request: ModifyResourceGroupRequest, runtime: Util.RuntimeOptions): ModifyResourceGroupResponse {
  Util.validateModel(request);
  return doRequest('ModifyResourceGroup', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifyResourceGroup(request: ModifyResourceGroupRequest): ModifyResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyResourceGroupWithOptions(request, runtime);
}

model DescribeRenewalPriceRequest = {
  clientToken?: string(name='ClientToken'),
  DBInstanceId: string(name='DBInstanceId'),
  regionId?: string(name='RegionId'),
  payType?: string(name='PayType'),
  DBInstanceClass?: string(name='DBInstanceClass'),
  usedTime: integer(name='UsedTime'),
  timeType: string(name='TimeType'),
  quantity?: integer(name='Quantity'),
  orderType?: string(name='OrderType'),
  businessInfo?: string(name='BusinessInfo'),
}

model DescribeRenewalPriceResponse = {
  requestId: string(name='RequestId'),
  rules: {
    rule: [
      {
        ruleId: long(name='RuleId'),
        name: string(name='Name'),
        description: string(name='Description'),
      }
    ](name='Rule'),
  }(name='Rules'),
  priceInfo: {
    currency: string(name='Currency'),
    originalPrice: float(name='OriginalPrice'),
    tradePrice: float(name='TradePrice'),
    discountPrice: float(name='DiscountPrice'),
    coupons: {
      coupon: [
        {
          couponNo: string(name='CouponNo'),
          name: string(name='Name'),
          description: string(name='Description'),
          isSelected: string(name='IsSelected'),
        }
      ](name='Coupon'),
    }(name='Coupons'),
    activityInfo: {
      checkErrMsg: string(name='CheckErrMsg'),
      errorCode: string(name='ErrorCode'),
      success: string(name='Success'),
    }(name='ActivityInfo'),
    ruleIds: {
      ruleId: [ string ](name='RuleId', description='RuleId'),
    }(name='RuleIds'),
  }(name='PriceInfo'),
}

async function describeRenewalPriceWithOptions(request: DescribeRenewalPriceRequest, runtime: Util.RuntimeOptions): DescribeRenewalPriceResponse {
  Util.validateModel(request);
  return doRequest('DescribeRenewalPrice', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeRenewalPrice(request: DescribeRenewalPriceRequest): DescribeRenewalPriceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRenewalPriceWithOptions(request, runtime);
}

model DescribePriceRequest = {
  clientToken?: string(name='ClientToken'),
  commodityCode?: string(name='CommodityCode'),
  regionId?: string(name='RegionId'),
  engine: string(name='Engine'),
  engineVersion: string(name='EngineVersion'),
  DBInstanceClass: string(name='DBInstanceClass'),
  DBInstanceStorage: integer(name='DBInstanceStorage'),
  payType?: string(name='PayType'),
  zoneId?: string(name='ZoneId'),
  usedTime?: integer(name='UsedTime'),
  timeType?: string(name='TimeType'),
  quantity: integer(name='Quantity'),
  instanceUsedType?: integer(name='InstanceUsedType'),
  orderType?: string(name='OrderType'),
  DBInstanceStorageType?: string(name='DBInstanceStorageType'),
  DBInstanceId?: string(name='DBInstanceId'),
}

model DescribePriceResponse = {
  requestId: string(name='RequestId'),
  rules: {
    rule: [
      {
        ruleId: long(name='RuleId'),
        name: string(name='Name'),
        description: string(name='Description'),
      }
    ](name='Rule'),
  }(name='Rules'),
  priceInfo: {
    currency: string(name='Currency'),
    originalPrice: float(name='OriginalPrice'),
    tradePrice: float(name='TradePrice'),
    discountPrice: float(name='DiscountPrice'),
    coupons: {
      coupon: [
        {
          couponNo: string(name='CouponNo'),
          name: string(name='Name'),
          description: string(name='Description'),
          isSelected: string(name='IsSelected'),
        }
      ](name='Coupon'),
    }(name='Coupons'),
    activityInfo: {
      checkErrMsg: string(name='CheckErrMsg'),
      errorCode: string(name='ErrorCode'),
      success: string(name='Success'),
    }(name='ActivityInfo'),
    ruleIds: {
      ruleId: [ string ](name='RuleId', description='RuleId'),
    }(name='RuleIds'),
  }(name='PriceInfo'),
}

async function describePriceWithOptions(request: DescribePriceRequest, runtime: Util.RuntimeOptions): DescribePriceResponse {
  Util.validateModel(request);
  return doRequest('DescribePrice', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describePrice(request: DescribePriceRequest): DescribePriceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePriceWithOptions(request, runtime);
}

model RenewInstanceRequest = {
  clientToken?: string(name='ClientToken'),
  DBInstanceId: string(name='DBInstanceId'),
  period: integer(name='Period'),
  autoPay?: string(name='AutoPay'),
}

model RenewInstanceResponse = {
  requestId: string(name='RequestId'),
  orderId: long(name='OrderId'),
}

async function renewInstanceWithOptions(request: RenewInstanceRequest, runtime: Util.RuntimeOptions): RenewInstanceResponse {
  Util.validateModel(request);
  return doRequest('RenewInstance', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function renewInstance(request: RenewInstanceRequest): RenewInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return renewInstanceWithOptions(request, runtime);
}

model CheckRecoveryConditionsRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  backupId?: string(name='BackupId'),
  backupFile?: string(name='BackupFile'),
  restoreTime?: string(name='RestoreTime'),
}

model CheckRecoveryConditionsResponse = {
  requestId: string(name='RequestId'),
  DBInstanceId: string(name='DBInstanceId'),
  recoveryStatus: string(name='RecoveryStatus'),
}

async function checkRecoveryConditionsWithOptions(request: CheckRecoveryConditionsRequest, runtime: Util.RuntimeOptions): CheckRecoveryConditionsResponse {
  Util.validateModel(request);
  return doRequest('CheckRecoveryConditions', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function checkRecoveryConditions(request: CheckRecoveryConditionsRequest): CheckRecoveryConditionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkRecoveryConditionsWithOptions(request, runtime);
}

model ModifyInstanceAutoRenewalAttributeRequest = {
  regionId: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  DBInstanceId: string(name='DBInstanceId'),
  duration?: string(name='Duration'),
  autoRenew?: string(name='AutoRenew'),
}

model ModifyInstanceAutoRenewalAttributeResponse = {
  requestId: string(name='RequestId'),
}

async function modifyInstanceAutoRenewalAttributeWithOptions(request: ModifyInstanceAutoRenewalAttributeRequest, runtime: Util.RuntimeOptions): ModifyInstanceAutoRenewalAttributeResponse {
  Util.validateModel(request);
  return doRequest('ModifyInstanceAutoRenewalAttribute', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifyInstanceAutoRenewalAttribute(request: ModifyInstanceAutoRenewalAttributeRequest): ModifyInstanceAutoRenewalAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyInstanceAutoRenewalAttributeWithOptions(request, runtime);
}

model DescribeInstanceAutoRenewalAttributeRequest = {
  clientToken?: string(name='ClientToken'),
  proxyId?: string(name='proxyId'),
  regionId: string(name='RegionId'),
  DBInstanceId?: string(name='DBInstanceId'),
  pageSize?: integer(name='PageSize'),
  pageNumber?: integer(name='PageNumber'),
}

model DescribeInstanceAutoRenewalAttributeResponse = {
  requestId: string(name='RequestId'),
  pageNumber: integer(name='PageNumber'),
  totalRecordCount: integer(name='TotalRecordCount'),
  pageRecordCount: integer(name='PageRecordCount'),
  items: {
    item: [
      {
        DBInstanceId: string(name='DBInstanceId'),
        regionId: string(name='RegionId'),
        duration: integer(name='Duration'),
        status: string(name='Status'),
        autoRenew: string(name='AutoRenew'),
      }
    ](name='Item'),
  }(name='Items'),
}

async function describeInstanceAutoRenewalAttributeWithOptions(request: DescribeInstanceAutoRenewalAttributeRequest, runtime: Util.RuntimeOptions): DescribeInstanceAutoRenewalAttributeResponse {
  Util.validateModel(request);
  return doRequest('DescribeInstanceAutoRenewalAttribute', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeInstanceAutoRenewalAttribute(request: DescribeInstanceAutoRenewalAttributeRequest): DescribeInstanceAutoRenewalAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceAutoRenewalAttributeWithOptions(request, runtime);
}

model ReleaseReadWriteSplittingConnectionRequest = {
  DBInstanceId: string(name='DBInstanceId'),
}

model ReleaseReadWriteSplittingConnectionResponse = {
  requestId: string(name='RequestId'),
}

async function releaseReadWriteSplittingConnectionWithOptions(request: ReleaseReadWriteSplittingConnectionRequest, runtime: Util.RuntimeOptions): ReleaseReadWriteSplittingConnectionResponse {
  Util.validateModel(request);
  return doRequest('ReleaseReadWriteSplittingConnection', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function releaseReadWriteSplittingConnection(request: ReleaseReadWriteSplittingConnectionRequest): ReleaseReadWriteSplittingConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return releaseReadWriteSplittingConnectionWithOptions(request, runtime);
}

model ModifyReadWriteSplittingConnectionRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  connectionStringPrefix?: string(name='ConnectionStringPrefix'),
  port?: string(name='Port'),
  maxDelayTime?: string(name='MaxDelayTime'),
  distributionType?: string(name='DistributionType'),
  weight?: string(name='Weight'),
}

model ModifyReadWriteSplittingConnectionResponse = {
  requestId: string(name='RequestId'),
}

async function modifyReadWriteSplittingConnectionWithOptions(request: ModifyReadWriteSplittingConnectionRequest, runtime: Util.RuntimeOptions): ModifyReadWriteSplittingConnectionResponse {
  Util.validateModel(request);
  return doRequest('ModifyReadWriteSplittingConnection', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifyReadWriteSplittingConnection(request: ModifyReadWriteSplittingConnectionRequest): ModifyReadWriteSplittingConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyReadWriteSplittingConnectionWithOptions(request, runtime);
}

model CalculateDBInstanceWeightRequest = {
  DBInstanceId: string(name='DBInstanceId'),
}

model CalculateDBInstanceWeightResponse = {
  requestId: string(name='RequestId'),
  items: {
    DBInstanceWeight: [
      {
        DBInstanceId: string(name='DBInstanceId'),
        DBInstanceType: string(name='DBInstanceType'),
        readonlyInstanceSQLDelayedTime: string(name='ReadonlyInstanceSQLDelayedTime'),
        availability: string(name='Availability'),
        weight: string(name='Weight'),
      }
    ](name='DBInstanceWeight'),
  }(name='Items'),
}

async function calculateDBInstanceWeightWithOptions(request: CalculateDBInstanceWeightRequest, runtime: Util.RuntimeOptions): CalculateDBInstanceWeightResponse {
  Util.validateModel(request);
  return doRequest('CalculateDBInstanceWeight', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function calculateDBInstanceWeight(request: CalculateDBInstanceWeightRequest): CalculateDBInstanceWeightResponse {
  var runtime = new Util.RuntimeOptions{};
  return calculateDBInstanceWeightWithOptions(request, runtime);
}

model AllocateReadWriteSplittingConnectionRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  connectionStringPrefix?: string(name='ConnectionStringPrefix'),
  port?: string(name='Port'),
  maxDelayTime?: string(name='MaxDelayTime'),
  netType?: string(name='NetType'),
  distributionType?: string(name='DistributionType'),
  weight?: string(name='Weight'),
}

model AllocateReadWriteSplittingConnectionResponse = {
  requestId: string(name='RequestId'),
}

async function allocateReadWriteSplittingConnectionWithOptions(request: AllocateReadWriteSplittingConnectionRequest, runtime: Util.RuntimeOptions): AllocateReadWriteSplittingConnectionResponse {
  Util.validateModel(request);
  return doRequest('AllocateReadWriteSplittingConnection', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function allocateReadWriteSplittingConnection(request: AllocateReadWriteSplittingConnectionRequest): AllocateReadWriteSplittingConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return allocateReadWriteSplittingConnectionWithOptions(request, runtime);
}

model ModifyDBInstancePayTypeRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  usedTime?: integer(name='UsedTime'),
  payType: string(name='PayType'),
  period: string(name='Period'),
}

model ModifyDBInstancePayTypeResponse = {
  requestId: string(name='RequestId'),
  DBInstanceId: string(name='DBInstanceId'),
  orderId: long(name='OrderId'),
}

async function modifyDBInstancePayTypeWithOptions(request: ModifyDBInstancePayTypeRequest, runtime: Util.RuntimeOptions): ModifyDBInstancePayTypeResponse {
  Util.validateModel(request);
  return doRequest('ModifyDBInstancePayType', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifyDBInstancePayType(request: ModifyDBInstancePayTypeRequest): ModifyDBInstancePayTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstancePayTypeWithOptions(request, runtime);
}

model DescribeCharacterSetNameRequest = {
  engine: string(name='Engine'),
  regionId: string(name='RegionId'),
}

model DescribeCharacterSetNameResponse = {
  requestId: string(name='RequestId'),
  engine: string(name='Engine'),
  characterSetNameItems: {
    characterSetName: [ string ](name='CharacterSetName'),
  }(name='CharacterSetNameItems'),
}

async function describeCharacterSetNameWithOptions(request: DescribeCharacterSetNameRequest, runtime: Util.RuntimeOptions): DescribeCharacterSetNameResponse {
  Util.validateModel(request);
  return doRequest('DescribeCharacterSetName', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeCharacterSetName(request: DescribeCharacterSetNameRequest): DescribeCharacterSetNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCharacterSetNameWithOptions(request, runtime);
}

model DeleteBackupRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  backupId: string(name='BackupId'),
}

model DeleteBackupResponse = {
  requestId: string(name='RequestId'),
}

async function deleteBackupWithOptions(request: DeleteBackupRequest, runtime: Util.RuntimeOptions): DeleteBackupResponse {
  Util.validateModel(request);
  return doRequest('DeleteBackup', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function deleteBackup(request: DeleteBackupRequest): DeleteBackupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBackupWithOptions(request, runtime);
}

model DescribeDiagnosticReportListRequest = {
  DBInstanceId: string(name='DBInstanceId'),
}

model DescribeDiagnosticReportListResponse = {
  requestId: string(name='RequestId'),
  reportList: [
    {
      diagnosticTime: string(name='DiagnosticTime'),
      score: integer(name='Score'),
      startTime: string(name='StartTime'),
      endTime: string(name='EndTime'),
      downloadURL: string(name='DownloadURL'),
    }
  ](name='ReportList'),
}

async function describeDiagnosticReportListWithOptions(request: DescribeDiagnosticReportListRequest, runtime: Util.RuntimeOptions): DescribeDiagnosticReportListResponse {
  Util.validateModel(request);
  return doRequest('DescribeDiagnosticReportList', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeDiagnosticReportList(request: DescribeDiagnosticReportListRequest): DescribeDiagnosticReportListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDiagnosticReportListWithOptions(request, runtime);
}

model CreateDiagnosticReportRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  startTime: string(name='StartTime'),
  endTime: string(name='EndTime'),
}

model CreateDiagnosticReportResponse = {
  requestId: string(name='RequestId'),
  reportId: string(name='ReportId'),
}

async function createDiagnosticReportWithOptions(request: CreateDiagnosticReportRequest, runtime: Util.RuntimeOptions): CreateDiagnosticReportResponse {
  Util.validateModel(request);
  return doRequest('CreateDiagnosticReport', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function createDiagnosticReport(request: CreateDiagnosticReportRequest): CreateDiagnosticReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDiagnosticReportWithOptions(request, runtime);
}

model CloneDBInstanceRequest = {
  regionId?: string(name='RegionId'),
  zoneId?: string(name='ZoneId'),
  DBInstanceClass?: string(name='DBInstanceClass'),
  DBInstanceStorage?: integer(name='DBInstanceStorage'),
  dbNames?: string(name='DbNames'),
  payType: string(name='PayType'),
  instanceNetworkType?: string(name='InstanceNetworkType'),
  DBInstanceId: string(name='DBInstanceId'),
  backupId?: string(name='BackupId'),
  restoreTime?: string(name='RestoreTime'),
  VPCId?: string(name='VPCId'),
  vSwitchId?: string(name='VSwitchId'),
  privateIpAddress?: string(name='PrivateIpAddress'),
  usedTime?: integer(name='UsedTime'),
  period?: string(name='Period'),
  category?: string(name='Category'),
  DBInstanceStorageType?: string(name='DBInstanceStorageType'),
  restoreTable?: string(name='RestoreTable'),
  tableMeta?: string(name='TableMeta'),
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
  backupType?: string(name='BackupType'),
}

model CloneDBInstanceResponse = {
  requestId: string(name='RequestId'),
  DBInstanceId: string(name='DBInstanceId'),
  orderId: string(name='OrderId'),
  connectionString: string(name='ConnectionString'),
  port: string(name='Port'),
}

async function cloneDBInstanceWithOptions(request: CloneDBInstanceRequest, runtime: Util.RuntimeOptions): CloneDBInstanceResponse {
  Util.validateModel(request);
  return doRequest('CloneDBInstance', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function cloneDBInstance(request: CloneDBInstanceRequest): CloneDBInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return cloneDBInstanceWithOptions(request, runtime);
}

model DescribeTagsRequest = {
  clientToken?: string(name='ClientToken', description='description: 用于保证请求的幂等性，防止重复提交请求。由客户端生成该参数值，要保证在不同请求间唯一，最大值不超过64个ASCII字符，且该参数值中不能包含非ASCII字符。; '),
  proxyId?: string(name='proxyId', description='description: 代理模式ID。; '),
  regionId: string(name='RegionId', description='description: 地域ID，可以通过接口[DescribeRegions](~~26243~~)查看可用的地域ID。; '),
  DBInstanceId?: string(name='DBInstanceId', description='description: 实例ID。>传入该参数，其他过滤条件失效。; '),
  tags?: string(name='Tags', description='description: 需要查询的标签，包括TagKey和TagValue。格式：{“key1”:”value1”}。; '),
}

model DescribeTagsResponse = {
  requestId: string(name='RequestId', description='description: 请求ID。; '),
  items: {
    tagInfos: [
      {
        tagKey: string(name='TagKey', description='description: 标签键。; '),
        tagValue: string(name='TagValue', description='description: 标签值。; '),
        DBInstanceIds: {
          DBInstanceIds: [ string ](name='DBInstanceIds', description='DBInstanceIds'),
        }(name='DBInstanceIds'),
      }
    ](name='TagInfos'),
  }(name='Items', description='description: 由Tag信息组成的数组。'),
}

/**
 * DescribeTags 调用DescribeTags接口查询RDS实例的标签。
  * request demo:   * ```
  * http(s)://rds.aliyuncs.com/?Action=DescribeTags
  * &RegionId=cn-hangzhou
  * &<公共请求参数>
  * ```
  * description:   * 调用本接口时限制条件如下：
  * * 如果传入指定实例ID，则查询该实例下所有标签，其他过滤条件失效；
  * * 若查询标签时仅传入标签键（TagKey），未传入标签值（TagValue），则返回所有符合标签键条件的结果。若同时传入标签键和标签值，则返回两个条件都符合的结果。

 */
async function describeTagsWithOptions(request: DescribeTagsRequest, runtime: Util.RuntimeOptions): DescribeTagsResponse {
  Util.validateModel(request);
  return doRequest('DescribeTags', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

/**
 * DescribeTags 调用DescribeTags接口查询RDS实例的标签。
  * request demo:   * ```
  * http(s)://rds.aliyuncs.com/?Action=DescribeTags
  * &RegionId=cn-hangzhou
  * &<公共请求参数>
  * ```
  * description:   * 调用本接口时限制条件如下：
  * * 如果传入指定实例ID，则查询该实例下所有标签，其他过滤条件失效；
  * * 若查询标签时仅传入标签键（TagKey），未传入标签值（TagValue），则返回所有符合标签键条件的结果。若同时传入标签键和标签值，则返回两个条件都符合的结果。

 */
async function describeTags(request: DescribeTagsRequest): DescribeTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTagsWithOptions(request, runtime);
}

model DescribeDBInstanceByTagsRequest = {
  clientToken?: string(name='ClientToken'),
  proxyId?: string(name='proxyId'),
  regionId: string(name='RegionId'),
  DBInstanceId?: string(name='DBInstanceId'),
  pageSize?: integer(name='PageSize'),
  pageNumber?: integer(name='PageNumber'),
}

model DescribeDBInstanceByTagsResponse = {
  requestId: string(name='RequestId'),
  pageNumber: integer(name='PageNumber'),
  pageRecordCount: integer(name='PageRecordCount'),
  totalRecordCount: integer(name='TotalRecordCount'),
  items: {
    DBInstanceTag: [
      {
        DBInstanceId: string(name='DBInstanceId'),
        tags: {
          tag: [
            {
              tagKey: string(name='TagKey'),
              tagValue: string(name='TagValue'),
            }
          ](name='Tag'),
        }(name='Tags'),
      }
    ](name='DBInstanceTag'),
  }(name='Items'),
}

async function describeDBInstanceByTagsWithOptions(request: DescribeDBInstanceByTagsRequest, runtime: Util.RuntimeOptions): DescribeDBInstanceByTagsResponse {
  Util.validateModel(request);
  return doRequest('DescribeDBInstanceByTags', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeDBInstanceByTags(request: DescribeDBInstanceByTagsRequest): DescribeDBInstanceByTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstanceByTagsWithOptions(request, runtime);
}

model RevokeOperatorPermissionRequest = {
  DBInstanceId: string(name='DBInstanceId'),
}

model RevokeOperatorPermissionResponse = {
  requestId: string(name='RequestId'),
}

async function revokeOperatorPermissionWithOptions(request: RevokeOperatorPermissionRequest, runtime: Util.RuntimeOptions): RevokeOperatorPermissionResponse {
  Util.validateModel(request);
  return doRequest('RevokeOperatorPermission', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function revokeOperatorPermission(request: RevokeOperatorPermissionRequest): RevokeOperatorPermissionResponse {
  var runtime = new Util.RuntimeOptions{};
  return revokeOperatorPermissionWithOptions(request, runtime);
}

model ModifyDBInstanceTDERequest = {
  DBInstanceId: string(name='DBInstanceId'),
  TDEStatus: string(name='TDEStatus'),
  DBName?: string(name='DBName'),
  encryptionKey?: string(name='EncryptionKey'),
  roleArn?: string(name='RoleArn'),
}

model ModifyDBInstanceTDEResponse = {
  requestId: string(name='RequestId'),
}

async function modifyDBInstanceTDEWithOptions(request: ModifyDBInstanceTDERequest, runtime: Util.RuntimeOptions): ModifyDBInstanceTDEResponse {
  Util.validateModel(request);
  return doRequest('ModifyDBInstanceTDE', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifyDBInstanceTDE(request: ModifyDBInstanceTDERequest): ModifyDBInstanceTDEResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstanceTDEWithOptions(request, runtime);
}

model ModifyDBInstanceSSLRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  connectionString: string(name='ConnectionString'),
  SSLEnabled?: integer(name='SSLEnabled'),
}

model ModifyDBInstanceSSLResponse = {
  requestId: string(name='RequestId'),
}

async function modifyDBInstanceSSLWithOptions(request: ModifyDBInstanceSSLRequest, runtime: Util.RuntimeOptions): ModifyDBInstanceSSLResponse {
  Util.validateModel(request);
  return doRequest('ModifyDBInstanceSSL', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifyDBInstanceSSL(request: ModifyDBInstanceSSLRequest): ModifyDBInstanceSSLResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstanceSSLWithOptions(request, runtime);
}

model GrantOperatorPermissionRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  expiredTime: string(name='ExpiredTime'),
  privileges: string(name='Privileges'),
}

model GrantOperatorPermissionResponse = {
  requestId: string(name='RequestId'),
}

async function grantOperatorPermissionWithOptions(request: GrantOperatorPermissionRequest, runtime: Util.RuntimeOptions): GrantOperatorPermissionResponse {
  Util.validateModel(request);
  return doRequest('GrantOperatorPermission', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function grantOperatorPermission(request: GrantOperatorPermissionRequest): GrantOperatorPermissionResponse {
  var runtime = new Util.RuntimeOptions{};
  return grantOperatorPermissionWithOptions(request, runtime);
}

model DescribeDBInstanceTDERequest = {
  DBInstanceId: string(name='DBInstanceId'),
}

model DescribeDBInstanceTDEResponse = {
  requestId: string(name='RequestId'),
  TDEStatus: string(name='TDEStatus'),
  databases: {
    database: [
      {
        DBName: string(name='DBName'),
        TDEStatus: string(name='TDEStatus'),
      }
    ](name='Database'),
  }(name='Databases'),
}

async function describeDBInstanceTDEWithOptions(request: DescribeDBInstanceTDERequest, runtime: Util.RuntimeOptions): DescribeDBInstanceTDEResponse {
  Util.validateModel(request);
  return doRequest('DescribeDBInstanceTDE', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeDBInstanceTDE(request: DescribeDBInstanceTDERequest): DescribeDBInstanceTDEResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstanceTDEWithOptions(request, runtime);
}

model DescribeDBInstanceSSLRequest = {
  DBInstanceId: string(name='DBInstanceId'),
}

model DescribeDBInstanceSSLResponse = {
  requestId: string(name='RequestId'),
  connectionString: string(name='ConnectionString'),
  SSLExpireTime: string(name='SSLExpireTime'),
  requireUpdate: string(name='RequireUpdate'),
  requireUpdateReason: string(name='RequireUpdateReason'),
}

async function describeDBInstanceSSLWithOptions(request: DescribeDBInstanceSSLRequest, runtime: Util.RuntimeOptions): DescribeDBInstanceSSLResponse {
  Util.validateModel(request);
  return doRequest('DescribeDBInstanceSSL', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeDBInstanceSSL(request: DescribeDBInstanceSSLRequest): DescribeDBInstanceSSLResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstanceSSLWithOptions(request, runtime);
}

model DescribeSQLLogFilesRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  fileName?: string(name='FileName'),
  pageSize?: integer(name='PageSize'),
  pageNumber?: integer(name='PageNumber'),
}

model DescribeSQLLogFilesResponse = {
  requestId: string(name='RequestId'),
  totalRecordCount: integer(name='TotalRecordCount'),
  pageNumber: integer(name='PageNumber'),
  pageRecordCount: integer(name='PageRecordCount'),
  items: {
    logFile: [
      {
        fileID: string(name='FileID'),
        logStatus: string(name='LogStatus'),
        logDownloadURL: string(name='LogDownloadURL'),
        logSize: string(name='LogSize'),
        logStartTime: string(name='LogStartTime'),
        logEndTime: string(name='LogEndTime'),
      }
    ](name='LogFile'),
  }(name='Items'),
}

async function describeSQLLogFilesWithOptions(request: DescribeSQLLogFilesRequest, runtime: Util.RuntimeOptions): DescribeSQLLogFilesResponse {
  Util.validateModel(request);
  return doRequest('DescribeSQLLogFiles', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeSQLLogFiles(request: DescribeSQLLogFilesRequest): DescribeSQLLogFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSQLLogFilesWithOptions(request, runtime);
}

model ModifyDBInstanceMonitorRequest = {
  clientToken?: string(name='ClientToken'),
  DBInstanceId: string(name='DBInstanceId'),
  period: string(name='Period'),
}

model ModifyDBInstanceMonitorResponse = {
  requestId: string(name='RequestId'),
}

async function modifyDBInstanceMonitorWithOptions(request: ModifyDBInstanceMonitorRequest, runtime: Util.RuntimeOptions): ModifyDBInstanceMonitorResponse {
  Util.validateModel(request);
  return doRequest('ModifyDBInstanceMonitor', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifyDBInstanceMonitor(request: ModifyDBInstanceMonitorRequest): ModifyDBInstanceMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstanceMonitorWithOptions(request, runtime);
}

model SwitchDBInstanceHARequest = {
  DBInstanceId: string(name='DBInstanceId'),
  nodeId: string(name='NodeId'),
  force?: string(name='Force'),
  effectiveTime?: string(name='EffectiveTime'),
}

model SwitchDBInstanceHAResponse = {
  requestId: string(name='RequestId'),
}

async function switchDBInstanceHAWithOptions(request: SwitchDBInstanceHARequest, runtime: Util.RuntimeOptions): SwitchDBInstanceHAResponse {
  Util.validateModel(request);
  return doRequest('SwitchDBInstanceHA', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function switchDBInstanceHA(request: SwitchDBInstanceHARequest): SwitchDBInstanceHAResponse {
  var runtime = new Util.RuntimeOptions{};
  return switchDBInstanceHAWithOptions(request, runtime);
}

model DescribeDBInstanceMonitorRequest = {
  clientToken?: string(name='ClientToken'),
  DBInstanceId: string(name='DBInstanceId'),
}

model DescribeDBInstanceMonitorResponse = {
  requestId: string(name='RequestId'),
  period: string(name='Period'),
}

async function describeDBInstanceMonitorWithOptions(request: DescribeDBInstanceMonitorRequest, runtime: Util.RuntimeOptions): DescribeDBInstanceMonitorResponse {
  Util.validateModel(request);
  return doRequest('DescribeDBInstanceMonitor', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeDBInstanceMonitor(request: DescribeDBInstanceMonitorRequest): DescribeDBInstanceMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstanceMonitorWithOptions(request, runtime);
}

model DescribeSQLCollectorPolicyRequest = {
  clientToken?: string(name='ClientToken'),
  DBInstanceId: string(name='DBInstanceId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeSQLCollectorPolicyResponse = {
  requestId: string(name='RequestId'),
  SQLCollectorStatus: string(name='SQLCollectorStatus'),
  storagePeriod: integer(name='StoragePeriod'),
}

async function describeSQLCollectorPolicyWithOptions(request: DescribeSQLCollectorPolicyRequest, runtime: Util.RuntimeOptions): DescribeSQLCollectorPolicyResponse {
  Util.validateModel(request);
  return doRequest('DescribeSQLCollectorPolicy', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeSQLCollectorPolicy(request: DescribeSQLCollectorPolicyRequest): DescribeSQLCollectorPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSQLCollectorPolicyWithOptions(request, runtime);
}

model ModifySQLCollectorPolicyRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  SQLCollectorStatus: string(name='SQLCollectorStatus'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ModifySQLCollectorPolicyResponse = {
  requestId: string(name='RequestId'),
}

async function modifySQLCollectorPolicyWithOptions(request: ModifySQLCollectorPolicyRequest, runtime: Util.RuntimeOptions): ModifySQLCollectorPolicyResponse {
  Util.validateModel(request);
  return doRequest('ModifySQLCollectorPolicy', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifySQLCollectorPolicy(request: ModifySQLCollectorPolicyRequest): ModifySQLCollectorPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySQLCollectorPolicyWithOptions(request, runtime);
}

model ModifyDBInstanceHAConfigRequest = {
  syncMode: string(name='SyncMode'),
  HAMode: string(name='HAMode'),
  dbInstanceId: string(name='DbInstanceId'),
}

model ModifyDBInstanceHAConfigResponse = {
  requestId: string(name='RequestId'),
}

async function modifyDBInstanceHAConfigWithOptions(request: ModifyDBInstanceHAConfigRequest, runtime: Util.RuntimeOptions): ModifyDBInstanceHAConfigResponse {
  Util.validateModel(request);
  return doRequest('ModifyDBInstanceHAConfig', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifyDBInstanceHAConfig(request: ModifyDBInstanceHAConfigRequest): ModifyDBInstanceHAConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstanceHAConfigWithOptions(request, runtime);
}

model DescribeDBInstanceHAConfigRequest = {
  DBInstanceId: string(name='DBInstanceId'),
}

model DescribeDBInstanceHAConfigResponse = {
  requestId: string(name='RequestId'),
  DBInstanceId: string(name='DBInstanceId'),
  syncMode: string(name='SyncMode'),
  HAMode: string(name='HAMode'),
  hostInstanceInfos: {
    nodeInfo: [
      {
        nodeId: string(name='NodeId'),
        regionId: string(name='RegionId'),
        logSyncTime: string(name='LogSyncTime'),
        dataSyncTime: string(name='DataSyncTime'),
        nodeType: string(name='NodeType'),
        zoneId: string(name='ZoneId'),
        syncStatus: string(name='SyncStatus'),
      }
    ](name='NodeInfo'),
  }(name='HostInstanceInfos'),
}

async function describeDBInstanceHAConfigWithOptions(request: DescribeDBInstanceHAConfigRequest, runtime: Util.RuntimeOptions): DescribeDBInstanceHAConfigResponse {
  Util.validateModel(request);
  return doRequest('DescribeDBInstanceHAConfig', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeDBInstanceHAConfig(request: DescribeDBInstanceHAConfigRequest): DescribeDBInstanceHAConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstanceHAConfigWithOptions(request, runtime);
}

model DescribeSQLReportsRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  startTime: string(name='StartTime'),
  endTime: string(name='EndTime'),
  pageSize?: integer(name='PageSize'),
  pageNumber?: integer(name='PageNumber'),
}

model DescribeSQLReportsResponse = {
  requestId: string(name='RequestId'),
  totalRecordCount: integer(name='TotalRecordCount'),
  pageNumber: integer(name='PageNumber'),
  pageRecordCount: integer(name='PageRecordCount'),
  items: {
    item: [
      {
        reportTime: string(name='ReportTime'),
        latencyTopNItems: {
          latencyTopNItem: [
            {
              SQLText: string(name='SQLText'),
              avgLatency: long(name='AvgLatency'),
              SQLExecuteTimes: long(name='SQLExecuteTimes'),
            }
          ](name='LatencyTopNItem'),
        }(name='LatencyTopNItems'),
        QPSTopNItems: {
          QPSTopNItem: [
            {
              SQLText: string(name='SQLText'),
              SQLExecuteTimes: long(name='SQLExecuteTimes'),
            }
          ](name='QPSTopNItem'),
        }(name='QPSTopNItems'),
      }
    ](name='Item'),
  }(name='Items'),
}

async function describeSQLReportsWithOptions(request: DescribeSQLReportsRequest, runtime: Util.RuntimeOptions): DescribeSQLReportsResponse {
  Util.validateModel(request);
  return doRequest('DescribeSQLReports', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeSQLReports(request: DescribeSQLReportsRequest): DescribeSQLReportsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSQLReportsWithOptions(request, runtime);
}

model DescribeDBInstanceIPArrayListRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  whitelistNetworkType?: string(name='WhitelistNetworkType'),
}

model DescribeDBInstanceIPArrayListResponse = {
  requestId: string(name='RequestId'),
  items: {
    DBInstanceIPArray: [
      {
        DBInstanceIPArrayName: string(name='DBInstanceIPArrayName'),
        DBInstanceIPArrayAttribute: string(name='DBInstanceIPArrayAttribute'),
        securityIPType: string(name='SecurityIPType'),
        securityIPList: string(name='SecurityIPList'),
        whitelistNetworkType: string(name='WhitelistNetworkType'),
      }
    ](name='DBInstanceIPArray'),
  }(name='Items'),
}

async function describeDBInstanceIPArrayListWithOptions(request: DescribeDBInstanceIPArrayListRequest, runtime: Util.RuntimeOptions): DescribeDBInstanceIPArrayListResponse {
  Util.validateModel(request);
  return doRequest('DescribeDBInstanceIPArrayList', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeDBInstanceIPArrayList(request: DescribeDBInstanceIPArrayListRequest): DescribeDBInstanceIPArrayListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstanceIPArrayListWithOptions(request, runtime);
}

model DescribeSQLLogReportListRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  startTime: string(name='StartTime'),
  endTime: string(name='EndTime'),
  pageSize?: integer(name='PageSize'),
  pageNumber?: integer(name='PageNumber'),
}

model DescribeSQLLogReportListResponse = {
  requestId: string(name='RequestId'),
  totalRecordCount: integer(name='TotalRecordCount'),
  pageNumber: integer(name='PageNumber'),
  pageRecordCount: integer(name='PageRecordCount'),
  items: {
    item: [
      {
        reportTime: string(name='ReportTime'),
        latencyTopNItems: {
          latencyTopNItem: [
            {
              SQLText: string(name='SQLText'),
              avgLatency: long(name='AvgLatency'),
              SQLExecuteTimes: long(name='SQLExecuteTimes'),
            }
          ](name='LatencyTopNItem'),
        }(name='LatencyTopNItems'),
        QPSTopNItems: {
          QPSTopNItem: [
            {
              SQLText: string(name='SQLText'),
              SQLExecuteTimes: long(name='SQLExecuteTimes'),
            }
          ](name='QPSTopNItem'),
        }(name='QPSTopNItems'),
      }
    ](name='Item'),
  }(name='Items'),
}

async function describeSQLLogReportListWithOptions(request: DescribeSQLLogReportListRequest, runtime: Util.RuntimeOptions): DescribeSQLLogReportListResponse {
  Util.validateModel(request);
  return doRequest('DescribeSQLLogReportList', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeSQLLogReportList(request: DescribeSQLLogReportListRequest): DescribeSQLLogReportListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSQLLogReportListWithOptions(request, runtime);
}

model ResetAccountForPGRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  accountName: string(name='AccountName'),
  accountPassword: string(name='AccountPassword'),
}

model ResetAccountForPGResponse = {
  requestId: string(name='RequestId'),
}

async function resetAccountForPGWithOptions(request: ResetAccountForPGRequest, runtime: Util.RuntimeOptions): ResetAccountForPGResponse {
  Util.validateModel(request);
  return doRequest('ResetAccountForPG', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function resetAccountForPG(request: ResetAccountForPGRequest): ResetAccountForPGResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetAccountForPGWithOptions(request, runtime);
}

model UpgradeDBInstanceEngineVersionRequest = {
  clientToken?: string(name='ClientToken'),
  DBInstanceId: string(name='DBInstanceId'),
  engineVersion: string(name='EngineVersion'),
  effectiveTime?: string(name='EffectiveTime'),
}

model UpgradeDBInstanceEngineVersionResponse = {
  requestId: string(name='RequestId'),
  taskId: string(name='TaskId'),
}

async function upgradeDBInstanceEngineVersionWithOptions(request: UpgradeDBInstanceEngineVersionRequest, runtime: Util.RuntimeOptions): UpgradeDBInstanceEngineVersionResponse {
  Util.validateModel(request);
  return doRequest('UpgradeDBInstanceEngineVersion', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function upgradeDBInstanceEngineVersion(request: UpgradeDBInstanceEngineVersionRequest): UpgradeDBInstanceEngineVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeDBInstanceEngineVersionWithOptions(request, runtime);
}

model RevokeAccountPrivilegeRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  accountName: string(name='AccountName'),
  DBName: string(name='DBName'),
}

model RevokeAccountPrivilegeResponse = {
  requestId: string(name='RequestId'),
}

async function revokeAccountPrivilegeWithOptions(request: RevokeAccountPrivilegeRequest, runtime: Util.RuntimeOptions): RevokeAccountPrivilegeResponse {
  Util.validateModel(request);
  return doRequest('RevokeAccountPrivilege', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function revokeAccountPrivilege(request: RevokeAccountPrivilegeRequest): RevokeAccountPrivilegeResponse {
  var runtime = new Util.RuntimeOptions{};
  return revokeAccountPrivilegeWithOptions(request, runtime);
}

model RestartDBInstanceRequest = {
  clientToken?: string(name='ClientToken'),
  DBInstanceId: string(name='DBInstanceId'),
}

model RestartDBInstanceResponse = {
  requestId: string(name='RequestId'),
}

async function restartDBInstanceWithOptions(request: RestartDBInstanceRequest, runtime: Util.RuntimeOptions): RestartDBInstanceResponse {
  Util.validateModel(request);
  return doRequest('RestartDBInstance', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function restartDBInstance(request: RestartDBInstanceRequest): RestartDBInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return restartDBInstanceWithOptions(request, runtime);
}

model ResetAccountPasswordRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  accountName: string(name='AccountName'),
  accountPassword: string(name='AccountPassword'),
}

model ResetAccountPasswordResponse = {
  requestId: string(name='RequestId'),
}

async function resetAccountPasswordWithOptions(request: ResetAccountPasswordRequest, runtime: Util.RuntimeOptions): ResetAccountPasswordResponse {
  Util.validateModel(request);
  return doRequest('ResetAccountPassword', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function resetAccountPassword(request: ResetAccountPasswordRequest): ResetAccountPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetAccountPasswordWithOptions(request, runtime);
}

model RemoveTagsFromResourceRequest = {
  clientToken?: string(name='ClientToken', description='description: 用于保证请求的幂等性，防止重复提交请求。由客户端生成该参数值，要保证在不同请求间唯一，最大值不超过64个ASCII字符，且该参数值中不能包含非ASCII字符。; '),
  proxyId?: string(name='proxyId', description='description: 代理模式ID。; '),
  regionId: string(name='RegionId', description='description: 地域ID，可以通过接口[DescribeRegions](~~26243~~)查看可用的地域ID。; '),
  DBInstanceId: string(name='DBInstanceId', description='description: 实例ID。; '),
  tags?: string(name='Tags', description='description: 需要解绑的一组标签，包括TagKey和TagValue。格式：{"key1":"value1"}。>TagKey不能为空，TagValue可以为空。; '),
  tag?: [
    {
      key?: string(name='key', description='description: 要解绑的第一组标签的Tagkey。需要解绑的标签，包括TagKey和TagValue，单次最多支持传入5组值。TagKey不能为空，TagValue可以为空。; '),
      value?: string(name='value', description='description: 要解绑的第一组标签的TagValue。需要解绑的标签，包括TagKey和TagValue，单次最多支持传入5组值。TagKey不能为空，TagValue可以为空。; '),
    }
  ](name='Tag'),
}

model RemoveTagsFromResourceResponse = {
  requestId: string(name='RequestId', description='description: 请求ID。; '),
}

/**
 * RemoveTagsFromResource 调用RemoveTagsFromResource接口解绑标签。
  * request demo:   * ```
  * http(s)://rds.aliyuncs.com/?Action=RemoveTagsFromResource
  * &DBInstanceId=rm-uf6wjk5xxxxxxx
  * &RegionId=cn-hangzhou
  * &Tag.1.key=test
  * &<公共请求参数>
  * ```
  * description:   * 限制条件如下：
  * * 单次最多支持解绑10个标签；
  * * 若一个标签所绑定的实例全都解绑，则该标签自动删除；
  * * 若解绑标签时仅传入标签键（TagKey），未传入标签值（TagValue），则解绑所有符合标签键条件的标签。
  * * 必须传入至少一组标签或者单独的一个标签键。

 */
async function removeTagsFromResourceWithOptions(request: RemoveTagsFromResourceRequest, runtime: Util.RuntimeOptions): RemoveTagsFromResourceResponse {
  Util.validateModel(request);
  return doRequest('RemoveTagsFromResource', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

/**
 * RemoveTagsFromResource 调用RemoveTagsFromResource接口解绑标签。
  * request demo:   * ```
  * http(s)://rds.aliyuncs.com/?Action=RemoveTagsFromResource
  * &DBInstanceId=rm-uf6wjk5xxxxxxx
  * &RegionId=cn-hangzhou
  * &Tag.1.key=test
  * &<公共请求参数>
  * ```
  * description:   * 限制条件如下：
  * * 单次最多支持解绑10个标签；
  * * 若一个标签所绑定的实例全都解绑，则该标签自动删除；
  * * 若解绑标签时仅传入标签键（TagKey），未传入标签值（TagValue），则解绑所有符合标签键条件的标签。
  * * 必须传入至少一组标签或者单独的一个标签键。

 */
async function removeTagsFromResource(request: RemoveTagsFromResourceRequest): RemoveTagsFromResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeTagsFromResourceWithOptions(request, runtime);
}

model PurgeDBInstanceLogRequest = {
  clientToken?: string(name='ClientToken'),
  DBInstanceId: string(name='DBInstanceId'),
}

model PurgeDBInstanceLogResponse = {
  requestId: string(name='RequestId'),
}

async function purgeDBInstanceLogWithOptions(request: PurgeDBInstanceLogRequest, runtime: Util.RuntimeOptions): PurgeDBInstanceLogResponse {
  Util.validateModel(request);
  return doRequest('PurgeDBInstanceLog', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function purgeDBInstanceLog(request: PurgeDBInstanceLogRequest): PurgeDBInstanceLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return purgeDBInstanceLogWithOptions(request, runtime);
}

model ModifySecurityIpsRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  securityIps: string(name='SecurityIps'),
  DBInstanceIPArrayName?: string(name='DBInstanceIPArrayName'),
  DBInstanceIPArrayAttribute?: string(name='DBInstanceIPArrayAttribute'),
  securityIPType?: string(name='SecurityIPType'),
  whitelistNetworkType?: string(name='WhitelistNetworkType'),
  modifyMode?: string(name='ModifyMode'),
}

model ModifySecurityIpsResponse = {
  requestId: string(name='RequestId'),
  taskId: string(name='TaskId'),
}

async function modifySecurityIpsWithOptions(request: ModifySecurityIpsRequest, runtime: Util.RuntimeOptions): ModifySecurityIpsResponse {
  Util.validateModel(request);
  return doRequest('ModifySecurityIps', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifySecurityIps(request: ModifySecurityIpsRequest): ModifySecurityIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySecurityIpsWithOptions(request, runtime);
}

model ModifyParameterRequest = {
  clientToken?: string(name='ClientToken'),
  DBInstanceId: string(name='DBInstanceId'),
  parameters?: string(name='Parameters'),
  forcerestart?: boolean(name='Forcerestart'),
  parameterGroupId?: string(name='ParameterGroupId'),
}

model ModifyParameterResponse = {
  requestId: string(name='RequestId'),
}

async function modifyParameterWithOptions(request: ModifyParameterRequest, runtime: Util.RuntimeOptions): ModifyParameterResponse {
  Util.validateModel(request);
  return doRequest('ModifyParameter', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifyParameter(request: ModifyParameterRequest): ModifyParameterResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyParameterWithOptions(request, runtime);
}

model ModifyDBInstanceSpecRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  DBInstanceClass?: string(name='DBInstanceClass'),
  DBInstanceStorage?: integer(name='DBInstanceStorage'),
  payType: string(name='PayType'),
  effectiveTime?: string(name='EffectiveTime'),
  engineVersion?: string(name='EngineVersion'),
  DBInstanceStorageType?: string(name='DBInstanceStorageType'),
  direction?: string(name='Direction'),
  sourceBiz?: string(name='SourceBiz'),
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
  zoneId?: string(name='ZoneId'),
}

model ModifyDBInstanceSpecResponse = {
  requestId: string(name='RequestId'),
}

async function modifyDBInstanceSpecWithOptions(request: ModifyDBInstanceSpecRequest, runtime: Util.RuntimeOptions): ModifyDBInstanceSpecResponse {
  Util.validateModel(request);
  return doRequest('ModifyDBInstanceSpec', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifyDBInstanceSpec(request: ModifyDBInstanceSpecRequest): ModifyDBInstanceSpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstanceSpecWithOptions(request, runtime);
}

model ModifyDBInstanceMaintainTimeRequest = {
  clientToken?: string(name='ClientToken'),
  DBInstanceId: string(name='DBInstanceId'),
  maintainTime: string(name='MaintainTime'),
}

model ModifyDBInstanceMaintainTimeResponse = {
  requestId: string(name='RequestId'),
}

async function modifyDBInstanceMaintainTimeWithOptions(request: ModifyDBInstanceMaintainTimeRequest, runtime: Util.RuntimeOptions): ModifyDBInstanceMaintainTimeResponse {
  Util.validateModel(request);
  return doRequest('ModifyDBInstanceMaintainTime', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifyDBInstanceMaintainTime(request: ModifyDBInstanceMaintainTimeRequest): ModifyDBInstanceMaintainTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstanceMaintainTimeWithOptions(request, runtime);
}

model ModifyDBInstanceDescriptionRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  DBInstanceDescription: string(name='DBInstanceDescription'),
}

model ModifyDBInstanceDescriptionResponse = {
  requestId: string(name='RequestId'),
}

async function modifyDBInstanceDescriptionWithOptions(request: ModifyDBInstanceDescriptionRequest, runtime: Util.RuntimeOptions): ModifyDBInstanceDescriptionResponse {
  Util.validateModel(request);
  return doRequest('ModifyDBInstanceDescription', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifyDBInstanceDescription(request: ModifyDBInstanceDescriptionRequest): ModifyDBInstanceDescriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstanceDescriptionWithOptions(request, runtime);
}

model ModifyDBDescriptionRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  DBName: string(name='DBName'),
  DBDescription: string(name='DBDescription'),
}

model ModifyDBDescriptionResponse = {
  requestId: string(name='RequestId'),
}

async function modifyDBDescriptionWithOptions(request: ModifyDBDescriptionRequest, runtime: Util.RuntimeOptions): ModifyDBDescriptionResponse {
  Util.validateModel(request);
  return doRequest('ModifyDBDescription', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifyDBDescription(request: ModifyDBDescriptionRequest): ModifyDBDescriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBDescriptionWithOptions(request, runtime);
}

model ModifyBackupPolicyRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  backupPolicyMode?: string(name='BackupPolicyMode'),
  preferredBackupTime?: string(name='PreferredBackupTime'),
  preferredBackupPeriod?: string(name='PreferredBackupPeriod'),
  backupRetentionPeriod?: string(name='BackupRetentionPeriod'),
  backupLog?: string(name='BackupLog'),
  logBackupRetentionPeriod?: string(name='LogBackupRetentionPeriod'),
  enableBackupLog?: string(name='EnableBackupLog'),
  localLogRetentionHours?: string(name='LocalLogRetentionHours'),
  localLogRetentionSpace?: string(name='LocalLogRetentionSpace'),
  highSpaceUsageProtection?: string(name='HighSpaceUsageProtection'),
  logBackupFrequency?: string(name='LogBackupFrequency'),
  compressType?: string(name='CompressType'),
  archiveBackupRetentionPeriod?: string(name='ArchiveBackupRetentionPeriod'),
  archiveBackupKeepPolicy?: string(name='ArchiveBackupKeepPolicy'),
  archiveBackupKeepCount?: string(name='ArchiveBackupKeepCount'),
  releasedKeepPolicy?: string(name='ReleasedKeepPolicy'),
  logBackupLocalRetentionNumber?: integer(name='LogBackupLocalRetentionNumber'),
  category?: string(name='Category'),
  backupInterval?: string(name='BackupInterval'),
}

model ModifyBackupPolicyResponse = {
  requestId: string(name='RequestId'),
  DBInstanceID: string(name='DBInstanceID'),
  enableBackupLog: string(name='EnableBackupLog'),
  localLogRetentionHours: integer(name='LocalLogRetentionHours'),
  localLogRetentionSpace: string(name='LocalLogRetentionSpace'),
  highSpaceUsageProtection: string(name='HighSpaceUsageProtection'),
  compressType: string(name='CompressType'),
  logBackupLocalRetentionNumber: integer(name='LogBackupLocalRetentionNumber'),
}

async function modifyBackupPolicyWithOptions(request: ModifyBackupPolicyRequest, runtime: Util.RuntimeOptions): ModifyBackupPolicyResponse {
  Util.validateModel(request);
  return doRequest('ModifyBackupPolicy', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifyBackupPolicy(request: ModifyBackupPolicyRequest): ModifyBackupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyBackupPolicyWithOptions(request, runtime);
}

model ModifyAccountDescriptionRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  accountName: string(name='AccountName'),
  accountDescription: string(name='AccountDescription'),
}

model ModifyAccountDescriptionResponse = {
  requestId: string(name='RequestId'),
}

async function modifyAccountDescriptionWithOptions(request: ModifyAccountDescriptionRequest, runtime: Util.RuntimeOptions): ModifyAccountDescriptionResponse {
  Util.validateModel(request);
  return doRequest('ModifyAccountDescription', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifyAccountDescription(request: ModifyAccountDescriptionRequest): ModifyAccountDescriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyAccountDescriptionWithOptions(request, runtime);
}

model MigrateToOtherZoneRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  VPCId?: string(name='VPCId'),
  zoneId: string(name='ZoneId'),
  effectiveTime?: string(name='EffectiveTime'),
  vSwitchId?: string(name='VSwitchId'),
  category?: string(name='Category'),
  zoneIdSlave1?: string(name='ZoneIdSlave1'),
  zoneIdSlave2?: string(name='ZoneIdSlave2'),
}

model MigrateToOtherZoneResponse = {
  requestId: string(name='RequestId'),
}

async function migrateToOtherZoneWithOptions(request: MigrateToOtherZoneRequest, runtime: Util.RuntimeOptions): MigrateToOtherZoneResponse {
  Util.validateModel(request);
  return doRequest('MigrateToOtherZone', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function migrateToOtherZone(request: MigrateToOtherZoneRequest): MigrateToOtherZoneResponse {
  var runtime = new Util.RuntimeOptions{};
  return migrateToOtherZoneWithOptions(request, runtime);
}

model ImportDatabaseBetweenInstancesRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  sourceDBInstanceId: string(name='SourceDBInstanceId'),
  DBInfo: string(name='DBInfo'),
}

model ImportDatabaseBetweenInstancesResponse = {
  requestId: string(name='RequestId'),
  importId: string(name='ImportId'),
}

async function importDatabaseBetweenInstancesWithOptions(request: ImportDatabaseBetweenInstancesRequest, runtime: Util.RuntimeOptions): ImportDatabaseBetweenInstancesResponse {
  Util.validateModel(request);
  return doRequest('ImportDatabaseBetweenInstances', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function importDatabaseBetweenInstances(request: ImportDatabaseBetweenInstancesRequest): ImportDatabaseBetweenInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return importDatabaseBetweenInstancesWithOptions(request, runtime);
}

model GrantAccountPrivilegeRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  accountName: string(name='AccountName'),
  DBName: string(name='DBName'),
  accountPrivilege: string(name='AccountPrivilege'),
}

model GrantAccountPrivilegeResponse = {
  requestId: string(name='RequestId'),
}

async function grantAccountPrivilegeWithOptions(request: GrantAccountPrivilegeRequest, runtime: Util.RuntimeOptions): GrantAccountPrivilegeResponse {
  Util.validateModel(request);
  return doRequest('GrantAccountPrivilege', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function grantAccountPrivilege(request: GrantAccountPrivilegeRequest): GrantAccountPrivilegeResponse {
  var runtime = new Util.RuntimeOptions{};
  return grantAccountPrivilegeWithOptions(request, runtime);
}

model DescribeTasksRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
  pageSize?: integer(name='PageSize'),
  pageNumber?: integer(name='PageNumber'),
  status?: string(name='Status'),
  taskAction?: string(name='TaskAction'),
}

model DescribeTasksResponse = {
  requestId: string(name='RequestId'),
  totalRecordCount: integer(name='TotalRecordCount'),
  pageNumber: integer(name='PageNumber'),
  pageRecordCount: integer(name='PageRecordCount'),
  items: {
    taskProgressInfo: [
      {
        DBName: string(name='DBName'),
        beginTime: string(name='BeginTime'),
        progressInfo: string(name='ProgressInfo'),
        finishTime: string(name='FinishTime'),
        taskAction: string(name='TaskAction'),
        taskId: string(name='TaskId'),
        progress: string(name='Progress'),
        expectedFinishTime: string(name='ExpectedFinishTime'),
        status: string(name='Status'),
        taskErrorCode: string(name='TaskErrorCode'),
        taskErrorMessage: string(name='TaskErrorMessage'),
        stepsInfo: string(name='StepsInfo'),
        remain: integer(name='Remain'),
        stepProgressInfo: string(name='StepProgressInfo'),
        currentStepName: string(name='CurrentStepName'),
      }
    ](name='TaskProgressInfo'),
  }(name='Items'),
}

async function describeTasksWithOptions(request: DescribeTasksRequest, runtime: Util.RuntimeOptions): DescribeTasksResponse {
  Util.validateModel(request);
  return doRequest('DescribeTasks', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeTasks(request: DescribeTasksRequest): DescribeTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTasksWithOptions(request, runtime);
}

model DescribeSQLLogReportsRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  startTime: string(name='StartTime'),
  endTime: string(name='EndTime'),
  pageSize?: integer(name='PageSize'),
  pageNumber?: integer(name='PageNumber'),
}

model DescribeSQLLogReportsResponse = {
  requestId: string(name='RequestId'),
  totalRecordCount: integer(name='TotalRecordCount'),
  pageNumber: integer(name='PageNumber'),
  pageRecordCount: integer(name='PageRecordCount'),
  items: {
    item: [
      {
        reportTime: string(name='ReportTime'),
        latencyTopNItems: {
          latencyTopNItem: [
            {
              SQLText: string(name='SQLText'),
              avgLatency: long(name='AvgLatency'),
              SQLExecuteTimes: long(name='SQLExecuteTimes'),
            }
          ](name='LatencyTopNItem'),
        }(name='LatencyTopNItems'),
        QPSTopNItems: {
          QPSTopNItem: [
            {
              SQLText: string(name='SQLText'),
              SQLExecuteTimes: long(name='SQLExecuteTimes'),
            }
          ](name='QPSTopNItem'),
        }(name='QPSTopNItems'),
      }
    ](name='Item'),
  }(name='Items'),
}

async function describeSQLLogReportsWithOptions(request: DescribeSQLLogReportsRequest, runtime: Util.RuntimeOptions): DescribeSQLLogReportsResponse {
  Util.validateModel(request);
  return doRequest('DescribeSQLLogReports', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeSQLLogReports(request: DescribeSQLLogReportsRequest): DescribeSQLLogReportsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSQLLogReportsWithOptions(request, runtime);
}

model DescribeSQLLogRecordsRequest = {
  clientToken?: string(name='ClientToken'),
  DBInstanceId: string(name='DBInstanceId'),
  SQLId?: long(name='SQLId'),
  queryKeywords?: string(name='QueryKeywords'),
  startTime: string(name='StartTime'),
  database?: string(name='Database'),
  user?: string(name='User'),
  form?: string(name='Form'),
  endTime: string(name='EndTime'),
  pageSize?: integer(name='PageSize'),
  pageNumber?: integer(name='PageNumber'),
}

model DescribeSQLLogRecordsResponse = {
  requestId: string(name='RequestId'),
  totalRecordCount: long(name='TotalRecordCount'),
  pageNumber: integer(name='PageNumber'),
  pageRecordCount: integer(name='PageRecordCount'),
  items: {
    SQLRecord: [
      {
        DBName: string(name='DBName'),
        accountName: string(name='AccountName'),
        hostAddress: string(name='HostAddress'),
        SQLText: string(name='SQLText'),
        totalExecutionTimes: long(name='TotalExecutionTimes'),
        returnRowCounts: long(name='ReturnRowCounts'),
        executeTime: string(name='ExecuteTime'),
        threadID: string(name='ThreadID'),
      }
    ](name='SQLRecord'),
  }(name='Items'),
}

async function describeSQLLogRecordsWithOptions(request: DescribeSQLLogRecordsRequest, runtime: Util.RuntimeOptions): DescribeSQLLogRecordsResponse {
  Util.validateModel(request);
  return doRequest('DescribeSQLLogRecords', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeSQLLogRecords(request: DescribeSQLLogRecordsRequest): DescribeSQLLogRecordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSQLLogRecordsWithOptions(request, runtime);
}

model DescribeSlowLogsRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  startTime: string(name='StartTime'),
  endTime: string(name='EndTime'),
  DBName?: string(name='DBName'),
  sortKey?: string(name='SortKey'),
  pageSize?: integer(name='PageSize'),
  pageNumber?: integer(name='PageNumber'),
}

model DescribeSlowLogsResponse = {
  requestId: string(name='RequestId'),
  DBInstanceId: string(name='DBInstanceId'),
  engine: string(name='Engine'),
  startTime: string(name='StartTime'),
  endTime: string(name='EndTime'),
  totalRecordCount: integer(name='TotalRecordCount'),
  pageNumber: integer(name='PageNumber'),
  pageRecordCount: integer(name='PageRecordCount'),
  items: {
    SQLSlowLog: [
      {
        slowLogId: long(name='SlowLogId'),
        SQLHASH: string(name='SQLHASH'),
        SQLIdStr: string(name='SQLIdStr'),
        DBName: string(name='DBName'),
        SQLText: string(name='SQLText'),
        mySQLTotalExecutionCounts: long(name='MySQLTotalExecutionCounts'),
        mySQLTotalExecutionTimes: long(name='MySQLTotalExecutionTimes'),
        totalLockTimes: long(name='TotalLockTimes'),
        maxLockTime: long(name='MaxLockTime'),
        parseTotalRowCounts: long(name='ParseTotalRowCounts'),
        parseMaxRowCount: long(name='ParseMaxRowCount'),
        returnTotalRowCounts: long(name='ReturnTotalRowCounts'),
        returnMaxRowCount: long(name='ReturnMaxRowCount'),
        createTime: string(name='CreateTime'),
        SQLServerTotalExecutionCounts: long(name='SQLServerTotalExecutionCounts'),
        SQLServerTotalExecutionTimes: long(name='SQLServerTotalExecutionTimes'),
        totalLogicalReadCounts: long(name='TotalLogicalReadCounts'),
        totalPhysicalReadCounts: long(name='TotalPhysicalReadCounts'),
        reportTime: string(name='ReportTime'),
        maxExecutionTime: long(name='MaxExecutionTime'),
        avgExecutionTime: long(name='AvgExecutionTime'),
        avgPhysicalReadCounts: long(name='AvgPhysicalReadCounts'),
        maxPhysicalReadCounts: long(name='MaxPhysicalReadCounts'),
        minPhysicalReadCounts: long(name='MinPhysicalReadCounts'),
        avgLogicalReadCounts: long(name='AvgLogicalReadCounts'),
        maxLogicalReadCounts: long(name='MaxLogicalReadCounts'),
        minLogicalReadCounts: long(name='MinLogicalReadCounts'),
        totalIOWriteCounts: long(name='TotalIOWriteCounts'),
        avgIOWriteCounts: long(name='AvgIOWriteCounts'),
        maxIOWriteCounts: long(name='MaxIOWriteCounts'),
        minIOWriteCounts: long(name='MinIOWriteCounts'),
        totalRowsAffectedCounts: long(name='TotalRowsAffectedCounts'),
        avgRowsAffectedCounts: long(name='AvgRowsAffectedCounts'),
        maxRowsAffectedCounts: long(name='MaxRowsAffectedCounts'),
        minRowsAffectedCounts: long(name='MinRowsAffectedCounts'),
        totalLastRowsAffectedCounts: long(name='TotalLastRowsAffectedCounts'),
        avgLastRowsAffectedCounts: long(name='AvgLastRowsAffectedCounts'),
        maxLastRowsAffectedCounts: long(name='MaxLastRowsAffectedCounts'),
        minLastRowsAffectedCounts: long(name='MinLastRowsAffectedCounts'),
        SQLServerMinExecutionTime: long(name='SQLServerMinExecutionTime'),
        SQLServerAvgExecutionTime: long(name='SQLServerAvgExecutionTime'),
        SQLServerTotalCpuTime: long(name='SQLServerTotalCpuTime'),
        SQLServerAvgCpuTime: long(name='SQLServerAvgCpuTime'),
        SQLServerMaxCpuTime: long(name='SQLServerMaxCpuTime'),
        SQLServerMinCpuTime: long(name='SQLServerMinCpuTime'),
      }
    ](name='SQLSlowLog'),
  }(name='Items'),
}

async function describeSlowLogsWithOptions(request: DescribeSlowLogsRequest, runtime: Util.RuntimeOptions): DescribeSlowLogsResponse {
  Util.validateModel(request);
  return doRequest('DescribeSlowLogs', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeSlowLogs(request: DescribeSlowLogsRequest): DescribeSlowLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSlowLogsWithOptions(request, runtime);
}

model DescribeSlowLogRecordsRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  SQLHASH?: string(name='SQLHASH'),
  startTime: string(name='StartTime'),
  endTime: string(name='EndTime'),
  DBName?: string(name='DBName'),
  pageSize?: integer(name='PageSize'),
  pageNumber?: integer(name='PageNumber'),
}

model DescribeSlowLogRecordsResponse = {
  requestId: string(name='RequestId'),
  DBInstanceId: string(name='DBInstanceId'),
  engine: string(name='Engine'),
  totalRecordCount: integer(name='TotalRecordCount'),
  pageNumber: integer(name='PageNumber'),
  pageRecordCount: integer(name='PageRecordCount'),
  SQLHash: string(name='SQLHash'),
  CPUTime: long(name='CPUTime'),
  logicalIORead: long(name='LogicalIORead'),
  physicalIORead: long(name='PhysicalIORead'),
  writesIOCount: long(name='WritesIOCount'),
  rowsAffectedCount: long(name='RowsAffectedCount'),
  lastRowsAffectedCount: long(name='LastRowsAffectedCount'),
  userName: string(name='UserName'),
  items: {
    SQLSlowRecord: [
      {
        hostAddress: string(name='HostAddress'),
        DBName: string(name='DBName'),
        SQLText: string(name='SQLText'),
        queryTimes: long(name='QueryTimes'),
        lockTimes: long(name='LockTimes'),
        parseRowCounts: long(name='ParseRowCounts'),
        returnRowCounts: long(name='ReturnRowCounts'),
        executionStartTime: string(name='ExecutionStartTime'),
        queryTimeMS: long(name='QueryTimeMS'),
        cpuTime: long(name='CpuTime'),
        logicalIORead: long(name='LogicalIORead'),
        physicalIORead: long(name='PhysicalIORead'),
        writeIOCount: long(name='WriteIOCount'),
        rowsAffectedCount: long(name='RowsAffectedCount'),
        lastRowsAffectedCount: long(name='LastRowsAffectedCount'),
        userName: string(name='UserName'),
        applicationName: string(name='ApplicationName'),
        clientHostName: string(name='ClientHostName'),
      }
    ](name='SQLSlowRecord'),
  }(name='Items'),
}

async function describeSlowLogRecordsWithOptions(request: DescribeSlowLogRecordsRequest, runtime: Util.RuntimeOptions): DescribeSlowLogRecordsResponse {
  Util.validateModel(request);
  return doRequest('DescribeSlowLogRecords', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeSlowLogRecords(request: DescribeSlowLogRecordsRequest): DescribeSlowLogRecordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSlowLogRecordsWithOptions(request, runtime);
}

model DescribeResourceUsageRequest = {
  DBInstanceId: string(name='DBInstanceId'),
}

model DescribeResourceUsageResponse = {
  requestId: string(name='RequestId'),
  DBInstanceId: string(name='DBInstanceId'),
  engine: string(name='Engine'),
  diskUsed: long(name='DiskUsed'),
  dataSize: long(name='DataSize'),
  logSize: long(name='LogSize'),
  backupSize: long(name='BackupSize'),
  backupOssDataSize: long(name='BackupOssDataSize'),
  backupOssLogSize: long(name='BackupOssLogSize'),
  SQLSize: long(name='SQLSize'),
  coldBackupSize: long(name='ColdBackupSize'),
  backupDataSize: long(name='BackupDataSize'),
  backupLogSize: long(name='BackupLogSize'),
  paidBackupSize: long(name='PaidBackupSize'),
  archiveBackupSize: long(name='ArchiveBackupSize'),
}

async function describeResourceUsageWithOptions(request: DescribeResourceUsageRequest, runtime: Util.RuntimeOptions): DescribeResourceUsageResponse {
  Util.validateModel(request);
  return doRequest('DescribeResourceUsage', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeResourceUsage(request: DescribeResourceUsageRequest): DescribeResourceUsageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeResourceUsageWithOptions(request, runtime);
}

model DescribeRegionsRequest = {
}

model DescribeRegionsResponse = {
  requestId: string(name='RequestId'),
  regions: {
    RDSRegion: [
      {
        regionId: string(name='RegionId'),
        zoneId: string(name='ZoneId'),
      }
    ](name='RDSRegion'),
  }(name='Regions'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  return doRequest('DescribeRegions', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model DescribeParameterTemplatesRequest = {
  clientToken?: string(name='ClientToken'),
  engine: string(name='Engine'),
  engineVersion: string(name='EngineVersion'),
  category?: string(name='Category'),
  regionId?: string(name='RegionId'),
  DBInstanceId?: string(name='DBInstanceId'),
}

model DescribeParameterTemplatesResponse = {
  requestId: string(name='RequestId'),
  engine: string(name='Engine'),
  engineVersion: string(name='EngineVersion'),
  parameterCount: string(name='ParameterCount'),
  parameters: {
    templateRecord: [
      {
        parameterName: string(name='ParameterName'),
        parameterValue: string(name='ParameterValue'),
        forceModify: string(name='ForceModify'),
        forceRestart: string(name='ForceRestart'),
        checkingCode: string(name='CheckingCode'),
        parameterDescription: string(name='ParameterDescription'),
      }
    ](name='TemplateRecord'),
  }(name='Parameters'),
}

async function describeParameterTemplatesWithOptions(request: DescribeParameterTemplatesRequest, runtime: Util.RuntimeOptions): DescribeParameterTemplatesResponse {
  Util.validateModel(request);
  return doRequest('DescribeParameterTemplates', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeParameterTemplates(request: DescribeParameterTemplatesRequest): DescribeParameterTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeParameterTemplatesWithOptions(request, runtime);
}

model DescribeParametersRequest = {
  clientToken?: string(name='ClientToken'),
  DBInstanceId: string(name='DBInstanceId'),
}

model DescribeParametersResponse = {
  requestId: string(name='RequestId'),
  engine: string(name='Engine'),
  engineVersion: string(name='EngineVersion'),
  configParameters: {
    DBInstanceParameter: [
      {
        parameterName: string(name='ParameterName'),
        parameterValue: string(name='ParameterValue'),
        parameterDescription: string(name='ParameterDescription'),
      }
    ](name='DBInstanceParameter'),
  }(name='ConfigParameters'),
  runningParameters: {
    DBInstanceParameter: [
      {
        parameterName: string(name='ParameterName'),
        parameterValue: string(name='ParameterValue'),
        parameterDescription: string(name='ParameterDescription'),
      }
    ](name='DBInstanceParameter'),
  }(name='RunningParameters'),
}

async function describeParametersWithOptions(request: DescribeParametersRequest, runtime: Util.RuntimeOptions): DescribeParametersResponse {
  Util.validateModel(request);
  return doRequest('DescribeParameters', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeParameters(request: DescribeParametersRequest): DescribeParametersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeParametersWithOptions(request, runtime);
}

model DescribeModifyParameterLogRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  startTime: string(name='StartTime'),
  endTime: string(name='EndTime'),
  pageSize?: integer(name='PageSize'),
  pageNumber?: integer(name='PageNumber'),
}

model DescribeModifyParameterLogResponse = {
  requestId: string(name='RequestId'),
  engine: string(name='Engine'),
  DBInstanceId: string(name='DBInstanceId'),
  engineVersion: string(name='EngineVersion'),
  totalRecordCount: integer(name='TotalRecordCount'),
  pageNumber: integer(name='PageNumber'),
  pageRecordCount: integer(name='PageRecordCount'),
  items: {
    parameterChangeLog: [
      {
        modifyTime: string(name='ModifyTime'),
        oldParameterValue: string(name='OldParameterValue'),
        newParameterValue: string(name='NewParameterValue'),
        parameterName: string(name='ParameterName'),
        status: string(name='Status'),
      }
    ](name='ParameterChangeLog'),
  }(name='Items'),
}

async function describeModifyParameterLogWithOptions(request: DescribeModifyParameterLogRequest, runtime: Util.RuntimeOptions): DescribeModifyParameterLogResponse {
  Util.validateModel(request);
  return doRequest('DescribeModifyParameterLog', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeModifyParameterLog(request: DescribeModifyParameterLogRequest): DescribeModifyParameterLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeModifyParameterLogWithOptions(request, runtime);
}

model DescribeErrorLogsRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  startTime: string(name='StartTime'),
  endTime: string(name='EndTime'),
  pageSize?: integer(name='PageSize'),
  pageNumber?: integer(name='PageNumber'),
}

model DescribeErrorLogsResponse = {
  pageNumber: integer(name='PageNumber'),
  pageRecordCount: integer(name='PageRecordCount'),
  requestId: string(name='RequestId'),
  totalRecordCount: integer(name='TotalRecordCount'),
  items: {
    errorLog: [
      {
        createTime: string(name='CreateTime'),
        errorInfo: string(name='ErrorInfo'),
      }
    ](name='ErrorLog'),
  }(name='Items'),
}

async function describeErrorLogsWithOptions(request: DescribeErrorLogsRequest, runtime: Util.RuntimeOptions): DescribeErrorLogsResponse {
  Util.validateModel(request);
  return doRequest('DescribeErrorLogs', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeErrorLogs(request: DescribeErrorLogsRequest): DescribeErrorLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeErrorLogsWithOptions(request, runtime);
}

model DescribeDBInstancePerformanceRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  key: string(name='Key'),
  startTime: string(name='StartTime'),
  endTime: string(name='EndTime'),
}

model DescribeDBInstancePerformanceResponse = {
  requestId: string(name='RequestId'),
  DBInstanceId: string(name='DBInstanceId'),
  engine: string(name='Engine'),
  startTime: string(name='StartTime'),
  endTime: string(name='EndTime'),
  performanceKeys: {
    performanceKey: [
      {
        key: string(name='Key'),
        unit: string(name='Unit'),
        valueFormat: string(name='ValueFormat'),
        values: {
          performanceValue: [
            {
              value: string(name='Value'),
              date: string(name='Date'),
            }
          ](name='PerformanceValue'),
        }(name='Values'),
      }
    ](name='PerformanceKey'),
  }(name='PerformanceKeys'),
}

async function describeDBInstancePerformanceWithOptions(request: DescribeDBInstancePerformanceRequest, runtime: Util.RuntimeOptions): DescribeDBInstancePerformanceResponse {
  Util.validateModel(request);
  return doRequest('DescribeDBInstancePerformance', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeDBInstancePerformance(request: DescribeDBInstancePerformanceRequest): DescribeDBInstancePerformanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstancePerformanceWithOptions(request, runtime);
}

model DescribeDatabasesRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  DBName?: string(name='DBName'),
  DBStatus?: string(name='DBStatus'),
  pageSize?: integer(name='PageSize'),
  pageNumber?: integer(name='PageNumber'),
}

model DescribeDatabasesResponse = {
  requestId: string(name='RequestId'),
  databases: {
    database: [
      {
        DBName: string(name='DBName'),
        DBInstanceId: string(name='DBInstanceId'),
        engine: string(name='Engine'),
        DBStatus: string(name='DBStatus'),
        characterSetName: string(name='CharacterSetName'),
        DBDescription: string(name='DBDescription'),
        accounts: {
          accountPrivilegeInfo: [
            {
              account: string(name='Account'),
              accountPrivilege: string(name='AccountPrivilege'),
              accountPrivilegeDetail: string(name='AccountPrivilegeDetail'),
            }
          ](name='AccountPrivilegeInfo'),
        }(name='Accounts'),
      }
    ](name='Database'),
  }(name='Databases'),
}

async function describeDatabasesWithOptions(request: DescribeDatabasesRequest, runtime: Util.RuntimeOptions): DescribeDatabasesResponse {
  Util.validateModel(request);
  return doRequest('DescribeDatabases', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeDatabases(request: DescribeDatabasesRequest): DescribeDatabasesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDatabasesWithOptions(request, runtime);
}

model DescribeBinlogFilesRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  startTime: string(name='StartTime'),
  endTime: string(name='EndTime'),
  pageSize?: integer(name='PageSize'),
  pageNumber?: integer(name='PageNumber'),
}

model DescribeBinlogFilesResponse = {
  requestId: string(name='RequestId'),
  totalRecordCount: integer(name='TotalRecordCount'),
  pageNumber: integer(name='PageNumber'),
  pageRecordCount: integer(name='PageRecordCount'),
  totalFileSize: long(name='TotalFileSize'),
  items: {
    binLogFile: [
      {
        fileSize: long(name='FileSize'),
        logBeginTime: string(name='LogBeginTime'),
        logEndTime: string(name='LogEndTime'),
        downloadLink: string(name='DownloadLink'),
        intranetDownloadLink: string(name='IntranetDownloadLink'),
        linkExpiredTime: string(name='LinkExpiredTime'),
        checksum: string(name='Checksum'),
        hostInstanceID: string(name='HostInstanceID'),
        logFileName: string(name='LogFileName'),
      }
    ](name='BinLogFile'),
  }(name='Items'),
}

async function describeBinlogFilesWithOptions(request: DescribeBinlogFilesRequest, runtime: Util.RuntimeOptions): DescribeBinlogFilesResponse {
  Util.validateModel(request);
  return doRequest('DescribeBinlogFiles', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeBinlogFiles(request: DescribeBinlogFilesRequest): DescribeBinlogFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBinlogFilesWithOptions(request, runtime);
}

model DescribeBackupTasksRequest = {
  clientToken?: string(name='ClientToken'),
  flag?: string(name='Flag'),
  DBInstanceId: string(name='DBInstanceId'),
  backupJobId?: integer(name='BackupJobId'),
  backupMode?: string(name='BackupMode'),
  backupJobStatus?: string(name='BackupJobStatus'),
}

model DescribeBackupTasksResponse = {
  requestId: string(name='RequestId'),
  items: {
    backupJob: [
      {
        backupProgressStatus: string(name='BackupProgressStatus'),
        backupStatus: string(name='BackupStatus'),
        jobMode: string(name='JobMode'),
        process: string(name='Process'),
        taskAction: string(name='TaskAction'),
        backupJobId: string(name='BackupJobId'),
        backupId: string(name='BackupId'),
      }
    ](name='BackupJob'),
  }(name='Items'),
}

async function describeBackupTasksWithOptions(request: DescribeBackupTasksRequest, runtime: Util.RuntimeOptions): DescribeBackupTasksResponse {
  Util.validateModel(request);
  return doRequest('DescribeBackupTasks', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeBackupTasks(request: DescribeBackupTasksRequest): DescribeBackupTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupTasksWithOptions(request, runtime);
}

model DescribeBackupsRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  backupId?: string(name='BackupId'),
  backupStatus?: string(name='BackupStatus'),
  backupMode?: string(name='BackupMode'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
  pageSize?: integer(name='PageSize'),
  pageNumber?: integer(name='PageNumber'),
}

model DescribeBackupsResponse = {
  requestId: string(name='RequestId'),
  totalRecordCount: string(name='TotalRecordCount'),
  pageNumber: string(name='PageNumber'),
  pageRecordCount: string(name='PageRecordCount'),
  totalBackupSize: long(name='TotalBackupSize'),
  totalEcsSnapshotSize: long(name='TotalEcsSnapshotSize'),
  items: {
    backup: [
      {
        backupId: string(name='BackupId'),
        DBInstanceId: string(name='DBInstanceId'),
        backupStatus: string(name='BackupStatus'),
        backupStartTime: string(name='BackupStartTime'),
        backupEndTime: string(name='BackupEndTime'),
        backupType: string(name='BackupType'),
        backupMode: string(name='BackupMode'),
        backupMethod: string(name='BackupMethod'),
        backupDownloadURL: string(name='BackupDownloadURL'),
        backupIntranetDownloadURL: string(name='BackupIntranetDownloadURL'),
        backupLocation: string(name='BackupLocation'),
        backupExtractionStatus: string(name='BackupExtractionStatus'),
        backupScale: string(name='BackupScale'),
        backupDBNames: string(name='BackupDBNames'),
        totalBackupSize: long(name='TotalBackupSize'),
        backupSize: long(name='BackupSize'),
        hostInstanceID: string(name='HostInstanceID'),
        storeStatus: string(name='StoreStatus'),
        metaStatus: string(name='MetaStatus'),
        slaveStatus: string(name='SlaveStatus'),
        consistentTime: long(name='ConsistentTime'),
        backupInitiator: string(name='BackupInitiator'),
        copyOnlyBackup: string(name='CopyOnlyBackup'),
        storageClass: string(name='StorageClass'),
        isAvail: integer(name='IsAvail'),
        encryption: string(name='Encryption'),
      }
    ](name='Backup'),
  }(name='Items'),
}

async function describeBackupsWithOptions(request: DescribeBackupsRequest, runtime: Util.RuntimeOptions): DescribeBackupsResponse {
  Util.validateModel(request);
  return doRequest('DescribeBackups', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeBackups(request: DescribeBackupsRequest): DescribeBackupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupsWithOptions(request, runtime);
}

model DescribeBackupPolicyRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  backupPolicyMode?: string(name='BackupPolicyMode'),
  compressType?: string(name='CompressType'),
  releasedKeepPolicy?: string(name='ReleasedKeepPolicy'),
}

model DescribeBackupPolicyResponse = {
  requestId: string(name='RequestId'),
  backupRetentionPeriod: integer(name='BackupRetentionPeriod'),
  preferredNextBackupTime: string(name='PreferredNextBackupTime'),
  preferredBackupTime: string(name='PreferredBackupTime'),
  preferredBackupPeriod: string(name='PreferredBackupPeriod'),
  backupLog: string(name='BackupLog'),
  logBackupRetentionPeriod: integer(name='LogBackupRetentionPeriod'),
  enableBackupLog: string(name='EnableBackupLog'),
  localLogRetentionHours: integer(name='LocalLogRetentionHours'),
  localLogRetentionSpace: string(name='LocalLogRetentionSpace'),
  duplication: string(name='Duplication'),
  duplicationContent: string(name='DuplicationContent'),
  highSpaceUsageProtection: string(name='HighSpaceUsageProtection'),
  logBackupFrequency: string(name='LogBackupFrequency'),
  compressType: string(name='CompressType'),
  archiveBackupRetentionPeriod: string(name='ArchiveBackupRetentionPeriod'),
  archiveBackupKeepPolicy: string(name='ArchiveBackupKeepPolicy'),
  archiveBackupKeepCount: string(name='ArchiveBackupKeepCount'),
  releasedKeepPolicy: string(name='ReleasedKeepPolicy'),
  logBackupLocalRetentionNumber: integer(name='LogBackupLocalRetentionNumber'),
  category: string(name='Category'),
  supportReleasedKeep: integer(name='SupportReleasedKeep'),
  backupInterval: string(name='BackupInterval'),
  duplicationLocation: {
    sotrage: string(name='Sotrage'),
    location: {
      endpoint: string(name='Endpoint'),
      bucket: string(name='Bucket'),
    }(name='Location'),
  }(name='DuplicationLocation'),
}

async function describeBackupPolicyWithOptions(request: DescribeBackupPolicyRequest, runtime: Util.RuntimeOptions): DescribeBackupPolicyResponse {
  Util.validateModel(request);
  return doRequest('DescribeBackupPolicy', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeBackupPolicy(request: DescribeBackupPolicyRequest): DescribeBackupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupPolicyWithOptions(request, runtime);
}

model DescribeAccountsRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  accountName?: string(name='AccountName'),
  pageSize?: integer(name='PageSize'),
  pageNumber?: integer(name='PageNumber'),
}

model DescribeAccountsResponse = {
  requestId: string(name='RequestId'),
  systemAdminAccountStatus: string(name='SystemAdminAccountStatus'),
  systemAdminAccountFirstActivationTime: string(name='SystemAdminAccountFirstActivationTime'),
  accounts: {
    DBInstanceAccount: [
      {
        DBInstanceId: string(name='DBInstanceId'),
        accountName: string(name='AccountName'),
        accountStatus: string(name='AccountStatus'),
        accountType: string(name='AccountType'),
        accountDescription: string(name='AccountDescription'),
        privExceeded: string(name='PrivExceeded'),
        databasePrivileges: {
          databasePrivilege: [
            {
              DBName: string(name='DBName'),
              accountPrivilege: string(name='AccountPrivilege'),
              accountPrivilegeDetail: string(name='AccountPrivilegeDetail'),
            }
          ](name='DatabasePrivilege'),
        }(name='DatabasePrivileges'),
      }
    ](name='DBInstanceAccount'),
  }(name='Accounts'),
}

async function describeAccountsWithOptions(request: DescribeAccountsRequest, runtime: Util.RuntimeOptions): DescribeAccountsResponse {
  Util.validateModel(request);
  return doRequest('DescribeAccounts', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeAccounts(request: DescribeAccountsRequest): DescribeAccountsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAccountsWithOptions(request, runtime);
}

model DescibeImportsFromDatabaseRequest = {
  clientToken?: string(name='ClientToken'),
  DBInstanceId: string(name='DBInstanceId'),
  engine: string(name='Engine'),
  importId?: integer(name='ImportId'),
  startTime: string(name='StartTime'),
  endTime: string(name='EndTime'),
  pageSize?: integer(name='PageSize'),
  pageNumber?: integer(name='PageNumber'),
}

model DescibeImportsFromDatabaseResponse = {
  requestId: string(name='RequestId'),
  totalRecordCount: integer(name='TotalRecordCount'),
  pageNumber: integer(name='PageNumber'),
  pageRecordCount: integer(name='PageRecordCount'),
  items: {
    importResultFromDB: [
      {
        importId: integer(name='ImportId'),
        importDataType: string(name='ImportDataType'),
        importDataStatus: string(name='ImportDataStatus'),
        importDataStatusDescription: string(name='ImportDataStatusDescription'),
        incrementalImportingTime: string(name='IncrementalImportingTime'),
      }
    ](name='ImportResultFromDB'),
  }(name='Items'),
}

async function descibeImportsFromDatabaseWithOptions(request: DescibeImportsFromDatabaseRequest, runtime: Util.RuntimeOptions): DescibeImportsFromDatabaseResponse {
  Util.validateModel(request);
  return doRequest('DescibeImportsFromDatabase', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function descibeImportsFromDatabase(request: DescibeImportsFromDatabaseRequest): DescibeImportsFromDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return descibeImportsFromDatabaseWithOptions(request, runtime);
}

model DeleteDBInstanceRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  releasedKeepPolicy?: string(name='ReleasedKeepPolicy'),
}

model DeleteDBInstanceResponse = {
  requestId: string(name='RequestId'),
  regionId: string(name='RegionId'),
}

async function deleteDBInstanceWithOptions(request: DeleteDBInstanceRequest, runtime: Util.RuntimeOptions): DeleteDBInstanceResponse {
  Util.validateModel(request);
  return doRequest('DeleteDBInstance', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function deleteDBInstance(request: DeleteDBInstanceRequest): DeleteDBInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDBInstanceWithOptions(request, runtime);
}

model DeleteDatabaseRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  DBName: string(name='DBName'),
}

model DeleteDatabaseResponse = {
  requestId: string(name='RequestId'),
}

async function deleteDatabaseWithOptions(request: DeleteDatabaseRequest, runtime: Util.RuntimeOptions): DeleteDatabaseResponse {
  Util.validateModel(request);
  return doRequest('DeleteDatabase', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function deleteDatabase(request: DeleteDatabaseRequest): DeleteDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDatabaseWithOptions(request, runtime);
}

model DeleteAccountRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  accountName: string(name='AccountName'),
}

model DeleteAccountResponse = {
  requestId: string(name='RequestId'),
}

async function deleteAccountWithOptions(request: DeleteAccountRequest, runtime: Util.RuntimeOptions): DeleteAccountResponse {
  Util.validateModel(request);
  return doRequest('DeleteAccount', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function deleteAccount(request: DeleteAccountRequest): DeleteAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAccountWithOptions(request, runtime);
}

model CreateTempDBInstanceRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  backupId?: integer(name='BackupId'),
  restoreTime?: string(name='RestoreTime'),
}

model CreateTempDBInstanceResponse = {
  requestId: string(name='RequestId'),
  tempDBInstanceId: string(name='TempDBInstanceId'),
}

async function createTempDBInstanceWithOptions(request: CreateTempDBInstanceRequest, runtime: Util.RuntimeOptions): CreateTempDBInstanceResponse {
  Util.validateModel(request);
  return doRequest('CreateTempDBInstance', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function createTempDBInstance(request: CreateTempDBInstanceRequest): CreateTempDBInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTempDBInstanceWithOptions(request, runtime);
}

model CreateDatabaseRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  DBName: string(name='DBName'),
  characterSetName: string(name='CharacterSetName'),
  DBDescription?: string(name='DBDescription'),
}

model CreateDatabaseResponse = {
  requestId: string(name='RequestId'),
}

async function createDatabaseWithOptions(request: CreateDatabaseRequest, runtime: Util.RuntimeOptions): CreateDatabaseResponse {
  Util.validateModel(request);
  return doRequest('CreateDatabase', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function createDatabase(request: CreateDatabaseRequest): CreateDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDatabaseWithOptions(request, runtime);
}

model CreateBackupRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  DBName?: string(name='DBName'),
  backupStrategy?: string(name='BackupStrategy'),
  backupMethod?: string(name='BackupMethod'),
  backupType?: string(name='BackupType'),
}

model CreateBackupResponse = {
  requestId: string(name='RequestId'),
  backupJobId: string(name='BackupJobId'),
}

async function createBackupWithOptions(request: CreateBackupRequest, runtime: Util.RuntimeOptions): CreateBackupResponse {
  Util.validateModel(request);
  return doRequest('CreateBackup', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function createBackup(request: CreateBackupRequest): CreateBackupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBackupWithOptions(request, runtime);
}

model CreateAccountRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  accountName: string(name='AccountName'),
  accountPassword: string(name='AccountPassword'),
  accountDescription?: string(name='AccountDescription'),
  accountType?: string(name='AccountType'),
}

model CreateAccountResponse = {
  requestId: string(name='RequestId'),
}

async function createAccountWithOptions(request: CreateAccountRequest, runtime: Util.RuntimeOptions): CreateAccountResponse {
  Util.validateModel(request);
  return doRequest('CreateAccount', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function createAccount(request: CreateAccountRequest): CreateAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAccountWithOptions(request, runtime);
}

model CheckDBNameAvailableRequest = {
  clientToken?: string(name='ClientToken'),
  DBInstanceId: string(name='DBInstanceId'),
  DBName: string(name='DBName'),
}

model CheckDBNameAvailableResponse = {
  requestId: string(name='RequestId'),
}

async function checkDBNameAvailableWithOptions(request: CheckDBNameAvailableRequest, runtime: Util.RuntimeOptions): CheckDBNameAvailableResponse {
  Util.validateModel(request);
  return doRequest('CheckDBNameAvailable', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function checkDBNameAvailable(request: CheckDBNameAvailableRequest): CheckDBNameAvailableResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkDBNameAvailableWithOptions(request, runtime);
}

model CheckAccountNameAvailableRequest = {
  clientToken?: string(name='ClientToken'),
  DBInstanceId: string(name='DBInstanceId'),
  accountName: string(name='AccountName'),
}

model CheckAccountNameAvailableResponse = {
  requestId: string(name='RequestId'),
}

async function checkAccountNameAvailableWithOptions(request: CheckAccountNameAvailableRequest, runtime: Util.RuntimeOptions): CheckAccountNameAvailableResponse {
  Util.validateModel(request);
  return doRequest('CheckAccountNameAvailable', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function checkAccountNameAvailable(request: CheckAccountNameAvailableRequest): CheckAccountNameAvailableResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkAccountNameAvailableWithOptions(request, runtime);
}

model CancelImportRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  importId: integer(name='ImportId'),
}

model CancelImportResponse = {
  requestId: string(name='RequestId'),
}

async function cancelImportWithOptions(request: CancelImportRequest, runtime: Util.RuntimeOptions): CancelImportResponse {
  Util.validateModel(request);
  return doRequest('CancelImport', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function cancelImport(request: CancelImportRequest): CancelImportResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelImportWithOptions(request, runtime);
}

model AddTagsToResourceRequest = {
  clientToken?: string(name='ClientToken'),
  proxyId?: string(name='proxyId'),
  regionId: string(name='RegionId'),
  DBInstanceId: string(name='DBInstanceId'),
  tags?: string(name='Tags'),
  tag?: [
    {
      key?: string(name='key'),
      value?: string(name='value'),
    }
  ](name='Tag'),
}

model AddTagsToResourceResponse = {
  requestId: string(name='RequestId'),
}

async function addTagsToResourceWithOptions(request: AddTagsToResourceRequest, runtime: Util.RuntimeOptions): AddTagsToResourceResponse {
  Util.validateModel(request);
  return doRequest('AddTagsToResource', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function addTagsToResource(request: AddTagsToResourceRequest): AddTagsToResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return addTagsToResourceWithOptions(request, runtime);
}

model SwitchDBInstanceNetTypeRequest = {
  clientToken?: string(name='ClientToken'),
  DBInstanceId: string(name='DBInstanceId'),
  connectionStringPrefix: string(name='ConnectionStringPrefix'),
  port?: string(name='Port'),
  connectionStringType?: string(name='ConnectionStringType'),
}

model SwitchDBInstanceNetTypeResponse = {
  requestId: string(name='RequestId'),
}

async function switchDBInstanceNetTypeWithOptions(request: SwitchDBInstanceNetTypeRequest, runtime: Util.RuntimeOptions): SwitchDBInstanceNetTypeResponse {
  Util.validateModel(request);
  return doRequest('SwitchDBInstanceNetType', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function switchDBInstanceNetType(request: SwitchDBInstanceNetTypeRequest): SwitchDBInstanceNetTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return switchDBInstanceNetTypeWithOptions(request, runtime);
}

model ReleaseInstancePublicConnectionRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  currentConnectionString: string(name='CurrentConnectionString'),
}

model ReleaseInstancePublicConnectionResponse = {
  requestId: string(name='RequestId'),
}

async function releaseInstancePublicConnectionWithOptions(request: ReleaseInstancePublicConnectionRequest, runtime: Util.RuntimeOptions): ReleaseInstancePublicConnectionResponse {
  Util.validateModel(request);
  return doRequest('ReleaseInstancePublicConnection', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function releaseInstancePublicConnection(request: ReleaseInstancePublicConnectionRequest): ReleaseInstancePublicConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return releaseInstancePublicConnectionWithOptions(request, runtime);
}

model ModifyDBInstanceNetworkTypeRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  retainClassic?: string(name='RetainClassic'),
  classicExpiredDays?: string(name='ClassicExpiredDays'),
  instanceNetworkType: string(name='InstanceNetworkType'),
  readWriteSplittingClassicExpiredDays?: integer(name='ReadWriteSplittingClassicExpiredDays'),
  VPCId?: string(name='VPCId'),
  vSwitchId?: string(name='VSwitchId'),
  privateIpAddress?: string(name='PrivateIpAddress'),
  readWriteSplittingPrivateIpAddress?: string(name='ReadWriteSplittingPrivateIpAddress'),
}

model ModifyDBInstanceNetworkTypeResponse = {
  requestId: string(name='RequestId'),
  taskId: string(name='TaskId'),
}

async function modifyDBInstanceNetworkTypeWithOptions(request: ModifyDBInstanceNetworkTypeRequest, runtime: Util.RuntimeOptions): ModifyDBInstanceNetworkTypeResponse {
  Util.validateModel(request);
  return doRequest('ModifyDBInstanceNetworkType', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifyDBInstanceNetworkType(request: ModifyDBInstanceNetworkTypeRequest): ModifyDBInstanceNetworkTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstanceNetworkTypeWithOptions(request, runtime);
}

model ModifyDBInstanceConnectionStringRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  currentConnectionString: string(name='CurrentConnectionString'),
  connectionStringPrefix: string(name='ConnectionStringPrefix'),
  port: string(name='Port'),
}

model ModifyDBInstanceConnectionStringResponse = {
  requestId: string(name='RequestId'),
}

async function modifyDBInstanceConnectionStringWithOptions(request: ModifyDBInstanceConnectionStringRequest, runtime: Util.RuntimeOptions): ModifyDBInstanceConnectionStringResponse {
  Util.validateModel(request);
  return doRequest('ModifyDBInstanceConnectionString', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifyDBInstanceConnectionString(request: ModifyDBInstanceConnectionStringRequest): ModifyDBInstanceConnectionStringResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstanceConnectionStringWithOptions(request, runtime);
}

model ModifyDBInstanceConnectionModeRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  connectionMode: string(name='ConnectionMode'),
}

model ModifyDBInstanceConnectionModeResponse = {
  requestId: string(name='RequestId'),
}

async function modifyDBInstanceConnectionModeWithOptions(request: ModifyDBInstanceConnectionModeRequest, runtime: Util.RuntimeOptions): ModifyDBInstanceConnectionModeResponse {
  Util.validateModel(request);
  return doRequest('ModifyDBInstanceConnectionMode', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function modifyDBInstanceConnectionMode(request: ModifyDBInstanceConnectionModeRequest): ModifyDBInstanceConnectionModeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstanceConnectionModeWithOptions(request, runtime);
}

model DescribeDBInstanceNetInfoRequest = {
  clientToken?: string(name='ClientToken'),
  DBInstanceId: string(name='DBInstanceId'),
  flag?: integer(name='Flag'),
  DBInstanceNetRWSplitType?: string(name='DBInstanceNetRWSplitType'),
}

model DescribeDBInstanceNetInfoResponse = {
  requestId: string(name='RequestId'),
  instanceNetworkType: string(name='InstanceNetworkType'),
  securityIPMode: string(name='SecurityIPMode'),
  DBInstanceNetInfos: {
    DBInstanceNetInfo: [
      {
        upgradeable: string(name='Upgradeable'),
        expiredTime: string(name='ExpiredTime'),
        connectionString: string(name='ConnectionString'),
        IPAddress: string(name='IPAddress'),
        IPType: string(name='IPType'),
        port: string(name='Port'),
        VPCId: string(name='VPCId'),
        vSwitchId: string(name='VSwitchId'),
        connectionStringType: string(name='ConnectionStringType'),
        maxDelayTime: string(name='MaxDelayTime'),
        distributionType: string(name='DistributionType'),
        securityIPGroups: {
          securityIPGroup: [
            {
              securityIPGroupName: string(name='SecurityIPGroupName'),
              securityIPs: string(name='SecurityIPs'),
            }
          ](name='securityIPGroup'),
        }(name='SecurityIPGroups'),
        DBInstanceWeights: {
          DBInstanceWeight: [
            {
              DBInstanceId: string(name='DBInstanceId'),
              DBInstanceType: string(name='DBInstanceType'),
              availability: string(name='Availability'),
              weight: string(name='Weight'),
            }
          ](name='DBInstanceWeight'),
        }(name='DBInstanceWeights'),
      }
    ](name='DBInstanceNetInfo'),
  }(name='DBInstanceNetInfos'),
}

async function describeDBInstanceNetInfoWithOptions(request: DescribeDBInstanceNetInfoRequest, runtime: Util.RuntimeOptions): DescribeDBInstanceNetInfoResponse {
  Util.validateModel(request);
  return doRequest('DescribeDBInstanceNetInfo', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeDBInstanceNetInfo(request: DescribeDBInstanceNetInfoRequest): DescribeDBInstanceNetInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstanceNetInfoWithOptions(request, runtime);
}

model CreateReadOnlyDBInstanceRequest = {
  clientToken?: string(name='ClientToken'),
  regionId: string(name='RegionId'),
  zoneId: string(name='ZoneId'),
  DBInstanceId: string(name='DBInstanceId'),
  DBInstanceClass: string(name='DBInstanceClass'),
  DBInstanceStorage: integer(name='DBInstanceStorage'),
  engineVersion: string(name='EngineVersion'),
  payType: string(name='PayType'),
  DBInstanceDescription?: string(name='DBInstanceDescription'),
  instanceNetworkType?: string(name='InstanceNetworkType'),
  VPCId?: string(name='VPCId'),
  vSwitchId?: string(name='VSwitchId'),
  privateIpAddress?: string(name='PrivateIpAddress'),
  resourceGroupId?: string(name='ResourceGroupId'),
  category?: string(name='Category'),
  DBInstanceStorageType?: string(name='DBInstanceStorageType'),
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
  targetDedicatedHostIdForMaster?: string(name='TargetDedicatedHostIdForMaster'),
  gdnInstanceName?: string(name='GdnInstanceName'),
  tddlBizType?: string(name='TddlBizType'),
  tddlRegionConfig?: string(name='TddlRegionConfig'),
  instructionSetArch?: string(name='InstructionSetArch'),
}

model CreateReadOnlyDBInstanceResponse = {
  requestId: string(name='RequestId'),
  DBInstanceId: string(name='DBInstanceId'),
  orderId: string(name='OrderId'),
  connectionString: string(name='ConnectionString'),
  port: string(name='Port'),
}

async function createReadOnlyDBInstanceWithOptions(request: CreateReadOnlyDBInstanceRequest, runtime: Util.RuntimeOptions): CreateReadOnlyDBInstanceResponse {
  Util.validateModel(request);
  return doRequest('CreateReadOnlyDBInstance', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function createReadOnlyDBInstance(request: CreateReadOnlyDBInstanceRequest): CreateReadOnlyDBInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createReadOnlyDBInstanceWithOptions(request, runtime);
}

model CreateDBInstanceRequest = {
  regionId: string(name='RegionId', description='description: 地域ID，可以通过接口[DescribeRegions](~~26243~~)查看可用的地域ID。; '),
  engine: string(name='Engine', description='description: 数据库类型，取值：* **MySQL**；* **SQLServer**；* **PostgreSQL**；* **PPAS**；* **MariaDB**。; '),
  engineVersion: string(name='EngineVersion', description='description: 数据库版本，取值：* MySQL：**5.5/5.6/5.7/8.0**；* SQL Server：**2008r2/2012/2012_ent_ha/2012_std_ha/2012_web/2016_ent_ha/2016_std_ha/2016_web/2017_ent**；* PostgreSQL：**9.4/10.0**；* PPAS：**9.3/10.0**；* MariaDB：**10.3**。; '),
  DBInstanceClass: string(name='DBInstanceClass', description='description: 实例规格，详见[实例规格表](~~26312~~)。; '),
  DBInstanceStorage: integer(name='DBInstanceStorage', description='description: 实例存储空间，单位：GB。每5GB进行递增，详见[实例规格表](~~26312~~)。; '),
  systemDBCharset?: string(name='SystemDBCharset', description='description: 字符集，取值：* MySQL/MariaDB实例：**utf8、gbk、latin1、utf8mb4**；* SQL Server实例：**Chinese_PRC_CI_AS、Chinese_PRC_CS_AS、SQL_Latin1_General_CP1_CI_AS、SQL_Latin1_General_CP1_CS_AS、Chinese_PRC_BIN**。; '),
  DBInstanceNetType: string(name='DBInstanceNetType', description='description: 实例的网络连接类型，取值：* **Internet**：公网连接；* **Intranet**：内网连接。; '),
  DBInstanceDescription?: string(name='DBInstanceDescription', description='description: 实例名称，长度为2~256个字符。以中文、英文字母开头，可以包含数字、中文、英文、下划线（_）、短横线（-）。>不能以 http:// 和 https:// 开头。; '),
  securityIPList: string(name='SecurityIPList', description='description: 该实例的[IP白名单](~~43185~~)，多个IP地址请以英文逗号（,）隔开，不可重复，最多1000个。支持如下两种格式：* IP地址形式，例如：10.23.12.24；* CIDR形式，例如：10.23.12.24/24（无类域间路由，24表示了地址中前缀的长度，范围为1~32）。; '),
  clientToken?: string(name='ClientToken', description='description: 用于保证请求的幂等性，防止重复提交请求。由客户端生成该参数值，要保证在不同请求间唯一，最大值不超过64个ASCII字符，且该参数值中不能包含非ASCII字符。; '),
  payType: string(name='PayType', description='description: 实例的付费类型，取值：* **Postpaid**：后付费（按量付费）；* **Prepaid**：预付费（包年包月）。; '),
  zoneId?: string(name='ZoneId', description='description: 可用区ID。多可用区用英文冒号（:）分隔。> 指定了VPC和交换机时，为匹配交换机对应的可用区，该参数必填。; '),
  zoneIdSlave1?: string(name='ZoneIdSlave1'),
  zoneIdSlave2?: string(name='ZoneIdSlave2'),
  instanceNetworkType?: string(name='InstanceNetworkType', description='description: 实例的网络类型，取值：* **VPC**：VPC网络；* **Classic**：经典网络。默认创建经典网络类型的实例。> * SQL Server2017集群版只支持VPC网络；* 如果数据库类型为MariaDB，该参数必填。; '),
  connectionMode?: string(name='ConnectionMode', description='description: 实例的访问模式，取值：* **Standard**：标准访问模式；* **Safe**：数据库代理模式。默认为RDS系统分配。> SQL Server 2012/2016/2017只支持标准访问模式。; '),
  VPCId?: string(name='VPCId', description='description: VPC ID。>如果数据库类型为MariaDB，该参数必填。; '),
  vSwitchId?: string(name='VSwitchId', description='description: VSwitch ID，多个值用英文逗号（,）隔开。>如果数据库类型为MariaDB，该参数必填。; '),
  privateIpAddress?: string(name='PrivateIpAddress', description='description: 设置实例的内网IP，需要在指定交换机的IP地址范围内。系统默认通过**VPCId**和**VSwitchId**自动分配。; '),
  usedTime?: string(name='UsedTime', description='description: 指定购买时长，取值：* 当参数**Period**为**Year**时，UsedTime取值为**1~3**；* 当参数**Period**为**Month**时，UsedTime取值为**1~9**。> 若付费类型为**Prepaid**则该参数必须传入。; '),
  period?: string(name='Period', description='description: 指定预付费实例为包年或者包月类型，取值：* **Year**：包年；* **Month**：包月。> 若付费类型为**Prepaid**则该参数必须传入。; '),
  resourceGroupId?: string(name='ResourceGroupId'),
  DBInstanceStorageType?: string(name='DBInstanceStorageType', description='description: 实例存储类型，取值：* **local_ssd**/**ephemeral_ssd**：本地SSD盘（推荐）；* **cloud_ssd**：SSD云盘；* **cloud_essd**：ESSD云盘。; '),
  businessInfo?: string(name='BusinessInfo', description='description: 业务扩展参数。; '),
  encryptionKey?: string(name='EncryptionKey'),
  roleARN?: string(name='RoleARN'),
  autoRenew?: string(name='AutoRenew', description='description: 实例是否自动续费，取值：**true | false**>* 按月购买，则自动续费周期为1个月；* 按年购买，则自动续费周期为1年。; '),
  category?: string(name='Category'),
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
  targetDedicatedHostIdForMaster?: string(name='TargetDedicatedHostIdForMaster'),
  targetDedicatedHostIdForSlave?: string(name='TargetDedicatedHostIdForSlave'),
  targetDedicatedHostIdForLog?: string(name='TargetDedicatedHostIdForLog'),
  DBParamGroupId?: string(name='DBParamGroupId'),
  DBTimeZone?: string(name='DBTimeZone'),
  DBIsIgnoreCase?: string(name='DBIsIgnoreCase'),
  targetMinorVersion?: string(name='TargetMinorVersion'),
  storageAutoScale?: string(name='StorageAutoScale'),
  storageThreshold?: integer(name='StorageThreshold'),
  storageUpperBound?: integer(name='StorageUpperBound'),
}

model CreateDBInstanceResponse = {
  requestId: string(name='RequestId', description='description: 请求ID。; '),
  DBInstanceId: string(name='DBInstanceId', description='description: 实例ID。; '),
  orderId: string(name='OrderId', description='description: 订单ID。; '),
  connectionString: string(name='ConnectionString', description='description: 数据库连接地址。>参数**DBInstanceNetType**决定该地址为内网或外网。; '),
  port: string(name='Port', description='description: 数据库连接端口。>参数**DBInstanceNetType**决定该端口为内网或外网。; '),
}

/**
 * CreateDBInstance 调用CreateDBInstance接口创建一个RDS实例。
  * request demo:   * ```
  * http(s)://rds.aliyuncs.com/?Action=CreateDBInstance
  * &RegionId=cn-hangzhou
  * &Engine=MySQL
  * &EngineVersion=5.6
  * &DBInstanceClass=rds.mysql.s1.small
  * &DBInstanceStorage=20
  * &DBInstanceNetType=Internet
  * &PayType=Postpaid
  * &SecurityIPList=10.23.12.27/24
  * &<公共请求参数>
  * ```
  * description:   * **请确保在使用该接口前，已充分了解RDS产品的收费方式和<xref href="https://www.alibabacloud.com/product/apsaradb-for-rds#pricing" format="html" scope="external" props="intl">价格</xref><xref href="https://www.aliyun.com/price/product#/rds/detail" format="html" scope="external" props="china">价格</xref>。**
  * 关于RDS实例的规格，请参见[实例规格表](~~26312~~)。

 */
async function createDBInstanceWithOptions(request: CreateDBInstanceRequest, runtime: Util.RuntimeOptions): CreateDBInstanceResponse {
  Util.validateModel(request);
  return doRequest('CreateDBInstance', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

/**
 * CreateDBInstance 调用CreateDBInstance接口创建一个RDS实例。
  * request demo:   * ```
  * http(s)://rds.aliyuncs.com/?Action=CreateDBInstance
  * &RegionId=cn-hangzhou
  * &Engine=MySQL
  * &EngineVersion=5.6
  * &DBInstanceClass=rds.mysql.s1.small
  * &DBInstanceStorage=20
  * &DBInstanceNetType=Internet
  * &PayType=Postpaid
  * &SecurityIPList=10.23.12.27/24
  * &<公共请求参数>
  * ```
  * description:   * **请确保在使用该接口前，已充分了解RDS产品的收费方式和<xref href="https://www.alibabacloud.com/product/apsaradb-for-rds#pricing" format="html" scope="external" props="intl">价格</xref><xref href="https://www.aliyun.com/price/product#/rds/detail" format="html" scope="external" props="china">价格</xref>。**
  * 关于RDS实例的规格，请参见[实例规格表](~~26312~~)。

 */
async function createDBInstance(request: CreateDBInstanceRequest): CreateDBInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDBInstanceWithOptions(request, runtime);
}

model AllocateInstancePublicConnectionRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  connectionStringPrefix: string(name='ConnectionStringPrefix'),
  port: string(name='Port'),
}

model AllocateInstancePublicConnectionResponse = {
  requestId: string(name='RequestId'),
}

async function allocateInstancePublicConnectionWithOptions(request: AllocateInstancePublicConnectionRequest, runtime: Util.RuntimeOptions): AllocateInstancePublicConnectionResponse {
  Util.validateModel(request);
  return doRequest('AllocateInstancePublicConnection', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function allocateInstancePublicConnection(request: AllocateInstancePublicConnectionRequest): AllocateInstancePublicConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return allocateInstancePublicConnectionWithOptions(request, runtime);
}

model DescribeDBInstancesByPerformanceRequest = {
  clientToken?: string(name='ClientToken'),
  proxyId?: string(name='proxyId'),
  DBInstanceId?: string(name='DBInstanceId'),
  pageSize?: integer(name='PageSize'),
  pageNumber?: integer(name='PageNumber'),
  sortMethod?: string(name='SortMethod'),
  sortKey?: string(name='SortKey'),
  tags?: string(name='Tags'),
  tag?: [
    {
      key?: string(name='key'),
      value?: string(name='value'),
    }
  ](name='Tag'),
  regionId?: string(name='RegionId'),
}

model DescribeDBInstancesByPerformanceResponse = {
  requestId: string(name='RequestId'),
  pageNumber: integer(name='PageNumber'),
  totalRecordCount: integer(name='TotalRecordCount'),
  pageRecordCount: integer(name='PageRecordCount'),
  items: {
    DBInstancePerformance: [
      {
        CPUUsage: string(name='CPUUsage'),
        IOPSUsage: string(name='IOPSUsage'),
        diskUsage: string(name='DiskUsage'),
        sessionUsage: string(name='SessionUsage'),
        DBInstanceId: string(name='DBInstanceId'),
        DBInstanceDescription: string(name='DBInstanceDescription'),
      }
    ](name='DBInstancePerformance'),
  }(name='Items'),
}

async function describeDBInstancesByPerformanceWithOptions(request: DescribeDBInstancesByPerformanceRequest, runtime: Util.RuntimeOptions): DescribeDBInstancesByPerformanceResponse {
  Util.validateModel(request);
  return doRequest('DescribeDBInstancesByPerformance', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeDBInstancesByPerformance(request: DescribeDBInstancesByPerformanceRequest): DescribeDBInstancesByPerformanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstancesByPerformanceWithOptions(request, runtime);
}

model DescribeDBInstancesByExpireTimeRequest = {
  regionId?: string(name='RegionId'),
  proxyId?: string(name='proxyId'),
  expirePeriod?: integer(name='ExpirePeriod'),
  expired?: boolean(name='Expired'),
  pageSize?: integer(name='PageSize'),
  pageNumber?: integer(name='PageNumber'),
  tags?: string(name='Tags'),
}

model DescribeDBInstancesByExpireTimeResponse = {
  requestId: string(name='RequestId'),
  pageNumber: integer(name='PageNumber'),
  totalRecordCount: integer(name='TotalRecordCount'),
  pageRecordCount: integer(name='PageRecordCount'),
  items: {
    DBInstanceExpireTime: [
      {
        DBInstanceId: string(name='DBInstanceId'),
        DBInstanceDescription: string(name='DBInstanceDescription'),
        expireTime: string(name='ExpireTime'),
        DBInstanceStatus: string(name='DBInstanceStatus'),
        lockMode: string(name='LockMode'),
        payType: string(name='PayType'),
      }
    ](name='DBInstanceExpireTime'),
  }(name='Items'),
}

async function describeDBInstancesByExpireTimeWithOptions(request: DescribeDBInstancesByExpireTimeRequest, runtime: Util.RuntimeOptions): DescribeDBInstancesByExpireTimeResponse {
  Util.validateModel(request);
  return doRequest('DescribeDBInstancesByExpireTime', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeDBInstancesByExpireTime(request: DescribeDBInstancesByExpireTimeRequest): DescribeDBInstancesByExpireTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstancesByExpireTimeWithOptions(request, runtime);
}

model DescribeDBInstancesRequest = {
  clientToken?: string(name='ClientToken'),
  proxyId?: string(name='proxyId'),
  engine?: string(name='Engine'),
  zoneId?: string(name='ZoneId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  DBInstanceStatus?: string(name='DBInstanceStatus'),
  expired?: string(name='Expired'),
  searchKey?: string(name='SearchKey'),
  DBInstanceId?: string(name='DBInstanceId'),
  DBInstanceType?: string(name='DBInstanceType'),
  regionId: string(name='RegionId'),
  pageSize?: integer(name='PageSize'),
  pageNumber?: integer(name='PageNumber'),
  instanceNetworkType?: string(name='InstanceNetworkType'),
  vpcId?: string(name='VpcId'),
  vSwitchId?: string(name='VSwitchId'),
  DBInstanceClass?: string(name='DBInstanceClass'),
  engineVersion?: string(name='EngineVersion'),
  payType?: string(name='PayType'),
  connectionMode?: string(name='ConnectionMode'),
  tags?: string(name='Tags'),
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
  dedicatedHostId?: string(name='DedicatedHostId'),
  instanceLevel?: integer(name='InstanceLevel'),
  needVpcName?: boolean(name='NeedVpcName'),
}

model DescribeDBInstancesResponse = {
  requestId: string(name='RequestId'),
  pageNumber: integer(name='PageNumber'),
  totalRecordCount: integer(name='TotalRecordCount'),
  pageRecordCount: integer(name='PageRecordCount'),
  items: {
    DBInstance: [
      {
        insId: integer(name='InsId'),
        DBInstanceId: string(name='DBInstanceId'),
        DBInstanceDescription: string(name='DBInstanceDescription'),
        payType: string(name='PayType'),
        DBInstanceType: string(name='DBInstanceType'),
        regionId: string(name='RegionId'),
        expireTime: string(name='ExpireTime'),
        destroyTime: string(name='DestroyTime'),
        DBInstanceStatus: string(name='DBInstanceStatus'),
        engine: string(name='Engine'),
        DBInstanceNetType: string(name='DBInstanceNetType'),
        connectionMode: string(name='ConnectionMode'),
        lockMode: string(name='LockMode'),
        category: string(name='Category'),
        DBInstanceStorageType: string(name='DBInstanceStorageType'),
        DBInstanceClass: string(name='DBInstanceClass'),
        instanceNetworkType: string(name='InstanceNetworkType'),
        vpcCloudInstanceId: string(name='VpcCloudInstanceId'),
        lockReason: string(name='LockReason'),
        zoneId: string(name='ZoneId'),
        mutriORsignle: boolean(name='MutriORsignle'),
        createTime: string(name='CreateTime'),
        engineVersion: string(name='EngineVersion'),
        guardDBInstanceId: string(name='GuardDBInstanceId'),
        tempDBInstanceId: string(name='TempDBInstanceId'),
        masterInstanceId: string(name='MasterInstanceId'),
        vpcId: string(name='VpcId'),
        vSwitchId: string(name='VSwitchId'),
        replicateId: string(name='ReplicateId'),
        resourceGroupId: string(name='ResourceGroupId'),
        autoUpgradeMinorVersion: string(name='AutoUpgradeMinorVersion'),
        dedicatedHostGroupId: string(name='DedicatedHostGroupId'),
        dedicatedHostIdForMaster: string(name='DedicatedHostIdForMaster'),
        dedicatedHostIdForSlave: string(name='DedicatedHostIdForSlave'),
        dedicatedHostIdForLog: string(name='DedicatedHostIdForLog'),
        dedicatedHostNameForMaster: string(name='DedicatedHostNameForMaster'),
        dedicatedHostNameForSlave: string(name='DedicatedHostNameForSlave'),
        dedicatedHostNameForLog: string(name='DedicatedHostNameForLog'),
        dedicatedHostZoneIdForMaster: string(name='DedicatedHostZoneIdForMaster'),
        dedicatedHostZoneIdForSlave: string(name='DedicatedHostZoneIdForSlave'),
        dedicatedHostZoneIdForLog: string(name='DedicatedHostZoneIdForLog'),
        vpcName: string(name='VpcName'),
        dedicatedHostGroupName: string(name='DedicatedHostGroupName'),
        readOnlyDBInstanceIds: {
          readOnlyDBInstanceId: [
            {
              DBInstanceId: string(name='DBInstanceId'),
            }
          ](name='ReadOnlyDBInstanceId'),
        }(name='ReadOnlyDBInstanceIds'),
      }
    ](name='DBInstance'),
  }(name='Items'),
}

async function describeDBInstancesWithOptions(request: DescribeDBInstancesRequest, runtime: Util.RuntimeOptions): DescribeDBInstancesResponse {
  Util.validateModel(request);
  return doRequest('DescribeDBInstances', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeDBInstances(request: DescribeDBInstancesRequest): DescribeDBInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstancesWithOptions(request, runtime);
}

model DescribeDBInstanceAttributeRequest = {
  DBInstanceId: string(name='DBInstanceId'),
  expired?: string(name='Expired'),
}

model DescribeDBInstanceAttributeResponse = {
  requestId: string(name='RequestId'),
  items: {
    DBInstanceAttribute: [
      {
        IPType: string(name='IPType'),
        DBInstanceDiskUsed: string(name='DBInstanceDiskUsed'),
        guardDBInstanceName: string(name='GuardDBInstanceName'),
        canTempUpgrade: boolean(name='CanTempUpgrade'),
        tempUpgradeTimeStart: string(name='TempUpgradeTimeStart'),
        tempUpgradeTimeEnd: string(name='TempUpgradeTimeEnd'),
        tempUpgradeRecoveryTime: string(name='TempUpgradeRecoveryTime'),
        tempUpgradeRecoveryClass: string(name='TempUpgradeRecoveryClass'),
        tempUpgradeRecoveryCpu: integer(name='TempUpgradeRecoveryCpu'),
        tempUpgradeRecoveryMemory: integer(name='TempUpgradeRecoveryMemory'),
        tempUpgradeRecoveryMaxIOPS: string(name='TempUpgradeRecoveryMaxIOPS'),
        tempUpgradeRecoveryMaxConnections: string(name='TempUpgradeRecoveryMaxConnections'),
        insId: integer(name='InsId'),
        DBInstanceId: string(name='DBInstanceId'),
        payType: string(name='PayType'),
        DBInstanceClassType: string(name='DBInstanceClassType'),
        DBInstanceType: string(name='DBInstanceType'),
        regionId: string(name='RegionId'),
        connectionString: string(name='ConnectionString'),
        port: string(name='Port'),
        engine: string(name='Engine'),
        engineVersion: string(name='EngineVersion'),
        DBInstanceClass: string(name='DBInstanceClass'),
        DBInstanceMemory: long(name='DBInstanceMemory'),
        DBInstanceStorage: integer(name='DBInstanceStorage'),
        vpcCloudInstanceId: string(name='VpcCloudInstanceId'),
        DBInstanceNetType: string(name='DBInstanceNetType'),
        DBInstanceStatus: string(name='DBInstanceStatus'),
        DBInstanceDescription: string(name='DBInstanceDescription'),
        lockMode: string(name='LockMode'),
        lockReason: string(name='LockReason'),
        readDelayTime: string(name='ReadDelayTime'),
        DBMaxQuantity: integer(name='DBMaxQuantity'),
        accountMaxQuantity: integer(name='AccountMaxQuantity'),
        creationTime: string(name='CreationTime'),
        expireTime: string(name='ExpireTime'),
        maintainTime: string(name='MaintainTime'),
        availabilityValue: string(name='AvailabilityValue'),
        maxIOPS: integer(name='MaxIOPS'),
        maxConnections: integer(name='MaxConnections'),
        masterInstanceId: string(name='MasterInstanceId'),
        DBInstanceCPU: string(name='DBInstanceCPU'),
        incrementSourceDBInstanceId: string(name='IncrementSourceDBInstanceId'),
        guardDBInstanceId: string(name='GuardDBInstanceId'),
        replicateId: string(name='ReplicateId'),
        tempDBInstanceId: string(name='TempDBInstanceId'),
        securityIPList: string(name='SecurityIPList'),
        zoneId: string(name='ZoneId'),
        instanceNetworkType: string(name='InstanceNetworkType'),
        DBInstanceStorageType: string(name='DBInstanceStorageType'),
        advancedFeatures: string(name='AdvancedFeatures'),
        category: string(name='Category'),
        accountType: string(name='AccountType'),
        supportUpgradeAccountType: string(name='SupportUpgradeAccountType'),
        supportCreateSuperAccount: string(name='SupportCreateSuperAccount'),
        vpcId: string(name='VpcId'),
        vSwitchId: string(name='VSwitchId'),
        connectionMode: string(name='ConnectionMode'),
        currentKernelVersion: string(name='CurrentKernelVersion'),
        latestKernelVersion: string(name='LatestKernelVersion'),
        resourceGroupId: string(name='ResourceGroupId'),
        readonlyInstanceSQLDelayedTime: string(name='ReadonlyInstanceSQLDelayedTime'),
        securityIPMode: string(name='SecurityIPMode'),
        timeZone: string(name='TimeZone'),
        collation: string(name='Collation'),
        dispenseMode: string(name='DispenseMode'),
        masterZone: string(name='MasterZone'),
        autoUpgradeMinorVersion: string(name='AutoUpgradeMinorVersion'),
        proxyType: integer(name='ProxyType'),
        consoleVersion: string(name='ConsoleVersion'),
        multipleTempUpgrade: boolean(name='MultipleTempUpgrade'),
        originConfiguration: string(name='OriginConfiguration'),
        dedicatedHostGroupId: string(name='DedicatedHostGroupId'),
        superPermissionMode: string(name='SuperPermissionMode'),
        slaveZones: {
          slaveZone: [
            {
              zoneId: string(name='ZoneId'),
            }
          ](name='SlaveZone'),
        }(name='SlaveZones'),
        readOnlyDBInstanceIds: {
          readOnlyDBInstanceId: [
            {
              DBInstanceId: string(name='DBInstanceId'),
            }
          ](name='ReadOnlyDBInstanceId'),
        }(name='ReadOnlyDBInstanceIds'),
        extra: {
          replicaGroupID: string(name='ReplicaGroupID'),
          replicaGroupStatus: string(name='ReplicaGroupStatus'),
          activeReplicaDBInstanceID: string(name='ActiveReplicaDBInstanceID'),
          DBInstanceIds: {
            DBInstanceId: [ string ](name='DBInstanceId', description='DBInstanceId'),
          }(name='DBInstanceIds'),
        }(name='Extra'),
      }
    ](name='DBInstanceAttribute'),
  }(name='Items'),
}

async function describeDBInstanceAttributeWithOptions(request: DescribeDBInstanceAttributeRequest, runtime: Util.RuntimeOptions): DescribeDBInstanceAttributeResponse {
  Util.validateModel(request);
  return doRequest('DescribeDBInstanceAttribute', 'HTTPS', 'POST', '2014-08-15', 'AK', null, request, runtime);
}

async function describeDBInstanceAttribute(request: DescribeDBInstanceAttributeRequest): DescribeDBInstanceAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstanceAttributeWithOptions(request, runtime);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
