import Util;
import RPC;
import EndpointUtil;

extends RPC;

init(config: RPC.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-1 = 'business.ap-southeast-1.aliyuncs.com',
    ap-northeast-2-pop = 'business.ap-southeast-1.aliyuncs.com',
    ap-south-1 = 'business.ap-southeast-1.aliyuncs.com',
    ap-southeast-1 = 'business.ap-southeast-1.aliyuncs.com',
    ap-southeast-2 = 'business.ap-southeast-1.aliyuncs.com',
    ap-southeast-3 = 'business.ap-southeast-1.aliyuncs.com',
    ap-southeast-5 = 'business.ap-southeast-1.aliyuncs.com',
    cn-beijing = 'business.aliyuncs.com',
    cn-beijing-finance-1 = 'business.aliyuncs.com',
    cn-beijing-finance-pop = 'business.aliyuncs.com',
    cn-beijing-gov-1 = 'business.aliyuncs.com',
    cn-beijing-nu16-b01 = 'business.aliyuncs.com',
    cn-chengdu = 'business.aliyuncs.com',
    cn-edge-1 = 'business.aliyuncs.com',
    cn-fujian = 'business.aliyuncs.com',
    cn-haidian-cm12-c01 = 'business.aliyuncs.com',
    cn-hangzhou = 'business.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'business.aliyuncs.com',
    cn-hangzhou-finance = 'business.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'business.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'business.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'business.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'business.aliyuncs.com',
    cn-hangzhou-test-306 = 'business.aliyuncs.com',
    cn-hongkong = 'business.aliyuncs.com',
    cn-hongkong-finance-pop = 'business.aliyuncs.com',
    cn-huhehaote = 'business.aliyuncs.com',
    cn-north-2-gov-1 = 'business.aliyuncs.com',
    cn-qingdao = 'business.aliyuncs.com',
    cn-qingdao-nebula = 'business.aliyuncs.com',
    cn-shanghai = 'business.aliyuncs.com',
    cn-shanghai-et15-b01 = 'business.aliyuncs.com',
    cn-shanghai-et2-b01 = 'business.aliyuncs.com',
    cn-shanghai-finance-1 = 'business.aliyuncs.com',
    cn-shanghai-inner = 'business.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'business.aliyuncs.com',
    cn-shenzhen = 'business.aliyuncs.com',
    cn-shenzhen-finance-1 = 'business.aliyuncs.com',
    cn-shenzhen-inner = 'business.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'business.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'business.aliyuncs.com',
    cn-wuhan = 'business.aliyuncs.com',
    cn-yushanfang = 'business.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'business.aliyuncs.com',
    cn-zhangjiakou = 'business.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'business.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'business.aliyuncs.com',
    eu-central-1 = 'business.ap-southeast-1.aliyuncs.com',
    eu-west-1 = 'business.ap-southeast-1.aliyuncs.com',
    eu-west-1-oxs = 'business.ap-southeast-1.aliyuncs.com',
    me-east-1 = 'business.ap-southeast-1.aliyuncs.com',
    rus-west-1-pop = 'business.ap-southeast-1.aliyuncs.com',
    us-east-1 = 'business.ap-southeast-1.aliyuncs.com',
    us-west-1 = 'business.ap-southeast-1.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('bssopenapi', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

model QuerySettleBillRequest = {
  billingCycle: string(name='BillingCycle'),
  type?: string(name='Type'),
  productCode?: string(name='ProductCode'),
  productType?: string(name='ProductType'),
  subscriptionType?: string(name='SubscriptionType'),
  isHideZeroCharge?: boolean(name='IsHideZeroCharge'),
  isDisplayLocalCurrency?: boolean(name='IsDisplayLocalCurrency'),
  nextToken?: string(name='NextToken'),
  maxResults?: integer(name='MaxResults'),
}

model QuerySettleBillResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    billingCycle: string(name='BillingCycle'),
    accountID: string(name='AccountID'),
    accountName: string(name='AccountName'),
    nextToken: string(name='NextToken'),
    maxResults: integer(name='MaxResults'),
    totalCount: integer(name='TotalCount'),
    items: {
      item: [
        {
          recordID: string(name='RecordID'),
          item: string(name='Item'),
          ownerID: string(name='OwnerID'),
          usageStartTime: string(name='UsageStartTime'),
          usageEndTime: string(name='UsageEndTime'),
          paymentTime: string(name='PaymentTime'),
          productCode: string(name='ProductCode'),
          productType: string(name='ProductType'),
          subscriptionType: string(name='SubscriptionType'),
          productName: string(name='ProductName'),
          productDetail: string(name='ProductDetail'),
          pretaxGrossAmount: float(name='PretaxGrossAmount'),
          deductedByCoupons: float(name='DeductedByCoupons'),
          invoiceDiscount: float(name='InvoiceDiscount'),
          pretaxAmount: float(name='PretaxAmount'),
          currency: string(name='Currency'),
          pretaxAmountLocal: float(name='PretaxAmountLocal'),
          tax: float(name='Tax'),
          paymentAmount: float(name='PaymentAmount'),
          deductedByCashCoupons: float(name='DeductedByCashCoupons'),
          deductedByPrepaidCard: float(name='DeductedByPrepaidCard'),
          outstandingAmount: float(name='OutstandingAmount'),
          afterTaxAmount: float(name='AfterTaxAmount'),
          status: string(name='Status'),
          paymentCurrency: string(name='PaymentCurrency'),
          paymentTransactionID: string(name='PaymentTransactionID'),
          roundDownDiscount: string(name='RoundDownDiscount'),
          subOrderId: string(name='SubOrderId'),
        }
      ](name='Item'),
    }(name='Items'),
  }(name='Data'),
}

async function querySettleBillWithOptions(request: QuerySettleBillRequest, runtime: Util.RuntimeOptions): QuerySettleBillResponse {
  Util.validateModel(request);
  return doRequest('QuerySettleBill', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function querySettleBill(request: QuerySettleBillRequest): QuerySettleBillResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySettleBillWithOptions(request, runtime);
}

model QuerySplitItemBillRequest = {
  billingCycle: string(name='BillingCycle'),
  productCode?: string(name='ProductCode'),
  productType?: string(name='ProductType'),
  subscriptionType?: string(name='SubscriptionType'),
  pageNum?: integer(name='PageNum'),
  pageSize?: integer(name='PageSize'),
}

model QuerySplitItemBillResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    billingCycle: string(name='BillingCycle'),
    accountID: string(name='AccountID'),
    accountName: string(name='AccountName'),
    totalCount: integer(name='TotalCount'),
    pageNum: integer(name='PageNum'),
    pageSize: integer(name='PageSize'),
    items: {
      item: [
        {
          instanceID: string(name='InstanceID'),
          billingType: string(name='BillingType'),
          costUnit: string(name='CostUnit'),
          productCode: string(name='ProductCode'),
          productType: string(name='ProductType'),
          subscriptionType: string(name='SubscriptionType'),
          productName: string(name='ProductName'),
          productDetail: string(name='ProductDetail'),
          ownerID: string(name='OwnerID'),
          billingItem: string(name='BillingItem'),
          listPrice: string(name='ListPrice'),
          listPriceUnit: string(name='ListPriceUnit'),
          usage: string(name='Usage'),
          usageUnit: string(name='UsageUnit'),
          deductedByResourcePackage: string(name='DeductedByResourcePackage'),
          pretaxGrossAmount: float(name='PretaxGrossAmount'),
          invoiceDiscount: float(name='InvoiceDiscount'),
          deductedByCoupons: float(name='DeductedByCoupons'),
          pretaxAmount: float(name='PretaxAmount'),
          deductedByCashCoupons: float(name='DeductedByCashCoupons'),
          deductedByPrepaidCard: float(name='DeductedByPrepaidCard'),
          paymentAmount: float(name='PaymentAmount'),
          outstandingAmount: float(name='OutstandingAmount'),
          currency: string(name='Currency'),
          nickName: string(name='NickName'),
          resourceGroup: string(name='ResourceGroup'),
          tag: string(name='Tag'),
          instanceConfig: string(name='InstanceConfig'),
          instanceSpec: string(name='InstanceSpec'),
          internetIP: string(name='InternetIP'),
          intranetIP: string(name='IntranetIP'),
          region: string(name='Region'),
          zone: string(name='Zone'),
          item: string(name='Item'),
          servicePeriod: string(name='ServicePeriod'),
          billingDate: string(name='BillingDate'),
          splitItemID: string(name='SplitItemID'),
          splitItemName: string(name='SplitItemName'),
        }
      ](name='Item'),
    }(name='Items'),
  }(name='Data'),
}

async function querySplitItemBillWithOptions(request: QuerySplitItemBillRequest, runtime: Util.RuntimeOptions): QuerySplitItemBillResponse {
  Util.validateModel(request);
  return doRequest('QuerySplitItemBill', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function querySplitItemBill(request: QuerySplitItemBillRequest): QuerySplitItemBillResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySplitItemBillWithOptions(request, runtime);
}

model QueryRIUtilizationDetailRequest = {
  RIInstanceId?: string(name='RIInstanceId'),
  instanceSpec?: string(name='InstanceSpec'),
  RICommodityCode: string(name='RICommodityCode'),
  deductedInstanceId?: string(name='DeductedInstanceId'),
  startTime: string(name='StartTime'),
  endTime: string(name='EndTime'),
  pageNum?: integer(name='PageNum'),
  pageSize?: integer(name='PageSize'),
}

model QueryRIUtilizationDetailResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    pageNum: long(name='PageNum'),
    pageSize: long(name='PageSize'),
    totalCount: long(name='TotalCount'),
    detailList: {
      detailList: [
        {
          RIInstanceId: string(name='RIInstanceId'),
          instanceSpec: string(name='InstanceSpec'),
          deductedInstanceId: string(name='DeductedInstanceId'),
          deductedCommodityCode: string(name='DeductedCommodityCode'),
          deductDate: string(name='DeductDate'),
          deductHours: string(name='DeductHours'),
          deductedProductDetail: string(name='DeductedProductDetail'),
          deductQuantity: float(name='DeductQuantity'),
          deductFactorTotal: float(name='DeductFactorTotal'),
        }
      ](name='DetailList'),
    }(name='DetailList'),
  }(name='Data'),
}

async function queryRIUtilizationDetailWithOptions(request: QueryRIUtilizationDetailRequest, runtime: Util.RuntimeOptions): QueryRIUtilizationDetailResponse {
  Util.validateModel(request);
  return doRequest('QueryRIUtilizationDetail', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function queryRIUtilizationDetail(request: QueryRIUtilizationDetailRequest): QueryRIUtilizationDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryRIUtilizationDetailWithOptions(request, runtime);
}

model QueryBillToOSSSubscriptionRequest = {
}

model QueryBillToOSSSubscriptionResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    accountID: string(name='AccountID'),
    accountName: string(name='AccountName'),
    items: {
      item: [
        {
          subscribeType: string(name='SubscribeType'),
          subscribeBucket: string(name='SubscribeBucket'),
          bucketOwnerId: long(name='BucketOwnerId'),
          subscribeTime: string(name='SubscribeTime'),
          subscribeLanguage: string(name='SubscribeLanguage'),
          multAccountRelSubscribe: string(name='MultAccountRelSubscribe'),
        }
      ](name='Item'),
    }(name='Items'),
  }(name='Data'),
}

async function queryBillToOSSSubscriptionWithOptions(request: QueryBillToOSSSubscriptionRequest, runtime: Util.RuntimeOptions): QueryBillToOSSSubscriptionResponse {
  Util.validateModel(request);
  return doRequest('QueryBillToOSSSubscription', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function queryBillToOSSSubscription(request: QueryBillToOSSSubscriptionRequest): QueryBillToOSSSubscriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryBillToOSSSubscriptionWithOptions(request, runtime);
}

model QueryAccountBillRequest = {
  billingCycle: string(name='BillingCycle'),
  pageNum?: integer(name='PageNum'),
  pageSize?: integer(name='PageSize'),
  ownerID?: long(name='OwnerID'),
  isGroupByProduct?: boolean(name='IsGroupByProduct'),
  productCode?: string(name='ProductCode'),
}

model QueryAccountBillResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    billingCycle: string(name='BillingCycle'),
    accountID: string(name='AccountID'),
    accountName: string(name='AccountName'),
    totalCount: integer(name='TotalCount'),
    pageNum: integer(name='PageNum'),
    pageSize: integer(name='PageSize'),
    items: {
      item: [
        {
          costUnit: string(name='CostUnit'),
          ownerID: string(name='OwnerID'),
          pretaxGrossAmount: float(name='PretaxGrossAmount'),
          invoiceDiscount: float(name='InvoiceDiscount'),
          deductedByCoupons: float(name='DeductedByCoupons'),
          pretaxAmount: float(name='PretaxAmount'),
          deductedByCashCoupons: float(name='DeductedByCashCoupons'),
          deductedByPrepaidCard: float(name='DeductedByPrepaidCard'),
          paymentAmount: float(name='PaymentAmount'),
          outstandingAmount: float(name='OutstandingAmount'),
          currency: string(name='Currency'),
          ownerName: string(name='OwnerName'),
          productCode: string(name='ProductCode'),
          productName: string(name='ProductName'),
          subscriptionType: string(name='SubscriptionType'),
        }
      ](name='Item'),
    }(name='Items'),
  }(name='Data'),
}

async function queryAccountBillWithOptions(request: QueryAccountBillRequest, runtime: Util.RuntimeOptions): QueryAccountBillResponse {
  Util.validateModel(request);
  return doRequest('QueryAccountBill', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function queryAccountBill(request: QueryAccountBillRequest): QueryAccountBillResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryAccountBillWithOptions(request, runtime);
}

model CreateCostUnitRequest = {
  unitEntityList?: [
    {
      ownerUid: long(name='OwnerUid'),
      parentUnitId: long(name='ParentUnitId'),
      unitName: string(name='UnitName'),
    }
  ](name='UnitEntityList'),
}

model CreateCostUnitResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    costUnitDtoList: [
      {
        ownerUid: long(name='OwnerUid'),
        parentUnitId: long(name='ParentUnitId'),
        unitId: long(name='UnitId'),
        unitName: string(name='UnitName'),
      }
    ](name='CostUnitDtoList'),
  }(name='Data'),
}

async function createCostUnitWithOptions(request: CreateCostUnitRequest, runtime: Util.RuntimeOptions): CreateCostUnitResponse {
  Util.validateModel(request);
  return doRequest('CreateCostUnit', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function createCostUnit(request: CreateCostUnitRequest): CreateCostUnitResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCostUnitWithOptions(request, runtime);
}

model ModifyCostUnitRequest = {
  unitEntityList?: [
    {
      ownerUid: long(name='OwnerUid'),
      unitId: long(name='UnitId'),
      newUnitName: string(name='NewUnitName'),
    }
  ](name='UnitEntityList'),
}

model ModifyCostUnitResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: [
    {
      ownerUid: long(name='OwnerUid'),
      unitId: long(name='UnitId'),
      isSuccess: boolean(name='IsSuccess'),
    }
  ](name='Data'),
}

async function modifyCostUnitWithOptions(request: ModifyCostUnitRequest, runtime: Util.RuntimeOptions): ModifyCostUnitResponse {
  Util.validateModel(request);
  return doRequest('ModifyCostUnit', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function modifyCostUnit(request: ModifyCostUnitRequest): ModifyCostUnitResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyCostUnitWithOptions(request, runtime);
}

model QueryCostUnitRequest = {
  ownerUid: long(name='OwnerUid'),
  parentUnitId: long(name='ParentUnitId'),
  pageNum?: integer(name='PageNum'),
  pageSize?: integer(name='PageSize'),
}

model QueryCostUnitResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    pageNum: integer(name='PageNum'),
    pageSize: integer(name='PageSize'),
    totalCount: integer(name='TotalCount'),
    costUnitDtoList: [
      {
        ownerUid: long(name='OwnerUid'),
        parentUnitId: long(name='ParentUnitId'),
        unitId: long(name='UnitId'),
        unitName: string(name='UnitName'),
      }
    ](name='CostUnitDtoList'),
  }(name='Data'),
}

async function queryCostUnitWithOptions(request: QueryCostUnitRequest, runtime: Util.RuntimeOptions): QueryCostUnitResponse {
  Util.validateModel(request);
  return doRequest('QueryCostUnit', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function queryCostUnit(request: QueryCostUnitRequest): QueryCostUnitResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryCostUnitWithOptions(request, runtime);
}

model DeleteCostUnitRequest = {
  ownerUid: long(name='OwnerUid'),
  unitId: long(name='UnitId'),
}

model DeleteCostUnitResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    ownerUid: long(name='OwnerUid'),
    unitId: long(name='UnitId'),
    isSuccess: boolean(name='IsSuccess'),
  }(name='Data'),
}

async function deleteCostUnitWithOptions(request: DeleteCostUnitRequest, runtime: Util.RuntimeOptions): DeleteCostUnitResponse {
  Util.validateModel(request);
  return doRequest('DeleteCostUnit', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function deleteCostUnit(request: DeleteCostUnitRequest): DeleteCostUnitResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCostUnitWithOptions(request, runtime);
}

model AllocateCostUnitResourceRequest = {
  fromUnitUserId: long(name='FromUnitUserId'),
  fromUnitId: long(name='FromUnitId'),
  resourceInstanceList: [
    {
      resourceUserId: long(name='ResourceUserId'),
      resourceId: string(name='ResourceId'),
      commodityCode: string(name='CommodityCode'),
      apportionCode?: string(name='ApportionCode'),
    }
  ](name='ResourceInstanceList'),
  toUnitUserId: long(name='ToUnitUserId'),
  toUnitId: long(name='ToUnitId'),
}

model AllocateCostUnitResourceResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    toUnitUserId: long(name='ToUnitUserId'),
    toUnitId: long(name='ToUnitId'),
    isSuccess: boolean(name='IsSuccess'),
  }(name='Data'),
}

async function allocateCostUnitResourceWithOptions(request: AllocateCostUnitResourceRequest, runtime: Util.RuntimeOptions): AllocateCostUnitResourceResponse {
  Util.validateModel(request);
  return doRequest('AllocateCostUnitResource', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function allocateCostUnitResource(request: AllocateCostUnitResourceRequest): AllocateCostUnitResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return allocateCostUnitResourceWithOptions(request, runtime);
}

model QueryCostUnitResourceRequest = {
  ownerUid: long(name='OwnerUid'),
  unitId: long(name='UnitId'),
  pageNum?: integer(name='PageNum'),
  pageSize?: integer(name='PageSize'),
}

model QueryCostUnitResourceResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    pageNum: integer(name='PageNum'),
    pageSize: integer(name='PageSize'),
    totalCount: integer(name='TotalCount'),
    resourceInstanceDtoList: [
      {
        resourceUserId: long(name='ResourceUserId'),
        resourceId: string(name='ResourceId'),
        commodityCode: string(name='CommodityCode'),
        resourceUserName: string(name='ResourceUserName'),
        commodityName: string(name='CommodityName'),
        resourceGroup: string(name='ResourceGroup'),
        resourceTag: string(name='ResourceTag'),
        resourceNick: string(name='ResourceNick'),
        resourceType: string(name='ResourceType'),
        resourceStatus: string(name='ResourceStatus'),
        relatedResources: string(name='RelatedResources'),
        apportionCode: string(name='ApportionCode'),
        apportionName: string(name='ApportionName'),
      }
    ](name='ResourceInstanceDtoList'),
    costUnit: {
      ownerUid: long(name='OwnerUid'),
      parentUnitId: long(name='ParentUnitId'),
      unitId: long(name='UnitId'),
      unitName: string(name='UnitName'),
    }(name='CostUnit'),
    costUnitStatisInfo: {
      resourceCount: long(name='ResourceCount'),
      resourceGroupCount: long(name='ResourceGroupCount'),
      subUnitCount: long(name='SubUnitCount'),
      userCount: long(name='UserCount'),
      totalResourceCount: long(name='TotalResourceCount'),
      totalUserCount: long(name='TotalUserCount'),
      totalResourceGroupCount: long(name='TotalResourceGroupCount'),
    }(name='CostUnitStatisInfo'),
  }(name='Data'),
}

async function queryCostUnitResourceWithOptions(request: QueryCostUnitResourceRequest, runtime: Util.RuntimeOptions): QueryCostUnitResourceResponse {
  Util.validateModel(request);
  return doRequest('QueryCostUnitResource', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function queryCostUnitResource(request: QueryCostUnitResourceRequest): QueryCostUnitResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryCostUnitResourceWithOptions(request, runtime);
}

model RenewResourcePackageRequest = {
  instanceId: string(name='InstanceId'),
  effectiveDate?: string(name='EffectiveDate'),
  duration: integer(name='Duration'),
  pricingCycle: string(name='PricingCycle'),
}

model RenewResourcePackageResponse = {
  requestId: string(name='RequestId'),
  orderId: long(name='OrderId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    orderId: long(name='OrderId'),
    instanceId: string(name='InstanceId'),
  }(name='Data'),
}

async function renewResourcePackageWithOptions(request: RenewResourcePackageRequest, runtime: Util.RuntimeOptions): RenewResourcePackageResponse {
  Util.validateModel(request);
  return doRequest('RenewResourcePackage', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function renewResourcePackage(request: RenewResourcePackageRequest): RenewResourcePackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return renewResourcePackageWithOptions(request, runtime);
}

model UpgradeResourcePackageRequest = {
  instanceId?: string(name='InstanceId'),
  effectiveDate?: string(name='EffectiveDate'),
  specification?: string(name='Specification'),
}

model UpgradeResourcePackageResponse = {
  requestId: string(name='RequestId'),
  orderId: long(name='OrderId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    orderId: long(name='OrderId'),
    instanceId: string(name='InstanceId'),
  }(name='Data'),
}

async function upgradeResourcePackageWithOptions(request: UpgradeResourcePackageRequest, runtime: Util.RuntimeOptions): UpgradeResourcePackageResponse {
  Util.validateModel(request);
  return doRequest('UpgradeResourcePackage', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function upgradeResourcePackage(request: UpgradeResourcePackageRequest): UpgradeResourcePackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeResourcePackageWithOptions(request, runtime);
}

model CreateAgAccountRequest = {
  loginEmail: string(name='LoginEmail'),
  accountAttr?: string(name='AccountAttr'),
  enterpriseName?: string(name='EnterpriseName'),
  firstName?: string(name='FirstName'),
  lastName?: string(name='LastName'),
  nationCode?: string(name='NationCode'),
  provinceName?: string(name='ProvinceName'),
  cityName?: string(name='CityName'),
  postcode?: string(name='Postcode'),
}

model CreateAgAccountResponse = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  agRelationDto: {
    pk: string(name='Pk'),
    type: string(name='Type'),
    mpk: string(name='Mpk'),
    ramAdminRoleName: string(name='RamAdminRoleName'),
  }(name='AgRelationDto'),
}

async function createAgAccountWithOptions(request: CreateAgAccountRequest, runtime: Util.RuntimeOptions): CreateAgAccountResponse {
  Util.validateModel(request);
  return doRequest('CreateAgAccount', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function createAgAccount(request: CreateAgAccountRequest): CreateAgAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAgAccountWithOptions(request, runtime);
}

model GetCustomerAccountInfoRequest = {
}

model GetCustomerAccountInfoResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    loginEmail: string(name='LoginEmail'),
    accountType: string(name='AccountType'),
    mpk: long(name='Mpk'),
    hostingStatus: string(name='HostingStatus'),
    creditLimitStatus: string(name='CreditLimitStatus'),
    isCertified: boolean(name='IsCertified'),
  }(name='Data'),
}

async function getCustomerAccountInfoWithOptions(request: GetCustomerAccountInfoRequest, runtime: Util.RuntimeOptions): GetCustomerAccountInfoResponse {
  Util.validateModel(request);
  return doRequest('GetCustomerAccountInfo', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function getCustomerAccountInfo(request: GetCustomerAccountInfoRequest): GetCustomerAccountInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCustomerAccountInfoWithOptions(request, runtime);
}

model GetCustomerListRequest = {
}

model GetCustomerListResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    uidList: [ string ](name='UidList'),
  }(name='Data'),
}

async function getCustomerListWithOptions(request: GetCustomerListRequest, runtime: Util.RuntimeOptions): GetCustomerListResponse {
  Util.validateModel(request);
  return doRequest('GetCustomerList', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function getCustomerList(request: GetCustomerListRequest): GetCustomerListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCustomerListWithOptions(request, runtime);
}

model ChangeResellerConsumeAmountRequest = {
  adjustType: string(name='AdjustType'),
  amount: string(name='Amount'),
  currency: string(name='Currency'),
  businessType: string(name='BusinessType'),
  source: string(name='Source'),
  outBizId: string(name='OutBizId'),
  extendMap?: string(name='ExtendMap'),
}

model ChangeResellerConsumeAmountResponse = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  data: string(name='Data'),
}

async function changeResellerConsumeAmountWithOptions(request: ChangeResellerConsumeAmountRequest, runtime: Util.RuntimeOptions): ChangeResellerConsumeAmountResponse {
  Util.validateModel(request);
  return doRequest('ChangeResellerConsumeAmount', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function changeResellerConsumeAmount(request: ChangeResellerConsumeAmountRequest): ChangeResellerConsumeAmountResponse {
  var runtime = new Util.RuntimeOptions{};
  return changeResellerConsumeAmountWithOptions(request, runtime);
}

model SetResellerUserStatusRequest = {
  status: string(name='Status'),
  businessType: string(name='BusinessType'),
}

model SetResellerUserStatusResponse = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  data: boolean(name='Data'),
}

async function setResellerUserStatusWithOptions(request: SetResellerUserStatusRequest, runtime: Util.RuntimeOptions): SetResellerUserStatusResponse {
  Util.validateModel(request);
  return doRequest('SetResellerUserStatus', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function setResellerUserStatus(request: SetResellerUserStatusRequest): SetResellerUserStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return setResellerUserStatusWithOptions(request, runtime);
}

model CreateResellerUserQuotaRequest = {
  amount: string(name='Amount'),
  currency: string(name='Currency'),
  outBizId?: string(name='OutBizId'),
}

model CreateResellerUserQuotaResponse = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  data: boolean(name='Data'),
}

async function createResellerUserQuotaWithOptions(request: CreateResellerUserQuotaRequest, runtime: Util.RuntimeOptions): CreateResellerUserQuotaResponse {
  Util.validateModel(request);
  return doRequest('CreateResellerUserQuota', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function createResellerUserQuota(request: CreateResellerUserQuotaRequest): CreateResellerUserQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  return createResellerUserQuotaWithOptions(request, runtime);
}

model SetResellerUserQuotaRequest = {
  amount: string(name='Amount'),
  currency?: string(name='Currency'),
  outBizId?: string(name='OutBizId'),
}

model SetResellerUserQuotaResponse = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  data: boolean(name='Data'),
}

async function setResellerUserQuotaWithOptions(request: SetResellerUserQuotaRequest, runtime: Util.RuntimeOptions): SetResellerUserQuotaResponse {
  Util.validateModel(request);
  return doRequest('SetResellerUserQuota', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function setResellerUserQuota(request: SetResellerUserQuotaRequest): SetResellerUserQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  return setResellerUserQuotaWithOptions(request, runtime);
}

model QueryResellerAvailableQuotaRequest = {
  itemCodes?: string(name='ItemCodes'),
}

model QueryResellerAvailableQuotaResponse = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  data: string(name='Data'),
}

async function queryResellerAvailableQuotaWithOptions(request: QueryResellerAvailableQuotaRequest, runtime: Util.RuntimeOptions): QueryResellerAvailableQuotaResponse {
  Util.validateModel(request);
  return doRequest('QueryResellerAvailableQuota', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function queryResellerAvailableQuota(request: QueryResellerAvailableQuotaRequest): QueryResellerAvailableQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryResellerAvailableQuotaWithOptions(request, runtime);
}

model SetResellerUserAlarmThresholdRequest = {
  alarmType: string(name='AlarmType'),
  alarmThresholds?: string(name='AlarmThresholds'),
}

model SetResellerUserAlarmThresholdResponse = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  data: boolean(name='Data'),
}

async function setResellerUserAlarmThresholdWithOptions(request: SetResellerUserAlarmThresholdRequest, runtime: Util.RuntimeOptions): SetResellerUserAlarmThresholdResponse {
  Util.validateModel(request);
  return doRequest('SetResellerUserAlarmThreshold', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function setResellerUserAlarmThreshold(request: SetResellerUserAlarmThresholdRequest): SetResellerUserAlarmThresholdResponse {
  var runtime = new Util.RuntimeOptions{};
  return setResellerUserAlarmThresholdWithOptions(request, runtime);
}

model QueryAccountTransactionsRequest = {
  transactionNumber?: string(name='TransactionNumber'),
  recordID?: string(name='RecordID'),
  transactionChannelSN?: string(name='TransactionChannelSN'),
  createTimeStart?: string(name='CreateTimeStart'),
  createTimeEnd?: string(name='CreateTimeEnd'),
  pageNum?: integer(name='PageNum'),
  pageSize?: integer(name='PageSize'),
}

model QueryAccountTransactionsResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    accountName: string(name='AccountName'),
    totalCount: integer(name='TotalCount'),
    pageNum: integer(name='PageNum'),
    pageSize: integer(name='PageSize'),
    accountTransactionsList: {
      accountTransactionsList: [
        {
          transactionNumber: string(name='TransactionNumber'),
          transactionTime: string(name='TransactionTime'),
          transactionFlow: string(name='TransactionFlow'),
          transactionType: string(name='TransactionType'),
          transactionChannel: string(name='TransactionChannel'),
          transactionChannelSN: string(name='TransactionChannelSN'),
          fundType: string(name='FundType'),
          recordID: string(name='RecordID'),
          remarks: string(name='Remarks'),
          billingCycle: string(name='BillingCycle'),
          amount: string(name='Amount'),
          balance: string(name='Balance'),
          transactionAccount: string(name='TransactionAccount'),
        }
      ](name='AccountTransactionsList'),
    }(name='AccountTransactionsList'),
  }(name='Data'),
}

async function queryAccountTransactionsWithOptions(request: QueryAccountTransactionsRequest, runtime: Util.RuntimeOptions): QueryAccountTransactionsResponse {
  Util.validateModel(request);
  return doRequest('QueryAccountTransactions', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function queryAccountTransactions(request: QueryAccountTransactionsRequest): QueryAccountTransactionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryAccountTransactionsWithOptions(request, runtime);
}

model UnsubscribeBillToOSSRequest = {
  subscribeType: string(name='SubscribeType'),
  multAccountRelSubscribe?: string(name='MultAccountRelSubscribe'),
}

model UnsubscribeBillToOSSResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
}

async function unsubscribeBillToOSSWithOptions(request: UnsubscribeBillToOSSRequest, runtime: Util.RuntimeOptions): UnsubscribeBillToOSSResponse {
  Util.validateModel(request);
  return doRequest('UnsubscribeBillToOSS', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function unsubscribeBillToOSS(request: UnsubscribeBillToOSSRequest): UnsubscribeBillToOSSResponse {
  var runtime = new Util.RuntimeOptions{};
  return unsubscribeBillToOSSWithOptions(request, runtime);
}

model SubscribeBillToOSSRequest = {
  subscribeBucket: string(name='SubscribeBucket'),
  subscribeType?: string(name='SubscribeType'),
  multAccountRelSubscribe?: string(name='MultAccountRelSubscribe'),
  bucketOwnerId?: long(name='BucketOwnerId'),
}

model SubscribeBillToOSSResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
}

async function subscribeBillToOSSWithOptions(request: SubscribeBillToOSSRequest, runtime: Util.RuntimeOptions): SubscribeBillToOSSResponse {
  Util.validateModel(request);
  return doRequest('SubscribeBillToOSS', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function subscribeBillToOSS(request: SubscribeBillToOSSRequest): SubscribeBillToOSSResponse {
  var runtime = new Util.RuntimeOptions{};
  return subscribeBillToOSSWithOptions(request, runtime);
}

model QueryUserOmsDataRequest = {
  table: string(name='Table'),
  dataType: string(name='DataType'),
  startTime: string(name='StartTime'),
  endTime: string(name='EndTime'),
  marker?: string(name='Marker'),
  pageSize?: integer(name='PageSize'),
}

model QueryUserOmsDataResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    marker: string(name='Marker'),
    hostId: string(name='HostId'),
    omsData: [ map[string]any ](name='OmsData'),
  }(name='Data'),
}

async function queryUserOmsDataWithOptions(request: QueryUserOmsDataRequest, runtime: Util.RuntimeOptions): QueryUserOmsDataResponse {
  Util.validateModel(request);
  return doRequest('QueryUserOmsData', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function queryUserOmsData(request: QueryUserOmsDataRequest): QueryUserOmsDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryUserOmsDataWithOptions(request, runtime);
}

model CancelOrderRequest = {
  orderId: string(name='OrderId'),
}

model CancelOrderResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    hostId: string(name='HostId'),
  }(name='Data'),
}

async function cancelOrderWithOptions(request: CancelOrderRequest, runtime: Util.RuntimeOptions): CancelOrderResponse {
  Util.validateModel(request);
  return doRequest('CancelOrder', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function cancelOrder(request: CancelOrderRequest): CancelOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelOrderWithOptions(request, runtime);
}

model ApplyInvoiceRequest = {
  invoiceAmount: long(name='InvoiceAmount'),
  customerId: long(name='CustomerId'),
  addressId: long(name='AddressId'),
  invoicingType?: integer(name='InvoicingType'),
  processWay?: integer(name='ProcessWay'),
  applyUserNick: string(name='ApplyUserNick'),
  selectedIds: [ long ](name='SelectedIds'),
  invoiceByAmount?: boolean(name='InvoiceByAmount'),
}

model ApplyInvoiceResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    invoiceApplyId: long(name='InvoiceApplyId'),
  }(name='Data'),
}

async function applyInvoiceWithOptions(request: ApplyInvoiceRequest, runtime: Util.RuntimeOptions): ApplyInvoiceResponse {
  Util.validateModel(request);
  return doRequest('ApplyInvoice', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function applyInvoice(request: ApplyInvoiceRequest): ApplyInvoiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return applyInvoiceWithOptions(request, runtime);
}

model QueryCustomerAddressListRequest = {
}

model QueryCustomerAddressListResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    customerInvoiceAddressList: {
      customerInvoiceAddress: [
        {
          id: long(name='Id'),
          userId: long(name='UserId'),
          userNick: string(name='UserNick'),
          addressee: string(name='Addressee'),
          province: string(name='Province'),
          city: string(name='City'),
          county: string(name='County'),
          street: string(name='Street'),
          postalCode: string(name='PostalCode'),
          phone: string(name='Phone'),
          bizType: string(name='BizType'),
          deliveryAddress: string(name='DeliveryAddress'),
        }
      ](name='CustomerInvoiceAddress'),
    }(name='CustomerInvoiceAddressList'),
  }(name='Data'),
}

async function queryCustomerAddressListWithOptions(request: QueryCustomerAddressListRequest, runtime: Util.RuntimeOptions): QueryCustomerAddressListResponse {
  Util.validateModel(request);
  return doRequest('QueryCustomerAddressList', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function queryCustomerAddressList(request: QueryCustomerAddressListRequest): QueryCustomerAddressListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryCustomerAddressListWithOptions(request, runtime);
}

model QueryEvaluateListRequest = {
  type?: integer(name='Type'),
  outBizId?: string(name='OutBizId'),
  pageNum?: integer(name='PageNum'),
  pageSize?: integer(name='PageSize'),
  startAmount?: long(name='StartAmount'),
  endAmount?: long(name='EndAmount'),
  startBizTime?: string(name='StartBizTime'),
  endBizTime?: string(name='EndBizTime'),
  sortType?: integer(name='SortType'),
  startSearchTime?: string(name='StartSearchTime'),
  endSearchTime?: string(name='EndSearchTime'),
  billCycle?: string(name='BillCycle'),
  bizTypeList?: [ string ](name='BizTypeList'),
}

model QueryEvaluateListResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    hostId: string(name='HostId'),
    pageNum: integer(name='PageNum'),
    pageSize: integer(name='PageSize'),
    totalCount: integer(name='TotalCount'),
    totalInvoiceAmount: long(name='TotalInvoiceAmount'),
    totalUnAppliedInvoiceAmount: long(name='TotalUnAppliedInvoiceAmount'),
    evaluateList: {
      evaluate: [
        {
          id: long(name='Id'),
          gmtCreate: string(name='GmtCreate'),
          gmtModified: string(name='GmtModified'),
          userId: long(name='UserId'),
          userNick: string(name='UserNick'),
          outBizId: string(name='OutBizId'),
          billId: long(name='BillId'),
          itemId: long(name='ItemId'),
          billCycle: string(name='BillCycle'),
          bizType: string(name='BizType'),
          originalAmount: long(name='OriginalAmount'),
          presentAmount: long(name='PresentAmount'),
          canInvoiceAmount: long(name='CanInvoiceAmount'),
          invoicedAmount: long(name='InvoicedAmount'),
          offsetCostAmount: long(name='OffsetCostAmount'),
          offsetAcceptAmount: long(name='OffsetAcceptAmount'),
          status: integer(name='Status'),
          opId: string(name='OpId'),
          name: string(name='Name'),
          bizTime: string(name='BizTime'),
          type: integer(name='Type'),
        }
      ](name='Evaluate'),
    }(name='EvaluateList'),
  }(name='Data'),
}

async function queryEvaluateListWithOptions(request: QueryEvaluateListRequest, runtime: Util.RuntimeOptions): QueryEvaluateListResponse {
  Util.validateModel(request);
  return doRequest('QueryEvaluateList', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function queryEvaluateList(request: QueryEvaluateListRequest): QueryEvaluateListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryEvaluateListWithOptions(request, runtime);
}

model QueryInvoicingCustomerListRequest = {
}

model QueryInvoicingCustomerListResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    customerInvoiceList: {
      customerInvoice: [
        {
          id: long(name='Id'),
          userId: long(name='UserId'),
          userNick: string(name='UserNick'),
          invoiceTitle: string(name='InvoiceTitle'),
          customerType: long(name='CustomerType'),
          taxpayerType: long(name='TaxpayerType'),
          bank: string(name='Bank'),
          bankNo: string(name='BankNo'),
          operatingLicenseAddress: string(name='OperatingLicenseAddress'),
          operatingLicensePhone: string(name='OperatingLicensePhone'),
          registerNo: string(name='RegisterNo'),
          startCycle: long(name='StartCycle'),
          status: long(name='Status'),
          gmtCreate: string(name='GmtCreate'),
          taxationLicense: string(name='TaxationLicense'),
          adjustType: long(name='AdjustType'),
          endCycle: long(name='EndCycle'),
          titleChangeInstructions: string(name='TitleChangeInstructions'),
          issueType: long(name='IssueType'),
          type: long(name='Type'),
          defaultRemark: string(name='DefaultRemark'),
        }
      ](name='CustomerInvoice'),
    }(name='CustomerInvoiceList'),
  }(name='Data'),
}

async function queryInvoicingCustomerListWithOptions(request: QueryInvoicingCustomerListRequest, runtime: Util.RuntimeOptions): QueryInvoicingCustomerListResponse {
  Util.validateModel(request);
  return doRequest('QueryInvoicingCustomerList', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function queryInvoicingCustomerList(request: QueryInvoicingCustomerListRequest): QueryInvoicingCustomerListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryInvoicingCustomerListWithOptions(request, runtime);
}

model QueryBillOverviewRequest = {
  billingCycle: string(name='BillingCycle'),
  productCode?: string(name='ProductCode'),
  productType?: string(name='ProductType'),
  subscriptionType?: string(name='SubscriptionType'),
}

model QueryBillOverviewResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    billingCycle: string(name='BillingCycle'),
    accountID: string(name='AccountID'),
    accountName: string(name='AccountName'),
    items: {
      item: [
        {
          item: string(name='Item'),
          productCode: string(name='ProductCode'),
          productType: string(name='ProductType'),
          subscriptionType: string(name='SubscriptionType'),
          productName: string(name='ProductName'),
          productDetail: string(name='ProductDetail'),
          pretaxGrossAmount: float(name='PretaxGrossAmount'),
          invoiceDiscount: float(name='InvoiceDiscount'),
          deductedByCoupons: float(name='DeductedByCoupons'),
          pretaxAmount: float(name='PretaxAmount'),
          currency: string(name='Currency'),
          paymentAmount: float(name='PaymentAmount'),
          outstandingAmount: float(name='OutstandingAmount'),
          deductedByCashCoupons: float(name='DeductedByCashCoupons'),
          deductedByPrepaidCard: float(name='DeductedByPrepaidCard'),
          pretaxAmountLocal: float(name='PretaxAmountLocal'),
          tax: float(name='Tax'),
          afterTaxAmount: float(name='AfterTaxAmount'),
          paymentCurrency: string(name='PaymentCurrency'),
          roundDownDiscount: string(name='RoundDownDiscount'),
        }
      ](name='Item'),
    }(name='Items'),
  }(name='Data'),
}

async function queryBillOverviewWithOptions(request: QueryBillOverviewRequest, runtime: Util.RuntimeOptions): QueryBillOverviewResponse {
  Util.validateModel(request);
  return doRequest('QueryBillOverview', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function queryBillOverview(request: QueryBillOverviewRequest): QueryBillOverviewResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryBillOverviewWithOptions(request, runtime);
}

model QueryBillRequest = {
  billingCycle: string(name='BillingCycle'),
  type?: string(name='Type'),
  productCode?: string(name='ProductCode'),
  productType?: string(name='ProductType'),
  subscriptionType?: string(name='SubscriptionType'),
  isHideZeroCharge?: boolean(name='IsHideZeroCharge'),
  isDisplayLocalCurrency?: boolean(name='IsDisplayLocalCurrency'),
  pageNum?: integer(name='PageNum'),
  pageSize?: integer(name='PageSize'),
}

model QueryBillResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    billingCycle: string(name='BillingCycle'),
    accountID: string(name='AccountID'),
    accountName: string(name='AccountName'),
    pageNum: integer(name='PageNum'),
    pageSize: integer(name='PageSize'),
    totalCount: integer(name='TotalCount'),
    items: {
      item: [
        {
          recordID: string(name='RecordID'),
          item: string(name='Item'),
          ownerID: string(name='OwnerID'),
          usageStartTime: string(name='UsageStartTime'),
          usageEndTime: string(name='UsageEndTime'),
          paymentTime: string(name='PaymentTime'),
          productCode: string(name='ProductCode'),
          productType: string(name='ProductType'),
          subscriptionType: string(name='SubscriptionType'),
          productName: string(name='ProductName'),
          productDetail: string(name='ProductDetail'),
          pretaxGrossAmount: float(name='PretaxGrossAmount'),
          deductedByCoupons: float(name='DeductedByCoupons'),
          invoiceDiscount: float(name='InvoiceDiscount'),
          pretaxAmount: float(name='PretaxAmount'),
          currency: string(name='Currency'),
          pretaxAmountLocal: float(name='PretaxAmountLocal'),
          tax: float(name='Tax'),
          paymentAmount: float(name='PaymentAmount'),
          deductedByCashCoupons: float(name='DeductedByCashCoupons'),
          deductedByPrepaidCard: float(name='DeductedByPrepaidCard'),
          outstandingAmount: float(name='OutstandingAmount'),
          afterTaxAmount: float(name='AfterTaxAmount'),
          status: string(name='Status'),
          paymentCurrency: string(name='PaymentCurrency'),
          paymentTransactionID: string(name='PaymentTransactionID'),
          roundDownDiscount: string(name='RoundDownDiscount'),
          subOrderId: string(name='SubOrderId'),
        }
      ](name='Item'),
    }(name='Items'),
  }(name='Data'),
}

async function queryBillWithOptions(request: QueryBillRequest, runtime: Util.RuntimeOptions): QueryBillResponse {
  Util.validateModel(request);
  return doRequest('QueryBill', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function queryBill(request: QueryBillRequest): QueryBillResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryBillWithOptions(request, runtime);
}

model QueryInstanceBillRequest = {
  billingCycle: string(name='BillingCycle'),
  productCode?: string(name='ProductCode'),
  productType?: string(name='ProductType'),
  subscriptionType?: string(name='SubscriptionType'),
  isBillingItem?: boolean(name='IsBillingItem'),
  pageNum?: integer(name='PageNum'),
  pageSize?: integer(name='PageSize'),
  isHideZeroCharge?: boolean(name='IsHideZeroCharge'),
  billingDate?: string(name='BillingDate'),
  granularity?: string(name='Granularity'),
}

model QueryInstanceBillResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    billingCycle: string(name='BillingCycle'),
    accountID: string(name='AccountID'),
    accountName: string(name='AccountName'),
    totalCount: integer(name='TotalCount'),
    pageNum: integer(name='PageNum'),
    pageSize: integer(name='PageSize'),
    items: {
      item: [
        {
          instanceID: string(name='InstanceID'),
          billingType: string(name='BillingType'),
          costUnit: string(name='CostUnit'),
          productCode: string(name='ProductCode'),
          productType: string(name='ProductType'),
          subscriptionType: string(name='SubscriptionType'),
          productName: string(name='ProductName'),
          productDetail: string(name='ProductDetail'),
          ownerID: string(name='OwnerID'),
          billingItem: string(name='BillingItem'),
          listPrice: string(name='ListPrice'),
          listPriceUnit: string(name='ListPriceUnit'),
          usage: string(name='Usage'),
          usageUnit: string(name='UsageUnit'),
          deductedByResourcePackage: string(name='DeductedByResourcePackage'),
          pretaxGrossAmount: float(name='PretaxGrossAmount'),
          invoiceDiscount: float(name='InvoiceDiscount'),
          deductedByCoupons: float(name='DeductedByCoupons'),
          pretaxAmount: float(name='PretaxAmount'),
          deductedByCashCoupons: float(name='DeductedByCashCoupons'),
          deductedByPrepaidCard: float(name='DeductedByPrepaidCard'),
          paymentAmount: float(name='PaymentAmount'),
          outstandingAmount: float(name='OutstandingAmount'),
          currency: string(name='Currency'),
          nickName: string(name='NickName'),
          resourceGroup: string(name='ResourceGroup'),
          tag: string(name='Tag'),
          instanceConfig: string(name='InstanceConfig'),
          instanceSpec: string(name='InstanceSpec'),
          internetIP: string(name='InternetIP'),
          intranetIP: string(name='IntranetIP'),
          region: string(name='Region'),
          zone: string(name='Zone'),
          item: string(name='Item'),
          servicePeriod: string(name='ServicePeriod'),
          billingDate: string(name='BillingDate'),
          servicePeriodUnit: string(name='ServicePeriodUnit'),
        }
      ](name='Item'),
    }(name='Items'),
  }(name='Data'),
}

async function queryInstanceBillWithOptions(request: QueryInstanceBillRequest, runtime: Util.RuntimeOptions): QueryInstanceBillResponse {
  Util.validateModel(request);
  return doRequest('QueryInstanceBill', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function queryInstanceBill(request: QueryInstanceBillRequest): QueryInstanceBillResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryInstanceBillWithOptions(request, runtime);
}

model EnableBillGenerationRequest = {
  productCode: string(name='ProductCode'),
}

model EnableBillGenerationResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    boolean: boolean(name='Boolean'),
  }(name='Data'),
}

async function enableBillGenerationWithOptions(request: EnableBillGenerationRequest, runtime: Util.RuntimeOptions): EnableBillGenerationResponse {
  Util.validateModel(request);
  return doRequest('EnableBillGeneration', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function enableBillGeneration(request: EnableBillGenerationRequest): EnableBillGenerationResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableBillGenerationWithOptions(request, runtime);
}

model QueryRedeemRequest = {
  expiryTimeStart?: string(name='ExpiryTimeStart'),
  expiryTimeEnd?: string(name='ExpiryTimeEnd'),
  effectiveOrNot?: boolean(name='EffectiveOrNot'),
  pageNum?: integer(name='PageNum'),
  pageSize?: integer(name='PageSize'),
}

model QueryRedeemResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    pageNum: long(name='PageNum'),
    pageSize: long(name='PageSize'),
    totalCount: long(name='TotalCount'),
    redeem: {
      redeem: [
        {
          redeemId: string(name='RedeemId'),
          redeemNo: string(name='RedeemNo'),
          status: string(name='Status'),
          grantedTime: string(name='GrantedTime'),
          effectiveTime: string(name='EffectiveTime'),
          expiryTime: string(name='ExpiryTime'),
          nominalValue: string(name='NominalValue'),
          balance: string(name='Balance'),
          applicableProducts: string(name='ApplicableProducts'),
          specification: string(name='Specification'),
        }
      ](name='Redeem'),
    }(name='Redeem'),
  }(name='Data'),
}

async function queryRedeemWithOptions(request: QueryRedeemRequest, runtime: Util.RuntimeOptions): QueryRedeemResponse {
  Util.validateModel(request);
  return doRequest('QueryRedeem', 'HTTPS', 'GET', '2017-12-14', 'AK', request, null, runtime);
}

async function queryRedeem(request: QueryRedeemRequest): QueryRedeemResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryRedeemWithOptions(request, runtime);
}

model ConvertChargeTypeRequest = {
  productType?: string(name='ProductType'),
  subscriptionType: string(name='SubscriptionType'),
  period?: integer(name='Period'),
  productCode: string(name='ProductCode'),
  instanceId: string(name='InstanceId'),
}

model ConvertChargeTypeResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    orderId: string(name='OrderId'),
  }(name='Data'),
}

async function convertChargeTypeWithOptions(request: ConvertChargeTypeRequest, runtime: Util.RuntimeOptions): ConvertChargeTypeResponse {
  Util.validateModel(request);
  return doRequest('ConvertChargeType', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function convertChargeType(request: ConvertChargeTypeRequest): ConvertChargeTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return convertChargeTypeWithOptions(request, runtime);
}

model CreateInstanceRequest = {
  productCode: string(name='ProductCode'),
  parameter?: [
    {
      code: string(name='Code'),
      value: string(name='Value'),
    }
  ](name='Parameter'),
  productType?: string(name='ProductType'),
  subscriptionType: string(name='SubscriptionType'),
  period?: integer(name='Period'),
  renewalStatus?: string(name='RenewalStatus'),
  renewPeriod?: integer(name='RenewPeriod'),
  clientToken?: string(name='ClientToken'),
}

model CreateInstanceResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    instanceId: string(name='InstanceId'),
    orderId: string(name='OrderId'),
  }(name='Data'),
}

async function createInstanceWithOptions(request: CreateInstanceRequest, runtime: Util.RuntimeOptions): CreateInstanceResponse {
  Util.validateModel(request);
  return doRequest('CreateInstance', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function createInstance(request: CreateInstanceRequest): CreateInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createInstanceWithOptions(request, runtime);
}

model ModifyInstanceRequest = {
  productCode: string(name='ProductCode'),
  productType?: string(name='ProductType'),
  subscriptionType: string(name='SubscriptionType'),
  modifyType: string(name='ModifyType'),
  instanceId?: string(name='InstanceId'),
  parameter?: [
    {
      code: string(name='Code'),
      value: string(name='Value'),
    }
  ](name='Parameter'),
  clientToken?: string(name='ClientToken'),
}

model ModifyInstanceResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    hostId: string(name='HostId'),
    orderId: string(name='OrderId'),
  }(name='Data'),
}

async function modifyInstanceWithOptions(request: ModifyInstanceRequest, runtime: Util.RuntimeOptions): ModifyInstanceResponse {
  Util.validateModel(request);
  return doRequest('ModifyInstance', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function modifyInstance(request: ModifyInstanceRequest): ModifyInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyInstanceWithOptions(request, runtime);
}

model DescribePricingModuleRequest = {
  productCode: string(name='ProductCode'),
  productType?: string(name='ProductType'),
  subscriptionType: string(name='SubscriptionType'),
}

model DescribePricingModuleResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    moduleList: {
      module: [
        {
          moduleCode: string(name='ModuleCode'),
          moduleName: string(name='ModuleName'),
          priceType: string(name='PriceType'),
          currency: string(name='Currency'),
          configList: {
            configList: [ string ](name='ConfigList', description='ConfigList'),
          }(name='ConfigList'),
        }
      ](name='Module'),
    }(name='ModuleList'),
    attributeList: {
      attribute: [
        {
          code: string(name='Code'),
          name: string(name='Name'),
          unit: string(name='Unit'),
          values: {
            attributeValue: [
              {
                type: string(name='Type'),
                name: string(name='Name'),
                value: string(name='Value'),
                remark: string(name='Remark'),
              }
            ](name='AttributeValue'),
          }(name='Values'),
        }
      ](name='Attribute'),
    }(name='AttributeList'),
  }(name='Data'),
}

async function describePricingModuleWithOptions(request: DescribePricingModuleRequest, runtime: Util.RuntimeOptions): DescribePricingModuleResponse {
  Util.validateModel(request);
  return doRequest('DescribePricingModule', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function describePricingModule(request: DescribePricingModuleRequest): DescribePricingModuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePricingModuleWithOptions(request, runtime);
}

model QueryProductListRequest = {
  queryTotalCount?: boolean(name='QueryTotalCount'),
  pageNum: integer(name='PageNum'),
  pageSize?: integer(name='PageSize'),
}

model QueryProductListResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    totalCount: integer(name='TotalCount'),
    pageNum: integer(name='PageNum'),
    pageSize: integer(name='PageSize'),
    productList: {
      product: [
        {
          productCode: string(name='ProductCode'),
          productName: string(name='ProductName'),
          productType: string(name='ProductType'),
          subscriptionType: string(name='SubscriptionType'),
        }
      ](name='Product'),
    }(name='ProductList'),
  }(name='Data'),
}

async function queryProductListWithOptions(request: QueryProductListRequest, runtime: Util.RuntimeOptions): QueryProductListResponse {
  Util.validateModel(request);
  return doRequest('QueryProductList', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function queryProductList(request: QueryProductListRequest): QueryProductListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryProductListWithOptions(request, runtime);
}

model QueryInstanceGaapCostRequest = {
  pageNum?: integer(name='PageNum'),
  pageSize?: integer(name='PageSize'),
  billingCycle: string(name='BillingCycle'),
  productCode?: string(name='ProductCode'),
  productType?: string(name='ProductType'),
  subscriptionType?: string(name='SubscriptionType'),
}

model QueryInstanceGaapCostResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    hostId: string(name='HostId'),
    pageNum: integer(name='PageNum'),
    pageSize: integer(name='PageSize'),
    totalCount: integer(name='TotalCount'),
    modules: {
      module: [
        {
          billingCycle: string(name='BillingCycle'),
          instanceID: string(name='InstanceID'),
          productCode: string(name='ProductCode'),
          productType: string(name='ProductType'),
          subscriptionType: string(name='SubscriptionType'),
          tag: string(name='Tag'),
          resourceGroup: string(name='ResourceGroup'),
          accountingUnit: string(name='AccountingUnit'),
          payerAccount: string(name='PayerAccount'),
          ownerID: string(name='OwnerID'),
          region: string(name='Region'),
          currency: string(name='Currency'),
          paymentCurrency: string(name='PaymentCurrency'),
          orderType: string(name='OrderType'),
          payTime: string(name='PayTime'),
          pretaxGrossAmount: string(name='PretaxGrossAmount'),
          pricingDiscount: string(name='PricingDiscount'),
          deductedByCoupons: string(name='DeductedByCoupons'),
          pretaxAmount: string(name='PretaxAmount'),
          pretaxAmountLocal: string(name='PretaxAmountLocal'),
          deductedByCashCoupons: string(name='DeductedByCashCoupons'),
          deductedByPrepaidCard: string(name='DeductedByPrepaidCard'),
          paymentAmount: string(name='PaymentAmount'),
          gaapPretaxGrossAmount: string(name='GaapPretaxGrossAmount'),
          gaapPricingDiscount: string(name='GaapPricingDiscount'),
          gaapDeductedByCoupons: string(name='GaapDeductedByCoupons'),
          gaapPretaxAmount: string(name='GaapPretaxAmount'),
          gaapPretaxAmountLocal: string(name='GaapPretaxAmountLocal'),
          gaapDeductedByCashCoupons: string(name='GaapDeductedByCashCoupons'),
          gaapDeductedByPrepaidCard: string(name='GaapDeductedByPrepaidCard'),
          gaapPaymentAmount: string(name='GaapPaymentAmount'),
          monthGaapPretaxGrossAmount: string(name='MonthGaapPretaxGrossAmount'),
          monthGaapPricingDiscount: string(name='MonthGaapPricingDiscount'),
          monthGaapDeductedByCoupons: string(name='MonthGaapDeductedByCoupons'),
          monthGaapPretaxAmount: string(name='MonthGaapPretaxAmount'),
          monthGaapPretaxAmountLocal: string(name='MonthGaapPretaxAmountLocal'),
          monthGaapDeductedByCashCoupons: string(name='MonthGaapDeductedByCashCoupons'),
          monthGaapDeductedByPrepaidCard: string(name='MonthGaapDeductedByPrepaidCard'),
          monthGaapPaymentAmount: string(name='MonthGaapPaymentAmount'),
          unallocatedPaymentAmount: string(name='UnallocatedPaymentAmount'),
          usageStartDate: string(name='UsageStartDate'),
          usageEndDate: string(name='UsageEndDate'),
          billType: string(name='BillType'),
          orderId: string(name='OrderId'),
          subOrderId: string(name='SubOrderId'),
          unallocatedPretaxGrossAmount: string(name='UnallocatedPretaxGrossAmount'),
          unallocatedPricingDiscount: string(name='UnallocatedPricingDiscount'),
          unallocatedDeductedByCoupons: string(name='UnallocatedDeductedByCoupons'),
          unallocatedPretaxAmount: string(name='UnallocatedPretaxAmount'),
          unallocatedPretaxAmountLocal: string(name='UnallocatedPretaxAmountLocal'),
          unallocatedDeductedByCashCoupons: string(name='UnallocatedDeductedByCashCoupons'),
          unallocatedDeductedByPrepaidCard: string(name='UnallocatedDeductedByPrepaidCard'),
        }
      ](name='Module'),
    }(name='Modules'),
  }(name='Data'),
}

async function queryInstanceGaapCostWithOptions(request: QueryInstanceGaapCostRequest, runtime: Util.RuntimeOptions): QueryInstanceGaapCostResponse {
  Util.validateModel(request);
  return doRequest('QueryInstanceGaapCost', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function queryInstanceGaapCost(request: QueryInstanceGaapCostRequest): QueryInstanceGaapCostResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryInstanceGaapCostWithOptions(request, runtime);
}

model RenewInstanceRequest = {
  productCode: string(name='ProductCode'),
  instanceId: string(name='InstanceId'),
  renewPeriod: integer(name='RenewPeriod'),
  clientToken?: string(name='ClientToken'),
  productType?: string(name='ProductType'),
}

model RenewInstanceResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    orderId: string(name='OrderId'),
  }(name='Data'),
}

async function renewInstanceWithOptions(request: RenewInstanceRequest, runtime: Util.RuntimeOptions): RenewInstanceResponse {
  Util.validateModel(request);
  return doRequest('RenewInstance', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function renewInstance(request: RenewInstanceRequest): RenewInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return renewInstanceWithOptions(request, runtime);
}

model GetOrderDetailRequest = {
  orderId: string(name='OrderId'),
}

model GetOrderDetailResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    hostName: string(name='HostName'),
    pageNum: integer(name='PageNum'),
    pageSize: integer(name='PageSize'),
    totalCount: integer(name='TotalCount'),
    orderList: {
      order: [
        {
          orderId: string(name='OrderId'),
          subOrderId: string(name='SubOrderId'),
          productCode: string(name='ProductCode'),
          productType: string(name='ProductType'),
          subscriptionType: string(name='SubscriptionType'),
          orderType: string(name='OrderType'),
          createTime: string(name='CreateTime'),
          paymentTime: string(name='PaymentTime'),
          paymentStatus: string(name='PaymentStatus'),
          region: string(name='Region'),
          config: string(name='Config'),
          quantity: string(name='Quantity'),
          usageStartTime: string(name='UsageStartTime'),
          usageEndTime: string(name='UsageEndTime'),
          instanceIDs: string(name='InstanceIDs'),
          pretaxGrossAmount: string(name='PretaxGrossAmount'),
          pretaxAmount: string(name='PretaxAmount'),
          currency: string(name='Currency'),
          pretaxAmountLocal: string(name='PretaxAmountLocal'),
          tax: string(name='Tax'),
          afterTaxAmount: string(name='AfterTaxAmount'),
          paymentCurrency: string(name='PaymentCurrency'),
          operator: string(name='Operator'),
          relatedOrderId: string(name='RelatedOrderId'),
          orderSubType: string(name='OrderSubType'),
          originalConfig: string(name='OriginalConfig'),
        }
      ](name='Order'),
    }(name='OrderList'),
  }(name='Data'),
}

async function getOrderDetailWithOptions(request: GetOrderDetailRequest, runtime: Util.RuntimeOptions): GetOrderDetailResponse {
  Util.validateModel(request);
  return doRequest('GetOrderDetail', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function getOrderDetail(request: GetOrderDetailRequest): GetOrderDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOrderDetailWithOptions(request, runtime);
}

model QueryOrdersRequest = {
  createTimeEnd?: string(name='CreateTimeEnd'),
  pageNum?: integer(name='PageNum'),
  pageSize?: integer(name='PageSize'),
  productCode?: string(name='ProductCode'),
  productType?: string(name='ProductType'),
  subscriptionType?: string(name='SubscriptionType'),
  orderType?: string(name='OrderType'),
  paymentStatus?: string(name='PaymentStatus'),
  createTimeStart?: string(name='CreateTimeStart'),
}

model QueryOrdersResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    hostName: string(name='HostName'),
    pageNum: integer(name='PageNum'),
    pageSize: integer(name='PageSize'),
    totalCount: integer(name='TotalCount'),
    orderList: {
      order: [
        {
          orderId: string(name='OrderId'),
          productCode: string(name='ProductCode'),
          productType: string(name='ProductType'),
          subscriptionType: string(name='SubscriptionType'),
          orderType: string(name='OrderType'),
          createTime: string(name='CreateTime'),
          paymentTime: string(name='PaymentTime'),
          paymentStatus: string(name='PaymentStatus'),
          pretaxGrossAmount: string(name='PretaxGrossAmount'),
          pretaxAmount: string(name='PretaxAmount'),
          currency: string(name='Currency'),
          pretaxAmountLocal: string(name='PretaxAmountLocal'),
          tax: string(name='Tax'),
          afterTaxAmount: string(name='AfterTaxAmount'),
          paymentCurrency: string(name='PaymentCurrency'),
          relatedOrderId: string(name='RelatedOrderId'),
        }
      ](name='Order'),
    }(name='OrderList'),
  }(name='Data'),
}

async function queryOrdersWithOptions(request: QueryOrdersRequest, runtime: Util.RuntimeOptions): QueryOrdersResponse {
  Util.validateModel(request);
  return doRequest('QueryOrders', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function queryOrders(request: QueryOrdersRequest): QueryOrdersResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryOrdersWithOptions(request, runtime);
}

model QueryMonthlyInstanceConsumptionRequest = {
  productCode?: string(name='ProductCode'),
  pageNum?: integer(name='PageNum'),
  pageSize?: integer(name='PageSize'),
  billingCycle: string(name='BillingCycle'),
  productType?: string(name='ProductType'),
  subscriptionType?: string(name='SubscriptionType'),
}

model QueryMonthlyInstanceConsumptionResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    pageNum: integer(name='PageNum'),
    pageSize: integer(name='PageSize'),
    totalCount: integer(name='TotalCount'),
    billingCycle: string(name='BillingCycle'),
    items: {
      item: [
        {
          instanceID: string(name='InstanceID'),
          productCode: string(name='ProductCode'),
          productType: string(name='ProductType'),
          subscriptionType: string(name='SubscriptionType'),
          tag: string(name='Tag'),
          resourceGroup: string(name='ResourceGroup'),
          payerAccount: string(name='PayerAccount'),
          ownerID: string(name='OwnerID'),
          region: string(name='Region'),
          pretaxGrossAmount: float(name='PretaxGrossAmount'),
          discountAmount: float(name='DiscountAmount'),
          pretaxAmount: float(name='PretaxAmount'),
          currency: string(name='Currency'),
          pretaxAmountLocal: float(name='PretaxAmountLocal'),
          tax: float(name='Tax'),
          afterTaxAmount: float(name='AfterTaxAmount'),
          paymentCurrency: string(name='PaymentCurrency'),
        }
      ](name='Item'),
    }(name='Items'),
  }(name='Data'),
}

async function queryMonthlyInstanceConsumptionWithOptions(request: QueryMonthlyInstanceConsumptionRequest, runtime: Util.RuntimeOptions): QueryMonthlyInstanceConsumptionResponse {
  Util.validateModel(request);
  return doRequest('QueryMonthlyInstanceConsumption', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function queryMonthlyInstanceConsumption(request: QueryMonthlyInstanceConsumptionRequest): QueryMonthlyInstanceConsumptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMonthlyInstanceConsumptionWithOptions(request, runtime);
}

model QuerySettlementBillRequest = {
  pageSize?: integer(name='PageSize'),
  pageNum?: integer(name='PageNum'),
  billingCycle: string(name='BillingCycle'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
  type?: string(name='Type'),
  productCode?: string(name='ProductCode'),
  productType?: string(name='ProductType'),
  subscriptionType?: string(name='SubscriptionType'),
  isHideZeroCharge?: boolean(name='IsHideZeroCharge'),
}

model QuerySettlementBillResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    pageNum: integer(name='PageNum'),
    pageSize: integer(name='PageSize'),
    totalCount: integer(name='TotalCount'),
    billingCycle: string(name='BillingCycle'),
    items: {
      item: [
        {
          recordID: string(name='RecordID'),
          item: string(name='Item'),
          payerAccount: string(name='PayerAccount'),
          ownerID: string(name='OwnerID'),
          createTime: string(name='CreateTime'),
          usageStartTime: string(name='UsageStartTime'),
          usageEndTime: string(name='UsageEndTime'),
          suborderID: string(name='SuborderID'),
          orderID: string(name='OrderID'),
          orderType: string(name='OrderType'),
          linkedCustomerOrderID: string(name='LinkedCustomerOrderID'),
          originalOrderID: string(name='OriginalOrderID'),
          paymentTime: string(name='PaymentTime'),
          solutionID: string(name='SolutionID'),
          solutionName: string(name='SolutionName'),
          billID: string(name='BillID'),
          productCode: string(name='ProductCode'),
          productType: string(name='ProductType'),
          subscriptionType: string(name='SubscriptionType'),
          region: string(name='Region'),
          config: string(name='Config'),
          quantity: string(name='Quantity'),
          pretaxGrossAmount: float(name='PretaxGrossAmount'),
          chargeDiscount: float(name='ChargeDiscount'),
          deductedByCoupons: float(name='DeductedByCoupons'),
          accountDiscount: float(name='AccountDiscount'),
          promotion: string(name='Promotion'),
          pretaxAmount: float(name='PretaxAmount'),
          currency: string(name='Currency'),
          pretaxAmountLocal: float(name='PretaxAmountLocal'),
          previousBillingCycleBalance: float(name='PreviousBillingCycleBalance'),
          tax: float(name='Tax'),
          afterTaxAmount: float(name='AfterTaxAmount'),
          status: string(name='Status'),
          clearedTime: string(name='ClearedTime'),
          outstandingAmount: float(name='OutstandingAmount'),
          deductedByCashCoupons: float(name='DeductedByCashCoupons'),
          deductedByPrepaidCard: float(name='DeductedByPrepaidCard'),
          mybankPaymentAmount: float(name='MybankPaymentAmount'),
          paymentAmount: float(name='PaymentAmount'),
          paymentCurrency: string(name='PaymentCurrency'),
          seller: string(name='Seller'),
          invoiceNo: string(name='InvoiceNo'),
        }
      ](name='Item'),
    }(name='Items'),
  }(name='Data'),
}

async function querySettlementBillWithOptions(request: QuerySettlementBillRequest, runtime: Util.RuntimeOptions): QuerySettlementBillResponse {
  Util.validateModel(request);
  return doRequest('QuerySettlementBill', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function querySettlementBill(request: QuerySettlementBillRequest): QuerySettlementBillResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySettlementBillWithOptions(request, runtime);
}

model QueryMonthlyBillRequest = {
  billingCycle: string(name='BillingCycle'),
}

model QueryMonthlyBillResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    outstandingAmount: float(name='OutstandingAmount'),
    totalOutstandingAmount: float(name='TotalOutstandingAmount'),
    newInvoiceAmount: float(name='NewInvoiceAmount'),
    billingCycle: string(name='BillingCycle'),
    items: {
      item: [
        {
          item: string(name='Item'),
          productCode: string(name='ProductCode'),
          productType: string(name='ProductType'),
          subscriptionType: string(name='SubscriptionType'),
          solutionCode: string(name='SolutionCode'),
          solutionName: string(name='SolutionName'),
          pretaxGrossAmount: float(name='PretaxGrossAmount'),
          invoiceDiscount: float(name='InvoiceDiscount'),
          deductedByCoupons: float(name='DeductedByCoupons'),
          pretaxAmount: float(name='PretaxAmount'),
          currency: string(name='Currency'),
          pretaxAmountLocal: float(name='PretaxAmountLocal'),
          tax: float(name='Tax'),
          afterTaxAmount: float(name='AfterTaxAmount'),
          outstandingAmount: float(name='OutstandingAmount'),
          deductedByCashCoupons: float(name='DeductedByCashCoupons'),
          deductedByPrepaidCard: float(name='DeductedByPrepaidCard'),
          paymentAmount: float(name='PaymentAmount'),
          paymentCurrency: string(name='PaymentCurrency'),
        }
      ](name='Item'),
    }(name='Items'),
  }(name='Data'),
}

async function queryMonthlyBillWithOptions(request: QueryMonthlyBillRequest, runtime: Util.RuntimeOptions): QueryMonthlyBillResponse {
  Util.validateModel(request);
  return doRequest('QueryMonthlyBill', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function queryMonthlyBill(request: QueryMonthlyBillRequest): QueryMonthlyBillResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMonthlyBillWithOptions(request, runtime);
}

model SetRenewalRequest = {
  renewalPeriod?: integer(name='RenewalPeriod'),
  instanceIDs: string(name='InstanceIDs'),
  productCode?: string(name='ProductCode'),
  productType?: string(name='ProductType'),
  subscriptionType?: string(name='SubscriptionType'),
  renewalPeriodUnit?: string(name='RenewalPeriodUnit'),
  renewalStatus: string(name='RenewalStatus'),
}

model SetRenewalResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
}

async function setRenewalWithOptions(request: SetRenewalRequest, runtime: Util.RuntimeOptions): SetRenewalResponse {
  Util.validateModel(request);
  return doRequest('SetRenewal', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function setRenewal(request: SetRenewalRequest): SetRenewalResponse {
  var runtime = new Util.RuntimeOptions{};
  return setRenewalWithOptions(request, runtime);
}

model QueryAvailableInstancesRequest = {
  region?: string(name='Region'),
  pageNum?: integer(name='PageNum'),
  pageSize?: integer(name='PageSize'),
  productCode?: string(name='ProductCode'),
  productType?: string(name='ProductType'),
  subscriptionType?: string(name='SubscriptionType'),
  instanceIDs?: string(name='InstanceIDs'),
  endTimeStart?: string(name='EndTimeStart'),
  endTimeEnd?: string(name='EndTimeEnd'),
  createTimeStart?: string(name='CreateTimeStart'),
  createTimeEnd?: string(name='CreateTimeEnd'),
  renewStatus?: string(name='RenewStatus'),
}

model QueryAvailableInstancesResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    pageNum: integer(name='PageNum'),
    pageSize: integer(name='PageSize'),
    totalCount: integer(name='TotalCount'),
    instanceList: [
      {
        ownerId: long(name='OwnerId'),
        sellerId: long(name='SellerId'),
        productCode: string(name='ProductCode'),
        productType: string(name='ProductType'),
        subscriptionType: string(name='SubscriptionType'),
        instanceID: string(name='InstanceID'),
        region: string(name='Region'),
        createTime: string(name='CreateTime'),
        endTime: string(name='EndTime'),
        stopTime: string(name='StopTime'),
        releaseTime: string(name='ReleaseTime'),
        expectedReleaseTime: string(name='ExpectedReleaseTime'),
        status: string(name='Status'),
        subStatus: string(name='SubStatus'),
        renewStatus: string(name='RenewStatus'),
        renewalDuration: integer(name='RenewalDuration'),
        renewalDurationUnit: string(name='RenewalDurationUnit'),
        seller: string(name='Seller'),
      }
    ](name='InstanceList'),
  }(name='Data'),
}

async function queryAvailableInstancesWithOptions(request: QueryAvailableInstancesRequest, runtime: Util.RuntimeOptions): QueryAvailableInstancesResponse {
  Util.validateModel(request);
  return doRequest('QueryAvailableInstances', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function queryAvailableInstances(request: QueryAvailableInstancesRequest): QueryAvailableInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryAvailableInstancesWithOptions(request, runtime);
}

model CreateResourcePackageRequest = {
  productCode?: string(name='ProductCode'),
  packageType?: string(name='PackageType'),
  effectiveDate?: string(name='EffectiveDate'),
  specification?: string(name='Specification'),
  duration?: integer(name='Duration'),
  pricingCycle?: string(name='PricingCycle'),
}

model CreateResourcePackageResponse = {
  requestId: string(name='RequestId'),
  orderId: long(name='OrderId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    orderId: long(name='OrderId'),
    instanceId: string(name='InstanceId'),
  }(name='Data'),
}

async function createResourcePackageWithOptions(request: CreateResourcePackageRequest, runtime: Util.RuntimeOptions): CreateResourcePackageResponse {
  Util.validateModel(request);
  return doRequest('CreateResourcePackage', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function createResourcePackage(request: CreateResourcePackageRequest): CreateResourcePackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return createResourcePackageWithOptions(request, runtime);
}

model QueryResourcePackageInstancesRequest = {
  productCode?: string(name='ProductCode'),
  expiryTimeStart?: string(name='ExpiryTimeStart'),
  expiryTimeEnd?: string(name='ExpiryTimeEnd'),
  pageNum?: integer(name='PageNum'),
  pageSize?: integer(name='PageSize'),
}

model QueryResourcePackageInstancesResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  page: integer(name='Page'),
  pageSize: integer(name='PageSize'),
  total: integer(name='Total'),
  data: {
    hostId: string(name='HostId'),
    pageNum: string(name='PageNum'),
    pageSize: string(name='PageSize'),
    totalCount: string(name='TotalCount'),
    instances: {
      instance: [
        {
          instanceId: string(name='InstanceId'),
          region: string(name='Region'),
          totalAmount: string(name='TotalAmount'),
          totalAmountUnit: string(name='TotalAmountUnit'),
          remainingAmount: string(name='RemainingAmount'),
          remainingAmountUnit: string(name='RemainingAmountUnit'),
          effectiveTime: string(name='EffectiveTime'),
          expiryTime: string(name='ExpiryTime'),
          remark: string(name='Remark'),
          packageType: string(name='PackageType'),
          status: string(name='Status'),
          deductType: string(name='DeductType'),
          applicableProducts: {
            product: [ string ](name='Product', description='Product'),
          }(name='ApplicableProducts'),
        }
      ](name='Instance'),
    }(name='Instances'),
  }(name='Data'),
}

async function queryResourcePackageInstancesWithOptions(request: QueryResourcePackageInstancesRequest, runtime: Util.RuntimeOptions): QueryResourcePackageInstancesResponse {
  Util.validateModel(request);
  return doRequest('QueryResourcePackageInstances', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function queryResourcePackageInstances(request: QueryResourcePackageInstancesRequest): QueryResourcePackageInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryResourcePackageInstancesWithOptions(request, runtime);
}

model GetResourcePackagePriceRequest = {
  productCode?: string(name='ProductCode'),
  packageType?: string(name='PackageType'),
  effectiveDate?: string(name='EffectiveDate'),
  specification?: string(name='Specification'),
  duration?: integer(name='Duration'),
  pricingCycle?: string(name='PricingCycle'),
  orderType?: string(name='OrderType'),
  instanceId?: string(name='InstanceId'),
}

model GetResourcePackagePriceResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    currency: string(name='Currency'),
    originalPrice: float(name='OriginalPrice'),
    tradePrice: float(name='TradePrice'),
    discountPrice: float(name='DiscountPrice'),
    promotions: {
      promotion: [
        {
          id: long(name='Id'),
          name: string(name='Name'),
        }
      ](name='Promotion'),
    }(name='Promotions'),
  }(name='Data'),
}

async function getResourcePackagePriceWithOptions(request: GetResourcePackagePriceRequest, runtime: Util.RuntimeOptions): GetResourcePackagePriceResponse {
  Util.validateModel(request);
  return doRequest('GetResourcePackagePrice', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function getResourcePackagePrice(request: GetResourcePackagePriceRequest): GetResourcePackagePriceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getResourcePackagePriceWithOptions(request, runtime);
}

model GetSubscriptionPriceRequest = {
  servicePeriodUnit?: string(name='ServicePeriodUnit'),
  subscriptionType: string(name='SubscriptionType'),
  productCode: string(name='ProductCode'),
  orderType: string(name='OrderType'),
  servicePeriodQuantity?: integer(name='ServicePeriodQuantity'),
  productType?: string(name='ProductType'),
  region?: string(name='Region'),
  instanceId?: string(name='InstanceId'),
  moduleList: [
    {
      moduleCode: string(name='ModuleCode'),
      config: string(name='Config'),
      moduleStatus?: integer(name='ModuleStatus'),
      tag?: string(name='Tag'),
    }
  ](name='ModuleList'),
  quantity?: integer(name='Quantity'),
}

model GetSubscriptionPriceResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    originalPrice: float(name='OriginalPrice'),
    discountPrice: float(name='DiscountPrice'),
    tradePrice: float(name='TradePrice'),
    currency: string(name='Currency'),
    quantity: integer(name='Quantity'),
    moduleDetails: {
      moduleDetail: [
        {
          moduleCode: string(name='ModuleCode'),
          originalCost: float(name='OriginalCost'),
          invoiceDiscount: float(name='InvoiceDiscount'),
          costAfterDiscount: float(name='CostAfterDiscount'),
          unitPrice: float(name='UnitPrice'),
        }
      ](name='ModuleDetail'),
    }(name='ModuleDetails'),
    promotionDetails: {
      promotionDetail: [
        {
          promotionName: string(name='PromotionName'),
          promotionDesc: string(name='PromotionDesc'),
          promotionId: long(name='PromotionId'),
        }
      ](name='PromotionDetail'),
    }(name='PromotionDetails'),
  }(name='Data'),
}

async function getSubscriptionPriceWithOptions(request: GetSubscriptionPriceRequest, runtime: Util.RuntimeOptions): GetSubscriptionPriceResponse {
  Util.validateModel(request);
  return doRequest('GetSubscriptionPrice', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function getSubscriptionPrice(request: GetSubscriptionPriceRequest): GetSubscriptionPriceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSubscriptionPriceWithOptions(request, runtime);
}

model GetPayAsYouGoPriceRequest = {
  productCode: string(name='ProductCode'),
  productType?: string(name='ProductType'),
  subscriptionType: string(name='SubscriptionType'),
  region?: string(name='Region'),
  moduleList: [
    {
      moduleCode: string(name='ModuleCode'),
      config: string(name='Config'),
      priceType: string(name='PriceType'),
    }
  ](name='ModuleList'),
}

model GetPayAsYouGoPriceResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    currency: string(name='Currency'),
    moduleDetails: {
      moduleDetail: [
        {
          moduleCode: string(name='ModuleCode'),
          originalCost: float(name='OriginalCost'),
          invoiceDiscount: float(name='InvoiceDiscount'),
          costAfterDiscount: float(name='CostAfterDiscount'),
          unitPrice: float(name='UnitPrice'),
        }
      ](name='ModuleDetail'),
    }(name='ModuleDetails'),
    promotionDetails: {
      promotionDetail: [
        {
          promotionName: string(name='PromotionName'),
          promotionDesc: string(name='PromotionDesc'),
          promotionId: long(name='PromotionId'),
        }
      ](name='PromotionDetail'),
    }(name='PromotionDetails'),
  }(name='Data'),
}

async function getPayAsYouGoPriceWithOptions(request: GetPayAsYouGoPriceRequest, runtime: Util.RuntimeOptions): GetPayAsYouGoPriceResponse {
  Util.validateModel(request);
  return doRequest('GetPayAsYouGoPrice', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function getPayAsYouGoPrice(request: GetPayAsYouGoPriceRequest): GetPayAsYouGoPriceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPayAsYouGoPriceWithOptions(request, runtime);
}

model QueryPrepaidCardsRequest = {
  expiryTimeEnd?: string(name='ExpiryTimeEnd'),
  expiryTimeStart?: string(name='ExpiryTimeStart'),
  effectiveOrNot?: boolean(name='EffectiveOrNot'),
}

model QueryPrepaidCardsResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    prepaidCard: [
      {
        prepaidCardId: long(name='PrepaidCardId'),
        prepaidCardNo: string(name='PrepaidCardNo'),
        grantedTime: string(name='GrantedTime'),
        effectiveTime: string(name='EffectiveTime'),
        expiryTime: string(name='ExpiryTime'),
        applicableProducts: string(name='ApplicableProducts'),
        applicableScenarios: string(name='ApplicableScenarios'),
        nominalValue: string(name='NominalValue'),
        balance: string(name='Balance'),
        status: string(name='Status'),
      }
    ](name='PrepaidCard'),
  }(name='Data'),
}

async function queryPrepaidCardsWithOptions(request: QueryPrepaidCardsRequest, runtime: Util.RuntimeOptions): QueryPrepaidCardsResponse {
  Util.validateModel(request);
  return doRequest('QueryPrepaidCards', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function queryPrepaidCards(request: QueryPrepaidCardsRequest): QueryPrepaidCardsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryPrepaidCardsWithOptions(request, runtime);
}

model QueryCashCouponsRequest = {
  expiryTimeEnd?: string(name='ExpiryTimeEnd'),
  expiryTimeStart?: string(name='ExpiryTimeStart'),
  effectiveOrNot?: boolean(name='EffectiveOrNot'),
}

model QueryCashCouponsResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    cashCoupon: [
      {
        cashCouponId: long(name='CashCouponId'),
        cashCouponNo: string(name='CashCouponNo'),
        grantedTime: string(name='GrantedTime'),
        effectiveTime: string(name='EffectiveTime'),
        expiryTime: string(name='ExpiryTime'),
        applicableProducts: string(name='ApplicableProducts'),
        applicableScenarios: string(name='ApplicableScenarios'),
        nominalValue: string(name='NominalValue'),
        balance: string(name='Balance'),
        status: string(name='Status'),
      }
    ](name='CashCoupon'),
  }(name='Data'),
}

async function queryCashCouponsWithOptions(request: QueryCashCouponsRequest, runtime: Util.RuntimeOptions): QueryCashCouponsResponse {
  Util.validateModel(request);
  return doRequest('QueryCashCoupons', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function queryCashCoupons(request: QueryCashCouponsRequest): QueryCashCouponsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryCashCouponsWithOptions(request, runtime);
}

model QueryAccountBalanceRequest = {
}

model QueryAccountBalanceResponse = {
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    availableAmount: string(name='AvailableAmount'),
    availableCashAmount: string(name='AvailableCashAmount'),
    creditAmount: string(name='CreditAmount'),
    mybankCreditAmount: string(name='MybankCreditAmount'),
    currency: string(name='Currency'),
  }(name='Data'),
}

async function queryAccountBalanceWithOptions(request: QueryAccountBalanceRequest, runtime: Util.RuntimeOptions): QueryAccountBalanceResponse {
  Util.validateModel(request);
  return doRequest('QueryAccountBalance', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function queryAccountBalance(request: QueryAccountBalanceRequest): QueryAccountBalanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryAccountBalanceWithOptions(request, runtime);
}

model DescribeResourcePackageProductRequest = {
  productCode?: string(name='ProductCode'),
}

model DescribeResourcePackageProductResponse = {
  requestId: string(name='RequestId'),
  orderId: long(name='OrderId'),
  success: boolean(name='Success'),
  code: string(name='Code'),
  message: string(name='Message'),
  data: {
    resourcePackages: {
      resourcePackage: [
        {
          productCode: string(name='ProductCode'),
          productType: string(name='ProductType'),
          name: string(name='Name'),
          packageTypes: {
            packageType: [
              {
                name: string(name='Name'),
                code: string(name='Code'),
                properties: {
                  property: [
                    {
                      name: string(name='Name'),
                      value: string(name='Value'),
                    }
                  ](name='Property'),
                }(name='Properties'),
                specifications: {
                  specification: [
                    {
                      name: string(name='Name'),
                      value: string(name='Value'),
                      availableDurations: {
                        availableDuration: [
                          {
                            name: string(name='Name'),
                            value: integer(name='Value'),
                            unit: string(name='Unit'),
                          }
                        ](name='AvailableDuration'),
                      }(name='AvailableDurations'),
                    }
                  ](name='Specification'),
                }(name='Specifications'),
              }
            ](name='PackageType'),
          }(name='PackageTypes'),
        }
      ](name='ResourcePackage'),
    }(name='ResourcePackages'),
  }(name='Data'),
}

async function describeResourcePackageProductWithOptions(request: DescribeResourcePackageProductRequest, runtime: Util.RuntimeOptions): DescribeResourcePackageProductResponse {
  Util.validateModel(request);
  return doRequest('DescribeResourcePackageProduct', 'HTTPS', 'POST', '2017-12-14', 'AK', null, request, runtime);
}

async function describeResourcePackageProduct(request: DescribeResourcePackageProductRequest): DescribeResourcePackageProductResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeResourcePackageProductWithOptions(request, runtime);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
