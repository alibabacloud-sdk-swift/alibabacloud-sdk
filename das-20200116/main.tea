import Util;

import RPC;
import EndpointUtil;

extends RPC;

init(config: RPC.Config){
  super(config);
  @endpointRule = 'central';
  @endpointMap = {
    cn-shanghai = 'das.cn-shanghai.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('das', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

model GetEventOverviewRequest = {
  instanceId?: string(name='InstanceId'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
  minLevel?: string(name='MinLevel'),
}

model GetEventOverviewResponse = {
  code: string(name='Code'),
  data: string(name='Data'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  success: string(name='Success'),
}

async function getEventOverviewWithOptions(request: GetEventOverviewRequest, runtime: Util.RuntimeOptions): GetEventOverviewResponse {
  Util.validateModel(request);
  return doRequest('GetEventOverview', 'HTTPS', 'POST', '2020-01-16', 'AK', null, request, runtime);
}

async function getEventOverview(request: GetEventOverviewRequest): GetEventOverviewResponse {
  var runtime = new Util.RuntimeOptions{};
  return getEventOverviewWithOptions(request, runtime);
}

model DescribeHotKeysRequest = {
  instanceId?: string(name='InstanceId'),
  nodeId?: string(name='NodeId'),
}

model DescribeHotKeysResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  success: string(name='Success'),
  data: {
    hotKey: [
      {
        db: integer(name='Db'),
        keyType: string(name='KeyType'),
        size: long(name='Size'),
        hot: string(name='Hot'),
        key: string(name='Key'),
      }
    ](name='HotKey'),
  }(name='Data'),
}

async function describeHotKeysWithOptions(request: DescribeHotKeysRequest, runtime: Util.RuntimeOptions): DescribeHotKeysResponse {
  Util.validateModel(request);
  return doRequest('DescribeHotKeys', 'HTTPS', 'POST', '2020-01-16', 'AK', null, request, runtime);
}

async function describeHotKeys(request: DescribeHotKeysRequest): DescribeHotKeysResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHotKeysWithOptions(request, runtime);
}

model GetAutonomousNotifyEventDetailRequest = {
  context?: string(name='__context'),
  instanceId?: string(name='InstanceId'),
  spanId?: string(name='SpanId'),
}

model GetAutonomousNotifyEventDetailResponse = {
  code: string(name='Code'),
  data: string(name='Data'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  success: string(name='Success'),
}

async function getAutonomousNotifyEventDetailWithOptions(request: GetAutonomousNotifyEventDetailRequest, runtime: Util.RuntimeOptions): GetAutonomousNotifyEventDetailResponse {
  Util.validateModel(request);
  return doRequest('GetAutonomousNotifyEventDetail', 'HTTPS', 'POST', '2020-01-16', 'AK', null, request, runtime);
}

async function getAutonomousNotifyEventDetail(request: GetAutonomousNotifyEventDetailRequest): GetAutonomousNotifyEventDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAutonomousNotifyEventDetailWithOptions(request, runtime);
}

model GetAutonomousNotifyEventsRequest = {
  context?: string(name='__context'),
  instanceId?: string(name='InstanceId'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
  nodeId?: string(name='NodeId'),
  eventContext?: string(name='EventContext'),
  level?: string(name='Level'),
  minLevel?: string(name='MinLevel'),
  pageOffset?: string(name='PageOffset'),
  pageSize?: string(name='PageSize'),
}

model GetAutonomousNotifyEventsResponse = {
  code: string(name='Code'),
  data: string(name='Data'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  success: string(name='Success'),
}

async function getAutonomousNotifyEventsWithOptions(request: GetAutonomousNotifyEventsRequest, runtime: Util.RuntimeOptions): GetAutonomousNotifyEventsResponse {
  Util.validateModel(request);
  return doRequest('GetAutonomousNotifyEvents', 'HTTPS', 'POST', '2020-01-16', 'AK', null, request, runtime);
}

async function getAutonomousNotifyEvents(request: GetAutonomousNotifyEventsRequest): GetAutonomousNotifyEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAutonomousNotifyEventsWithOptions(request, runtime);
}

model CreateCacheAnalysisJobRequest = {
  instanceId?: string(name='InstanceId'),
  nodeId?: string(name='NodeId'),
}

model CreateCacheAnalysisJobResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  success: string(name='Success'),
  data: {
    jobId: string(name='JobId'),
    instanceId: string(name='InstanceId'),
    nodeId: string(name='NodeId'),
    taskState: string(name='TaskState'),
    message: string(name='Message'),
    bigKeys: {
      keyInfo: [
        {
          count: long(name='Count'),
          bytes: long(name='Bytes'),
          db: integer(name='Db'),
          encoding: string(name='Encoding'),
          expirationTimeMillis: long(name='ExpirationTimeMillis'),
          key: string(name='Key'),
          nodeId: string(name='NodeId'),
          type: string(name='Type'),
        }
      ](name='KeyInfo'),
    }(name='BigKeys'),
  }(name='Data'),
}

async function createCacheAnalysisJobWithOptions(request: CreateCacheAnalysisJobRequest, runtime: Util.RuntimeOptions): CreateCacheAnalysisJobResponse {
  Util.validateModel(request);
  return doRequest('CreateCacheAnalysisJob', 'HTTPS', 'POST', '2020-01-16', 'AK', null, request, runtime);
}

async function createCacheAnalysisJob(request: CreateCacheAnalysisJobRequest): CreateCacheAnalysisJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCacheAnalysisJobWithOptions(request, runtime);
}

model DescribeCacheAnalysisJobsRequest = {
  instanceId?: string(name='InstanceId'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
  pageNo?: string(name='PageNo'),
  pageSize?: string(name='PageSize'),
}

model DescribeCacheAnalysisJobsResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  success: string(name='Success'),
  data: {
    total: long(name='Total'),
    pageNo: long(name='PageNo'),
    pageSize: long(name='PageSize'),
    extra: string(name='Extra'),
    list: {
      cacheAnalysisJob: [
        {
          jobId: string(name='JobId'),
          instanceId: string(name='InstanceId'),
          nodeId: string(name='NodeId'),
          taskState: string(name='TaskState'),
          message: string(name='Message'),
          bigKeys: {
            keyInfo: [
              {
                count: long(name='Count'),
                bytes: long(name='Bytes'),
                db: integer(name='Db'),
                encoding: string(name='Encoding'),
                expirationTimeMillis: long(name='ExpirationTimeMillis'),
                key: string(name='Key'),
                nodeId: string(name='NodeId'),
                type: string(name='Type'),
              }
            ](name='KeyInfo'),
          }(name='BigKeys'),
        }
      ](name='CacheAnalysisJob'),
    }(name='List'),
  }(name='Data'),
}

async function describeCacheAnalysisJobsWithOptions(request: DescribeCacheAnalysisJobsRequest, runtime: Util.RuntimeOptions): DescribeCacheAnalysisJobsResponse {
  Util.validateModel(request);
  return doRequest('DescribeCacheAnalysisJobs', 'HTTPS', 'POST', '2020-01-16', 'AK', null, request, runtime);
}

async function describeCacheAnalysisJobs(request: DescribeCacheAnalysisJobsRequest): DescribeCacheAnalysisJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCacheAnalysisJobsWithOptions(request, runtime);
}

model DescribeCacheAnalysisJobRequest = {
  instanceId?: string(name='InstanceId'),
  jobId?: string(name='JobId'),
}

model DescribeCacheAnalysisJobResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  success: string(name='Success'),
  data: {
    jobId: string(name='JobId'),
    instanceId: string(name='InstanceId'),
    nodeId: string(name='NodeId'),
    taskState: string(name='TaskState'),
    message: string(name='Message'),
    bigKeys: {
      keyInfo: [
        {
          count: long(name='Count'),
          bytes: long(name='Bytes'),
          db: integer(name='Db'),
          encoding: string(name='Encoding'),
          expirationTimeMillis: long(name='ExpirationTimeMillis'),
          key: string(name='Key'),
          nodeId: string(name='NodeId'),
          type: string(name='Type'),
        }
      ](name='KeyInfo'),
    }(name='BigKeys'),
    keyPrefixes: {
      prefix: [
        {
          prefix: string(name='Prefix'),
          type: string(name='Type'),
          bytes: long(name='Bytes'),
          keyNum: long(name='KeyNum'),
          count: long(name='Count'),
        }
      ](name='Prefix'),
    }(name='KeyPrefixes'),
  }(name='Data'),
}

async function describeCacheAnalysisJobWithOptions(request: DescribeCacheAnalysisJobRequest, runtime: Util.RuntimeOptions): DescribeCacheAnalysisJobResponse {
  Util.validateModel(request);
  return doRequest('DescribeCacheAnalysisJob', 'HTTPS', 'POST', '2020-01-16', 'AK', null, request, runtime);
}

async function describeCacheAnalysisJob(request: DescribeCacheAnalysisJobRequest): DescribeCacheAnalysisJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCacheAnalysisJobWithOptions(request, runtime);
}

model DescribeDiagnosticReportListRequest = {
  uid?: string(name='Uid'),
  accessKey?: string(name='accessKey'),
  signature?: string(name='signature'),
  timestamp?: string(name='timestamp'),
  context?: string(name='__context'),
  skipAuth?: string(name='skipAuth'),
  userId?: string(name='UserId'),
  DBInstanceId?: string(name='DBInstanceId'),
  pageNo?: string(name='PageNo'),
  pageSize?: string(name='PageSize'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
}

model DescribeDiagnosticReportListResponse = {
  code: string(name='Code'),
  data: string(name='Data'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  success: string(name='Success'),
  synchro: string(name='Synchro'),
}

async function describeDiagnosticReportListWithOptions(request: DescribeDiagnosticReportListRequest, runtime: Util.RuntimeOptions): DescribeDiagnosticReportListResponse {
  Util.validateModel(request);
  return doRequest('DescribeDiagnosticReportList', 'HTTPS', 'POST', '2020-01-16', 'AK', null, request, runtime);
}

async function describeDiagnosticReportList(request: DescribeDiagnosticReportListRequest): DescribeDiagnosticReportListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDiagnosticReportListWithOptions(request, runtime);
}

model CreateDiagnosticReportRequest = {
  uid?: string(name='Uid'),
  accessKey?: string(name='accessKey'),
  signature?: string(name='signature'),
  timestamp?: string(name='timestamp'),
  context?: string(name='__context'),
  skipAuth?: string(name='skipAuth'),
  userId?: string(name='UserId'),
  DBInstanceId?: string(name='DBInstanceId'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
}

model CreateDiagnosticReportResponse = {
  code: string(name='Code'),
  data: string(name='Data'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  success: string(name='Success'),
  synchro: string(name='Synchro'),
}

async function createDiagnosticReportWithOptions(request: CreateDiagnosticReportRequest, runtime: Util.RuntimeOptions): CreateDiagnosticReportResponse {
  Util.validateModel(request);
  return doRequest('CreateDiagnosticReport', 'HTTPS', 'POST', '2020-01-16', 'AK', null, request, runtime);
}

async function createDiagnosticReport(request: CreateDiagnosticReportRequest): CreateDiagnosticReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDiagnosticReportWithOptions(request, runtime);
}

model AccessHDMInstanceRequest = {
  uid?: string(name='Uid'),
  accessKey?: string(name='accessKey'),
  signature?: string(name='signature'),
  timestamp?: string(name='timestamp'),
  context?: string(name='__context'),
  skipAuth?: string(name='skipAuth'),
  userId?: string(name='UserId'),
  instanceArea?: string(name='InstanceArea'),
  instanceId?: string(name='InstanceId'),
  ip?: string(name='Ip'),
  port?: string(name='Port'),
  engine?: string(name='Engine'),
  username?: string(name='Username'),
  password?: string(name='Password'),
  instanceAlias?: string(name='InstanceAlias'),
  networkType?: string(name='NetworkType'),
  vpcId?: string(name='VpcId'),
  region?: string(name='Region'),
  callerBid?: string(name='CallerBid'),
  tenantId?: string(name='TenantId'),
  ownerIdSignature?: string(name='OwnerIdSignature'),
  callerType?: string(name='CallerType'),
  callerUid?: string(name='CallerUid'),
  target?: string(name='Target'),
  product?: string(name='Product'),
  external?: string(name='External'),
}

model AccessHDMInstanceResponse = {
  code: string(name='Code'),
  data: string(name='Data'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  success: string(name='Success'),
  synchro: string(name='Synchro'),
}

async function accessHDMInstanceWithOptions(request: AccessHDMInstanceRequest, runtime: Util.RuntimeOptions): AccessHDMInstanceResponse {
  Util.validateModel(request);
  return doRequest('AccessHDMInstance', 'HTTPS', 'POST', '2020-01-16', 'AK', null, request, runtime);
}

async function accessHDMInstance(request: AccessHDMInstanceRequest): AccessHDMInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return accessHDMInstanceWithOptions(request, runtime);
}

model SyncHDMAliyunResourceRequest = {
  uid?: string(name='Uid'),
  accessKey?: string(name='accessKey'),
  signature?: string(name='signature'),
  timestamp?: string(name='timestamp'),
  context?: string(name='__context'),
  skipAuth?: string(name='skipAuth'),
  userId?: string(name='UserId'),
  async?: string(name='Async'),
  waitForModifySecurityIps?: string(name='WaitForModifySecurityIps'),
  resourceTypes?: string(name='ResourceTypes'),
}

model SyncHDMAliyunResourceResponse = {
  code: string(name='Code'),
  data: string(name='Data'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  success: string(name='Success'),
  synchro: string(name='Synchro'),
}

async function syncHDMAliyunResourceWithOptions(request: SyncHDMAliyunResourceRequest, runtime: Util.RuntimeOptions): SyncHDMAliyunResourceResponse {
  Util.validateModel(request);
  return doRequest('SyncHDMAliyunResource', 'HTTPS', 'POST', '2020-01-16', 'AK', null, request, runtime);
}

async function syncHDMAliyunResource(request: SyncHDMAliyunResourceRequest): SyncHDMAliyunResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return syncHDMAliyunResourceWithOptions(request, runtime);
}

model GetHDMLastAliyunResourceSyncResultRequest = {
  uid?: string(name='Uid'),
  accessKey?: string(name='accessKey'),
  signature?: string(name='signature'),
  timestamp?: string(name='timestamp'),
  context?: string(name='__context'),
  skipAuth?: string(name='skipAuth'),
  userId?: string(name='UserId'),
}

model GetHDMLastAliyunResourceSyncResultResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  success: string(name='Success'),
  synchro: string(name='Synchro'),
  data: {
    syncStatus: string(name='SyncStatus'),
    errorMsg: string(name='ErrorMsg'),
    results: string(name='Results'),
    subResults: {
      resourceSyncSubResult: [
        {
          resourceType: string(name='ResourceType'),
          syncCount: integer(name='SyncCount'),
          success: boolean(name='Success'),
          errMsg: string(name='ErrMsg'),
        }
      ](name='ResourceSyncSubResult'),
    }(name='SubResults'),
  }(name='Data'),
}

async function getHDMLastAliyunResourceSyncResultWithOptions(request: GetHDMLastAliyunResourceSyncResultRequest, runtime: Util.RuntimeOptions): GetHDMLastAliyunResourceSyncResultResponse {
  Util.validateModel(request);
  return doRequest('GetHDMLastAliyunResourceSyncResult', 'HTTPS', 'POST', '2020-01-16', 'AK', null, request, runtime);
}

async function getHDMLastAliyunResourceSyncResult(request: GetHDMLastAliyunResourceSyncResultRequest): GetHDMLastAliyunResourceSyncResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getHDMLastAliyunResourceSyncResultWithOptions(request, runtime);
}

model GetEndpointSwitchTaskRequest = {
  uid?: string(name='Uid'),
  accessKey?: string(name='accessKey'),
  signature?: string(name='signature'),
  timestamp?: string(name='timestamp'),
  context?: string(name='__context'),
  skipAuth?: string(name='skipAuth'),
  userId?: string(name='UserId'),
  taskId?: string(name='TaskId'),
}

model GetEndpointSwitchTaskResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  success: string(name='Success'),
  synchro: string(name='Synchro'),
  data: {
    accountId: string(name='AccountId'),
    dbLinkId: long(name='DbLinkId'),
    taskId: string(name='TaskId'),
    status: string(name='Status'),
    oriUuid: string(name='OriUuid'),
    uuid: string(name='Uuid'),
    errMsg: string(name='ErrMsg'),
  }(name='Data'),
}

async function getEndpointSwitchTaskWithOptions(request: GetEndpointSwitchTaskRequest, runtime: Util.RuntimeOptions): GetEndpointSwitchTaskResponse {
  Util.validateModel(request);
  return doRequest('GetEndpointSwitchTask', 'HTTPS', 'POST', '2020-01-16', 'AK', null, request, runtime);
}

async function getEndpointSwitchTask(request: GetEndpointSwitchTaskRequest): GetEndpointSwitchTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return getEndpointSwitchTaskWithOptions(request, runtime);
}

model GetHDMAliyunResourceSyncResultRequest = {
  uid?: string(name='Uid'),
  accessKey?: string(name='accessKey'),
  signature?: string(name='signature'),
  timestamp?: string(name='timestamp'),
  context?: string(name='__context'),
  skipAuth?: string(name='skipAuth'),
  userId?: string(name='UserId'),
  taskId?: string(name='TaskId'),
}

model GetHDMAliyunResourceSyncResultResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  success: string(name='Success'),
  synchro: string(name='Synchro'),
  data: {
    syncStatus: string(name='SyncStatus'),
    errorMsg: string(name='ErrorMsg'),
    results: string(name='Results'),
    subResults: {
      resourceSyncSubResult: [
        {
          resourceType: string(name='ResourceType'),
          syncCount: integer(name='SyncCount'),
          success: boolean(name='Success'),
          errMsg: string(name='ErrMsg'),
        }
      ](name='ResourceSyncSubResult'),
    }(name='SubResults'),
  }(name='Data'),
}

async function getHDMAliyunResourceSyncResultWithOptions(request: GetHDMAliyunResourceSyncResultRequest, runtime: Util.RuntimeOptions): GetHDMAliyunResourceSyncResultResponse {
  Util.validateModel(request);
  return doRequest('GetHDMAliyunResourceSyncResult', 'HTTPS', 'POST', '2020-01-16', 'AK', null, request, runtime);
}

async function getHDMAliyunResourceSyncResult(request: GetHDMAliyunResourceSyncResultRequest): GetHDMAliyunResourceSyncResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getHDMAliyunResourceSyncResultWithOptions(request, runtime);
}

model AddHDMInstanceRequest = {
  uid?: string(name='Uid'),
  accessKey?: string(name='accessKey'),
  signature?: string(name='signature'),
  timestamp?: string(name='timestamp'),
  context?: string(name='__context'),
  skipAuth?: string(name='skipAuth'),
  userId?: string(name='UserId'),
  instanceArea?: string(name='InstanceArea'),
  instanceId?: string(name='InstanceId'),
  ip?: string(name='Ip'),
  port?: string(name='Port'),
  engine?: string(name='Engine'),
  username?: string(name='Username'),
  password?: string(name='Password'),
  instanceAlias?: string(name='InstanceAlias'),
  networkType?: string(name='NetworkType'),
  vpcId?: string(name='VpcId'),
  region?: string(name='Region'),
  flushAccount?: string(name='FlushAccount'),
}

model AddHDMInstanceResponse = {
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  success: string(name='Success'),
  synchro: string(name='Synchro'),
  data: {
    instanceId: string(name='InstanceId'),
    vpcId: string(name='VpcId'),
    ip: string(name='Ip'),
    port: integer(name='Port'),
    uuid: string(name='Uuid'),
    role: string(name='Role'),
    code: integer(name='Code'),
    error: string(name='Error'),
    tenantId: string(name='TenantId'),
    ownerId: string(name='OwnerId'),
    token: string(name='Token'),
    callerUid: string(name='CallerUid'),
  }(name='Data'),
}

async function addHDMInstanceWithOptions(request: AddHDMInstanceRequest, runtime: Util.RuntimeOptions): AddHDMInstanceResponse {
  Util.validateModel(request);
  return doRequest('AddHDMInstance', 'HTTPS', 'POST', '2020-01-16', 'AK', null, request, runtime);
}

async function addHDMInstance(request: AddHDMInstanceRequest): AddHDMInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return addHDMInstanceWithOptions(request, runtime);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
