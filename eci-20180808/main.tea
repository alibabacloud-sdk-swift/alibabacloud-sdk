import Util;
import RPC;
import EndpointUtil;

extends RPC;

init(config: RPC.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('eci', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

model ListUsageRequest = {
  regionId?: string(name='RegionId'),
}

model ListUsageResponse = {
  requestId: string(name='RequestId'),
  attributes: map[string]any(name='Attributes'),
}

async function listUsageWithOptions(request: ListUsageRequest, runtime: Util.RuntimeOptions): ListUsageResponse {
  Util.validateModel(request);
  return doRequest('ListUsage', 'HTTPS', 'POST', '2018-08-08', 'AK', null, request, runtime);
}

async function listUsage(request: ListUsageRequest): ListUsageResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUsageWithOptions(request, runtime);
}

model DescribeRegionsRequest = {
  regionId?: string(name='RegionId'),
}

model DescribeRegionsResponse = {
  requestId: string(name='RequestId'),
  regions: [
    {
      regionId: string(name='RegionId'),
      regionEndpoint: string(name='RegionEndpoint'),
      zones: [ string ](name='Zones'),
    }
  ](name='Regions'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  return doRequest('DescribeRegions', 'HTTPS', 'POST', '2018-08-08', 'AK', null, request, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model DescribeImageCachesRequest = {
  regionId: string(name='RegionId'),
  imageCacheId?: string(name='ImageCacheId'),
  imageCacheName?: string(name='ImageCacheName'),
  snapshotId?: string(name='SnapshotId'),
  image?: string(name='Image'),
}

model DescribeImageCachesResponse = {
  requestId: string(name='RequestId'),
  imageCaches: [
    {
      containerGroupId: string(name='ContainerGroupId'),
      imageCacheId: string(name='ImageCacheId'),
      imageCacheName: string(name='ImageCacheName'),
      snapshotId: string(name='SnapshotId'),
      progress: string(name='Progress'),
      status: string(name='Status'),
      expireDateTime: string(name='ExpireDateTime'),
      creationTime: string(name='CreationTime'),
      regionId: string(name='RegionId'),
      events: [
        {
          count: integer(name='Count'),
          type: string(name='Type'),
          name: string(name='Name'),
          message: string(name='Message'),
          firstTimestamp: string(name='FirstTimestamp'),
          lastTimestamp: string(name='LastTimestamp'),
        }
      ](name='Events'),
      images: [ string ](name='Images'),
    }
  ](name='ImageCaches'),
}

async function describeImageCachesWithOptions(request: DescribeImageCachesRequest, runtime: Util.RuntimeOptions): DescribeImageCachesResponse {
  Util.validateModel(request);
  return doRequest('DescribeImageCaches', 'HTTPS', 'POST', '2018-08-08', 'AK', null, request, runtime);
}

async function describeImageCaches(request: DescribeImageCachesRequest): DescribeImageCachesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageCachesWithOptions(request, runtime);
}

model DeleteImageCacheRequest = {
  regionId: string(name='RegionId'),
  imageCacheId: string(name='ImageCacheId'),
  clientToken?: string(name='ClientToken'),
}

model DeleteImageCacheResponse = {
  requestId: string(name='RequestId'),
}

async function deleteImageCacheWithOptions(request: DeleteImageCacheRequest, runtime: Util.RuntimeOptions): DeleteImageCacheResponse {
  Util.validateModel(request);
  return doRequest('DeleteImageCache', 'HTTPS', 'POST', '2018-08-08', 'AK', null, request, runtime);
}

async function deleteImageCache(request: DeleteImageCacheRequest): DeleteImageCacheResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteImageCacheWithOptions(request, runtime);
}

model CreateImageCacheRequest = {
  regionId: string(name='RegionId'),
  zoneId?: string(name='ZoneId'),
  securityGroupId: string(name='SecurityGroupId'),
  vSwitchId: string(name='VSwitchId'),
  imageCacheName: string(name='ImageCacheName'),
  imageRegistryCredential?: [
    {
      server: string(name='Server'),
      userName: string(name='UserName'),
      password: string(name='Password'),
    }
  ](name='ImageRegistryCredential'),
  eipInstanceId?: string(name='EipInstanceId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  clientToken?: string(name='ClientToken'),
  image: [ string ](name='Image'),
  imageCacheSize?: integer(name='ImageCacheSize'),
  retentionDays?: integer(name='RetentionDays'),
}

model CreateImageCacheResponse = {
  requestId: string(name='RequestId'),
  imageCacheId: string(name='ImageCacheId'),
  containerGroupId: string(name='ContainerGroupId'),
}

async function createImageCacheWithOptions(request: CreateImageCacheRequest, runtime: Util.RuntimeOptions): CreateImageCacheResponse {
  Util.validateModel(request);
  return doRequest('CreateImageCache', 'HTTPS', 'POST', '2018-08-08', 'AK', null, request, runtime);
}

async function createImageCache(request: CreateImageCacheRequest): CreateImageCacheResponse {
  var runtime = new Util.RuntimeOptions{};
  return createImageCacheWithOptions(request, runtime);
}

model DescribeMultiContainerGroupMetricRequest = {
  regionId: string(name='RegionId'),
  containerGroupIds: string(name='ContainerGroupIds'),
  resourceGroupId?: string(name='ResourceGroupId'),
  metricType?: string(name='MetricType'),
}

model DescribeMultiContainerGroupMetricResponse = {
  requestId: string(name='RequestId'),
  monitorDatas: [
    {
      containerGroupId: string(name='ContainerGroupId'),
      records: [
        {
          timestamp: string(name='Timestamp'),
          containers: [
            {
              name: string(name='Name'),
              CPU: {
                limit: long(name='Limit'),
                load: long(name='Load'),
                usageCoreNanoSeconds: long(name='UsageCoreNanoSeconds'),
                usageNanoCores: long(name='UsageNanoCores'),
              }(name='CPU'),
              memory: {
                availableBytes: long(name='AvailableBytes'),
                usageBytes: long(name='UsageBytes'),
                cache: long(name='Cache'),
                workingSet: long(name='WorkingSet'),
                rss: long(name='Rss'),
              }(name='Memory'),
            }
          ](name='Containers'),
          CPU: {
            limit: long(name='Limit'),
            load: long(name='Load'),
            usageCoreNanoSeconds: long(name='UsageCoreNanoSeconds'),
            usageNanoCores: long(name='UsageNanoCores'),
          }(name='CPU'),
          memory: {
            availableBytes: long(name='AvailableBytes'),
            usageBytes: long(name='UsageBytes'),
            cache: long(name='Cache'),
            workingSet: long(name='WorkingSet'),
            rss: long(name='Rss'),
          }(name='Memory'),
          network: {
            interfaces: [
              {
                txBytes: long(name='TxBytes'),
                rxBytes: long(name='RxBytes'),
                txErrors: long(name='TxErrors'),
                rxErrors: long(name='RxErrors'),
                name: string(name='Name'),
              }
            ](name='Interfaces'),
          }(name='Network'),
        }
      ](name='Records'),
      containerInfos: [
        {
          id: string(name='Id'),
          name: string(name='Name'),
          namespace: string(name='Namespace'),
          labels: string(name='Labels'),
          containerStats: [
            {
              timestamp: string(name='Timestamp'),
              fsStats: [
                {
                  device: string(name='Device'),
                  type: string(name='Type'),
                  limit: long(name='Limit'),
                  usage: long(name='Usage'),
                  baseUsage: long(name='BaseUsage'),
                  available: long(name='Available'),
                  hasInodes: boolean(name='HasInodes'),
                  inodes: long(name='Inodes'),
                  inodesFree: long(name='InodesFree'),
                  readsCompleted: long(name='ReadsCompleted'),
                  readsMerged: long(name='ReadsMerged'),
                  sectorsRead: long(name='SectorsRead'),
                  readTime: long(name='ReadTime'),
                  writesCompleted: long(name='WritesCompleted'),
                  writesMerged: long(name='WritesMerged'),
                  sectorsWritten: long(name='SectorsWritten'),
                  writeTime: long(name='WriteTime'),
                  ioInProgress: long(name='IoInProgress'),
                  ioTime: long(name='IoTime'),
                  weightedIoTime: long(name='WeightedIoTime'),
                }
              ](name='FsStats'),
              acceleratorStats: [
                {
                  id: string(name='Id'),
                  make: string(name='Make'),
                  model: string(name='Model'),
                  memoryTotal: long(name='MemoryTotal'),
                  memoryUsed: long(name='MemoryUsed'),
                  dutyCycle: long(name='DutyCycle'),
                }
              ](name='AcceleratorStats'),
              cpuStats: {
                loadAverage: long(name='LoadAverage'),
                cpuUsage: {
                  total: long(name='Total'),
                  user: long(name='User'),
                  system: long(name='System'),
                  perCpuUsages: [ long ](name='PerCpuUsages'),
                }(name='CpuUsage'),
                cpuCFS: {
                  periods: long(name='Periods'),
                  throttledPeriods: long(name='ThrottledPeriods'),
                  throttledTime: long(name='ThrottledTime'),
                }(name='CpuCFS'),
              }(name='CpuStats'),
              diskIoStats: {
                ioServiceBytes: [
                  {
                    device: string(name='Device'),
                    major: long(name='Major'),
                    minor: long(name='Minor'),
                    stats: string(name='Stats'),
                  }
                ](name='IoServiceBytes'),
                ioServiced: [
                  {
                    device: string(name='Device'),
                    major: long(name='Major'),
                    minor: long(name='Minor'),
                    stats: string(name='Stats'),
                  }
                ](name='IoServiced'),
                ioQueued: [
                  {
                    device: string(name='Device'),
                    major: long(name='Major'),
                    minor: long(name='Minor'),
                    stats: string(name='Stats'),
                  }
                ](name='IoQueued'),
                sectors: [
                  {
                    device: string(name='Device'),
                    major: long(name='Major'),
                    minor: long(name='Minor'),
                    stats: string(name='Stats'),
                  }
                ](name='Sectors'),
                ioServiceTime: [
                  {
                    device: string(name='Device'),
                    major: long(name='Major'),
                    minor: long(name='Minor'),
                    stats: string(name='Stats'),
                  }
                ](name='IoServiceTime'),
                ioWaitTime: [
                  {
                    device: string(name='Device'),
                    major: long(name='Major'),
                    minor: long(name='Minor'),
                    stats: string(name='Stats'),
                  }
                ](name='IoWaitTime'),
                ioMerged: [
                  {
                    device: string(name='Device'),
                    major: long(name='Major'),
                    minor: long(name='Minor'),
                    stats: string(name='Stats'),
                  }
                ](name='IoMerged'),
                ioTime: [
                  {
                    device: string(name='Device'),
                    major: long(name='Major'),
                    minor: long(name='Minor'),
                    stats: string(name='Stats'),
                  }
                ](name='IoTime'),
              }(name='DiskIoStats'),
              memoryStats: {
                usage: long(name='Usage'),
                maxUsage: long(name='MaxUsage'),
                cache: long(name='Cache'),
                rss: long(name='Rss'),
                swap: long(name='Swap'),
                workingSet: long(name='WorkingSet'),
                failCnt: long(name='FailCnt'),
                containerData: {
                  pgFault: long(name='PgFault'),
                  pgmajFault: long(name='PgmajFault'),
                }(name='ContainerData'),
                hierarchicalData: {
                  pgFault: long(name='PgFault'),
                  pgmajFault: long(name='PgmajFault'),
                }(name='HierarchicalData'),
              }(name='MemoryStats'),
              networkStats: {
                name: string(name='Name'),
                rxBytes: long(name='RxBytes'),
                rxPackets: long(name='RxPackets'),
                rxErrors: long(name='RxErrors'),
                rxDropped: long(name='RxDropped'),
                txBytes: long(name='TxBytes'),
                txPackets: long(name='TxPackets'),
                txDropped: long(name='TxDropped'),
                txErrors: long(name='TxErrors'),
                interfaceStats: [
                  {
                    name: string(name='Name'),
                    rxBytes: long(name='RxBytes'),
                    rxPackets: long(name='RxPackets'),
                    rxErrors: long(name='RxErrors'),
                    rxDropped: long(name='RxDropped'),
                    txBytes: long(name='TxBytes'),
                    txPackets: long(name='TxPackets'),
                    txDropped: long(name='TxDropped'),
                    txErrors: long(name='TxErrors'),
                  }
                ](name='InterfaceStats'),
                tcp: {
                  established: long(name='Established'),
                  synSent: long(name='SynSent'),
                  synRecv: long(name='SynRecv'),
                  finWait1: long(name='FinWait1'),
                  finWait2: long(name='FinWait2'),
                  timeWait: long(name='TimeWait'),
                  close: long(name='Close'),
                  closeWait: long(name='CloseWait'),
                  lastAck: long(name='LastAck'),
                  listen: long(name='Listen'),
                  closing: long(name='Closing'),
                }(name='Tcp'),
                tcp6: {
                  established: long(name='Established'),
                  synSent: long(name='SynSent'),
                  synRecv: long(name='SynRecv'),
                  finWait1: long(name='FinWait1'),
                  finWait2: long(name='FinWait2'),
                  timeWait: long(name='TimeWait'),
                  close: long(name='Close'),
                  closeWait: long(name='CloseWait'),
                  lastAck: long(name='LastAck'),
                  listen: long(name='Listen'),
                  closing: long(name='Closing'),
                }(name='Tcp6'),
                udp: {
                  listen: long(name='Listen'),
                  dropped: long(name='Dropped'),
                  rxQueued: long(name='RxQueued'),
                  txQueued: long(name='TxQueued'),
                }(name='Udp'),
                udp6: {
                  listen: long(name='Listen'),
                  dropped: long(name='Dropped'),
                  rxQueued: long(name='RxQueued'),
                  txQueued: long(name='TxQueued'),
                }(name='Udp6'),
              }(name='NetworkStats'),
              taskStats: {
                nrSleeping: long(name='NrSleeping'),
                nrRunning: long(name='NrRunning'),
                nrStopped: long(name='NrStopped'),
                nrUninterruptible: long(name='NrUninterruptible'),
                nrIoWait: long(name='NrIoWait'),
              }(name='TaskStats'),
            }
          ](name='ContainerStats'),
          containerSpec: {
            creationTime: string(name='CreationTime'),
            hasCpu: boolean(name='HasCpu'),
            hasMemory: boolean(name='HasMemory'),
            hasNetwork: boolean(name='HasNetwork'),
            hasFilesystem: boolean(name='HasFilesystem'),
            hasDiskIo: boolean(name='HasDiskIo'),
            hasCustomMetrics: boolean(name='HasCustomMetrics'),
            image: string(name='Image'),
            labels: string(name='Labels'),
            envs: string(name='Envs'),
            containerCpu: {
              limit: long(name='Limit'),
              maxLimit: long(name='MaxLimit'),
              mask: string(name='Mask'),
              quota: long(name='Quota'),
              period: long(name='Period'),
            }(name='ContainerCpu'),
            containerMemory: {
              limit: long(name='Limit'),
              reservation: long(name='Reservation'),
              swapLimit: long(name='SwapLimit'),
            }(name='ContainerMemory'),
          }(name='ContainerSpec'),
          aliases: [ string ](name='Aliases'),
        }
      ](name='ContainerInfos'),
    }
  ](name='MonitorDatas'),
}

async function describeMultiContainerGroupMetricWithOptions(request: DescribeMultiContainerGroupMetricRequest, runtime: Util.RuntimeOptions): DescribeMultiContainerGroupMetricResponse {
  Util.validateModel(request);
  return doRequest('DescribeMultiContainerGroupMetric', 'HTTPS', 'POST', '2018-08-08', 'AK', null, request, runtime);
}

async function describeMultiContainerGroupMetric(request: DescribeMultiContainerGroupMetricRequest): DescribeMultiContainerGroupMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMultiContainerGroupMetricWithOptions(request, runtime);
}

model DescribeContainerGroupMetricRequest = {
  regionId: string(name='RegionId'),
  containerGroupId: string(name='ContainerGroupId'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
  period?: string(name='Period'),
}

model DescribeContainerGroupMetricResponse = {
  requestId: string(name='RequestId'),
  containerGroupId: string(name='ContainerGroupId'),
  records: [
    {
      timestamp: string(name='Timestamp'),
      containers: [
        {
          name: string(name='Name'),
          CPU: {
            usageNanoCores: long(name='UsageNanoCores'),
            usageCoreNanoSeconds: long(name='UsageCoreNanoSeconds'),
            load: long(name='Load'),
            limit: long(name='Limit'),
          }(name='CPU'),
          memory: {
            availableBytes: long(name='AvailableBytes'),
            usageBytes: long(name='UsageBytes'),
            cache: long(name='Cache'),
            workingSet: long(name='WorkingSet'),
            rss: long(name='Rss'),
          }(name='Memory'),
        }
      ](name='Containers'),
      CPU: {
        usageNanoCores: long(name='UsageNanoCores'),
        usageCoreNanoSeconds: long(name='UsageCoreNanoSeconds'),
        load: long(name='Load'),
        limit: long(name='Limit'),
      }(name='CPU'),
      memory: {
        availableBytes: long(name='AvailableBytes'),
        usageBytes: long(name='UsageBytes'),
        cache: long(name='Cache'),
        workingSet: long(name='WorkingSet'),
        rss: long(name='Rss'),
      }(name='Memory'),
      network: {
        interfaces: [
          {
            txBytes: long(name='TxBytes'),
            rxBytes: long(name='RxBytes'),
            txErrors: long(name='TxErrors'),
            rxErrors: long(name='RxErrors'),
            name: string(name='Name'),
          }
        ](name='Interfaces'),
      }(name='Network'),
    }
  ](name='Records'),
}

async function describeContainerGroupMetricWithOptions(request: DescribeContainerGroupMetricRequest, runtime: Util.RuntimeOptions): DescribeContainerGroupMetricResponse {
  Util.validateModel(request);
  return doRequest('DescribeContainerGroupMetric', 'HTTPS', 'POST', '2018-08-08', 'AK', null, request, runtime);
}

async function describeContainerGroupMetric(request: DescribeContainerGroupMetricRequest): DescribeContainerGroupMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContainerGroupMetricWithOptions(request, runtime);
}

model UpdateContainerGroupByTemplateRequest = {
  regionId: string(name='RegionId'),
  template: string(name='Template'),
  clientToken?: string(name='ClientToken'),
}

model UpdateContainerGroupByTemplateResponse = {
  requestId: string(name='RequestId'),
}

async function updateContainerGroupByTemplateWithOptions(request: UpdateContainerGroupByTemplateRequest, runtime: Util.RuntimeOptions): UpdateContainerGroupByTemplateResponse {
  Util.validateModel(request);
  return doRequest('UpdateContainerGroupByTemplate', 'HTTPS', 'POST', '2018-08-08', 'AK', null, request, runtime);
}

async function updateContainerGroupByTemplate(request: UpdateContainerGroupByTemplateRequest): UpdateContainerGroupByTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateContainerGroupByTemplateWithOptions(request, runtime);
}

model CreateContainerGroupFromTemplateRequest = {
  regionId: string(name='RegionId'),
  template: string(name='Template'),
  clientToken?: string(name='ClientToken'),
}

model CreateContainerGroupFromTemplateResponse = {
  requestId: string(name='RequestId'),
  containerGroupId: string(name='ContainerGroupId'),
}

async function createContainerGroupFromTemplateWithOptions(request: CreateContainerGroupFromTemplateRequest, runtime: Util.RuntimeOptions): CreateContainerGroupFromTemplateResponse {
  Util.validateModel(request);
  return doRequest('CreateContainerGroupFromTemplate', 'HTTPS', 'POST', '2018-08-08', 'AK', null, request, runtime);
}

async function createContainerGroupFromTemplate(request: CreateContainerGroupFromTemplateRequest): CreateContainerGroupFromTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return createContainerGroupFromTemplateWithOptions(request, runtime);
}

model ExportContainerGroupTemplateRequest = {
  regionId?: string(name='RegionId'),
  containerGroupId?: string(name='ContainerGroupId'),
}

model ExportContainerGroupTemplateResponse = {
  requestId: string(name='RequestId'),
  template: {
    regionId: string(name='RegionId'),
    zoneId: string(name='ZoneId'),
    securityGroupId: string(name='SecurityGroupId'),
    vSwitchId: string(name='VSwitchId'),
    resourceGroupId: string(name='ResourceGroupId'),
    eipInstanceId: string(name='EipInstanceId'),
    containerGroupName: string(name='ContainerGroupName'),
    instanceType: string(name='InstanceType'),
    tags: [
      {
        key: string(name='Key'),
        value: string(name='Value'),
      }
    ](name='Tags'),
    resources: {
      cpu: float(name='Cpu'),
      memory: float(name='Memory'),
    }(name='Resources'),
    spec: {
      restartPolicy: string(name='RestartPolicy'),
      dnsPolicy: string(name='DnsPolicy'),
      volumes: [
        {
          name: string(name='Name'),
          configFile: {
            defaultMode: integer(name='DefaultMode'),
            items: [
              {
                mode: integer(name='Mode'),
                path: string(name='Path'),
                content: string(name='Content'),
              }
            ](name='Items'),
          }(name='ConfigFile'),
          emptyDir: {
            sizeLimit: string(name='SizeLimit'),
          }(name='EmptyDir'),
          nfs: {
            server: string(name='Server'),
            path: string(name='Path'),
            readOnly: boolean(name='ReadOnly'),
          }(name='Nfs'),
        }
      ](name='Volumes'),
      initContainers: [
        {
          name: string(name='Name'),
          image: string(name='Image'),
          imagePullPolicy: string(name='ImagePullPolicy'),
          stdin: boolean(name='Stdin'),
          stdinOnce: boolean(name='StdinOnce'),
          tty: boolean(name='Tty'),
          workingDir: string(name='WorkingDir'),
          env: [
            {
              name: string(name='Name'),
              value: string(name='Value'),
              valueFrom: {
                fieldRef: {
                  fieldPath: string(name='FieldPath'),
                }(name='FieldRef'),
              }(name='ValueFrom'),
            }
          ](name='Env'),
          ports: [
            {
              name: string(name='Name'),
              protocol: string(name='Protocol'),
              containerPort: integer(name='ContainerPort'),
            }
          ](name='Ports'),
          volumeMounts: [
            {
              name: string(name='Name'),
              subPath: string(name='SubPath'),
              mountPath: string(name='MountPath'),
              readOnly: boolean(name='ReadOnly'),
            }
          ](name='VolumeMounts'),
          securityContext: {
            sysctls: [
              {
                name: string(name='Name'),
                value: string(name='Value'),
              }
            ](name='Sysctls'),
          }(name='SecurityContext'),
          resources: {
            cpu: float(name='Cpu'),
            memory: float(name='Memory'),
          }(name='Resources'),
          command: [ string ](name='Command'),
          args: [ string ](name='Args'),
        }
      ](name='InitContainers'),
      containers: [
        {
          name: string(name='Name'),
          image: string(name='Image'),
          imagePullPolicy: string(name='ImagePullPolicy'),
          stdin: boolean(name='Stdin'),
          stdinOnce: boolean(name='StdinOnce'),
          tty: boolean(name='Tty'),
          workingDir: string(name='WorkingDir'),
          env: [
            {
              name: string(name='Name'),
              value: string(name='Value'),
              valueFrom: {
                fieldRef: {
                  fieldPath: string(name='FieldPath'),
                }(name='FieldRef'),
              }(name='ValueFrom'),
            }
          ](name='Env'),
          ports: [
            {
              name: string(name='Name'),
              protocol: string(name='Protocol'),
              containerPort: integer(name='ContainerPort'),
            }
          ](name='Ports'),
          volumeMounts: [
            {
              name: string(name='Name'),
              subPath: string(name='SubPath'),
              mountPath: string(name='MountPath'),
              readOnly: boolean(name='ReadOnly'),
            }
          ](name='VolumeMounts'),
          securityContext: {
            sysctls: [
              {
                name: string(name='Name'),
                value: string(name='Value'),
              }
            ](name='Sysctls'),
          }(name='SecurityContext'),
          resources: {
            cpu: float(name='Cpu'),
            memory: float(name='Memory'),
          }(name='Resources'),
          readinessProbe: {
            initialDelaySeconds: integer(name='InitialDelaySeconds'),
            periodSeconds: integer(name='PeriodSeconds'),
            successThreshold: integer(name='SuccessThreshold'),
            failureThreshold: integer(name='FailureThreshold'),
            timeoutSeconds: integer(name='TimeoutSeconds'),
            exec: {
              command: [ string ](name='Command'),
            }(name='Exec'),
            tcpSocket: {
              port: integer(name='Port'),
            }(name='TcpSocket'),
            httpGet: {
              scheme: string(name='Scheme'),
              path: string(name='Path'),
              port: integer(name='Port'),
            }(name='HttpGet'),
          }(name='ReadinessProbe'),
          livenessProbe: {
            initialDelaySeconds: integer(name='InitialDelaySeconds'),
            periodSeconds: integer(name='PeriodSeconds'),
            successThreshold: integer(name='SuccessThreshold'),
            failureThreshold: integer(name='FailureThreshold'),
            timeoutSeconds: integer(name='TimeoutSeconds'),
            exec: {
              command: [ string ](name='Command'),
            }(name='Exec'),
            tcpSocket: {
              port: integer(name='Port'),
            }(name='TcpSocket'),
            httpGet: {
              scheme: string(name='Scheme'),
              path: string(name='Path'),
              port: integer(name='Port'),
            }(name='HttpGet'),
          }(name='LivenessProbe'),
          command: [ string ](name='Command'),
          args: [ string ](name='Args'),
        }
      ](name='Containers'),
      dnsConfig: {
        options: [
          {
            name: string(name='Name'),
            value: string(name='Value'),
          }
        ](name='Options'),
        nameServers: [ string ](name='NameServers'),
        searches: [ string ](name='Searches'),
      }(name='DnsConfig'),
      securityContext: {
        sysctls: [
          {
            name: string(name='Name'),
            value: string(name='Value'),
          }
        ](name='Sysctls'),
      }(name='SecurityContext'),
    }(name='Spec'),
  }(name='Template'),
}

async function exportContainerGroupTemplateWithOptions(request: ExportContainerGroupTemplateRequest, runtime: Util.RuntimeOptions): ExportContainerGroupTemplateResponse {
  Util.validateModel(request);
  return doRequest('ExportContainerGroupTemplate', 'HTTPS', 'POST', '2018-08-08', 'AK', null, request, runtime);
}

async function exportContainerGroupTemplate(request: ExportContainerGroupTemplateRequest): ExportContainerGroupTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return exportContainerGroupTemplateWithOptions(request, runtime);
}

model RestartContainerGroupRequest = {
  regionId: string(name='RegionId'),
  containerGroupId: string(name='ContainerGroupId'),
  clientToken?: string(name='ClientToken'),
}

model RestartContainerGroupResponse = {
  requestId: string(name='RequestId'),
}

async function restartContainerGroupWithOptions(request: RestartContainerGroupRequest, runtime: Util.RuntimeOptions): RestartContainerGroupResponse {
  Util.validateModel(request);
  return doRequest('RestartContainerGroup', 'HTTPS', 'POST', '2018-08-08', 'AK', null, request, runtime);
}

async function restartContainerGroup(request: RestartContainerGroupRequest): RestartContainerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return restartContainerGroupWithOptions(request, runtime);
}

model UpdateContainerGroupRequest = {
  regionId: string(name='RegionId'),
  containerGroupId: string(name='ContainerGroupId'),
  restartPolicy?: string(name='RestartPolicy'),
  tag?: [
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  volume?: [
    {
      name?: string(name='Name'),
      type?: string(name='Type'),
      NFSVolume?: {
        server?: string(name='Server'),
        path?: string(name='Path'),
        readOnly?: boolean(name='ReadOnly'),
      }(name='NFSVolume'),
      configFileVolume?: {
        configFileToPath: [
          {
            content?: string(name='Content'),
            path?: string(name='Path'),
          }
        ](name='ConfigFileToPath'),
      }(name='ConfigFileVolume'),
      emptyDirVolume?: {
        medium?: string(name='Medium'),
      }(name='EmptyDirVolume'),
    }
  ](name='Volume'),
  dnsConfig?: {
    nameServer?: [ string ](name='NameServer'),
    search?: [ string ](name='Search'),
    option?: [
      {
        name?: string(name='Name'),
        value?: string(name='Value'),
      }
    ](name='Option'),
  }(name='DnsConfig'),
  container?: [
    {
      name?: string(name='Name'),
      image?: string(name='Image'),
      cpu?: float(name='Cpu'),
      memory?: float(name='Memory'),
      workingDir?: string(name='WorkingDir'),
      imagePullPolicy?: string(name='ImagePullPolicy'),
      stdin?: boolean(name='Stdin'),
      stdinOnce?: boolean(name='StdinOnce'),
      tty?: boolean(name='Tty'),
      command: [ string ](name='Command'),
      arg: [ string ](name='Arg'),
      environmentVar: [
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='EnvironmentVar'),
      port: [
        {
          protocol?: string(name='Protocol'),
          port?: integer(name='Port'),
        }
      ](name='Port'),
      volumeMount: [
        {
          name?: string(name='Name'),
          mountPath?: string(name='MountPath'),
          subPath?: string(name='SubPath'),
          readOnly?: boolean(name='ReadOnly'),
        }
      ](name='VolumeMount'),
      readinessProbe?: {
        tcpSocket: {
          port?: integer(name='Port'),
        }(name='TcpSocket'),
        exec: {
          command: [ string ](name='Command'),
        }(name='Exec'),
        httpGet: {
          path?: string(name='Path'),
          port?: integer(name='Port'),
          scheme?: string(name='Scheme'),
        }(name='HttpGet'),
        initialDelaySeconds?: integer(name='InitialDelaySeconds'),
        periodSeconds?: integer(name='PeriodSeconds'),
        successThreshold?: integer(name='SuccessThreshold'),
        failureThreshold?: integer(name='FailureThreshold'),
        timeoutSeconds?: integer(name='TimeoutSeconds'),
      }(name='ReadinessProbe'),
      livenessProbe?: {
        tcpSocket: {
          port?: integer(name='Port'),
        }(name='TcpSocket'),
        exec: {
          command: [ string ](name='Command'),
        }(name='Exec'),
        httpGet: {
          path?: string(name='Path'),
          port?: integer(name='Port'),
          scheme?: string(name='Scheme'),
        }(name='HttpGet'),
        initialDelaySeconds?: integer(name='InitialDelaySeconds'),
        periodSeconds?: integer(name='PeriodSeconds'),
        successThreshold?: integer(name='SuccessThreshold'),
        failureThreshold: integer(name='FailureThreshold'),
        timeoutSeconds?: integer(name='TimeoutSeconds'),
      }(name='LivenessProbe'),
      securityContext?: {
        readOnlyRootFilesystem?: boolean(name='ReadOnlyRootFilesystem'),
        runAsUser?: long(name='RunAsUser'),
        capability: {
          add: [ string ](name='Add'),
        }(name='Capability'),
      }(name='SecurityContext'),
      gpu?: integer(name='Gpu'),
    }
  ](name='Container'),
  initContainer?: [
    {
      name?: string(name='Name'),
      image?: string(name='Image'),
      cpu?: float(name='Cpu'),
      memory?: float(name='Memory'),
      workingDir?: string(name='WorkingDir'),
      imagePullPolicy?: string(name='ImagePullPolicy'),
      stdin?: boolean(name='Stdin'),
      stdinOnce?: boolean(name='StdinOnce'),
      tty?: boolean(name='Tty'),
      command: [ string ](name='Command'),
      arg: [ string ](name='Arg'),
      environmentVar: [
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='EnvironmentVar'),
      port: [
        {
          port?: integer(name='Port'),
          protocol: string(name='Protocol'),
        }
      ](name='Port'),
      volumeMount: [
        {
          name?: string(name='Name'),
          mountPath?: string(name='MountPath'),
          subPath?: string(name='SubPath'),
          readOnly?: boolean(name='ReadOnly'),
        }
      ](name='VolumeMount'),
      securityContext?: {
        readOnlyRootFilesystem?: boolean(name='ReadOnlyRootFilesystem'),
        runAsUser?: long(name='RunAsUser'),
        capability: {
          add: [ string ](name='Add'),
        }(name='Capability'),
      }(name='SecurityContext'),
      gpu?: integer(name='Gpu'),
    }
  ](name='InitContainer'),
  imageRegistryCredential?: [
    {
      server?: string(name='Server'),
      userName?: string(name='UserName'),
      password?: string(name='Password'),
    }
  ](name='ImageRegistryCredential'),
  clientToken?: string(name='ClientToken'),
  cpu?: float(name='Cpu'),
  memory?: float(name='Memory'),
}

model UpdateContainerGroupResponse = {
  requestId: string(name='RequestId'),
}

async function updateContainerGroupWithOptions(request: UpdateContainerGroupRequest, runtime: Util.RuntimeOptions): UpdateContainerGroupResponse {
  Util.validateModel(request);
  return doRequest('UpdateContainerGroup', 'HTTPS', 'POST', '2018-08-08', 'AK', null, request, runtime);
}

async function updateContainerGroup(request: UpdateContainerGroupRequest): UpdateContainerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateContainerGroupWithOptions(request, runtime);
}

model DescribeContainerGroupPriceRequest = {
  regionId: string(name='RegionId'),
  cpu?: float(name='Cpu'),
  memory?: float(name='Memory'),
  instanceType?: string(name='InstanceType'),
  spotStrategy?: string(name='SpotStrategy'),
  zoneId?: string(name='ZoneId'),
  spotPriceLimit?: float(name='SpotPriceLimit'),
}

model DescribeContainerGroupPriceResponse = {
  requestId: string(name='RequestId'),
  priceInfo: {
    rules: {
      rule: [
        {
          ruleId: long(name='RuleId'),
          description: string(name='Description'),
        }
      ](name='Rule'),
    }(name='Rules'),
    spotPrices: {
      spotPrice: [
        {
          zoneId: string(name='ZoneId'),
          instanceType: string(name='InstanceType'),
          spotPrice: float(name='SpotPrice'),
          originPrice: float(name='OriginPrice'),
        }
      ](name='SpotPrice'),
    }(name='SpotPrices'),
    price: {
      originalPrice: float(name='OriginalPrice'),
      discountPrice: float(name='DiscountPrice'),
      tradePrice: float(name='TradePrice'),
      currency: string(name='Currency'),
      detailInfos: {
        detailInfo: [
          {
            resource: string(name='Resource'),
            originalPrice: float(name='OriginalPrice'),
            discountPrice: float(name='DiscountPrice'),
            tradePrice: float(name='TradePrice'),
            rules: {
              rule: [
                {
                  ruleId: long(name='RuleId'),
                  description: string(name='Description'),
                }
              ](name='Rule'),
            }(name='Rules'),
          }
        ](name='DetailInfo'),
      }(name='DetailInfos'),
    }(name='Price'),
  }(name='PriceInfo'),
}

async function describeContainerGroupPriceWithOptions(request: DescribeContainerGroupPriceRequest, runtime: Util.RuntimeOptions): DescribeContainerGroupPriceResponse {
  Util.validateModel(request);
  return doRequest('DescribeContainerGroupPrice', 'HTTPS', 'POST', '2018-08-08', 'AK', null, request, runtime);
}

async function describeContainerGroupPrice(request: DescribeContainerGroupPriceRequest): DescribeContainerGroupPriceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContainerGroupPriceWithOptions(request, runtime);
}

model ExecContainerCommandRequest = {
  regionId: string(name='RegionId'),
  containerGroupId: string(name='ContainerGroupId'),
  containerName: string(name='ContainerName'),
  command: string(name='Command'),
  TTY?: boolean(name='TTY'),
  stdin?: boolean(name='Stdin'),
}

model ExecContainerCommandResponse = {
  requestId: string(name='RequestId'),
  webSocketUri: string(name='WebSocketUri'),
}

async function execContainerCommandWithOptions(request: ExecContainerCommandRequest, runtime: Util.RuntimeOptions): ExecContainerCommandResponse {
  Util.validateModel(request);
  return doRequest('ExecContainerCommand', 'HTTPS', 'POST', '2018-08-08', 'AK', null, request, runtime);
}

async function execContainerCommand(request: ExecContainerCommandRequest): ExecContainerCommandResponse {
  var runtime = new Util.RuntimeOptions{};
  return execContainerCommandWithOptions(request, runtime);
}

model DescribeContainerLogRequest = {
  regionId: string(name='RegionId'),
  containerGroupId: string(name='ContainerGroupId'),
  containerName: string(name='ContainerName'),
  startTime?: string(name='StartTime'),
  tail?: integer(name='Tail'),
  lastTime?: boolean(name='LastTime'),
  sinceSeconds?: integer(name='SinceSeconds'),
  limitBytes?: long(name='LimitBytes'),
}

model DescribeContainerLogResponse = {
  requestId: string(name='RequestId'),
  containerName: string(name='ContainerName'),
  content: string(name='Content'),
}

async function describeContainerLogWithOptions(request: DescribeContainerLogRequest, runtime: Util.RuntimeOptions): DescribeContainerLogResponse {
  Util.validateModel(request);
  return doRequest('DescribeContainerLog', 'HTTPS', 'POST', '2018-08-08', 'AK', null, request, runtime);
}

async function describeContainerLog(request: DescribeContainerLogRequest): DescribeContainerLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContainerLogWithOptions(request, runtime);
}

model CreateContainerGroupRequest = {
  regionId: string(name='RegionId'),
  zoneId?: string(name='ZoneId'),
  securityGroupId: string(name='SecurityGroupId'),
  vSwitchId: string(name='VSwitchId'),
  containerGroupName: string(name='ContainerGroupName'),
  restartPolicy?: string(name='RestartPolicy'),
  tag?: [
    {
      key: string(name='Key'),
      value: string(name='Value'),
    }
  ](name='Tag'),
  imageRegistryCredential?: [
    {
      server: string(name='Server'),
      userName: string(name='UserName'),
      password: string(name='Password'),
    }
  ](name='ImageRegistryCredential'),
  container: [
    {
      image: string(name='Image'),
      name: string(name='Name'),
      cpu?: float(name='Cpu'),
      memory?: float(name='Memory'),
      workingDir?: string(name='WorkingDir'),
      imagePullPolicy?: string(name='ImagePullPolicy'),
      command?: [ string ](name='Command'),
      arg?: [ string ](name='Arg'),
      volumeMount?: [
        {
          mountPath: string(name='MountPath'),
          readOnly: boolean(name='ReadOnly'),
          name?: string(name='Name'),
          subPath?: string(name='SubPath'),
        }
      ](name='VolumeMount'),
      port?: [
        {
          protocol: string(name='Protocol'),
          port: integer(name='Port'),
        }
      ](name='Port'),
      environmentVar?: [
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
          fieldRef?: {
            fieldPath?: string(name='FieldPath'),
          }(name='FieldRef'),
        }
      ](name='EnvironmentVar'),
      readinessProbe?: {
        httpGet: {
          path?: string(name='Path'),
          port?: integer(name='Port'),
          scheme?: string(name='Scheme'),
        }(name='HttpGet'),
        initialDelaySeconds?: integer(name='InitialDelaySeconds'),
        periodSeconds?: integer(name='PeriodSeconds'),
        successThreshold?: integer(name='SuccessThreshold'),
        failureThreshold?: integer(name='FailureThreshold'),
        timeoutSeconds?: integer(name='TimeoutSeconds'),
        exec: {
          command: [ string ](name='Command'),
        }(name='Exec'),
        tcpSocket: {
          port?: integer(name='Port'),
        }(name='TcpSocket'),
      }(name='ReadinessProbe'),
      livenessProbe?: {
        httpGet: {
          path?: string(name='Path'),
          port?: integer(name='Port'),
          scheme?: string(name='Scheme'),
        }(name='HttpGet'),
        initialDelaySeconds?: integer(name='InitialDelaySeconds'),
        periodSeconds?: integer(name='PeriodSeconds'),
        successThreshold?: integer(name='SuccessThreshold'),
        failureThreshold?: integer(name='FailureThreshold'),
        timeoutSeconds?: integer(name='TimeoutSeconds'),
        exec: {
          command: [ string ](name='Command'),
        }(name='Exec'),
        tcpSocket: {
          port?: integer(name='Port'),
        }(name='TcpSocket'),
      }(name='LivenessProbe'),
      securityContext?: {
        capability: {
          add: [ string ](name='Add'),
        }(name='Capability'),
        readOnlyRootFilesystem?: boolean(name='ReadOnlyRootFilesystem'),
        runAsUser?: long(name='RunAsUser'),
      }(name='SecurityContext'),
      stdin?: boolean(name='Stdin'),
      stdinOnce?: boolean(name='StdinOnce'),
      tty?: boolean(name='Tty'),
      gpu?: integer(name='Gpu'),
      lifecyclePostStartHandlerHttpGetHost?: string(name='LifecyclePostStartHandlerHttpGetHost'),
      lifecyclePostStartHandlerHttpGetPort?: integer(name='LifecyclePostStartHandlerHttpGetPort'),
      lifecyclePostStartHandlerHttpGetPath?: string(name='LifecyclePostStartHandlerHttpGetPath'),
      lifecyclePostStartHandlerHttpGetScheme?: string(name='LifecyclePostStartHandlerHttpGetScheme'),
      lifecyclePostStartHandlerHttpGetHttpHeader?: [
        {
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='LifecyclePostStartHandlerHttpGetHttpHeader'),
      lifecyclePostStartHandlerExec?: [ string ](name='LifecyclePostStartHandlerExec'),
      lifecyclePostStartHandlerTcpSocketHost?: string(name='LifecyclePostStartHandlerTcpSocketHost'),
      lifecyclePostStartHandlerTcpSocketPort?: integer(name='LifecyclePostStartHandlerTcpSocketPort'),
      lifecyclePreStopHandlerHttpGetHost?: string(name='LifecyclePreStopHandlerHttpGetHost'),
      lifecyclePreStopHandlerHttpGetPort?: integer(name='LifecyclePreStopHandlerHttpGetPort'),
      lifecyclePreStopHandlerHttpGetPath?: string(name='LifecyclePreStopHandlerHttpGetPath'),
      lifecyclePreStopHandlerHttpGetScheme?: string(name='LifecyclePreStopHandlerHttpGetScheme'),
      lifecyclePreStopHandlerHttpGetHttpHeader?: [
        {
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='LifecyclePreStopHandlerHttpGetHttpHeader'),
      lifecyclePreStopHandlerExec?: [ string ](name='LifecyclePreStopHandlerExec'),
      lifecyclePreStopHandlerTcpSocketHost?: string(name='LifecyclePreStopHandlerTcpSocketHost'),
      lifecyclePreStopHandlerTcpSocketPort?: integer(name='LifecyclePreStopHandlerTcpSocketPort'),
      terminationMessagePath?: string(name='TerminationMessagePath'),
      terminationMessagePolicy?: string(name='TerminationMessagePolicy'),
    }
  ](name='Container'),
  volume?: [
    {
      name?: string(name='Name'),
      NFSVolume?: {
        server?: string(name='Server'),
        path?: string(name='Path'),
        readOnly?: boolean(name='ReadOnly'),
      }(name='NFSVolume'),
      configFileVolume?: {
        configFileToPath: [
          {
            content?: string(name='Content'),
            path?: string(name='Path'),
            mode?: integer(name='Mode'),
          }
        ](name='ConfigFileToPath'),
        defaultMode?: integer(name='DefaultMode'),
      }(name='ConfigFileVolume'),
      type?: string(name='Type'),
      emptyDirVolume?: {
        medium?: string(name='Medium'),
      }(name='EmptyDirVolume'),
      diskVolume?: {
        diskId?: string(name='DiskId'),
        fsType?: string(name='FsType'),
        diskSize?: integer(name='DiskSize'),
      }(name='DiskVolume'),
      flexVolume?: {
        driver?: string(name='Driver'),
        fsType?: string(name='FsType'),
        options?: string(name='Options'),
      }(name='FlexVolume'),
      hostPathVolume?: {
        type?: string(name='Type'),
        path?: string(name='Path'),
      }(name='HostPathVolume'),
    }
  ](name='Volume'),
  eipInstanceId?: string(name='EipInstanceId'),
  initContainer?: [
    {
      name?: string(name='Name'),
      image?: string(name='Image'),
      cpu?: float(name='Cpu'),
      memory?: float(name='Memory'),
      workingDir?: string(name='WorkingDir'),
      imagePullPolicy?: string(name='ImagePullPolicy'),
      command: [ string ](name='Command'),
      arg: [ string ](name='Arg'),
      volumeMount: [
        {
          mountPath?: string(name='MountPath'),
          readOnly?: boolean(name='ReadOnly'),
          name?: string(name='Name'),
          subPath?: string(name='SubPath'),
        }
      ](name='VolumeMount'),
      port: [
        {
          protocol?: string(name='Protocol'),
          port?: integer(name='Port'),
        }
      ](name='Port'),
      environmentVar: [
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
          fieldRef?: {
            fieldPath?: string(name='FieldPath'),
          }(name='FieldRef'),
        }
      ](name='EnvironmentVar'),
      securityContext?: {
        capability: {
          add: [ string ](name='Add'),
        }(name='Capability'),
        readOnlyRootFilesystem?: boolean(name='ReadOnlyRootFilesystem'),
        runAsUser?: long(name='RunAsUser'),
      }(name='SecurityContext'),
      gpu?: integer(name='Gpu'),
      terminationMessagePath?: string(name='TerminationMessagePath'),
      terminationMessagePolicy?: string(name='TerminationMessagePolicy'),
    }
  ](name='InitContainer'),
  dnsConfig?: {
    nameServer?: [ string ](name='NameServer'),
    search?: [ string ](name='Search'),
    option?: [
      {
        name?: string(name='Name'),
        value?: string(name='Value'),
      }
    ](name='Option'),
  }(name='DnsConfig'),
  cpu?: float(name='Cpu'),
  memory?: float(name='Memory'),
  resourceGroupId?: string(name='ResourceGroupId'),
  dnsPolicy?: string(name='DnsPolicy'),
  clientToken?: string(name='ClientToken'),
  hostAliase?: [
    {
      ip?: string(name='Ip'),
      hostname: [ string ](name='Hostname'),
    }
  ](name='HostAliase'),
  arn?: [
    {
      roleArn?: string(name='RoleArn'),
      roleType?: string(name='RoleType'),
      assumeRoleFor?: string(name='AssumeRoleFor'),
    }
  ](name='Arn'),
  instanceType?: string(name='InstanceType'),
  securityContext?: {
    sysctl?: [
      {
        name?: string(name='Name'),
        value?: string(name='Value'),
      }
    ](name='Sysctl'),
  }(name='SecurityContext'),
  slsEnable?: boolean(name='SlsEnable'),
  imageSnapshotId?: string(name='ImageSnapshotId'),
  ramRoleName?: string(name='RamRoleName'),
  ntpServer?: [ string ](name='NtpServer'),
  terminationGracePeriodSeconds?: long(name='TerminationGracePeriodSeconds'),
  autoMatchImageCache?: boolean(name='AutoMatchImageCache'),
  ipv6AddressCount?: integer(name='Ipv6AddressCount'),
  activeDeadlineSeconds?: long(name='ActiveDeadlineSeconds'),
  spotStrategy?: string(name='SpotStrategy'),
  spotPriceLimit?: float(name='SpotPriceLimit'),
  scheduleStrategy?: string(name='ScheduleStrategy'),
  tenantVSwitchId?: string(name='TenantVSwitchId'),
  tenantSecurityGroupId?: string(name='TenantSecurityGroupId'),
  corePattern?: string(name='CorePattern'),
  shareProcessNamespace?: boolean(name='ShareProcessNamespace'),
}

model CreateContainerGroupResponse = {
  requestId: string(name='RequestId'),
  containerGroupId: string(name='ContainerGroupId'),
}

async function createContainerGroupWithOptions(request: CreateContainerGroupRequest, runtime: Util.RuntimeOptions): CreateContainerGroupResponse {
  Util.validateModel(request);
  return doRequest('CreateContainerGroup', 'HTTPS', 'POST', '2018-08-08', 'AK', null, request, runtime);
}

async function createContainerGroup(request: CreateContainerGroupRequest): CreateContainerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createContainerGroupWithOptions(request, runtime);
}

model DescribeContainerGroupsRequest = {
  regionId: string(name='RegionId'),
  zoneId?: string(name='ZoneId'),
  vSwitchId?: string(name='VSwitchId'),
  nextToken?: string(name='NextToken'),
  limit?: integer(name='Limit'),
  tag?: [
    {
      key: string(name='Key'),
      value: string(name='Value'),
    }
  ](name='Tag'),
  containerGroupIds?: string(name='ContainerGroupIds'),
  containerGroupName?: string(name='ContainerGroupName'),
  status?: string(name='Status'),
  resourceGroupId?: string(name='ResourceGroupId'),
  withEvent?: boolean(name='WithEvent'),
}

model DescribeContainerGroupsResponse = {
  requestId: string(name='RequestId'),
  nextToken: string(name='NextToken'),
  totalCount: integer(name='TotalCount'),
  containerGroups: [
    {
      containerGroupId: string(name='ContainerGroupId'),
      containerGroupName: string(name='ContainerGroupName'),
      regionId: string(name='RegionId'),
      zoneId: string(name='ZoneId'),
      memory: float(name='Memory'),
      cpu: float(name='Cpu'),
      vSwitchId: string(name='VSwitchId'),
      securityGroupId: string(name='SecurityGroupId'),
      restartPolicy: string(name='RestartPolicy'),
      intranetIp: string(name='IntranetIp'),
      status: string(name='Status'),
      internetIp: string(name='InternetIp'),
      creationTime: string(name='CreationTime'),
      succeededTime: string(name='SucceededTime'),
      eniInstanceId: string(name='EniInstanceId'),
      instanceType: string(name='InstanceType'),
      expiredTime: string(name='ExpiredTime'),
      failedTime: string(name='FailedTime'),
      ramRoleName: string(name='RamRoleName'),
      ipv6Address: string(name='Ipv6Address'),
      vpcId: string(name='VpcId'),
      discount: integer(name='Discount'),
      resourceGroupId: string(name='ResourceGroupId'),
      tenantEniInstanceId: string(name='TenantEniInstanceId'),
      tenantVSwitchId: string(name='TenantVSwitchId'),
      tenantSecurityGroupId: string(name='TenantSecurityGroupId'),
      spotStrategy: string(name='SpotStrategy'),
      tags: [
        {
          key: string(name='Key'),
          value: string(name='Value'),
        }
      ](name='Tags'),
      events: [
        {
          count: integer(name='Count'),
          type: string(name='Type'),
          name: string(name='Name'),
          message: string(name='Message'),
          firstTimestamp: string(name='FirstTimestamp'),
          lastTimestamp: string(name='LastTimestamp'),
          reason: string(name='Reason'),
        }
      ](name='Events'),
      containers: [
        {
          name: string(name='Name'),
          image: string(name='Image'),
          memory: float(name='Memory'),
          cpu: float(name='Cpu'),
          restartCount: integer(name='RestartCount'),
          workingDir: string(name='WorkingDir'),
          imagePullPolicy: string(name='ImagePullPolicy'),
          ready: boolean(name='Ready'),
          gpu: integer(name='Gpu'),
          stdin: boolean(name='Stdin'),
          stdinOnce: boolean(name='StdinOnce'),
          tty: boolean(name='Tty'),
          volumeMounts: [
            {
              name: string(name='Name'),
              mountPath: string(name='MountPath'),
              readOnly: boolean(name='ReadOnly'),
            }
          ](name='VolumeMounts'),
          ports: [
            {
              port: integer(name='Port'),
              protocol: string(name='Protocol'),
            }
          ](name='Ports'),
          environmentVars: [
            {
              key: string(name='Key'),
              value: string(name='Value'),
              valueFrom: {
                fieldRef: {
                  fieldPath: string(name='FieldPath'),
                }(name='FieldRef'),
              }(name='ValueFrom'),
            }
          ](name='EnvironmentVars'),
          previousState: {
            state: string(name='State'),
            detailStatus: string(name='DetailStatus'),
            exitCode: integer(name='ExitCode'),
            startTime: string(name='StartTime'),
            finishTime: string(name='FinishTime'),
            reason: string(name='Reason'),
            message: string(name='Message'),
            signal: integer(name='Signal'),
          }(name='PreviousState'),
          currentState: {
            state: string(name='State'),
            detailStatus: string(name='DetailStatus'),
            exitCode: integer(name='ExitCode'),
            startTime: string(name='StartTime'),
            finishTime: string(name='FinishTime'),
            reason: string(name='Reason'),
            message: string(name='Message'),
            signal: integer(name='Signal'),
          }(name='CurrentState'),
          readinessProbe: {
            initialDelaySeconds: integer(name='InitialDelaySeconds'),
            periodSeconds: integer(name='PeriodSeconds'),
            timeoutSeconds: integer(name='TimeoutSeconds'),
            successThreshold: integer(name='SuccessThreshold'),
            failureThreshold: integer(name='FailureThreshold'),
            httpGet: {
              path: string(name='Path'),
              port: integer(name='Port'),
              scheme: string(name='Scheme'),
            }(name='HttpGet'),
            tcpSocket: {
              host: string(name='Host'),
              port: integer(name='Port'),
            }(name='TcpSocket'),
            execs: [ string ](name='Execs'),
          }(name='ReadinessProbe'),
          livenessProbe: {
            initialDelaySeconds: integer(name='InitialDelaySeconds'),
            periodSeconds: integer(name='PeriodSeconds'),
            timeoutSeconds: integer(name='TimeoutSeconds'),
            successThreshold: integer(name='SuccessThreshold'),
            failureThreshold: integer(name='FailureThreshold'),
            httpGet: {
              path: string(name='Path'),
              port: integer(name='Port'),
              scheme: string(name='Scheme'),
            }(name='HttpGet'),
            tcpSocket: {
              host: string(name='Host'),
              port: integer(name='Port'),
            }(name='TcpSocket'),
            execs: [ string ](name='Execs'),
          }(name='LivenessProbe'),
          securityContext: {
            readOnlyRootFilesystem: boolean(name='ReadOnlyRootFilesystem'),
            runAsUser: long(name='RunAsUser'),
            capability: {
              adds: [ string ](name='Adds'),
            }(name='Capability'),
          }(name='SecurityContext'),
          commands: [ string ](name='Commands'),
          args: [ string ](name='Args'),
        }
      ](name='Containers'),
      volumes: [
        {
          type: string(name='Type'),
          name: string(name='Name'),
          NFSVolumePath: string(name='NFSVolumePath'),
          NFSVolumeServer: string(name='NFSVolumeServer'),
          NFSVolumeReadOnly: boolean(name='NFSVolumeReadOnly'),
          diskVolumeDiskId: string(name='DiskVolumeDiskId'),
          diskVolumeFsType: string(name='DiskVolumeFsType'),
          flexVolumeDriver: string(name='FlexVolumeDriver'),
          flexVolumeFsType: string(name='FlexVolumeFsType'),
          flexVolumeOptions: string(name='FlexVolumeOptions'),
          configFileVolumeConfigFileToPaths: [
            {
              content: string(name='Content'),
              path: string(name='Path'),
            }
          ](name='ConfigFileVolumeConfigFileToPaths'),
        }
      ](name='Volumes'),
      initContainers: [
        {
          name: string(name='Name'),
          image: string(name='Image'),
          cpu: float(name='Cpu'),
          memory: float(name='Memory'),
          restartCount: integer(name='RestartCount'),
          workingDir: string(name='WorkingDir'),
          imagePullPolicy: string(name='ImagePullPolicy'),
          ready: boolean(name='Ready'),
          gpu: integer(name='Gpu'),
          volumeMounts: [
            {
              name: string(name='Name'),
              mountPath: string(name='MountPath'),
              readOnly: boolean(name='ReadOnly'),
            }
          ](name='VolumeMounts'),
          ports: [
            {
              port: integer(name='Port'),
              protocol: string(name='Protocol'),
            }
          ](name='Ports'),
          environmentVars: [
            {
              key: string(name='Key'),
              value: string(name='Value'),
              valueFrom: {
                fieldRef: {
                  fieldPath: string(name='FieldPath'),
                }(name='FieldRef'),
              }(name='ValueFrom'),
            }
          ](name='EnvironmentVars'),
          previousState: {
            state: string(name='State'),
            detailStatus: string(name='DetailStatus'),
            exitCode: integer(name='ExitCode'),
            startTime: string(name='StartTime'),
            finishTime: string(name='FinishTime'),
            reason: string(name='Reason'),
            message: string(name='Message'),
            signal: integer(name='Signal'),
          }(name='PreviousState'),
          currentState: {
            state: string(name='State'),
            detailStatus: string(name='DetailStatus'),
            exitCode: integer(name='ExitCode'),
            startTime: string(name='StartTime'),
            finishTime: string(name='FinishTime'),
            reason: string(name='Reason'),
            message: string(name='Message'),
            signal: integer(name='Signal'),
          }(name='CurrentState'),
          securityContext: {
            readOnlyRootFilesystem: boolean(name='ReadOnlyRootFilesystem'),
            runAsUser: long(name='RunAsUser'),
            capability: {
              adds: [ string ](name='Adds'),
            }(name='Capability'),
          }(name='SecurityContext'),
          command: [ string ](name='Command'),
          args: [ string ](name='Args'),
        }
      ](name='InitContainers'),
      hostAliases: [
        {
          ip: string(name='Ip'),
          hostnames: [ string ](name='Hostnames'),
        }
      ](name='HostAliases'),
      dnsConfig: {
        options: [
          {
            name: string(name='Name'),
            value: string(name='Value'),
          }
        ](name='Options'),
        nameServers: [ string ](name='NameServers'),
        searches: [ string ](name='Searches'),
      }(name='DnsConfig'),
      eciSecurityContext: {
        sysctls: [
          {
            name: string(name='Name'),
            value: string(name='Value'),
          }
        ](name='Sysctls'),
      }(name='EciSecurityContext'),
    }
  ](name='ContainerGroups'),
}

async function describeContainerGroupsWithOptions(request: DescribeContainerGroupsRequest, runtime: Util.RuntimeOptions): DescribeContainerGroupsResponse {
  Util.validateModel(request);
  return doRequest('DescribeContainerGroups', 'HTTPS', 'POST', '2018-08-08', 'AK', null, request, runtime);
}

async function describeContainerGroups(request: DescribeContainerGroupsRequest): DescribeContainerGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContainerGroupsWithOptions(request, runtime);
}

model DeleteContainerGroupRequest = {
  regionId: string(name='RegionId'),
  containerGroupId: string(name='ContainerGroupId'),
  clientToken?: string(name='ClientToken'),
}

model DeleteContainerGroupResponse = {
  requestId: string(name='RequestId'),
}

async function deleteContainerGroupWithOptions(request: DeleteContainerGroupRequest, runtime: Util.RuntimeOptions): DeleteContainerGroupResponse {
  Util.validateModel(request);
  return doRequest('DeleteContainerGroup', 'HTTPS', 'POST', '2018-08-08', 'AK', null, request, runtime);
}

async function deleteContainerGroup(request: DeleteContainerGroupRequest): DeleteContainerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteContainerGroupWithOptions(request, runtime);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
