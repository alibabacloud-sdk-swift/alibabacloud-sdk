import Util;
import ROA;

import EndpointUtil;

extends ROA;

const version = '2019-05-06';

init(config: ROA.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpointHost = getEndpoint('sae', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpointHost);
}


model RestartInstancesQuery = {
  appId: string(name='AppId'),
  instanceIds: string(name='InstanceIds'),
}

model RestartInstancesRequest = {
  headers?: map[string]string(name='headers'),
  query: RestartInstancesQuery(name='query'),
}

model RestartInstancesResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  message: string(name='Message'),
  traceId: string(name='TraceId'),
  data: {
    changeOrderId: string(name='ChangeOrderId'),
  }(name='Data'),
}

model RestartInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: RestartInstancesResponseBody(name='body'),
}

async function restartInstancesWithOptions(request: RestartInstancesRequest, runtime: Util.RuntimeOptions): RestartInstancesResponse {
  Util.validateModel(request);
  return doRequestWithAction('RestartInstances', '2019-05-06', 'HTTPS', 'PUT', 'AK', `/pop/v1/sam/app/restartInstances`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function restartInstances(request: RestartInstancesRequest): RestartInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return restartInstancesWithOptions(request, runtime);
}

model UpdateAppSecurityGroupQuery = {
  appId: string(name='AppId'),
  securityGroupId: string(name='SecurityGroupId'),
}

model UpdateAppSecurityGroupRequest = {
  headers?: map[string]string(name='headers'),
  query: UpdateAppSecurityGroupQuery(name='query'),
}

model UpdateAppSecurityGroupResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
  errorCode: string(name='ErrorCode'),
  traceId: string(name='TraceId'),
  success: boolean(name='Success'),
}

model UpdateAppSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAppSecurityGroupResponseBody(name='body'),
}

async function updateAppSecurityGroupWithOptions(request: UpdateAppSecurityGroupRequest, runtime: Util.RuntimeOptions): UpdateAppSecurityGroupResponse {
  Util.validateModel(request);
  return doRequestWithAction('UpdateAppSecurityGroup', '2019-05-06', 'HTTPS', 'PUT', 'AK', `/pop/v1/sam/app/updateAppSecurityGroup`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function updateAppSecurityGroup(request: UpdateAppSecurityGroupRequest): UpdateAppSecurityGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAppSecurityGroupWithOptions(request, runtime);
}

model DescribeConfigMapQuery = {
  configMapId: long(name='ConfigMapId'),
}

model DescribeConfigMapRequest = {
  headers?: map[string]string(name='headers'),
  query: DescribeConfigMapQuery(name='query'),
}

model DescribeConfigMapResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
  errorCode: string(name='ErrorCode'),
  traceId: string(name='TraceId'),
  success: boolean(name='Success'),
  data: {
    configMapId: long(name='ConfigMapId'),
    name: string(name='Name'),
    namespaceId: string(name='NamespaceId'),
    description: string(name='Description'),
    data: map[string]any(name='Data'),
    createTime: long(name='CreateTime'),
    updateTime: long(name='UpdateTime'),
    relateApps: [
      {
        appId: string(name='AppId'),
        appName: string(name='AppName'),
      }
    ](name='RelateApps'),
  }(name='Data'),
}

model DescribeConfigMapResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeConfigMapResponseBody(name='body'),
}

async function describeConfigMapWithOptions(request: DescribeConfigMapRequest, runtime: Util.RuntimeOptions): DescribeConfigMapResponse {
  Util.validateModel(request);
  return doRequestWithAction('DescribeConfigMap', '2019-05-06', 'HTTPS', 'GET', 'AK', `/pop/v1/sam/configmap/configMap`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function describeConfigMap(request: DescribeConfigMapRequest): DescribeConfigMapResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeConfigMapWithOptions(request, runtime);
}

model UpdateConfigMapQuery = {
  configMapId: long(name='ConfigMapId'),
}

model UpdateConfigMapBody = {
  data: string(name='Data'),
  description?: string(name='Description'),
}

model UpdateConfigMapRequest = {
  headers?: map[string]string(name='headers'),
  query: UpdateConfigMapQuery(name='query'),
  body: UpdateConfigMapBody(name='body'),
}

model UpdateConfigMapResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
  errorCode: string(name='ErrorCode'),
  traceId: string(name='TraceId'),
  success: boolean(name='Success'),
  data: {
    configMapId: string(name='ConfigMapId'),
  }(name='Data'),
}

model UpdateConfigMapResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateConfigMapResponseBody(name='body'),
}

async function updateConfigMapWithOptions(request: UpdateConfigMapRequest, runtime: Util.RuntimeOptions): UpdateConfigMapResponse {
  Util.validateModel(request);
  return doRequestWithAction('UpdateConfigMap', '2019-05-06', 'HTTPS', 'PUT', 'AK', `/pop/v1/sam/configmap/configMap`, Util.stringifyMapValue(request.query), request.headers, request.body, runtime);
}

async function updateConfigMap(request: UpdateConfigMapRequest): UpdateConfigMapResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateConfigMapWithOptions(request, runtime);
}

model CreateConfigMapQuery = {
  name: string(name='Name'),
  namespaceId: string(name='NamespaceId'),
  description?: string(name='Description'),
}

model CreateConfigMapBody = {
  data: string(name='Data'),
}

model CreateConfigMapRequest = {
  headers?: map[string]string(name='headers'),
  query: CreateConfigMapQuery(name='query'),
  body: CreateConfigMapBody(name='body'),
}

model CreateConfigMapResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
  errorCode: string(name='ErrorCode'),
  traceId: string(name='TraceId'),
  success: boolean(name='Success'),
  data: {
    configMapId: long(name='ConfigMapId'),
  }(name='Data'),
}

model CreateConfigMapResponse = {
  headers: map[string]string(name='headers'),
  body: CreateConfigMapResponseBody(name='body'),
}

async function createConfigMapWithOptions(request: CreateConfigMapRequest, runtime: Util.RuntimeOptions): CreateConfigMapResponse {
  Util.validateModel(request);
  return doRequestWithAction('CreateConfigMap', '2019-05-06', 'HTTPS', 'POST', 'AK', `/pop/v1/sam/configmap/configMap`, Util.stringifyMapValue(request.query), request.headers, request.body, runtime);
}

async function createConfigMap(request: CreateConfigMapRequest): CreateConfigMapResponse {
  var runtime = new Util.RuntimeOptions{};
  return createConfigMapWithOptions(request, runtime);
}

model ListNamespacedConfigMapsQuery = {
  namespaceId: string(name='NamespaceId'),
}

model ListNamespacedConfigMapsRequest = {
  headers?: map[string]string(name='headers'),
  query: ListNamespacedConfigMapsQuery(name='query'),
}

model ListNamespacedConfigMapsResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
  errorCode: string(name='ErrorCode'),
  traceId: string(name='TraceId'),
  success: boolean(name='Success'),
  data: {
    configMaps: [
      {
        configMapId: long(name='ConfigMapId'),
        name: string(name='Name'),
        namespaceId: string(name='NamespaceId'),
        description: string(name='Description'),
        data: map[string]any(name='Data'),
        createTime: long(name='CreateTime'),
        updateTime: long(name='UpdateTime'),
        relateApps: [
          {
            appId: string(name='AppId'),
            appName: string(name='AppName'),
          }
        ](name='RelateApps'),
      }
    ](name='ConfigMaps'),
  }(name='Data'),
}

model ListNamespacedConfigMapsResponse = {
  headers: map[string]string(name='headers'),
  body: ListNamespacedConfigMapsResponseBody(name='body'),
}

async function listNamespacedConfigMapsWithOptions(request: ListNamespacedConfigMapsRequest, runtime: Util.RuntimeOptions): ListNamespacedConfigMapsResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListNamespacedConfigMaps', '2019-05-06', 'HTTPS', 'GET', 'AK', `/pop/v1/sam/configmap/listNamespacedConfigMaps`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function listNamespacedConfigMaps(request: ListNamespacedConfigMapsRequest): ListNamespacedConfigMapsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNamespacedConfigMapsWithOptions(request, runtime);
}

model DeleteConfigMapQuery = {
  configMapId: long(name='ConfigMapId'),
}

model DeleteConfigMapRequest = {
  headers?: map[string]string(name='headers'),
  query: DeleteConfigMapQuery(name='query'),
}

model DeleteConfigMapResponseBody = {
  requestId: string(name='RequestId'),
  message: string(name='Message'),
  code: string(name='Code'),
  errorCode: string(name='ErrorCode'),
  traceId: string(name='TraceId'),
  success: boolean(name='Success'),
  data: {
    configMapId: long(name='ConfigMapId'),
  }(name='Data'),
}

model DeleteConfigMapResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteConfigMapResponseBody(name='body'),
}

async function deleteConfigMapWithOptions(request: DeleteConfigMapRequest, runtime: Util.RuntimeOptions): DeleteConfigMapResponse {
  Util.validateModel(request);
  return doRequestWithAction('DeleteConfigMap', '2019-05-06', 'HTTPS', 'DELETE', 'AK', `/pop/v1/sam/configmap/configMap`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function deleteConfigMap(request: DeleteConfigMapRequest): DeleteConfigMapResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteConfigMapWithOptions(request, runtime);
}

model ListAppVersionsQuery = {
  appId: string(name='AppId'),
}

model ListAppVersionsRequest = {
  headers?: map[string]string(name='headers'),
  query: ListAppVersionsQuery(name='query'),
}

model ListAppVersionsResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  data: [
    {
      id: string(name='Id'),
      createTime: string(name='CreateTime'),
      warUrl: string(name='WarUrl'),
      type: string(name='Type'),
      buildPackageUrl: string(name='BuildPackageUrl'),
    }
  ](name='Data'),
}

model ListAppVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListAppVersionsResponseBody(name='body'),
}

async function listAppVersionsWithOptions(request: ListAppVersionsRequest, runtime: Util.RuntimeOptions): ListAppVersionsResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListAppVersions', '2019-05-06', 'HTTPS', 'GET', 'AK', `/pop/v1/sam/app/listAppVersions`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function listAppVersions(request: ListAppVersionsRequest): ListAppVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAppVersionsWithOptions(request, runtime);
}

model RollbackApplicationQuery = {
  appId: string(name='AppId'),
  versionId: string(name='VersionId'),
  batchWaitTime?: integer(name='BatchWaitTime'),
  minReadyInstances?: integer(name='MinReadyInstances'),
  updateStrategy?: string(name='UpdateStrategy'),
}

model RollbackApplicationRequest = {
  headers?: map[string]string(name='headers'),
  query: RollbackApplicationQuery(name='query'),
}

model RollbackApplicationResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  message: string(name='Message'),
  traceId: string(name='TraceId'),
  data: {
    changeOrderId: string(name='ChangeOrderId'),
  }(name='Data'),
}

model RollbackApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: RollbackApplicationResponseBody(name='body'),
}

async function rollbackApplicationWithOptions(request: RollbackApplicationRequest, runtime: Util.RuntimeOptions): RollbackApplicationResponse {
  Util.validateModel(request);
  return doRequestWithAction('RollbackApplication', '2019-05-06', 'HTTPS', 'PUT', 'AK', `/pop/v1/sam/app/rollbackApplication`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function rollbackApplication(request: RollbackApplicationRequest): RollbackApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return rollbackApplicationWithOptions(request, runtime);
}

model UntagResourcesQuery = {
  regionId: string(name='RegionId'),
  resourceType: string(name='ResourceType'),
  resourceIds: string(name='ResourceIds'),
  tagKeys?: string(name='TagKeys'),
  deleteAll?: boolean(name='DeleteAll'),
}

model UntagResourcesRequest = {
  headers?: map[string]string(name='headers'),
  query: UntagResourcesQuery(name='query'),
}

model UntagResourcesResponseBody = {
  code: string(name='Code'),
  data: boolean(name='Data'),
  errorCode: string(name='ErrorCode'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  traceId: string(name='TraceId'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  return doRequestWithAction('UntagResources', '2019-05-06', 'HTTPS', 'DELETE', 'AK', `/tags`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model TagResourcesBody = {
  regionId: string(name='RegionId'),
  resourceType: string(name='ResourceType'),
  tags: string(name='Tags'),
  resourceIds: string(name='ResourceIds'),
}

model TagResourcesRequest = {
  headers?: map[string]string(name='headers'),
  body: TagResourcesBody(name='body'),
}

model TagResourcesResponseBody = {
  code: string(name='Code'),
  data: boolean(name='Data'),
  errorCode: string(name='ErrorCode'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  traceId: string(name='TraceId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  return doRequestWithAction('TagResources', '2019-05-06', 'HTTPS', 'POST', 'AK', `/tags`, null, request.headers, request.body, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model ListTagResourcesQuery = {
  regionId: string(name='RegionId'),
  resourceType: string(name='ResourceType'),
  nextToken?: string(name='NextToken'),
  resourceIds?: string(name='ResourceIds'),
  tags?: string(name='Tags'),
}

model ListTagResourcesRequest = {
  headers?: map[string]string(name='headers'),
  query: ListTagResourcesQuery(name='query'),
}

model ListTagResourcesResponseBody = {
  code: string(name='Code'),
  errorCode: string(name='ErrorCode'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  traceId: string(name='TraceId'),
  data: {
    nextToken: string(name='NextToken'),
    tagResources: [
      {
        tagKey: string(name='TagKey'),
        tagValue: string(name='TagValue'),
        resourceId: string(name='ResourceId'),
        resourceType: string(name='ResourceType'),
      }
    ](name='TagResources'),
  }(name='Data'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListTagResources', '2019-05-06', 'HTTPS', 'GET', 'AK', `/tags`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model DescribeIngressQuery = {
  ingressId: long(name='IngressId'),
}

model DescribeIngressRequest = {
  headers?: map[string]string(name='headers'),
  query: DescribeIngressQuery(name='query'),
}

model DescribeIngressResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  traceId: string(name='TraceId'),
  data: {
    id: long(name='Id'),
    name: string(name='Name'),
    namespaceId: string(name='NamespaceId'),
    description: string(name='Description'),
    slbId: string(name='SlbId'),
    listenerPort: integer(name='ListenerPort'),
    certId: string(name='CertId'),
    slbType: string(name='SlbType'),
    rules: [
      {
        appId: string(name='AppId'),
        containerPort: integer(name='ContainerPort'),
        domain: string(name='Domain'),
        path: string(name='Path'),
        appName: string(name='AppName'),
      }
    ](name='Rules'),
    defaultRule: {
      appId: string(name='AppId'),
      containerPort: integer(name='ContainerPort'),
      appName: string(name='AppName'),
    }(name='DefaultRule'),
  }(name='Data'),
}

model DescribeIngressResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIngressResponseBody(name='body'),
}

async function describeIngressWithOptions(request: DescribeIngressRequest, runtime: Util.RuntimeOptions): DescribeIngressResponse {
  Util.validateModel(request);
  return doRequestWithAction('DescribeIngress', '2019-05-06', 'HTTPS', 'GET', 'AK', `/pop/v1/sam/ingress/Ingress`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function describeIngress(request: DescribeIngressRequest): DescribeIngressResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIngressWithOptions(request, runtime);
}

model ListIngressesQuery = {
  namespaceId: string(name='NamespaceId'),
  appId?: string(name='AppId'),
}

model ListIngressesRequest = {
  headers?: map[string]string(name='headers'),
  query: ListIngressesQuery(name='query'),
}

model ListIngressesResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  traceId: string(name='TraceId'),
  data: {
    ingressList: [
      {
        id: long(name='Id'),
        name: string(name='Name'),
        namespaceId: string(name='NamespaceId'),
        slbId: string(name='SlbId'),
        listenerPort: string(name='ListenerPort'),
        certId: string(name='CertId'),
        description: string(name='Description'),
        slbType: string(name='SlbType'),
      }
    ](name='IngressList'),
  }(name='Data'),
}

model ListIngressesResponse = {
  headers: map[string]string(name='headers'),
  body: ListIngressesResponseBody(name='body'),
}

async function listIngressesWithOptions(request: ListIngressesRequest, runtime: Util.RuntimeOptions): ListIngressesResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListIngresses', '2019-05-06', 'HTTPS', 'GET', 'AK', `/pop/v1/sam/ingress/IngressList`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function listIngresses(request: ListIngressesRequest): ListIngressesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listIngressesWithOptions(request, runtime);
}

model UpdateIngressQuery = {
  ingressId: long(name='IngressId'),
  certId?: string(name='CertId'),
  description?: string(name='Description'),
  listenerPort?: string(name='ListenerPort'),
  defaultRule?: string(name='DefaultRule'),
}

model UpdateIngressBody = {
  rules?: string(name='Rules'),
}

model UpdateIngressRequest = {
  headers?: map[string]string(name='headers'),
  query: UpdateIngressQuery(name='query'),
  body?: UpdateIngressBody(name='body'),
}

model UpdateIngressResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  traceId: string(name='TraceId'),
  data: {
    ingressId: long(name='IngressId'),
  }(name='Data'),
}

model UpdateIngressResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateIngressResponseBody(name='body'),
}

async function updateIngressWithOptions(request: UpdateIngressRequest, runtime: Util.RuntimeOptions): UpdateIngressResponse {
  Util.validateModel(request);
  return doRequestWithAction('UpdateIngress', '2019-05-06', 'HTTPS', 'PUT', 'AK', `/pop/v1/sam/ingress/Ingress`, Util.stringifyMapValue(request.query), request.headers, request.body, runtime);
}

async function updateIngress(request: UpdateIngressRequest): UpdateIngressResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateIngressWithOptions(request, runtime);
}

model DeleteIngressQuery = {
  ingressId?: long(name='IngressId'),
}

model DeleteIngressRequest = {
  headers?: map[string]string(name='headers'),
  query?: DeleteIngressQuery(name='query'),
}

model DeleteIngressResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  traceId: string(name='TraceId'),
  data: {
    ingressId: long(name='IngressId'),
  }(name='Data'),
}

model DeleteIngressResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIngressResponseBody(name='body'),
}

async function deleteIngressWithOptions(request: DeleteIngressRequest, runtime: Util.RuntimeOptions): DeleteIngressResponse {
  Util.validateModel(request);
  return doRequestWithAction('DeleteIngress', '2019-05-06', 'HTTPS', 'DELETE', 'AK', `/pop/v1/sam/ingress/Ingress`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function deleteIngress(request: DeleteIngressRequest): DeleteIngressResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIngressWithOptions(request, runtime);
}

model CreateIngressQuery = {
  namespaceId: string(name='NamespaceId'),
  description?: string(name='Description'),
  slbId: string(name='SlbId'),
  listenerPort: integer(name='ListenerPort'),
  certId?: string(name='CertId'),
  defaultRule?: string(name='DefaultRule'),
}

model CreateIngressBody = {
  rules: string(name='Rules'),
}

model CreateIngressRequest = {
  headers?: map[string]string(name='headers'),
  query: CreateIngressQuery(name='query'),
  body: CreateIngressBody(name='body'),
}

model CreateIngressResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  traceId: string(name='TraceId'),
  data: {
    ingressId: long(name='IngressId'),
  }(name='Data'),
}

model CreateIngressResponse = {
  headers: map[string]string(name='headers'),
  body: CreateIngressResponseBody(name='body'),
}

async function createIngressWithOptions(request: CreateIngressRequest, runtime: Util.RuntimeOptions): CreateIngressResponse {
  Util.validateModel(request);
  return doRequestWithAction('CreateIngress', '2019-05-06', 'HTTPS', 'POST', 'AK', `/pop/v1/sam/ingress/Ingress`, Util.stringifyMapValue(request.query), request.headers, request.body, runtime);
}

async function createIngress(request: CreateIngressRequest): CreateIngressResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIngressWithOptions(request, runtime);
}

model UpdateNamespaceVpcQuery = {
  namespaceId: string(name='NamespaceId'),
  vpcId: string(name='VpcId'),
}

model UpdateNamespaceVpcRequest = {
  headers?: map[string]string(name='headers'),
  query: UpdateNamespaceVpcQuery(name='query'),
}

model UpdateNamespaceVpcResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
  errorCode: string(name='ErrorCode'),
  traceId: string(name='TraceId'),
  success: boolean(name='Success'),
}

model UpdateNamespaceVpcResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateNamespaceVpcResponseBody(name='body'),
}

async function updateNamespaceVpcWithOptions(request: UpdateNamespaceVpcRequest, runtime: Util.RuntimeOptions): UpdateNamespaceVpcResponse {
  Util.validateModel(request);
  return doRequestWithAction('UpdateNamespaceVpc', '2019-05-06', 'HTTPS', 'POST', 'AK', `/pop/v1/sam/namespace/updateNamespaceVpc`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function updateNamespaceVpc(request: UpdateNamespaceVpcRequest): UpdateNamespaceVpcResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateNamespaceVpcWithOptions(request, runtime);
}

model BatchStopApplicationsQuery = {
  namespaceId: string(name='NamespaceId'),
  appIds?: string(name='AppIds'),
}

model BatchStopApplicationsRequest = {
  headers?: map[string]string(name='headers'),
  query: BatchStopApplicationsQuery(name='query'),
}

model BatchStopApplicationsResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
  errorCode: string(name='ErrorCode'),
  traceId: string(name='TraceId'),
  success: boolean(name='Success'),
  data: {
    changeOrderId: string(name='ChangeOrderId'),
  }(name='Data'),
}

model BatchStopApplicationsResponse = {
  headers: map[string]string(name='headers'),
  body: BatchStopApplicationsResponseBody(name='body'),
}

async function batchStopApplicationsWithOptions(request: BatchStopApplicationsRequest, runtime: Util.RuntimeOptions): BatchStopApplicationsResponse {
  Util.validateModel(request);
  return doRequestWithAction('BatchStopApplications', '2019-05-06', 'HTTPS', 'PUT', 'AK', `/pop/v1/sam/app/batchStopApplications`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function batchStopApplications(request: BatchStopApplicationsRequest): BatchStopApplicationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchStopApplicationsWithOptions(request, runtime);
}

model DescribeNamespaceResourcesQuery = {
  namespaceId: string(name='NamespaceId'),
}

model DescribeNamespaceResourcesRequest = {
  headers?: map[string]string(name='headers'),
  query: DescribeNamespaceResourcesQuery(name='query'),
}

model DescribeNamespaceResourcesResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
  errorCode: string(name='ErrorCode'),
  traceId: string(name='TraceId'),
  success: boolean(name='Success'),
  data: {
    namespaceId: string(name='NamespaceId'),
    namespaceName: string(name='NamespaceName'),
    description: string(name='Description'),
    userId: string(name='UserId'),
    belongRegion: string(name='BelongRegion'),
    tenantId: string(name='TenantId'),
    vpcId: string(name='VpcId'),
    vSwitchId: string(name='VSwitchId'),
    securityGroupId: string(name='SecurityGroupId'),
    appCount: long(name='AppCount'),
    lastChangeOrderId: string(name='LastChangeOrderId'),
    lastChangeOrderStatus: string(name='LastChangeOrderStatus'),
    lastChangeOrderRunning: boolean(name='LastChangeOrderRunning'),
    vpcName: string(name='VpcName'),
    vSwitchName: string(name='VSwitchName'),
    notificationExpired: boolean(name='NotificationExpired'),
  }(name='Data'),
}

model DescribeNamespaceResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNamespaceResourcesResponseBody(name='body'),
}

async function describeNamespaceResourcesWithOptions(request: DescribeNamespaceResourcesRequest, runtime: Util.RuntimeOptions): DescribeNamespaceResourcesResponse {
  Util.validateModel(request);
  return doRequestWithAction('DescribeNamespaceResources', '2019-05-06', 'HTTPS', 'GET', 'AK', `/pop/v1/sam/namespace/describeNamespaceResources`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function describeNamespaceResources(request: DescribeNamespaceResourcesRequest): DescribeNamespaceResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNamespaceResourcesWithOptions(request, runtime);
}

model ListNamespaceChangeOrdersQuery = {
  namespaceId: string(name='NamespaceId'),
  coStatus?: string(name='CoStatus'),
  coType?: string(name='CoType'),
  key?: string(name='Key'),
  currentPage?: integer(name='CurrentPage'),
  pageSize?: integer(name='PageSize'),
}

model ListNamespaceChangeOrdersRequest = {
  headers?: map[string]string(name='headers'),
  query: ListNamespaceChangeOrdersQuery(name='query'),
}

model ListNamespaceChangeOrdersResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
  errorCode: string(name='ErrorCode'),
  traceId: string(name='TraceId'),
  success: boolean(name='Success'),
  data: {
    currentPage: integer(name='CurrentPage'),
    pageSize: integer(name='PageSize'),
    totalSize: integer(name='TotalSize'),
    changeOrderList: [
      {
        namespaceId: string(name='NamespaceId'),
        batchCount: integer(name='BatchCount'),
        batchType: string(name='BatchType'),
        changeOrderId: string(name='ChangeOrderId'),
        coType: string(name='CoType'),
        coTypeCode: string(name='CoTypeCode'),
        createTime: string(name='CreateTime'),
        description: string(name='Description'),
        finishTime: string(name='FinishTime'),
        groupId: string(name='GroupId'),
        pipelines: string(name='Pipelines'),
        source: string(name='Source'),
        status: integer(name='Status'),
        createUserId: string(name='CreateUserId'),
        userId: string(name='UserId'),
      }
    ](name='ChangeOrderList'),
  }(name='Data'),
}

model ListNamespaceChangeOrdersResponse = {
  headers: map[string]string(name='headers'),
  body: ListNamespaceChangeOrdersResponseBody(name='body'),
}

async function listNamespaceChangeOrdersWithOptions(request: ListNamespaceChangeOrdersRequest, runtime: Util.RuntimeOptions): ListNamespaceChangeOrdersResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListNamespaceChangeOrders', '2019-05-06', 'HTTPS', 'GET', 'AK', `/pop/v1/sam/changeorder/listNamespaceChangeOrders`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function listNamespaceChangeOrders(request: ListNamespaceChangeOrdersRequest): ListNamespaceChangeOrdersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNamespaceChangeOrdersWithOptions(request, runtime);
}

model BatchStartApplicationsQuery = {
  namespaceId: string(name='NamespaceId'),
  appIds: string(name='AppIds'),
}

model BatchStartApplicationsRequest = {
  headers?: map[string]string(name='headers'),
  query: BatchStartApplicationsQuery(name='query'),
}

model BatchStartApplicationsResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
  errorCode: string(name='ErrorCode'),
  traceId: string(name='TraceId'),
  success: boolean(name='Success'),
  data: {
    changeOrderId: string(name='ChangeOrderId'),
  }(name='Data'),
}

model BatchStartApplicationsResponse = {
  headers: map[string]string(name='headers'),
  body: BatchStartApplicationsResponseBody(name='body'),
}

async function batchStartApplicationsWithOptions(request: BatchStartApplicationsRequest, runtime: Util.RuntimeOptions): BatchStartApplicationsResponse {
  Util.validateModel(request);
  return doRequestWithAction('BatchStartApplications', '2019-05-06', 'HTTPS', 'PUT', 'AK', `/pop/v1/sam/app/batchStartApplications`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function batchStartApplications(request: BatchStartApplicationsRequest): BatchStartApplicationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchStartApplicationsWithOptions(request, runtime);
}

model ListAppEventsQuery = {
  currentPage: integer(name='CurrentPage'),
  pageSize?: integer(name='PageSize'),
  appId: string(name='AppId'),
  objectKind?: string(name='ObjectKind'),
  objectName?: string(name='ObjectName'),
  eventType?: string(name='EventType'),
  reason?: string(name='Reason'),
  namespace: string(name='Namespace'),
}

model ListAppEventsRequest = {
  headers?: map[string]string(name='headers'),
  query: ListAppEventsQuery(name='query'),
}

model ListAppEventsResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  data: {
    currentPage: integer(name='CurrentPage'),
    pageSize: integer(name='PageSize'),
    totalSize: integer(name='TotalSize'),
    appEventEntity: [
      {
        objectKind: string(name='ObjectKind'),
        objectName: string(name='ObjectName'),
        eventType: string(name='EventType'),
        message: string(name='Message'),
        firstTimestamp: string(name='FirstTimestamp'),
        lastTimestamp: string(name='LastTimestamp'),
        reason: string(name='Reason'),
      }
    ](name='AppEventEntity'),
  }(name='Data'),
}

model ListAppEventsResponse = {
  headers: map[string]string(name='headers'),
  body: ListAppEventsResponseBody(name='body'),
}

async function listAppEventsWithOptions(request: ListAppEventsRequest, runtime: Util.RuntimeOptions): ListAppEventsResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListAppEvents', '2019-05-06', 'HTTPS', 'GET', 'AK', `/pop/v1/sam/app/listAppEvents`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function listAppEvents(request: ListAppEventsRequest): ListAppEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAppEventsWithOptions(request, runtime);
}

model ListLogConfigsQuery = {
  appId: string(name='AppId'),
  pageSize: integer(name='PageSize'),
  currentPage: integer(name='CurrentPage'),
}

model ListLogConfigsRequest = {
  headers?: map[string]string(name='headers'),
  query: ListLogConfigsQuery(name='query'),
}

model ListLogConfigsResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  traceId: string(name='TraceId'),
  data: {
    currentPage: integer(name='CurrentPage'),
    pageSize: integer(name='PageSize'),
    totalSize: integer(name='TotalSize'),
    logConfigs: [
      {
        configName: string(name='ConfigName'),
        logDir: string(name='LogDir'),
        slsProject: string(name='SlsProject'),
        slsLogStore: string(name='SlsLogStore'),
        storeType: string(name='StoreType'),
        logType: string(name='LogType'),
        regionId: string(name='RegionId'),
        createTime: string(name='CreateTime'),
      }
    ](name='LogConfigs'),
  }(name='Data'),
}

model ListLogConfigsResponse = {
  headers: map[string]string(name='headers'),
  body: ListLogConfigsResponseBody(name='body'),
}

async function listLogConfigsWithOptions(request: ListLogConfigsRequest, runtime: Util.RuntimeOptions): ListLogConfigsResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListLogConfigs', '2019-05-06', 'HTTPS', 'GET', 'AK', `/pop/v1/sam/log/listLogConfigs`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function listLogConfigs(request: ListLogConfigsRequest): ListLogConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listLogConfigsWithOptions(request, runtime);
}

model RestartApplicationQuery = {
  appId: string(name='AppId'),
  minReadyInstances?: integer(name='MinReadyInstances'),
}

model RestartApplicationRequest = {
  headers?: map[string]string(name='headers'),
  query: RestartApplicationQuery(name='query'),
}

model RestartApplicationResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  message: string(name='Message'),
  traceId: string(name='TraceId'),
  data: {
    changeOrderId: string(name='ChangeOrderId'),
  }(name='Data'),
}

model RestartApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: RestartApplicationResponseBody(name='body'),
}

async function restartApplicationWithOptions(request: RestartApplicationRequest, runtime: Util.RuntimeOptions): RestartApplicationResponse {
  Util.validateModel(request);
  return doRequestWithAction('RestartApplication', '2019-05-06', 'HTTPS', 'PUT', 'AK', `/pop/v1/sam/app/restartApplication`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function restartApplication(request: RestartApplicationRequest): RestartApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return restartApplicationWithOptions(request, runtime);
}

model RescaleApplicationQuery = {
  appId: string(name='AppId'),
  replicas: integer(name='Replicas'),
  minReadyInstances?: integer(name='MinReadyInstances'),
}

model RescaleApplicationRequest = {
  headers?: map[string]string(name='headers'),
  query: RescaleApplicationQuery(name='query'),
}

model RescaleApplicationResponseBody = {
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  data: {
    changeOrderId: string(name='ChangeOrderId'),
  }(name='Data'),
}

model RescaleApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: RescaleApplicationResponseBody(name='body'),
}

async function rescaleApplicationWithOptions(request: RescaleApplicationRequest, runtime: Util.RuntimeOptions): RescaleApplicationResponse {
  Util.validateModel(request);
  return doRequestWithAction('RescaleApplication', '2019-05-06', 'HTTPS', 'PUT', 'AK', `/pop/v1/sam/app/rescaleApplication`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function rescaleApplication(request: RescaleApplicationRequest): RescaleApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return rescaleApplicationWithOptions(request, runtime);
}

model DeleteApplicationQuery = {
  appId: string(name='AppId'),
}

model DeleteApplicationRequest = {
  headers?: map[string]string(name='headers'),
  query: DeleteApplicationQuery(name='query'),
}

model DeleteApplicationResponseBody = {
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  traceId: string(name='TraceId'),
  data: {
    changeOrderId: string(name='ChangeOrderId'),
  }(name='Data'),
}

model DeleteApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteApplicationResponseBody(name='body'),
}

async function deleteApplicationWithOptions(request: DeleteApplicationRequest, runtime: Util.RuntimeOptions): DeleteApplicationResponse {
  Util.validateModel(request);
  return doRequestWithAction('DeleteApplication', '2019-05-06', 'HTTPS', 'DELETE', 'AK', `/pop/v1/sam/app/deleteApplication`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function deleteApplication(request: DeleteApplicationRequest): DeleteApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteApplicationWithOptions(request, runtime);
}

model DescribeChangeOrderQuery = {
  changeOrderId: string(name='ChangeOrderId'),
}

model DescribeChangeOrderRequest = {
  headers?: map[string]string(name='headers'),
  query: DescribeChangeOrderQuery(name='query'),
}

model DescribeChangeOrderResponseBody = {
  code: string(name='Code'),
  errorCode: string(name='ErrorCode'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  traceId: string(name='TraceId'),
  requestId: string(name='RequestId'),
  data: {
    appName: string(name='AppName'),
    auto: boolean(name='Auto'),
    batchCount: integer(name='BatchCount'),
    batchType: string(name='BatchType'),
    batchWaitTime: integer(name='BatchWaitTime'),
    changeOrderId: string(name='ChangeOrderId'),
    coType: string(name='CoType'),
    coTypeCode: string(name='CoTypeCode'),
    createTime: string(name='CreateTime'),
    currentPipelineId: string(name='CurrentPipelineId'),
    description: string(name='Description'),
    status: integer(name='Status'),
    supportRollback: boolean(name='SupportRollback'),
    errorMessage: string(name='ErrorMessage'),
    pipelines: [
      {
        batchType: integer(name='BatchType'),
        parallelCount: integer(name='ParallelCount'),
        pipelineId: string(name='PipelineId'),
        pipelineName: string(name='PipelineName'),
        startTime: long(name='StartTime'),
        status: integer(name='Status'),
        updateTime: long(name='UpdateTime'),
      }
    ](name='Pipelines'),
  }(name='Data'),
}

model DescribeChangeOrderResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeChangeOrderResponseBody(name='body'),
}

async function describeChangeOrderWithOptions(request: DescribeChangeOrderRequest, runtime: Util.RuntimeOptions): DescribeChangeOrderResponse {
  Util.validateModel(request);
  return doRequestWithAction('DescribeChangeOrder', '2019-05-06', 'HTTPS', 'GET', 'AK', `/pop/v1/sam/changeorder/DescribeChangeOrder`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function describeChangeOrder(request: DescribeChangeOrderRequest): DescribeChangeOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeChangeOrderWithOptions(request, runtime);
}

model AbortChangeOrderQuery = {
  changeOrderId: string(name='ChangeOrderId'),
}

model AbortChangeOrderRequest = {
  headers?: map[string]string(name='headers'),
  query: AbortChangeOrderQuery(name='query'),
}

model AbortChangeOrderResponseBody = {
  code: string(name='Code'),
  errorCode: string(name='ErrorCode'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  traceId: string(name='TraceId'),
  requestId: string(name='RequestId'),
  data: {
    changeOrderId: string(name='ChangeOrderId'),
  }(name='Data'),
}

model AbortChangeOrderResponse = {
  headers: map[string]string(name='headers'),
  body: AbortChangeOrderResponseBody(name='body'),
}

async function abortChangeOrderWithOptions(request: AbortChangeOrderRequest, runtime: Util.RuntimeOptions): AbortChangeOrderResponse {
  Util.validateModel(request);
  return doRequestWithAction('AbortChangeOrder', '2019-05-06', 'HTTPS', 'PUT', 'AK', `/pop/v1/sam/changeorder/AbortChangeOrder`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function abortChangeOrder(request: AbortChangeOrderRequest): AbortChangeOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return abortChangeOrderWithOptions(request, runtime);
}

model AbortAndRollbackChangeOrderQuery = {
  changeOrderId: string(name='ChangeOrderId'),
}

model AbortAndRollbackChangeOrderRequest = {
  headers?: map[string]string(name='headers'),
  query: AbortAndRollbackChangeOrderQuery(name='query'),
}

model AbortAndRollbackChangeOrderResponseBody = {
  code: string(name='Code'),
  errorCode: string(name='ErrorCode'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  traceId: string(name='TraceId'),
  requestId: string(name='RequestId'),
  data: {
    changeOrderId: string(name='ChangeOrderId'),
  }(name='Data'),
}

model AbortAndRollbackChangeOrderResponse = {
  headers: map[string]string(name='headers'),
  body: AbortAndRollbackChangeOrderResponseBody(name='body'),
}

async function abortAndRollbackChangeOrderWithOptions(request: AbortAndRollbackChangeOrderRequest, runtime: Util.RuntimeOptions): AbortAndRollbackChangeOrderResponse {
  Util.validateModel(request);
  return doRequestWithAction('AbortAndRollbackChangeOrder', '2019-05-06', 'HTTPS', 'PUT', 'AK', `/pop/v1/sam/changeorder/AbortAndRollbackChangeOrder`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function abortAndRollbackChangeOrder(request: AbortAndRollbackChangeOrderRequest): AbortAndRollbackChangeOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return abortAndRollbackChangeOrderWithOptions(request, runtime);
}

model ConfirmPipelineBatchQuery = {
  pipelineId: string(name='PipelineId'),
  confirm: boolean(name='Confirm'),
}

model ConfirmPipelineBatchRequest = {
  headers?: map[string]string(name='headers'),
  query: ConfirmPipelineBatchQuery(name='query'),
}

model ConfirmPipelineBatchResponseBody = {
  code: string(name='Code'),
  errorCode: string(name='ErrorCode'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  traceId: string(name='TraceId'),
  requestId: string(name='RequestId'),
  data: {
    pipelineId: string(name='PipelineId'),
  }(name='Data'),
}

model ConfirmPipelineBatchResponse = {
  headers: map[string]string(name='headers'),
  body: ConfirmPipelineBatchResponseBody(name='body'),
}

async function confirmPipelineBatchWithOptions(request: ConfirmPipelineBatchRequest, runtime: Util.RuntimeOptions): ConfirmPipelineBatchResponse {
  Util.validateModel(request);
  return doRequestWithAction('ConfirmPipelineBatch', '2019-05-06', 'HTTPS', 'GET', 'AK', `/pop/v1/sam/changeorder/ConfirmPipelineBatch`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function confirmPipelineBatch(request: ConfirmPipelineBatchRequest): ConfirmPipelineBatchResponse {
  var runtime = new Util.RuntimeOptions{};
  return confirmPipelineBatchWithOptions(request, runtime);
}

model ListChangeOrdersQuery = {
  appId: string(name='AppId'),
  currentPage?: integer(name='CurrentPage'),
  pageSize?: integer(name='PageSize'),
  key?: string(name='Key'),
  coType?: string(name='CoType'),
  coStatus?: string(name='CoStatus'),
}

model ListChangeOrdersRequest = {
  headers?: map[string]string(name='headers'),
  query: ListChangeOrdersQuery(name='query'),
}

model ListChangeOrdersResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  traceId: string(name='TraceId'),
  data: {
    currentPage: integer(name='CurrentPage'),
    pageSize: integer(name='PageSize'),
    totalSize: integer(name='TotalSize'),
    changeOrderList: [
      {
        appId: string(name='AppId'),
        batchCount: integer(name='BatchCount'),
        batchType: string(name='BatchType'),
        changeOrderId: string(name='ChangeOrderId'),
        coType: string(name='CoType'),
        coTypeCode: string(name='CoTypeCode'),
        createTime: string(name='CreateTime'),
        description: string(name='Description'),
        finishTime: string(name='FinishTime'),
        groupId: string(name='GroupId'),
        source: string(name='Source'),
        status: integer(name='Status'),
        userId: string(name='UserId'),
        createUserId: string(name='CreateUserId'),
      }
    ](name='ChangeOrderList'),
  }(name='Data'),
}

model ListChangeOrdersResponse = {
  headers: map[string]string(name='headers'),
  body: ListChangeOrdersResponseBody(name='body'),
}

async function listChangeOrdersWithOptions(request: ListChangeOrdersRequest, runtime: Util.RuntimeOptions): ListChangeOrdersResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListChangeOrders', '2019-05-06', 'HTTPS', 'GET', 'AK', `/pop/v1/sam/changeorder/ListChangeOrders`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function listChangeOrders(request: ListChangeOrdersRequest): ListChangeOrdersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listChangeOrdersWithOptions(request, runtime);
}

model DescribeNamespaceListQuery = {
  containCustom: boolean(name='ContainCustom'),
  hybridCloudExclude?: boolean(name='HybridCloudExclude'),
}

model DescribeNamespaceListRequest = {
  headers?: map[string]string(name='headers'),
  query: DescribeNamespaceListQuery(name='query'),
}

model DescribeNamespaceListResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  traceId: string(name='TraceId'),
  data: [
    {
      namespaceName: string(name='NamespaceName'),
      namespaceId: string(name='NamespaceId'),
      agentInstall: string(name='AgentInstall'),
      current: boolean(name='Current'),
      custom: boolean(name='Custom'),
      regionId: string(name='RegionId'),
      hybridCloudEnable: boolean(name='HybridCloudEnable'),
      vpcId: string(name='VpcId'),
      vSwitchId: string(name='VSwitchId'),
      securityGroupId: string(name='SecurityGroupId'),
    }
  ](name='Data'),
}

model DescribeNamespaceListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNamespaceListResponseBody(name='body'),
}

async function describeNamespaceListWithOptions(request: DescribeNamespaceListRequest, runtime: Util.RuntimeOptions): DescribeNamespaceListResponse {
  Util.validateModel(request);
  return doRequestWithAction('DescribeNamespaceList', '2019-05-06', 'HTTPS', 'GET', 'AK', `/pop/v1/sam/namespace/describeNamespaceList`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function describeNamespaceList(request: DescribeNamespaceListRequest): DescribeNamespaceListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNamespaceListWithOptions(request, runtime);
}

model StartApplicationQuery = {
  appId: string(name='AppId'),
}

model StartApplicationRequest = {
  headers?: map[string]string(name='headers'),
  query: StartApplicationQuery(name='query'),
}

model StartApplicationResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  message: string(name='Message'),
  traceId: string(name='TraceId'),
  data: {
    changeOrderId: string(name='ChangeOrderId'),
  }(name='Data'),
}

model StartApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: StartApplicationResponseBody(name='body'),
}

async function startApplicationWithOptions(request: StartApplicationRequest, runtime: Util.RuntimeOptions): StartApplicationResponse {
  Util.validateModel(request);
  return doRequestWithAction('StartApplication', '2019-05-06', 'HTTPS', 'PUT', 'AK', `/pop/v1/sam/app/startApplication`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function startApplication(request: StartApplicationRequest): StartApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return startApplicationWithOptions(request, runtime);
}

model StopApplicationQuery = {
  appId: string(name='AppId'),
}

model StopApplicationRequest = {
  headers?: map[string]string(name='headers'),
  query: StopApplicationQuery(name='query'),
}

model StopApplicationResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  message: string(name='Message'),
  traceId: string(name='TraceId'),
  data: {
    changeOrderId: string(name='ChangeOrderId'),
  }(name='Data'),
}

model StopApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: StopApplicationResponseBody(name='body'),
}

async function stopApplicationWithOptions(request: StopApplicationRequest, runtime: Util.RuntimeOptions): StopApplicationResponse {
  Util.validateModel(request);
  return doRequestWithAction('StopApplication', '2019-05-06', 'HTTPS', 'PUT', 'AK', `/pop/v1/sam/app/stopApplication`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function stopApplication(request: StopApplicationRequest): StopApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopApplicationWithOptions(request, runtime);
}

model QueryResourceStaticsQuery = {
  appId: string(name='AppId'),
}

model QueryResourceStaticsRequest = {
  headers?: map[string]string(name='headers'),
  query: QueryResourceStaticsQuery(name='query'),
}

model QueryResourceStaticsResponseBody = {
  code: string(name='Code'),
  errorCode: string(name='ErrorCode'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  traceId: string(name='TraceId'),
  requestId: string(name='RequestId'),
  data: {
    realTimeRes: {
      cpu: float(name='Cpu'),
      memory: float(name='Memory'),
    }(name='RealTimeRes'),
    summary: {
      cpu: float(name='Cpu'),
      memory: float(name='Memory'),
    }(name='Summary'),
  }(name='Data'),
}

model QueryResourceStaticsResponse = {
  headers: map[string]string(name='headers'),
  body: QueryResourceStaticsResponseBody(name='body'),
}

async function queryResourceStaticsWithOptions(request: QueryResourceStaticsRequest, runtime: Util.RuntimeOptions): QueryResourceStaticsResponse {
  Util.validateModel(request);
  return doRequestWithAction('QueryResourceStatics', '2019-05-06', 'HTTPS', 'GET', 'AK', `/pop/v1/paas/quota/queryResourceStatics`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function queryResourceStatics(request: QueryResourceStaticsRequest): QueryResourceStaticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryResourceStaticsWithOptions(request, runtime);
}

model DescribeApplicationSlbsQuery = {
  appId: string(name='AppId'),
}

model DescribeApplicationSlbsRequest = {
  headers?: map[string]string(name='headers'),
  query: DescribeApplicationSlbsQuery(name='query'),
}

model DescribeApplicationSlbsResponseBody = {
  code: string(name='Code'),
  errorCode: string(name='ErrorCode'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  traceId: string(name='TraceId'),
  requestId: string(name='RequestId'),
  data: {
    internetIp: string(name='InternetIp'),
    intranetIp: string(name='IntranetIp'),
    internetSlbId: string(name='InternetSlbId'),
    intranetSlbId: string(name='IntranetSlbId'),
    internet: [
      {
        port: integer(name='Port'),
        protocol: string(name='Protocol'),
        targetPort: integer(name='TargetPort'),
        httpsCertId: string(name='HttpsCertId'),
      }
    ](name='Internet'),
    intranet: [
      {
        port: integer(name='Port'),
        protocol: string(name='Protocol'),
        targetPort: integer(name='TargetPort'),
        httpsCertId: string(name='HttpsCertId'),
      }
    ](name='Intranet'),
  }(name='Data'),
}

model DescribeApplicationSlbsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeApplicationSlbsResponseBody(name='body'),
}

async function describeApplicationSlbsWithOptions(request: DescribeApplicationSlbsRequest, runtime: Util.RuntimeOptions): DescribeApplicationSlbsResponse {
  Util.validateModel(request);
  return doRequestWithAction('DescribeApplicationSlbs', '2019-05-06', 'HTTPS', 'GET', 'AK', `/pop/v1/sam/app/slb`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function describeApplicationSlbs(request: DescribeApplicationSlbsRequest): DescribeApplicationSlbsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeApplicationSlbsWithOptions(request, runtime);
}

model BindSlbQuery = {
  appId: string(name='AppId'),
  internet?: string(name='Internet'),
  intranet?: string(name='Intranet'),
  internetSlbId?: string(name='InternetSlbId'),
  intranetSlbId?: string(name='IntranetSlbId'),
}

model BindSlbRequest = {
  headers?: map[string]string(name='headers'),
  query: BindSlbQuery(name='query'),
}

model BindSlbResponseBody = {
  code: string(name='Code'),
  message: string(name='Message'),
  errorCode: string(name='ErrorCode'),
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  traceId: string(name='TraceId'),
  data: {
    changeOrderId: string(name='ChangeOrderId'),
  }(name='Data'),
}

model BindSlbResponse = {
  headers: map[string]string(name='headers'),
  body: BindSlbResponseBody(name='body'),
}

async function bindSlbWithOptions(request: BindSlbRequest, runtime: Util.RuntimeOptions): BindSlbResponse {
  Util.validateModel(request);
  return doRequestWithAction('BindSlb', '2019-05-06', 'HTTPS', 'POST', 'AK', `/pop/v1/sam/app/slb`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function bindSlb(request: BindSlbRequest): BindSlbResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindSlbWithOptions(request, runtime);
}

model UnbindSlbQuery = {
  appId: string(name='AppId'),
  internet: boolean(name='Internet'),
  intranet: boolean(name='Intranet'),
}

model UnbindSlbRequest = {
  headers?: map[string]string(name='headers'),
  query: UnbindSlbQuery(name='query'),
}

model UnbindSlbResponseBody = {
  code: string(name='Code'),
  message: string(name='Message'),
  errorCode: string(name='ErrorCode'),
  success: boolean(name='Success'),
  traceId: string(name='TraceId'),
  requestId: string(name='RequestId'),
  data: {
    changeOrderId: string(name='ChangeOrderId'),
  }(name='Data'),
}

model UnbindSlbResponse = {
  headers: map[string]string(name='headers'),
  body: UnbindSlbResponseBody(name='body'),
}

async function unbindSlbWithOptions(request: UnbindSlbRequest, runtime: Util.RuntimeOptions): UnbindSlbResponse {
  Util.validateModel(request);
  return doRequestWithAction('UnbindSlb', '2019-05-06', 'HTTPS', 'DELETE', 'AK', `/pop/v1/sam/app/slb`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function unbindSlb(request: UnbindSlbRequest): UnbindSlbResponse {
  var runtime = new Util.RuntimeOptions{};
  return unbindSlbWithOptions(request, runtime);
}

model CreateApplicationQuery = {
  appName: string(name='AppName'),
  namespaceId?: string(name='NamespaceId'),
  appDescription?: string(name='AppDescription'),
  vpcId?: string(name='VpcId'),
  vSwitchId?: string(name='VSwitchId'),
  packageType: string(name='PackageType'),
  packageVersion?: string(name='PackageVersion'),
  packageUrl?: string(name='PackageUrl'),
  imageUrl?: string(name='ImageUrl'),
  jdk?: string(name='Jdk'),
  webContainer?: string(name='WebContainer'),
  cpu?: integer(name='Cpu'),
  memory?: integer(name='Memory'),
  replicas: integer(name='Replicas'),
  command?: string(name='Command'),
  commandArgs?: string(name='CommandArgs'),
  envs?: string(name='Envs'),
  customHostAlias?: string(name='CustomHostAlias'),
  jarStartOptions?: string(name='JarStartOptions'),
  jarStartArgs?: string(name='JarStartArgs'),
  liveness?: string(name='Liveness'),
  readiness?: string(name='Readiness'),
  deploy?: boolean(name='Deploy'),
  edasContainerVersion?: string(name='EdasContainerVersion'),
  timezone?: string(name='Timezone'),
  slsConfigs?: string(name='SlsConfigs'),
  nasId?: string(name='NasId'),
  mountHost?: string(name='MountHost'),
  mountDesc?: string(name='MountDesc'),
  preStop?: string(name='PreStop'),
  postStart?: string(name='PostStart'),
  warStartOptions?: string(name='WarStartOptions'),
  securityGroupId?: string(name='SecurityGroupId'),
  autoConfig?: boolean(name='AutoConfig'),
  terminationGracePeriodSeconds?: integer(name='TerminationGracePeriodSeconds'),
  phpArmsConfigLocation?: string(name='PhpArmsConfigLocation'),
  phpConfigLocation?: string(name='PhpConfigLocation'),
  tomcatConfig?: string(name='TomcatConfig'),
  acrAssumeRoleArn?: string(name='AcrAssumeRoleArn'),
}

model CreateApplicationBody = {
  configMapMountDesc?: string(name='ConfigMapMountDesc'),
  phpConfig?: string(name='PhpConfig'),
}

model CreateApplicationRequest = {
  headers?: map[string]string(name='headers'),
  query: CreateApplicationQuery(name='query'),
  body?: CreateApplicationBody(name='body'),
}

model CreateApplicationResponseBody = {
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  traceId: string(name='TraceId'),
  errorCode: string(name='ErrorCode'),
  code: string(name='Code'),
  success: boolean(name='Success'),
  data: {
    appId: string(name='AppId'),
    changeOrderId: string(name='ChangeOrderId'),
  }(name='Data'),
}

model CreateApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: CreateApplicationResponseBody(name='body'),
}

async function createApplicationWithOptions(request: CreateApplicationRequest, runtime: Util.RuntimeOptions): CreateApplicationResponse {
  Util.validateModel(request);
  return doRequestWithAction('CreateApplication', '2019-05-06', 'HTTPS', 'POST', 'AK', `/pop/v1/sam/app/createApplication`, Util.stringifyMapValue(request.query), request.headers, request.body, runtime);
}

async function createApplication(request: CreateApplicationRequest): CreateApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createApplicationWithOptions(request, runtime);
}

model DeployApplicationQuery = {
  appId?: string(name='AppId'),
  jdk?: string(name='Jdk'),
  webContainer?: string(name='WebContainer'),
  packageVersion?: string(name='PackageVersion'),
  packageUrl?: string(name='PackageUrl'),
  imageUrl?: string(name='ImageUrl'),
  command?: string(name='Command'),
  commandArgs?: string(name='CommandArgs'),
  envs?: string(name='Envs'),
  customHostAlias?: string(name='CustomHostAlias'),
  jarStartOptions?: string(name='JarStartOptions'),
  jarStartArgs?: string(name='JarStartArgs'),
  liveness?: string(name='Liveness'),
  readiness?: string(name='Readiness'),
  minReadyInstances?: integer(name='MinReadyInstances'),
  batchWaitTime?: integer(name='BatchWaitTime'),
  edasContainerVersion?: string(name='EdasContainerVersion'),
  updateStrategy?: string(name='UpdateStrategy'),
  slsConfigs?: string(name='SlsConfigs'),
  timezone?: string(name='Timezone'),
  postStart?: string(name='PostStart'),
  preStop?: string(name='PreStop'),
  changeOrderDesc?: string(name='ChangeOrderDesc'),
  warStartOptions?: string(name='WarStartOptions'),
  terminationGracePeriodSeconds?: integer(name='TerminationGracePeriodSeconds'),
  enableAhas?: string(name='EnableAhas'),
  phpArmsConfigLocation?: string(name='PhpArmsConfigLocation'),
  phpConfigLocation?: string(name='PhpConfigLocation'),
  tomcatConfig?: string(name='TomcatConfig'),
  acrAssumeRoleArn?: string(name='AcrAssumeRoleArn'),
}

model DeployApplicationBody = {
  configMapMountDesc?: string(name='ConfigMapMountDesc'),
  phpConfig?: string(name='PhpConfig'),
}

model DeployApplicationRequest = {
  headers?: map[string]string(name='headers'),
  query?: DeployApplicationQuery(name='query'),
  body?: DeployApplicationBody(name='body'),
}

model DeployApplicationResponseBody = {
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  traceId: string(name='TraceId'),
  errorCode: string(name='ErrorCode'),
  code: string(name='Code'),
  success: boolean(name='Success'),
  data: {
    appId: string(name='AppId'),
    changeOrderId: string(name='ChangeOrderId'),
  }(name='Data'),
}

model DeployApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: DeployApplicationResponseBody(name='body'),
}

async function deployApplicationWithOptions(nasId: string, mountHost: string, mountDesc: string, request: DeployApplicationRequest, runtime: Util.RuntimeOptions): DeployApplicationResponse {
  Util.validateModel(request);
  return doRequestWithAction('DeployApplication', '2019-05-06', 'HTTPS', 'POST', 'AK', `/pop/v1/sam/app/deployApplication`, Util.stringifyMapValue(request.query), request.headers, request.body, runtime);
}

async function deployApplication(nasId: string, mountHost: string, mountDesc: string, request: DeployApplicationRequest): DeployApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deployApplicationWithOptions(nasId, mountHost, mountDesc, request, runtime);
}

model DescribeApplicationConfigQuery = {
  appId: string(name='AppId'),
  versionId?: string(name='VersionId'),
}

model DescribeApplicationConfigRequest = {
  headers?: map[string]string(name='headers'),
  query: DescribeApplicationConfigQuery(name='query'),
}

model DescribeApplicationConfigResponseBody = {
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  traceId: string(name='TraceId'),
  errorCode: string(name='ErrorCode'),
  code: string(name='Code'),
  success: boolean(name='Success'),
  data: {
    timezone: string(name='Timezone'),
    appDescription: string(name='AppDescription'),
    phpConfig: string(name='PhpConfig'),
    nasId: string(name='NasId'),
    warStartOptions: string(name='WarStartOptions'),
    liveness: string(name='Liveness'),
    memory: integer(name='Memory'),
    webContainer: string(name='WebContainer'),
    slsConfigs: string(name='SlsConfigs'),
    cpu: integer(name='Cpu'),
    packageVersion: string(name='PackageVersion'),
    appName: string(name='AppName'),
    jdk: string(name='Jdk'),
    jarStartArgs: string(name='JarStartArgs'),
    minReadyInstances: integer(name='MinReadyInstances'),
    preStop: string(name='PreStop'),
    readiness: string(name='Readiness'),
    phpArmsConfigLocation: string(name='PhpArmsConfigLocation'),
    packageType: string(name='PackageType'),
    commandArgs: string(name='CommandArgs'),
    acrAssumeRoleArn: string(name='AcrAssumeRoleArn'),
    terminationGracePeriodSeconds: integer(name='TerminationGracePeriodSeconds'),
    envs: string(name='Envs'),
    vSwitchId: string(name='VSwitchId'),
    securityGroupId: string(name='SecurityGroupId'),
    postStart: string(name='PostStart'),
    imageUrl: string(name='ImageUrl'),
    mountHost: string(name='MountHost'),
    jarStartOptions: string(name='JarStartOptions'),
    replicas: integer(name='Replicas'),
    customHostAlias: string(name='CustomHostAlias'),
    appId: string(name='AppId'),
    vpcId: string(name='VpcId'),
    edasContainerVersion: string(name='EdasContainerVersion'),
    command: string(name='Command'),
    phpConfigLocation: string(name='PhpConfigLocation'),
    packageUrl: string(name='PackageUrl'),
    batchWaitTime: integer(name='BatchWaitTime'),
    regionId: string(name='RegionId'),
    namespaceId: string(name='NamespaceId'),
    enableAhas: string(name='EnableAhas'),
    tomcatConfig: string(name='TomcatConfig'),
    mountDesc: [
      {
        mountPath: string(name='MountPath'),
        nasPath: string(name='NasPath'),
      }
    ](name='MountDesc'),
    tags: [
      {
        value: string(name='Value'),
        key: string(name='Key'),
      }
    ](name='Tags'),
    configMapMountDesc: [
      {
        mountPath: string(name='MountPath'),
        configMapId: long(name='ConfigMapId'),
        configMapName: string(name='ConfigMapName'),
        key: string(name='Key'),
      }
    ](name='ConfigMapMountDesc'),
  }(name='Data'),
}

model DescribeApplicationConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeApplicationConfigResponseBody(name='body'),
}

async function describeApplicationConfigWithOptions(request: DescribeApplicationConfigRequest, runtime: Util.RuntimeOptions): DescribeApplicationConfigResponse {
  Util.validateModel(request);
  return doRequestWithAction('DescribeApplicationConfig', '2019-05-06', 'HTTPS', 'GET', 'AK', `/pop/v1/sam/app/describeApplicationConfig`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function describeApplicationConfig(request: DescribeApplicationConfigRequest): DescribeApplicationConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeApplicationConfigWithOptions(request, runtime);
}

model DescribeApplicationStatusQuery = {
  appId: string(name='AppId'),
}

model DescribeApplicationStatusRequest = {
  headers?: map[string]string(name='headers'),
  query: DescribeApplicationStatusQuery(name='query'),
}

model DescribeApplicationStatusResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
  traceId: string(name='TraceId'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  data: {
    appId: string(name='AppId'),
    lastChangeOrderId: string(name='LastChangeOrderId'),
    lastChangeOrderStatus: string(name='LastChangeOrderStatus'),
    lastChangeOrderRunning: boolean(name='LastChangeOrderRunning'),
    currentStatus: string(name='CurrentStatus'),
    armsApmInfo: string(name='ArmsApmInfo'),
    runningInstances: integer(name='RunningInstances'),
    armsAdvancedEnabled: string(name='ArmsAdvancedEnabled'),
    createTime: string(name='CreateTime'),
  }(name='Data'),
}

model DescribeApplicationStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeApplicationStatusResponseBody(name='body'),
}

async function describeApplicationStatusWithOptions(request: DescribeApplicationStatusRequest, runtime: Util.RuntimeOptions): DescribeApplicationStatusResponse {
  Util.validateModel(request);
  return doRequestWithAction('DescribeApplicationStatus', '2019-05-06', 'HTTPS', 'GET', 'AK', `/pop/v1/sam/app/describeApplicationStatus`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function describeApplicationStatus(request: DescribeApplicationStatusRequest): DescribeApplicationStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeApplicationStatusWithOptions(request, runtime);
}

model RescaleApplicationVerticallyQuery = {
  appId: string(name='AppId'),
  cpu: string(name='Cpu'),
  memory: string(name='Memory'),
}

model RescaleApplicationVerticallyRequest = {
  headers?: map[string]string(name='headers'),
  query: RescaleApplicationVerticallyQuery(name='query'),
}

model RescaleApplicationVerticallyResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  message: string(name='Message'),
  traceId: string(name='TraceId'),
  data: {
    changeOrderId: string(name='ChangeOrderId'),
  }(name='Data'),
}

model RescaleApplicationVerticallyResponse = {
  headers: map[string]string(name='headers'),
  body: RescaleApplicationVerticallyResponseBody(name='body'),
}

async function rescaleApplicationVerticallyWithOptions(request: RescaleApplicationVerticallyRequest, runtime: Util.RuntimeOptions): RescaleApplicationVerticallyResponse {
  Util.validateModel(request);
  return doRequestWithAction('RescaleApplicationVertically', '2019-05-06', 'HTTPS', 'POST', 'AK', `/pop/v1/sam/app/rescaleApplicationVertically`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function rescaleApplicationVertically(request: RescaleApplicationVerticallyRequest): RescaleApplicationVerticallyResponse {
  var runtime = new Util.RuntimeOptions{};
  return rescaleApplicationVerticallyWithOptions(request, runtime);
}

model DescribeInstanceLogQuery = {
  instanceId: string(name='InstanceId'),
}

model DescribeInstanceLogRequest = {
  headers?: map[string]string(name='headers'),
  query: DescribeInstanceLogQuery(name='query'),
}

model DescribeInstanceLogResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  traceId: string(name='TraceId'),
  data: string(name='Data'),
}

model DescribeInstanceLogResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceLogResponseBody(name='body'),
}

async function describeInstanceLogWithOptions(request: DescribeInstanceLogRequest, runtime: Util.RuntimeOptions): DescribeInstanceLogResponse {
  Util.validateModel(request);
  return doRequestWithAction('DescribeInstanceLog', '2019-05-06', 'HTTPS', 'GET', 'AK', `/pop/v1/sam/instance/describeInstanceLog`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function describeInstanceLog(request: DescribeInstanceLogRequest): DescribeInstanceLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceLogWithOptions(request, runtime);
}

model DescribeApplicationInstancesQuery = {
  appId: string(name='AppId'),
  groupId: string(name='GroupId'),
  currentPage?: integer(name='CurrentPage'),
  pageSize?: integer(name='PageSize'),
}

model DescribeApplicationInstancesRequest = {
  headers?: map[string]string(name='headers'),
  query: DescribeApplicationInstancesQuery(name='query'),
}

model DescribeApplicationInstancesResponseBody = {
  code: string(name='Code'),
  message: string(name='Message'),
  traceId: string(name='TraceId'),
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  data: {
    currentPage: integer(name='CurrentPage'),
    pageSize: integer(name='PageSize'),
    totalSize: integer(name='TotalSize'),
    instances: [
      {
        groupId: string(name='GroupId'),
        instanceId: string(name='InstanceId'),
        instanceContainerStatus: string(name='InstanceContainerStatus'),
        instanceContainerIp: string(name='InstanceContainerIp'),
        createTimeStamp: long(name='CreateTimeStamp'),
        vSwitchId: string(name='VSwitchId'),
        instanceContainerRestarts: long(name='InstanceContainerRestarts'),
      }
    ](name='Instances'),
  }(name='Data'),
}

model DescribeApplicationInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeApplicationInstancesResponseBody(name='body'),
}

async function describeApplicationInstancesWithOptions(request: DescribeApplicationInstancesRequest, runtime: Util.RuntimeOptions): DescribeApplicationInstancesResponse {
  Util.validateModel(request);
  return doRequestWithAction('DescribeApplicationInstances', '2019-05-06', 'HTTPS', 'GET', 'AK', `/pop/v1/sam/app/describeApplicationInstances`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function describeApplicationInstances(request: DescribeApplicationInstancesRequest): DescribeApplicationInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeApplicationInstancesWithOptions(request, runtime);
}

model DescribeApplicationGroupsQuery = {
  appId: string(name='AppId'),
  currentPage?: integer(name='CurrentPage'),
  pageSize?: integer(name='PageSize'),
}

model DescribeApplicationGroupsRequest = {
  headers?: map[string]string(name='headers'),
  query: DescribeApplicationGroupsQuery(name='query'),
}

model DescribeApplicationGroupsResponseBody = {
  code: string(name='Code'),
  message: string(name='Message'),
  traceId: string(name='TraceId'),
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  data: [
    {
      groupId: string(name='GroupId'),
      groupName: string(name='GroupName'),
      groupType: integer(name='GroupType'),
      packageType: string(name='PackageType'),
      packageVersion: string(name='PackageVersion'),
      imageUrl: string(name='ImageUrl'),
      packageUrl: string(name='PackageUrl'),
      jdk: string(name='Jdk'),
      webContainer: string(name='WebContainer'),
      edasContainerVersion: string(name='EdasContainerVersion'),
      replicas: integer(name='Replicas'),
      runningInstances: integer(name='RunningInstances'),
    }
  ](name='Data'),
}

model DescribeApplicationGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeApplicationGroupsResponseBody(name='body'),
}

async function describeApplicationGroupsWithOptions(request: DescribeApplicationGroupsRequest, runtime: Util.RuntimeOptions): DescribeApplicationGroupsResponse {
  Util.validateModel(request);
  return doRequestWithAction('DescribeApplicationGroups', '2019-05-06', 'HTTPS', 'GET', 'AK', `/pop/v1/sam/app/describeApplicationGroups`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function describeApplicationGroups(request: DescribeApplicationGroupsRequest): DescribeApplicationGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeApplicationGroupsWithOptions(request, runtime);
}

model DescribeApplicationImageQuery = {
  appId: string(name='AppId'),
  imageUrl: string(name='ImageUrl'),
}

model DescribeApplicationImageRequest = {
  headers?: map[string]string(name='headers'),
  query: DescribeApplicationImageQuery(name='query'),
}

model DescribeApplicationImageResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  traceId: string(name='TraceId'),
  data: {
    crUrl: string(name='CrUrl'),
    logo: string(name='Logo'),
    regionId: string(name='RegionId'),
    repoName: string(name='RepoName'),
    repoNamespace: string(name='RepoNamespace'),
    repoOriginType: string(name='RepoOriginType'),
    repoType: string(name='RepoType'),
    repoTag: string(name='RepoTag'),
  }(name='Data'),
}

model DescribeApplicationImageResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeApplicationImageResponseBody(name='body'),
}

async function describeApplicationImageWithOptions(request: DescribeApplicationImageRequest, runtime: Util.RuntimeOptions): DescribeApplicationImageResponse {
  Util.validateModel(request);
  return doRequestWithAction('DescribeApplicationImage', '2019-05-06', 'HTTPS', 'GET', 'AK', `/pop/v1/sam/container/describeApplicationImage`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function describeApplicationImage(request: DescribeApplicationImageRequest): DescribeApplicationImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeApplicationImageWithOptions(request, runtime);
}

model DescribeEdasContainersRequest = {
  headers?: map[string]string(name='headers'),
}

model DescribeEdasContainersResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  traceId: string(name='TraceId'),
  data: [
    {
      disabled: boolean(name='Disabled'),
      edasContainerVersion: string(name='EdasContainerVersion'),
    }
  ](name='Data'),
}

model DescribeEdasContainersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEdasContainersResponseBody(name='body'),
}

async function describeEdasContainersWithOptions(request: DescribeEdasContainersRequest, runtime: Util.RuntimeOptions): DescribeEdasContainersResponse {
  Util.validateModel(request);
  return doRequestWithAction('DescribeEdasContainers', '2019-05-06', 'HTTPS', 'GET', 'AK', `/pop/v1/sam/resource/edasContainers`, null, request.headers, null, runtime);
}

async function describeEdasContainers(request: DescribeEdasContainersRequest): DescribeEdasContainersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEdasContainersWithOptions(request, runtime);
}

model CreateNamespaceQuery = {
  namespaceId: string(name='NamespaceId'),
  namespaceName: string(name='NamespaceName'),
  namespaceDescription?: string(name='NamespaceDescription'),
}

model CreateNamespaceRequest = {
  headers?: map[string]string(name='headers'),
  query: CreateNamespaceQuery(name='query'),
}

model CreateNamespaceResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  errorCode: string(name='ErrorCode'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  traceId: string(name='TraceId'),
  data: {
    regionId: string(name='RegionId'),
    namespaceId: string(name='NamespaceId'),
    namespaceName: string(name='NamespaceName'),
    namespaceDescription: string(name='NamespaceDescription'),
  }(name='Data'),
}

model CreateNamespaceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNamespaceResponseBody(name='body'),
}

async function createNamespaceWithOptions(request: CreateNamespaceRequest, runtime: Util.RuntimeOptions): CreateNamespaceResponse {
  Util.validateModel(request);
  return doRequestWithAction('CreateNamespace', '2019-05-06', 'HTTPS', 'POST', 'AK', `/pop/v1/paas/namespace`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function createNamespace(request: CreateNamespaceRequest): CreateNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNamespaceWithOptions(request, runtime);
}

model ListApplicationsQuery = {
  currentPage: integer(name='CurrentPage'),
  pageSize?: integer(name='PageSize'),
  appName?: string(name='AppName'),
  namespaceId?: string(name='NamespaceId'),
  tags?: string(name='Tags'),
}

model ListApplicationsRequest = {
  headers?: map[string]string(name='headers'),
  query: ListApplicationsQuery(name='query'),
}

model ListApplicationsResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  data: {
    currentPage: integer(name='CurrentPage'),
    pageSize: integer(name='PageSize'),
    totalSize: integer(name='TotalSize'),
    applications: [
      {
        appDeletingStatus: boolean(name='AppDeletingStatus'),
        appId: string(name='AppId'),
        appName: string(name='AppName'),
        regionId: string(name='RegionId'),
        runningInstances: integer(name='RunningInstances'),
        instances: integer(name='Instances'),
        namespaceId: string(name='NamespaceId'),
        tags: [
          {
            key: string(name='Key'),
            value: string(name='Value'),
          }
        ](name='Tags'),
      }
    ](name='Applications'),
  }(name='Data'),
}

model ListApplicationsResponse = {
  headers: map[string]string(name='headers'),
  body: ListApplicationsResponseBody(name='body'),
}

async function listApplicationsWithOptions(request: ListApplicationsRequest, runtime: Util.RuntimeOptions): ListApplicationsResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListApplications', '2019-05-06', 'HTTPS', 'GET', 'AK', `/pop/v1/sam/app/listApplications`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function listApplications(request: ListApplicationsRequest): ListApplicationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listApplicationsWithOptions(request, runtime);
}

model DeleteNamespaceQuery = {
  namespaceId: string(name='NamespaceId'),
}

model DeleteNamespaceRequest = {
  headers?: map[string]string(name='headers'),
  query: DeleteNamespaceQuery(name='query'),
}

model DeleteNamespaceResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  errorCode: string(name='ErrorCode'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  traceId: string(name='TraceId'),
}

model DeleteNamespaceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNamespaceResponseBody(name='body'),
}

async function deleteNamespaceWithOptions(request: DeleteNamespaceRequest, runtime: Util.RuntimeOptions): DeleteNamespaceResponse {
  Util.validateModel(request);
  return doRequestWithAction('DeleteNamespace', '2019-05-06', 'HTTPS', 'DELETE', 'AK', `/pop/v1/paas/namespace`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function deleteNamespace(request: DeleteNamespaceRequest): DeleteNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNamespaceWithOptions(request, runtime);
}

model UpdateNamespaceQuery = {
  namespaceId: string(name='NamespaceId'),
  namespaceName: string(name='NamespaceName'),
  namespaceDescription?: string(name='NamespaceDescription'),
}

model UpdateNamespaceRequest = {
  headers?: map[string]string(name='headers'),
  query: UpdateNamespaceQuery(name='query'),
}

model UpdateNamespaceResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  errorCode: string(name='ErrorCode'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  traceId: string(name='TraceId'),
  data: {
    regionId: string(name='RegionId'),
    namespaceId: string(name='NamespaceId'),
    namespaceName: string(name='NamespaceName'),
    namespaceDescription: string(name='NamespaceDescription'),
  }(name='Data'),
}

model UpdateNamespaceResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateNamespaceResponseBody(name='body'),
}

async function updateNamespaceWithOptions(request: UpdateNamespaceRequest, runtime: Util.RuntimeOptions): UpdateNamespaceResponse {
  Util.validateModel(request);
  return doRequestWithAction('UpdateNamespace', '2019-05-06', 'HTTPS', 'PUT', 'AK', `/pop/v1/paas/namespace`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function updateNamespace(request: UpdateNamespaceRequest): UpdateNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateNamespaceWithOptions(request, runtime);
}

model DescribeNamespaceQuery = {
  namespaceId: string(name='NamespaceId'),
}

model DescribeNamespaceRequest = {
  headers?: map[string]string(name='headers'),
  query: DescribeNamespaceQuery(name='query'),
}

model DescribeNamespaceResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  errorCode: string(name='ErrorCode'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  traceId: string(name='TraceId'),
  data: {
    regionId: string(name='RegionId'),
    namespaceId: string(name='NamespaceId'),
    namespaceName: string(name='NamespaceName'),
    namespaceDescription: string(name='NamespaceDescription'),
  }(name='Data'),
}

model DescribeNamespaceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNamespaceResponseBody(name='body'),
}

async function describeNamespaceWithOptions(request: DescribeNamespaceRequest, runtime: Util.RuntimeOptions): DescribeNamespaceResponse {
  Util.validateModel(request);
  return doRequestWithAction('DescribeNamespace', '2019-05-06', 'HTTPS', 'GET', 'AK', `/pop/v1/paas/namespace`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function describeNamespace(request: DescribeNamespaceRequest): DescribeNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNamespaceWithOptions(request, runtime);
}

model DescribeNamespacesQuery = {
  currentPage: integer(name='CurrentPage'),
  pageSize: integer(name='PageSize'),
}

model DescribeNamespacesRequest = {
  headers?: map[string]string(name='headers'),
  query: DescribeNamespacesQuery(name='query'),
}

model DescribeNamespacesResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  errorCode: string(name='ErrorCode'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  traceId: string(name='TraceId'),
  data: {
    currentPage: integer(name='CurrentPage'),
    pageSize: integer(name='PageSize'),
    totalSize: integer(name='TotalSize'),
    namespaces: [
      {
        accessKey: string(name='AccessKey'),
        secretKey: string(name='SecretKey'),
        tenantId: string(name='TenantId'),
        regionId: string(name='RegionId'),
        namespaceId: string(name='NamespaceId'),
        namespaceName: string(name='NamespaceName'),
        namespaceDescription: string(name='NamespaceDescription'),
      }
    ](name='Namespaces'),
  }(name='Data'),
}

model DescribeNamespacesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNamespacesResponseBody(name='body'),
}

async function describeNamespacesWithOptions(request: DescribeNamespacesRequest, runtime: Util.RuntimeOptions): DescribeNamespacesResponse {
  Util.validateModel(request);
  return doRequestWithAction('DescribeNamespaces', '2019-05-06', 'HTTPS', 'GET', 'AK', `/pop/v1/paas/namespaces`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function describeNamespaces(request: DescribeNamespacesRequest): DescribeNamespacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNamespacesWithOptions(request, runtime);
}

model ListConsumedServicesQuery = {
  appId: string(name='AppId'),
}

model ListConsumedServicesRequest = {
  headers?: map[string]string(name='headers'),
  query: ListConsumedServicesQuery(name='query'),
}

model ListConsumedServicesResponseBody = {
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  traceId: string(name='TraceId'),
  data: [
    {
      appId: string(name='AppId'),
      group2Ip: string(name='Group2Ip'),
      name: string(name='Name'),
      type: string(name='Type'),
      version: string(name='Version'),
      groups: [ string ](name='Groups'),
      ips: [ string ](name='Ips'),
    }
  ](name='Data'),
}

model ListConsumedServicesResponse = {
  headers: map[string]string(name='headers'),
  body: ListConsumedServicesResponseBody(name='body'),
}

async function listConsumedServicesWithOptions(request: ListConsumedServicesRequest, runtime: Util.RuntimeOptions): ListConsumedServicesResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListConsumedServices', '2019-05-06', 'HTTPS', 'GET', 'AK', `/pop/v1/sam/service/listConsumedServices`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function listConsumedServices(request: ListConsumedServicesRequest): ListConsumedServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listConsumedServicesWithOptions(request, runtime);
}

model ListPublishedServicesQuery = {
  appId: string(name='AppId'),
}

model ListPublishedServicesRequest = {
  headers?: map[string]string(name='headers'),
  query: ListPublishedServicesQuery(name='query'),
}

model ListPublishedServicesResponseBody = {
  code: string(name='Code'),
  message: string(name='Message'),
  requestId: string(name='RequestId'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  traceId: string(name='TraceId'),
  data: [
    {
      appId: string(name='AppId'),
      group2Ip: string(name='Group2Ip'),
      name: string(name='Name'),
      type: string(name='Type'),
      version: string(name='Version'),
      groups: [ string ](name='Groups'),
      ips: [ string ](name='Ips'),
    }
  ](name='Data'),
}

model ListPublishedServicesResponse = {
  headers: map[string]string(name='headers'),
  body: ListPublishedServicesResponseBody(name='body'),
}

async function listPublishedServicesWithOptions(request: ListPublishedServicesRequest, runtime: Util.RuntimeOptions): ListPublishedServicesResponse {
  Util.validateModel(request);
  return doRequestWithAction('ListPublishedServices', '2019-05-06', 'HTTPS', 'GET', 'AK', `/pop/v1/sam/service/listPublishedServices`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function listPublishedServices(request: ListPublishedServicesRequest): ListPublishedServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPublishedServicesWithOptions(request, runtime);
}

model DescribeComponentsQuery = {
  appId: string(name='AppId'),
  type: string(name='Type'),
}

model DescribeComponentsRequest = {
  headers?: map[string]string(name='headers'),
  query: DescribeComponentsQuery(name='query'),
}

model DescribeComponentsResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  errorCode: string(name='ErrorCode'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  traceId: string(name='TraceId'),
  data: [
    {
      componentKey: string(name='ComponentKey'),
      componentDescription: string(name='ComponentDescription'),
      expired: boolean(name='Expired'),
      type: string(name='Type'),
    }
  ](name='Data'),
}

model DescribeComponentsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeComponentsResponseBody(name='body'),
}

async function describeComponentsWithOptions(request: DescribeComponentsRequest, runtime: Util.RuntimeOptions): DescribeComponentsResponse {
  Util.validateModel(request);
  return doRequestWithAction('DescribeComponents', '2019-05-06', 'HTTPS', 'GET', 'AK', `/pop/v1/sam/resource/components`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function describeComponents(request: DescribeComponentsRequest): DescribeComponentsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeComponentsWithOptions(request, runtime);
}

model DescribeInstanceSpecificationsRequest = {
  headers?: map[string]string(name='headers'),
}

model DescribeInstanceSpecificationsResponseBody = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  errorCode: string(name='ErrorCode'),
  traceId: string(name='TraceId'),
  data: [
    {
      cpu: integer(name='Cpu'),
      enable: boolean(name='Enable'),
      id: integer(name='Id'),
      memory: integer(name='Memory'),
      specInfo: string(name='SpecInfo'),
      version: integer(name='Version'),
    }
  ](name='Data'),
}

model DescribeInstanceSpecificationsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceSpecificationsResponseBody(name='body'),
}

async function describeInstanceSpecificationsWithOptions(request: DescribeInstanceSpecificationsRequest, runtime: Util.RuntimeOptions): DescribeInstanceSpecificationsResponse {
  Util.validateModel(request);
  return doRequestWithAction('DescribeInstanceSpecifications', '2019-05-06', 'HTTPS', 'GET', 'AK', `/pop/v1/paas/quota/instanceSpecifications`, null, request.headers, null, runtime);
}

async function describeInstanceSpecifications(request: DescribeInstanceSpecificationsRequest): DescribeInstanceSpecificationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceSpecificationsWithOptions(request, runtime);
}

model DescribeRegionsRequest = {
  headers?: map[string]string(name='headers'),
}

model DescribeRegionsResponseBody = {
  requestId: string(name='RequestId'),
  code: integer(name='Code'),
  message: string(name='Message'),
  regions: {
    region: [
      {
        regionId: string(name='RegionId'),
        regionEndpoint: string(name='RegionEndpoint'),
        localName: string(name='LocalName'),
      }
    ](name='Region'),
  }(name='Regions'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  return doRequestWithAction('DescribeRegions', '2019-05-06', 'HTTPS', 'GET', 'AK', `/pop/v1/paas/regionConfig`, null, request.headers, null, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
