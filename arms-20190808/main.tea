/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
@endpointMap = {
    ap-northeast-1 = 'arms.ap-southeast-1.aliyuncs.com',
    ap-south-1 = 'arms.ap-southeast-1.aliyuncs.com',
    ap-southeast-2 = 'arms.ap-southeast-1.aliyuncs.com',
    ap-southeast-3 = 'arms.ap-southeast-1.aliyuncs.com',
    ap-southeast-5 = 'arms.ap-southeast-1.aliyuncs.com',
    cn-chengdu = 'arms.aliyuncs.com',
    cn-huhehaote = 'arms.aliyuncs.com',
    eu-central-1 = 'arms.ap-southeast-1.aliyuncs.com',
    eu-west-1 = 'arms.ap-southeast-1.aliyuncs.com',
    me-east-1 = 'arms.ap-southeast-1.aliyuncs.com',
    us-east-1 = 'arms.ap-southeast-1.aliyuncs.com',
    cn-hangzhou-finance = 'arms.aliyuncs.com',
    cn-shenzhen-finance-1 = 'arms.aliyuncs.com',
    cn-shanghai-finance-1 = 'arms.aliyuncs.com',
    cn-north-2-gov-1 = 'arms.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('arms', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model AddGrafanaRequest {
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  integration?: string(name='Integration'),
}

model AddGrafanaResponseBody = {
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
}

model AddGrafanaResponse = {
  headers: map[string]string(name='headers'),
  body: AddGrafanaResponseBody(name='body'),
}

async function addGrafanaWithOptions(request: AddGrafanaRequest, runtime: Util.RuntimeOptions): AddGrafanaResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddGrafana', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addGrafana(request: AddGrafanaRequest): AddGrafanaResponse {
  var runtime = new Util.RuntimeOptions{};
  return addGrafanaWithOptions(request, runtime);
}

model AddIntegrationRequest {
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  integration?: string(name='Integration'),
}

model AddIntegrationResponseBody = {
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
}

model AddIntegrationResponse = {
  headers: map[string]string(name='headers'),
  body: AddIntegrationResponseBody(name='body'),
}

async function addIntegrationWithOptions(request: AddIntegrationRequest, runtime: Util.RuntimeOptions): AddIntegrationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddIntegration', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addIntegration(request: AddIntegrationRequest): AddIntegrationResponse {
  var runtime = new Util.RuntimeOptions{};
  return addIntegrationWithOptions(request, runtime);
}

model ApplyScenarioRequest {
  regionId?: string(name='RegionId'),
  scenario?: string(name='Scenario'),
  name?: string(name='Name'),
  appId?: string(name='AppId'),
  sign?: string(name='Sign'),
  config?: map[string]any(name='Config'),
  snTransfer?: boolean(name='SnTransfer'),
  snStat?: boolean(name='SnStat'),
  snDump?: boolean(name='SnDump'),
  snForce?: boolean(name='SnForce'),
  updateOption?: boolean(name='UpdateOption'),
}

model ApplyScenarioShrinkRequest {
  regionId?: string(name='RegionId'),
  scenario?: string(name='Scenario'),
  name?: string(name='Name'),
  appId?: string(name='AppId'),
  sign?: string(name='Sign'),
  configShrink?: string(name='Config'),
  snTransfer?: boolean(name='SnTransfer'),
  snStat?: boolean(name='SnStat'),
  snDump?: boolean(name='SnDump'),
  snForce?: boolean(name='SnForce'),
  updateOption?: boolean(name='UpdateOption'),
}

model ApplyScenarioResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model ApplyScenarioResponse = {
  headers: map[string]string(name='headers'),
  body: ApplyScenarioResponseBody(name='body'),
}

async function applyScenarioWithOptions(tmpReq: ApplyScenarioRequest, runtime: Util.RuntimeOptions): ApplyScenarioResponse {
  Util.validateModel(tmpReq);
  var request = new ApplyScenarioShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.config)) {
    request.configShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.config, 'Config', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ApplyScenario', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function applyScenario(request: ApplyScenarioRequest): ApplyScenarioResponse {
  var runtime = new Util.RuntimeOptions{};
  return applyScenarioWithOptions(request, runtime);
}

model CheckDataConsistencyRequest {
  currentTimestamp?: long(name='CurrentTimestamp'),
  regionId?: string(name='RegionId'),
  proxyUserId?: string(name='ProxyUserId'),
  pid?: string(name='Pid'),
  appType?: string(name='AppType'),
}

model CheckDataConsistencyResponseBody = {
  isDataConsistency?: boolean(name='IsDataConsistency'),
  requestId?: string(name='RequestId'),
}

model CheckDataConsistencyResponse = {
  headers: map[string]string(name='headers'),
  body: CheckDataConsistencyResponseBody(name='body'),
}

async function checkDataConsistencyWithOptions(request: CheckDataConsistencyRequest, runtime: Util.RuntimeOptions): CheckDataConsistencyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CheckDataConsistency', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function checkDataConsistency(request: CheckDataConsistencyRequest): CheckDataConsistencyResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkDataConsistencyWithOptions(request, runtime);
}

model CheckServiceLinkedRoleForDeletingRequest {
  roleArn?: string(name='RoleArn'),
  serviceName?: string(name='ServiceName'),
  SPIRegionId?: string(name='SPIRegionId'),
  deletionTaskId?: string(name='DeletionTaskId'),
  regionId?: string(name='RegionId'),
}

model CheckServiceLinkedRoleForDeletingResponseBody = {
  requestId?: string(name='RequestId'),
  deletable?: boolean(name='Deletable'),
  roleUsages?: [ 
    {
      region?: string(name='Region'),
      resources?: [ string ](name='Resources'),
    }
  ](name='RoleUsages'),
}

model CheckServiceLinkedRoleForDeletingResponse = {
  headers: map[string]string(name='headers'),
  body: CheckServiceLinkedRoleForDeletingResponseBody(name='body'),
}

async function checkServiceLinkedRoleForDeletingWithOptions(request: CheckServiceLinkedRoleForDeletingRequest, runtime: Util.RuntimeOptions): CheckServiceLinkedRoleForDeletingResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CheckServiceLinkedRoleForDeleting', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function checkServiceLinkedRoleForDeleting(request: CheckServiceLinkedRoleForDeletingRequest): CheckServiceLinkedRoleForDeletingResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkServiceLinkedRoleForDeletingWithOptions(request, runtime);
}

model ConfigAppRequest {
  appIds?: string(name='AppIds'),
  enable?: string(name='Enable'),
  regionId?: string(name='RegionId'),
}

model ConfigAppResponseBody = {
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
}

model ConfigAppResponse = {
  headers: map[string]string(name='headers'),
  body: ConfigAppResponseBody(name='body'),
}

async function configAppWithOptions(request: ConfigAppRequest, runtime: Util.RuntimeOptions): ConfigAppResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ConfigApp', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function configApp(request: ConfigAppRequest): ConfigAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return configAppWithOptions(request, runtime);
}

model CreateAlertContactRequest {
  contactName?: string(name='ContactName'),
  phoneNum?: string(name='PhoneNum'),
  email?: string(name='Email'),
  dingRobotWebhookUrl?: string(name='DingRobotWebhookUrl'),
  systemNoc?: boolean(name='SystemNoc'),
  regionId?: string(name='RegionId'),
  proxyUserId?: string(name='ProxyUserId'),
}

model CreateAlertContactResponseBody = {
  requestId?: string(name='RequestId'),
  contactId?: string(name='ContactId'),
}

model CreateAlertContactResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAlertContactResponseBody(name='body'),
}

async function createAlertContactWithOptions(request: CreateAlertContactRequest, runtime: Util.RuntimeOptions): CreateAlertContactResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateAlertContact', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createAlertContact(request: CreateAlertContactRequest): CreateAlertContactResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAlertContactWithOptions(request, runtime);
}

model CreateAlertContactGroupRequest {
  contactGroupName?: string(name='ContactGroupName'),
  contactIds?: string(name='ContactIds'),
  regionId?: string(name='RegionId'),
  proxyUserId?: string(name='ProxyUserId'),
}

model CreateAlertContactGroupResponseBody = {
  contactGroupId?: string(name='ContactGroupId'),
  requestId?: string(name='RequestId'),
}

model CreateAlertContactGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAlertContactGroupResponseBody(name='body'),
}

async function createAlertContactGroupWithOptions(request: CreateAlertContactGroupRequest, runtime: Util.RuntimeOptions): CreateAlertContactGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateAlertContactGroup', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createAlertContactGroup(request: CreateAlertContactGroupRequest): CreateAlertContactGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAlertContactGroupWithOptions(request, runtime);
}

model CreateRetcodeAppRequest {
  retcodeAppName?: string(name='RetcodeAppName'),
  retcodeAppType?: string(name='RetcodeAppType'),
  regionId?: string(name='RegionId'),
}

model CreateRetcodeAppResponseBody = {
  requestId?: string(name='RequestId'),
  retcodeAppDataBean?: {
    pid?: string(name='Pid'),
    appId?: long(name='AppId'),
  }(name='RetcodeAppDataBean'),
}

model CreateRetcodeAppResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRetcodeAppResponseBody(name='body'),
}

async function createRetcodeAppWithOptions(request: CreateRetcodeAppRequest, runtime: Util.RuntimeOptions): CreateRetcodeAppResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateRetcodeApp', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createRetcodeApp(request: CreateRetcodeAppRequest): CreateRetcodeAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRetcodeAppWithOptions(request, runtime);
}

model CreateWehookRequest {
  contactName?: string(name='ContactName'),
  method?: string(name='Method'),
  url?: string(name='Url'),
  httpParams?: string(name='HttpParams'),
  httpHeaders?: string(name='HttpHeaders'),
  regionId?: string(name='RegionId'),
  proxyUserId?: string(name='ProxyUserId'),
  body?: string(name='Body'),
}

model CreateWehookResponseBody = {
  requestId?: string(name='RequestId'),
  contactId?: string(name='ContactId'),
}

model CreateWehookResponse = {
  headers: map[string]string(name='headers'),
  body: CreateWehookResponseBody(name='body'),
}

async function createWehookWithOptions(request: CreateWehookRequest, runtime: Util.RuntimeOptions): CreateWehookResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateWehook', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createWehook(request: CreateWehookRequest): CreateWehookResponse {
  var runtime = new Util.RuntimeOptions{};
  return createWehookWithOptions(request, runtime);
}

model DeleteAlertContactRequest {
  regionId?: string(name='RegionId'),
  proxyUserId?: string(name='ProxyUserId'),
  contactId?: long(name='ContactId'),
}

model DeleteAlertContactResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model DeleteAlertContactResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAlertContactResponseBody(name='body'),
}

async function deleteAlertContactWithOptions(request: DeleteAlertContactRequest, runtime: Util.RuntimeOptions): DeleteAlertContactResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteAlertContact', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteAlertContact(request: DeleteAlertContactRequest): DeleteAlertContactResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAlertContactWithOptions(request, runtime);
}

model DeleteAlertContactGroupRequest {
  regionId?: string(name='RegionId'),
  proxyUserId?: string(name='ProxyUserId'),
  contactGroupId?: long(name='ContactGroupId'),
}

model DeleteAlertContactGroupResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model DeleteAlertContactGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAlertContactGroupResponseBody(name='body'),
}

async function deleteAlertContactGroupWithOptions(request: DeleteAlertContactGroupRequest, runtime: Util.RuntimeOptions): DeleteAlertContactGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteAlertContactGroup', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteAlertContactGroup(request: DeleteAlertContactGroupRequest): DeleteAlertContactGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAlertContactGroupWithOptions(request, runtime);
}

model DeleteAlertRulesRequest {
  alertIds?: string(name='AlertIds'),
  proxyUserId?: string(name='ProxyUserId'),
  regionId?: string(name='RegionId'),
}

model DeleteAlertRulesResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model DeleteAlertRulesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAlertRulesResponseBody(name='body'),
}

async function deleteAlertRulesWithOptions(request: DeleteAlertRulesRequest, runtime: Util.RuntimeOptions): DeleteAlertRulesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteAlertRules', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteAlertRules(request: DeleteAlertRulesRequest): DeleteAlertRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAlertRulesWithOptions(request, runtime);
}

model DeleteRetcodeAppRequest {
  appId?: string(name='AppId'),
  regionId?: string(name='RegionId'),
}

model DeleteRetcodeAppResponseBody = {
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
}

model DeleteRetcodeAppResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRetcodeAppResponseBody(name='body'),
}

async function deleteRetcodeAppWithOptions(request: DeleteRetcodeAppRequest, runtime: Util.RuntimeOptions): DeleteRetcodeAppResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteRetcodeApp', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteRetcodeApp(request: DeleteRetcodeAppRequest): DeleteRetcodeAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRetcodeAppWithOptions(request, runtime);
}

model DeleteScenarioRequest {
  scenarioId?: long(name='ScenarioId'),
  regionId?: string(name='RegionId'),
}

model DeleteScenarioResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DeleteScenarioResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteScenarioResponseBody(name='body'),
}

async function deleteScenarioWithOptions(request: DeleteScenarioRequest, runtime: Util.RuntimeOptions): DeleteScenarioResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteScenario', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteScenario(request: DeleteScenarioRequest): DeleteScenarioResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteScenarioWithOptions(request, runtime);
}

model DeleteTraceAppRequest {
  appId?: string(name='AppId'),
  regionId?: string(name='RegionId'),
  type?: string(name='Type'),
  pid?: string(name='Pid'),
}

model DeleteTraceAppResponseBody = {
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
}

model DeleteTraceAppResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTraceAppResponseBody(name='body'),
}

async function deleteTraceAppWithOptions(request: DeleteTraceAppRequest, runtime: Util.RuntimeOptions): DeleteTraceAppResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteTraceApp', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteTraceApp(request: DeleteTraceAppRequest): DeleteTraceAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTraceAppWithOptions(request, runtime);
}

model DescribeDispatchRuleRequest {
  id?: string(name='Id'),
  regionId?: string(name='RegionId'),
  proxyUserId?: string(name='ProxyUserId'),
}

model DescribeDispatchRuleResponseBody = {
  requestId?: string(name='RequestId'),
  dispatchRule?: {
    state?: string(name='State'),
    labelMatchExpressionGrid?: {
      labelMatchExpressionGroups?: [ 
        {
          labelMatchExpressions?: [ 
            {
              key?: string(name='Key'),
              value?: string(name='Value'),
              operator?: string(name='Operator'),
            }
          ](name='LabelMatchExpressions'),
        }
      ](name='LabelMatchExpressionGroups'),
    }(name='LabelMatchExpressionGrid'),
    name?: string(name='Name'),
    groupRules?: [ 
      {
        groupingFields?: [ string ](name='GroupingFields'),
        groupId?: long(name='GroupId'),
        groupInterval?: long(name='GroupInterval'),
        groupWaitTime?: long(name='GroupWaitTime'),
      }
    ](name='GroupRules'),
    ruleId?: long(name='RuleId'),
    notifyRules?: [ 
      {
        notifyObjects?: [ 
          {
            notifyObjectId?: string(name='NotifyObjectId'),
            notifyType?: string(name='NotifyType'),
            name?: string(name='Name'),
          }
        ](name='NotifyObjects'),
        notifyChannels?: [ string ](name='NotifyChannels'),
      }
    ](name='NotifyRules'),
  }(name='DispatchRule'),
}

model DescribeDispatchRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDispatchRuleResponseBody(name='body'),
}

async function describeDispatchRuleWithOptions(request: DescribeDispatchRuleRequest, runtime: Util.RuntimeOptions): DescribeDispatchRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeDispatchRule', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeDispatchRule(request: DescribeDispatchRuleRequest): DescribeDispatchRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDispatchRuleWithOptions(request, runtime);
}

model DescribeTraceLicenseKeyRequest {
  regionId?: string(name='RegionId'),
}

model DescribeTraceLicenseKeyResponseBody = {
  requestId?: string(name='RequestId'),
  licenseKey?: string(name='LicenseKey'),
}

model DescribeTraceLicenseKeyResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeTraceLicenseKeyResponseBody(name='body'),
}

async function describeTraceLicenseKeyWithOptions(request: DescribeTraceLicenseKeyRequest, runtime: Util.RuntimeOptions): DescribeTraceLicenseKeyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeTraceLicenseKey', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeTraceLicenseKey(request: DescribeTraceLicenseKeyRequest): DescribeTraceLicenseKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTraceLicenseKeyWithOptions(request, runtime);
}

model DescribeTraceLocationRequest {
  regionId?: string(name='RegionId'),
}

model DescribeTraceLocationResponseBody = {
  requestId?: string(name='RequestId'),
  regionConfigs?: [ 
    {
      regionNo?: string(name='RegionNo'),
      url?: string(name='Url'),
    }
  ](name='RegionConfigs'),
}

model DescribeTraceLocationResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeTraceLocationResponseBody(name='body'),
}

async function describeTraceLocationWithOptions(request: DescribeTraceLocationRequest, runtime: Util.RuntimeOptions): DescribeTraceLocationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeTraceLocation', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeTraceLocation(request: DescribeTraceLocationRequest): DescribeTraceLocationResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTraceLocationWithOptions(request, runtime);
}

model ExportPrometheusRulesRequest {
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  nameSpace?: string(name='NameSpace'),
  name?: string(name='Name'),
}

model ExportPrometheusRulesResponseBody = {
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
}

model ExportPrometheusRulesResponse = {
  headers: map[string]string(name='headers'),
  body: ExportPrometheusRulesResponseBody(name='body'),
}

async function exportPrometheusRulesWithOptions(request: ExportPrometheusRulesRequest, runtime: Util.RuntimeOptions): ExportPrometheusRulesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ExportPrometheusRules', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function exportPrometheusRules(request: ExportPrometheusRulesRequest): ExportPrometheusRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return exportPrometheusRulesWithOptions(request, runtime);
}

model GetAgentDownloadUrlRequest {
  regionId?: string(name='RegionId'),
}

model GetAgentDownloadUrlResponseBody = {
  armsAgentDownloadUrl?: string(name='ArmsAgentDownloadUrl'),
  requestId?: string(name='RequestId'),
}

model GetAgentDownloadUrlResponse = {
  headers: map[string]string(name='headers'),
  body: GetAgentDownloadUrlResponseBody(name='body'),
}

async function getAgentDownloadUrlWithOptions(request: GetAgentDownloadUrlRequest, runtime: Util.RuntimeOptions): GetAgentDownloadUrlResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('GetAgentDownloadUrl', '2019-08-08', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function getAgentDownloadUrl(request: GetAgentDownloadUrlRequest): GetAgentDownloadUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAgentDownloadUrlWithOptions(request, runtime);
}

model GetAppApiByPageRequest {
  regionId?: string(name='RegionId'),
  startTime?: long(name='StartTime'),
  endTime?: long(name='EndTime'),
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  intervalMills?: int32(name='IntervalMills'),
  PId?: string(name='PId'),
}

model GetAppApiByPageResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    items?: [  map[string]any ](name='Items'),
    pageSize?: int32(name='PageSize'),
    total?: string(name='Total'),
    page?: int32(name='Page'),
  }(name='Data'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model GetAppApiByPageResponse = {
  headers: map[string]string(name='headers'),
  body: GetAppApiByPageResponseBody(name='body'),
}

async function getAppApiByPageWithOptions(request: GetAppApiByPageRequest, runtime: Util.RuntimeOptions): GetAppApiByPageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetAppApiByPage', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getAppApiByPage(request: GetAppApiByPageRequest): GetAppApiByPageResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAppApiByPageWithOptions(request, runtime);
}

model GetConsistencySnapshotRequest {
  currentTimestamp?: long(name='CurrentTimestamp'),
  regionId?: string(name='RegionId'),
  proxyUserId?: string(name='ProxyUserId'),
  pid?: string(name='Pid'),
  appType?: string(name='AppType'),
}

model GetConsistencySnapshotResponseBody = {
  requestId?: string(name='RequestId'),
  consistencyResultJsonStr?: string(name='ConsistencyResultJsonStr'),
}

model GetConsistencySnapshotResponse = {
  headers: map[string]string(name='headers'),
  body: GetConsistencySnapshotResponseBody(name='body'),
}

async function getConsistencySnapshotWithOptions(request: GetConsistencySnapshotRequest, runtime: Util.RuntimeOptions): GetConsistencySnapshotResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetConsistencySnapshot', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getConsistencySnapshot(request: GetConsistencySnapshotRequest): GetConsistencySnapshotResponse {
  var runtime = new Util.RuntimeOptions{};
  return getConsistencySnapshotWithOptions(request, runtime);
}

model GetIntegrationTokenRequest {
  productType?: string(name='ProductType'),
  regionId?: string(name='RegionId'),
  proxyUserId?: string(name='ProxyUserId'),
}

model GetIntegrationTokenResponseBody = {
  requestId?: string(name='RequestId'),
  token?: string(name='Token'),
}

model GetIntegrationTokenResponse = {
  headers: map[string]string(name='headers'),
  body: GetIntegrationTokenResponseBody(name='body'),
}

async function getIntegrationTokenWithOptions(request: GetIntegrationTokenRequest, runtime: Util.RuntimeOptions): GetIntegrationTokenResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetIntegrationToken', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getIntegrationToken(request: GetIntegrationTokenRequest): GetIntegrationTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return getIntegrationTokenWithOptions(request, runtime);
}

model GetMultipleTraceRequest {
  regionId?: string(name='RegionId'),
  traceIDs?: [ string ](name='TraceIDs'),
}

model GetMultipleTraceResponseBody = {
  requestId?: string(name='RequestId'),
  multiCallChainInfos?: [ 
    {
      spans?: [ 
        {
          operationName?: string(name='OperationName'),
          resultCode?: string(name='ResultCode'),
          timestamp?: long(name='Timestamp'),
          rpcType?: int32(name='RpcType'),
          tagEntryList?: [ 
            {
              key?: string(name='Key'),
              value?: string(name='Value'),
            }
          ](name='TagEntryList'),
          logEventList?: [ 
            {
              tagEntryList?: [ 
                {
                  key?: string(name='Key'),
                  value?: string(name='Value'),
                }
              ](name='TagEntryList'),
              timestamp?: long(name='Timestamp'),
            }
          ](name='LogEventList'),
          haveStack?: boolean(name='HaveStack'),
          serviceIp?: string(name='ServiceIp'),
          duration?: long(name='Duration'),
          rpcId?: string(name='RpcId'),
          serviceName?: string(name='ServiceName'),
          traceID?: string(name='TraceID'),
        }
      ](name='Spans'),
      traceID?: string(name='TraceID'),
    }
  ](name='MultiCallChainInfos'),
}

model GetMultipleTraceResponse = {
  headers: map[string]string(name='headers'),
  body: GetMultipleTraceResponseBody(name='body'),
}

async function getMultipleTraceWithOptions(request: GetMultipleTraceRequest, runtime: Util.RuntimeOptions): GetMultipleTraceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetMultipleTrace', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getMultipleTrace(request: GetMultipleTraceRequest): GetMultipleTraceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMultipleTraceWithOptions(request, runtime);
}

model GetPrometheusApiTokenRequest {
  regionId?: string(name='RegionId'),
}

model GetPrometheusApiTokenResponseBody = {
  requestId?: string(name='RequestId'),
  token?: string(name='Token'),
}

model GetPrometheusApiTokenResponse = {
  headers: map[string]string(name='headers'),
  body: GetPrometheusApiTokenResponseBody(name='body'),
}

async function getPrometheusApiTokenWithOptions(request: GetPrometheusApiTokenRequest, runtime: Util.RuntimeOptions): GetPrometheusApiTokenResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetPrometheusApiToken', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getPrometheusApiToken(request: GetPrometheusApiTokenRequest): GetPrometheusApiTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPrometheusApiTokenWithOptions(request, runtime);
}

model GetRetcodeShareUrlRequest {
  pid?: string(name='Pid'),
}

model GetRetcodeShareUrlResponseBody = {
  requestId?: string(name='RequestId'),
  url?: string(name='Url'),
}

model GetRetcodeShareUrlResponse = {
  headers: map[string]string(name='headers'),
  body: GetRetcodeShareUrlResponseBody(name='body'),
}

async function getRetcodeShareUrlWithOptions(request: GetRetcodeShareUrlRequest, runtime: Util.RuntimeOptions): GetRetcodeShareUrlResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetRetcodeShareUrl', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getRetcodeShareUrl(request: GetRetcodeShareUrlRequest): GetRetcodeShareUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRetcodeShareUrlWithOptions(request, runtime);
}

model GetStackRequest {
  traceID?: string(name='TraceID'),
  regionId?: string(name='RegionId'),
  rpcID?: string(name='RpcID'),
  pid?: string(name='Pid'),
}

model GetStackResponseBody = {
  requestId?: string(name='RequestId'),
  stackInfo?: [ 
    {
      startTime?: long(name='StartTime'),
      exception?: string(name='Exception'),
      api?: string(name='Api'),
      line?: string(name='Line'),
      duration?: long(name='Duration'),
      rpcId?: string(name='RpcId'),
      serviceName?: string(name='ServiceName'),
      extInfo?: {
        type?: string(name='Type'),
        info?: string(name='Info'),
      }(name='ExtInfo'),
    }
  ](name='StackInfo'),
}

model GetStackResponse = {
  headers: map[string]string(name='headers'),
  body: GetStackResponseBody(name='body'),
}

async function getStackWithOptions(request: GetStackRequest, runtime: Util.RuntimeOptions): GetStackResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetStack', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getStack(request: GetStackRequest): GetStackResponse {
  var runtime = new Util.RuntimeOptions{};
  return getStackWithOptions(request, runtime);
}

model GetTraceRequest {
  traceID?: string(name='TraceID'),
  regionId?: string(name='RegionId'),
}

model GetTraceResponseBody = {
  requestId?: string(name='RequestId'),
  spans?: [ 
    {
      operationName?: string(name='OperationName'),
      resultCode?: string(name='ResultCode'),
      timestamp?: long(name='Timestamp'),
      rpcType?: int32(name='RpcType'),
      tagEntryList?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='TagEntryList'),
      logEventList?: [ 
        {
          tagEntryList?: [ 
            {
              key?: string(name='Key'),
              value?: string(name='Value'),
            }
          ](name='TagEntryList'),
          timestamp?: long(name='Timestamp'),
        }
      ](name='LogEventList'),
      haveStack?: boolean(name='HaveStack'),
      serviceIp?: string(name='ServiceIp'),
      duration?: long(name='Duration'),
      rpcId?: string(name='RpcId'),
      serviceName?: string(name='ServiceName'),
      traceID?: string(name='TraceID'),
    }
  ](name='Spans'),
}

model GetTraceResponse = {
  headers: map[string]string(name='headers'),
  body: GetTraceResponseBody(name='body'),
}

async function getTraceWithOptions(request: GetTraceRequest, runtime: Util.RuntimeOptions): GetTraceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetTrace', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getTrace(request: GetTraceRequest): GetTraceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTraceWithOptions(request, runtime);
}

model GetTraceAppRequest {
  pid?: string(name='Pid'),
  regionId?: string(name='RegionId'),
}

model GetTraceAppResponseBody = {
  requestId?: string(name='RequestId'),
  traceApp?: {
    type?: string(name='Type'),
    appName?: string(name='AppName'),
    updateTime?: long(name='UpdateTime'),
    labels?: [ string ](name='Labels'),
    show?: boolean(name='Show'),
    createTime?: long(name='CreateTime'),
    pid?: string(name='Pid'),
    appId?: long(name='AppId'),
    userId?: string(name='UserId'),
    regionId?: string(name='RegionId'),
  }(name='TraceApp'),
}

model GetTraceAppResponse = {
  headers: map[string]string(name='headers'),
  body: GetTraceAppResponseBody(name='body'),
}

async function getTraceAppWithOptions(request: GetTraceAppRequest, runtime: Util.RuntimeOptions): GetTraceAppResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetTraceApp', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getTraceApp(request: GetTraceAppRequest): GetTraceAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTraceAppWithOptions(request, runtime);
}

model ImportAppAlertRulesRequest {
  templateAlertId?: string(name='TemplateAlertId'),
  pids?: string(name='Pids'),
  regionId?: string(name='RegionId'),
  contactGroupIds?: string(name='ContactGroupIds'),
  isAutoStart?: boolean(name='IsAutoStart'),
  templageAlertConfig?: string(name='TemplageAlertConfig'),
  proxyUserId?: string(name='ProxyUserId'),
}

model ImportAppAlertRulesResponseBody = {
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
}

model ImportAppAlertRulesResponse = {
  headers: map[string]string(name='headers'),
  body: ImportAppAlertRulesResponseBody(name='body'),
}

async function importAppAlertRulesWithOptions(request: ImportAppAlertRulesRequest, runtime: Util.RuntimeOptions): ImportAppAlertRulesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ImportAppAlertRules', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function importAppAlertRules(request: ImportAppAlertRulesRequest): ImportAppAlertRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return importAppAlertRulesWithOptions(request, runtime);
}

model ImportCustomAlertRulesRequest {
  regionId?: string(name='RegionId'),
  contactGroupIds?: string(name='ContactGroupIds'),
  isAutoStart?: boolean(name='IsAutoStart'),
  templateAlertConfig?: string(name='TemplateAlertConfig'),
  proxyUserId?: string(name='ProxyUserId'),
  templageAlertConfig?: string(name='TemplageAlertConfig'),
}

model ImportCustomAlertRulesResponseBody = {
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
}

model ImportCustomAlertRulesResponse = {
  headers: map[string]string(name='headers'),
  body: ImportCustomAlertRulesResponseBody(name='body'),
}

async function importCustomAlertRulesWithOptions(request: ImportCustomAlertRulesRequest, runtime: Util.RuntimeOptions): ImportCustomAlertRulesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ImportCustomAlertRules', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function importCustomAlertRules(request: ImportCustomAlertRulesRequest): ImportCustomAlertRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return importCustomAlertRulesWithOptions(request, runtime);
}

model ImportPrometheusRulesRequest {
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  nameSpace?: string(name='NameSpace'),
  name?: string(name='Name'),
  content?: string(name='Content'),
}

model ImportPrometheusRulesResponseBody = {
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
}

model ImportPrometheusRulesResponse = {
  headers: map[string]string(name='headers'),
  body: ImportPrometheusRulesResponseBody(name='body'),
}

async function importPrometheusRulesWithOptions(request: ImportPrometheusRulesRequest, runtime: Util.RuntimeOptions): ImportPrometheusRulesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ImportPrometheusRules', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function importPrometheusRules(request: ImportPrometheusRulesRequest): ImportPrometheusRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return importPrometheusRulesWithOptions(request, runtime);
}

model ListClusterFromGrafanaRequest {
  regionId?: string(name='RegionId'),
}

model ListClusterFromGrafanaResponseBody = {
  requestId?: string(name='RequestId'),
  promClusterList?: [ 
    {
      updateTime?: long(name='UpdateTime'),
      createTime?: long(name='CreateTime'),
      userId?: string(name='UserId'),
      options?: string(name='Options'),
      isControllerInstalled?: boolean(name='IsControllerInstalled'),
      agentStatus?: string(name='AgentStatus'),
      extra?: string(name='Extra'),
      controllerId?: string(name='ControllerId'),
      regionId?: string(name='RegionId'),
      installTime?: long(name='InstallTime'),
      pluginsJsonArray?: string(name='PluginsJsonArray'),
      clusterType?: string(name='ClusterType'),
      clusterName?: string(name='ClusterName'),
      stateJson?: string(name='StateJson'),
      lastHeartBeatTime?: long(name='LastHeartBeatTime'),
      nodeNum?: int32(name='NodeNum'),
      id?: long(name='Id'),
      clusterId?: string(name='ClusterId'),
    }
  ](name='PromClusterList'),
}

model ListClusterFromGrafanaResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterFromGrafanaResponseBody(name='body'),
}

async function listClusterFromGrafanaWithOptions(request: ListClusterFromGrafanaRequest, runtime: Util.RuntimeOptions): ListClusterFromGrafanaResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListClusterFromGrafana', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listClusterFromGrafana(request: ListClusterFromGrafanaRequest): ListClusterFromGrafanaResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterFromGrafanaWithOptions(request, runtime);
}

model ListDashboardsRequest {
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  clusterType?: string(name='ClusterType'),
  title?: string(name='Title'),
}

model ListDashboardsResponseBody = {
  dashboardVos?: [ 
    {
      type?: string(name='Type'),
      time?: string(name='Time'),
      exporter?: string(name='Exporter'),
      isArmsExporter?: boolean(name='IsArmsExporter'),
      url?: string(name='Url'),
      tags?: [ string ](name='Tags'),
      title?: string(name='Title'),
      id?: string(name='Id'),
      uid?: string(name='Uid'),
    }
  ](name='DashboardVos'),
  requestId?: string(name='RequestId'),
}

model ListDashboardsResponse = {
  headers: map[string]string(name='headers'),
  body: ListDashboardsResponseBody(name='body'),
}

async function listDashboardsWithOptions(request: ListDashboardsRequest, runtime: Util.RuntimeOptions): ListDashboardsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListDashboards', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listDashboards(request: ListDashboardsRequest): ListDashboardsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDashboardsWithOptions(request, runtime);
}

model ListPromClustersRequest {
  regionId?: string(name='RegionId'),
}

model ListPromClustersResponseBody = {
  requestId?: string(name='RequestId'),
  promClusterList?: [ 
    {
      updateTime?: long(name='UpdateTime'),
      createTime?: long(name='CreateTime'),
      userId?: string(name='UserId'),
      options?: string(name='Options'),
      isControllerInstalled?: boolean(name='IsControllerInstalled'),
      agentStatus?: string(name='AgentStatus'),
      extra?: string(name='Extra'),
      controllerId?: string(name='ControllerId'),
      regionId?: string(name='RegionId'),
      installTime?: long(name='InstallTime'),
      pluginsJsonArray?: string(name='PluginsJsonArray'),
      clusterType?: string(name='ClusterType'),
      clusterName?: string(name='ClusterName'),
      stateJson?: string(name='StateJson'),
      lastHeartBeatTime?: long(name='LastHeartBeatTime'),
      nodeNum?: int32(name='NodeNum'),
      id?: long(name='Id'),
      clusterId?: string(name='ClusterId'),
    }
  ](name='PromClusterList'),
}

model ListPromClustersResponse = {
  headers: map[string]string(name='headers'),
  body: ListPromClustersResponseBody(name='body'),
}

async function listPromClustersWithOptions(request: ListPromClustersRequest, runtime: Util.RuntimeOptions): ListPromClustersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListPromClusters', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listPromClusters(request: ListPromClustersRequest): ListPromClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPromClustersWithOptions(request, runtime);
}

model ListRetcodeAppsRequest {
  securityToken?: string(name='SecurityToken'),
  regionId?: string(name='RegionId'),
}

model ListRetcodeAppsResponseBody = {
  requestId?: string(name='RequestId'),
  retcodeApps?: [ 
    {
      appName?: string(name='AppName'),
      appId?: long(name='AppId'),
      pid?: string(name='Pid'),
    }
  ](name='RetcodeApps'),
}

model ListRetcodeAppsResponse = {
  headers: map[string]string(name='headers'),
  body: ListRetcodeAppsResponseBody(name='body'),
}

async function listRetcodeAppsWithOptions(request: ListRetcodeAppsRequest, runtime: Util.RuntimeOptions): ListRetcodeAppsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListRetcodeApps', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listRetcodeApps(request: ListRetcodeAppsRequest): ListRetcodeAppsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRetcodeAppsWithOptions(request, runtime);
}

model ListScenarioRequest {
  regionId?: string(name='RegionId'),
  scenario?: string(name='Scenario'),
  name?: string(name='Name'),
  appId?: string(name='AppId'),
  sign?: string(name='Sign'),
}

model ListScenarioResponseBody = {
  requestId?: string(name='RequestId'),
  armsScenarios?: [ 
    {
      updateTime?: string(name='UpdateTime'),
      appId?: string(name='AppId'),
      sign?: string(name='Sign'),
      createTime?: string(name='CreateTime'),
      userId?: string(name='UserId'),
      extensions?: string(name='Extensions'),
      name?: string(name='Name'),
      id?: long(name='Id'),
      regionId?: string(name='RegionId'),
    }
  ](name='ArmsScenarios'),
}

model ListScenarioResponse = {
  headers: map[string]string(name='headers'),
  body: ListScenarioResponseBody(name='body'),
}

async function listScenarioWithOptions(request: ListScenarioRequest, runtime: Util.RuntimeOptions): ListScenarioResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListScenario', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listScenario(request: ListScenarioRequest): ListScenarioResponse {
  var runtime = new Util.RuntimeOptions{};
  return listScenarioWithOptions(request, runtime);
}

model ListTraceAppsRequest {
  regionId?: string(name='RegionId'),
}

model ListTraceAppsResponseBody = {
  traceApps?: [ 
    {
      type?: string(name='Type'),
      appName?: string(name='AppName'),
      updateTime?: long(name='UpdateTime'),
      labels?: [ string ](name='Labels'),
      show?: boolean(name='Show'),
      createTime?: long(name='CreateTime'),
      pid?: string(name='Pid'),
      appId?: long(name='AppId'),
      userId?: string(name='UserId'),
      regionId?: string(name='RegionId'),
    }
  ](name='TraceApps'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model ListTraceAppsResponse = {
  headers: map[string]string(name='headers'),
  body: ListTraceAppsResponseBody(name='body'),
}

async function listTraceAppsWithOptions(request: ListTraceAppsRequest, runtime: Util.RuntimeOptions): ListTraceAppsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListTraceApps', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listTraceApps(request: ListTraceAppsRequest): ListTraceAppsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTraceAppsWithOptions(request, runtime);
}

model OpenArmsServiceRequest {
  ownerId?: long(name='OwnerId'),
  type?: string(name='Type'),
}

model OpenArmsServiceResponseBody = {
  requestId?: string(name='RequestId'),
  orderId?: string(name='OrderId'),
}

model OpenArmsServiceResponse = {
  headers: map[string]string(name='headers'),
  body: OpenArmsServiceResponseBody(name='body'),
}

async function openArmsServiceWithOptions(request: OpenArmsServiceRequest, runtime: Util.RuntimeOptions): OpenArmsServiceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('OpenArmsService', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function openArmsService(request: OpenArmsServiceRequest): OpenArmsServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return openArmsServiceWithOptions(request, runtime);
}

model QueryDatasetRequest {
  datasetId?: long(name='DatasetId'),
  intervalInSec?: int32(name='IntervalInSec'),
  dateStr?: string(name='DateStr'),
  minTime?: long(name='MinTime'),
  maxTime?: long(name='MaxTime'),
  isDrillDown?: boolean(name='IsDrillDown'),
  orderByKey?: string(name='OrderByKey'),
  limit?: int32(name='Limit'),
  reduceTail?: boolean(name='ReduceTail'),
  hungryMode?: boolean(name='HungryMode'),
  proxyUserId?: string(name='ProxyUserId'),
  measures?: [ string ](name='Measures'),
  dimensions?: [ 
    {
      key?: string(name='Key'),
      type?: string(name='Type'),
      value?: string(name='Value'),
    }
  ](name='Dimensions'),
  requiredDims?: [ 
    {
      key?: string(name='Key'),
      type?: string(name='Type'),
      value?: string(name='Value'),
    }
  ](name='RequiredDims'),
  optionalDims?: [ 
    {
      key?: string(name='Key'),
      type?: string(name='Type'),
      value?: string(name='Value'),
    }
  ](name='OptionalDims'),
}

model QueryDatasetResponseBody = {
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
}

model QueryDatasetResponse = {
  headers: map[string]string(name='headers'),
  body: QueryDatasetResponseBody(name='body'),
}

async function queryDatasetWithOptions(request: QueryDatasetRequest, runtime: Util.RuntimeOptions): QueryDatasetResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryDataset', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryDataset(request: QueryDatasetRequest): QueryDatasetResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDatasetWithOptions(request, runtime);
}

model QueryMetricRequest {
  intervalInSec?: int32(name='IntervalInSec'),
  startTime?: long(name='StartTime'),
  endTime?: long(name='EndTime'),
  orderBy?: string(name='OrderBy'),
  limit?: int32(name='Limit'),
  metric?: string(name='Metric'),
  order?: string(name='Order'),
  proxyUserId?: string(name='ProxyUserId'),
  consistencyDataKey?: string(name='ConsistencyDataKey'),
  consistencyQueryStrategy?: string(name='ConsistencyQueryStrategy'),
  filters?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Filters'),
  dimensions?: [ string ](name='Dimensions'),
  measures?: [ string ](name='Measures'),
}

model QueryMetricResponseBody = {
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
}

model QueryMetricResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMetricResponseBody(name='body'),
}

async function queryMetricWithOptions(request: QueryMetricRequest, runtime: Util.RuntimeOptions): QueryMetricResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryMetric', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryMetric(request: QueryMetricRequest): QueryMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMetricWithOptions(request, runtime);
}

model QueryMetricByPageRequest {
  intervalInSec?: int32(name='IntervalInSec'),
  startTime?: long(name='StartTime'),
  endTime?: long(name='EndTime'),
  orderBy?: string(name='OrderBy'),
  metric?: string(name='Metric'),
  order?: string(name='Order'),
  proxyUserId?: string(name='ProxyUserId'),
  consistencyDataKey?: string(name='ConsistencyDataKey'),
  consistencyQueryStrategy?: string(name='ConsistencyQueryStrategy'),
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  filters?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Filters'),
  dimensions?: [ string ](name='Dimensions'),
  measures?: [ string ](name='Measures'),
}

model QueryMetricByPageResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    items?: [  map[string]any ](name='Items'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
    page?: int32(name='Page'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model QueryMetricByPageResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMetricByPageResponseBody(name='body'),
}

async function queryMetricByPageWithOptions(request: QueryMetricByPageRequest, runtime: Util.RuntimeOptions): QueryMetricByPageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryMetricByPage', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryMetricByPage(request: QueryMetricByPageRequest): QueryMetricByPageResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMetricByPageWithOptions(request, runtime);
}

model SaveTraceAppConfigRequest {
  pid?: string(name='Pid'),
  settings?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Settings'),
}

model SaveTraceAppConfigResponseBody = {
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
}

model SaveTraceAppConfigResponse = {
  headers: map[string]string(name='headers'),
  body: SaveTraceAppConfigResponseBody(name='body'),
}

async function saveTraceAppConfigWithOptions(request: SaveTraceAppConfigRequest, runtime: Util.RuntimeOptions): SaveTraceAppConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveTraceAppConfig', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveTraceAppConfig(request: SaveTraceAppConfigRequest): SaveTraceAppConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveTraceAppConfigWithOptions(request, runtime);
}

model SearchAlertContactRequest {
  contactName?: string(name='ContactName'),
  phone?: string(name='Phone'),
  email?: string(name='Email'),
  currentPage?: string(name='CurrentPage'),
  pageSize?: string(name='PageSize'),
  regionId?: string(name='RegionId'),
  proxyUserId?: string(name='ProxyUserId'),
  contactIds?: string(name='ContactIds'),
}

model SearchAlertContactResponseBody = {
  pageBean?: {
    contacts?: [ 
      {
        updateTime?: long(name='UpdateTime'),
        dingRobot?: string(name='DingRobot'),
        webhook?: string(name='Webhook'),
        email?: string(name='Email'),
        contactId?: long(name='ContactId'),
        createTime?: long(name='CreateTime'),
        userId?: string(name='UserId'),
        contactName?: string(name='ContactName'),
        systemNoc?: boolean(name='SystemNoc'),
        phone?: string(name='Phone'),
      }
    ](name='Contacts'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model SearchAlertContactResponse = {
  headers: map[string]string(name='headers'),
  body: SearchAlertContactResponseBody(name='body'),
}

async function searchAlertContactWithOptions(request: SearchAlertContactRequest, runtime: Util.RuntimeOptions): SearchAlertContactResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SearchAlertContact', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function searchAlertContact(request: SearchAlertContactRequest): SearchAlertContactResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchAlertContactWithOptions(request, runtime);
}

model SearchAlertContactGroupRequest {
  contactGroupName?: string(name='ContactGroupName'),
  regionId?: string(name='RegionId'),
  proxyUserId?: string(name='ProxyUserId'),
  contactName?: string(name='ContactName'),
  contactId?: long(name='ContactId'),
  contactGroupIds?: string(name='ContactGroupIds'),
  isDetail?: boolean(name='IsDetail'),
}

model SearchAlertContactGroupResponseBody = {
  contactGroups?: [ 
    {
      updateTime?: long(name='UpdateTime'),
      contactGroupName?: string(name='ContactGroupName'),
      contacts?: [ 
        {
          updateTime?: long(name='UpdateTime'),
          dingRobot?: string(name='DingRobot'),
          email?: string(name='Email'),
          contactId?: long(name='ContactId'),
          createTime?: long(name='CreateTime'),
          userId?: string(name='UserId'),
          contactName?: string(name='ContactName'),
          systemNoc?: boolean(name='SystemNoc'),
          phone?: string(name='Phone'),
        }
      ](name='Contacts'),
      contactGroupId?: long(name='ContactGroupId'),
      createTime?: long(name='CreateTime'),
      userId?: string(name='UserId'),
    }
  ](name='ContactGroups'),
  requestId?: string(name='RequestId'),
}

model SearchAlertContactGroupResponse = {
  headers: map[string]string(name='headers'),
  body: SearchAlertContactGroupResponseBody(name='body'),
}

async function searchAlertContactGroupWithOptions(request: SearchAlertContactGroupRequest, runtime: Util.RuntimeOptions): SearchAlertContactGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SearchAlertContactGroup', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function searchAlertContactGroup(request: SearchAlertContactGroupRequest): SearchAlertContactGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchAlertContactGroupWithOptions(request, runtime);
}

model SearchAlertHistoriesRequest {
  proxyUserId?: string(name='ProxyUserId'),
  alertId?: long(name='AlertId'),
  alertType?: int32(name='AlertType'),
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  startTime?: long(name='StartTime'),
  endTime?: long(name='EndTime'),
}

model SearchAlertHistoriesResponseBody = {
  pageBean?: {
    alarmHistories?: [ 
      {
        alarmTime?: long(name='AlarmTime'),
        strategyId?: string(name='StrategyId'),
        alarmResponseCode?: int32(name='AlarmResponseCode'),
        emails?: string(name='Emails'),
        userId?: string(name='UserId'),
        alarmSources?: string(name='AlarmSources'),
        alarmContent?: string(name='AlarmContent'),
        phones?: string(name='Phones'),
        alarmType?: int32(name='AlarmType'),
        target?: string(name='Target'),
        id?: long(name='Id'),
      }
    ](name='AlarmHistories'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model SearchAlertHistoriesResponse = {
  headers: map[string]string(name='headers'),
  body: SearchAlertHistoriesResponseBody(name='body'),
}

async function searchAlertHistoriesWithOptions(request: SearchAlertHistoriesRequest, runtime: Util.RuntimeOptions): SearchAlertHistoriesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SearchAlertHistories', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function searchAlertHistories(request: SearchAlertHistoriesRequest): SearchAlertHistoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchAlertHistoriesWithOptions(request, runtime);
}

model SearchAlertRulesRequest {
  proxyUserId?: string(name='ProxyUserId'),
  title?: string(name='Title'),
  type?: string(name='Type'),
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  pid?: string(name='Pid'),
  appType?: string(name='AppType'),
}

model SearchAlertRulesResponseBody = {
  pageBean?: {
    alertRules?: [ 
      {
        status?: string(name='Status'),
        alarmContext?: {
          alarmContentSubTitle?: string(name='AlarmContentSubTitle'),
          alarmContentTemplate?: string(name='AlarmContentTemplate'),
          subTitle?: string(name='SubTitle'),
          content?: string(name='Content'),
        }(name='AlarmContext'),
        updateTime?: long(name='UpdateTime'),
        contactGroupIdList?: string(name='ContactGroupIdList'),
        notice?: {
          endTime?: long(name='EndTime'),
          noticeEndTime?: long(name='NoticeEndTime'),
          startTime?: long(name='StartTime'),
          noticeStartTime?: long(name='NoticeStartTime'),
        }(name='Notice'),
        createTime?: long(name='CreateTime'),
        alertTitle?: string(name='AlertTitle'),
        userId?: string(name='UserId'),
        alertVersion?: int32(name='AlertVersion'),
        alertRule?: {
          operator?: string(name='Operator'),
          rules?: [ 
            {
              measure?: string(name='Measure'),
              value?: float(name='Value'),
              aggregates?: string(name='Aggregates'),
              NValue?: int32(name='NValue'),
              operator?: string(name='Operator'),
              alias?: string(name='Alias'),
            }
          ](name='Rules'),
        }(name='AlertRule'),
        metricParam?: {
          type?: string(name='Type'),
          appGroupId?: string(name='AppGroupId'),
          appId?: string(name='AppId'),
          pid?: string(name='Pid'),
          dimensions?: [ 
            {
              key?: string(name='Key'),
              type?: string(name='Type'),
              value?: string(name='Value'),
            }
          ](name='Dimensions'),
        }(name='MetricParam'),
        alertType?: int32(name='AlertType'),
        contactGroupIds?: string(name='ContactGroupIds'),
        config?: string(name='Config'),
        regionId?: string(name='RegionId'),
        alertLevel?: string(name='AlertLevel'),
        alertWay?: [ string ](name='AlertWay'),
        taskStatus?: string(name='TaskStatus'),
        title?: string(name='Title'),
        taskId?: long(name='TaskId'),
        id?: long(name='Id'),
        alertWays?: [ string ](name='AlertWays'),
      }
    ](name='AlertRules'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model SearchAlertRulesResponse = {
  headers: map[string]string(name='headers'),
  body: SearchAlertRulesResponseBody(name='body'),
}

async function searchAlertRulesWithOptions(request: SearchAlertRulesRequest, runtime: Util.RuntimeOptions): SearchAlertRulesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SearchAlertRules', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function searchAlertRules(request: SearchAlertRulesRequest): SearchAlertRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchAlertRulesWithOptions(request, runtime);
}

model SearchEventsRequest {
  proxyUserId?: string(name='ProxyUserId'),
  alertId?: long(name='AlertId'),
  pid?: string(name='Pid'),
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  appType?: string(name='AppType'),
  alertType?: int32(name='AlertType'),
  isTrigger?: int32(name='IsTrigger'),
  startTime?: long(name='StartTime'),
  endTime?: long(name='EndTime'),
}

model SearchEventsResponseBody = {
  pageBean?: {
    event?: [ 
      {
        eventTime?: long(name='EventTime'),
        links?: [ string ](name='Links'),
        eventLevel?: string(name='EventLevel'),
        alertRule?: string(name='AlertRule'),
        message?: string(name='Message'),
        alertType?: int32(name='AlertType'),
        alertName?: string(name='AlertName'),
        id?: long(name='Id'),
        alertId?: long(name='AlertId'),
      }
    ](name='Event'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
  isTrigger?: int32(name='IsTrigger'),
}

model SearchEventsResponse = {
  headers: map[string]string(name='headers'),
  body: SearchEventsResponseBody(name='body'),
}

async function searchEventsWithOptions(request: SearchEventsRequest, runtime: Util.RuntimeOptions): SearchEventsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SearchEvents', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function searchEvents(request: SearchEventsRequest): SearchEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchEventsWithOptions(request, runtime);
}

model SearchRetcodeAppByPageRequest {
  retcodeAppName?: string(name='RetcodeAppName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
}

model SearchRetcodeAppByPageResponseBody = {
  pageBean?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    retcodeApps?: [ 
      {
        type?: string(name='Type'),
        appName?: string(name='AppName'),
        updateTime?: long(name='UpdateTime'),
        createTime?: long(name='CreateTime'),
        appId?: long(name='AppId'),
        pid?: string(name='Pid'),
        userId?: string(name='UserId'),
        regionId?: string(name='RegionId'),
      }
    ](name='RetcodeApps'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model SearchRetcodeAppByPageResponse = {
  headers: map[string]string(name='headers'),
  body: SearchRetcodeAppByPageResponseBody(name='body'),
}

async function searchRetcodeAppByPageWithOptions(request: SearchRetcodeAppByPageRequest, runtime: Util.RuntimeOptions): SearchRetcodeAppByPageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SearchRetcodeAppByPage', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function searchRetcodeAppByPage(request: SearchRetcodeAppByPageRequest): SearchRetcodeAppByPageResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchRetcodeAppByPageWithOptions(request, runtime);
}

model SearchTraceAppByNameRequest {
  traceAppName?: string(name='TraceAppName'),
  regionId?: string(name='RegionId'),
}

model SearchTraceAppByNameResponseBody = {
  traceApps?: [ 
    {
      type?: string(name='Type'),
      appName?: string(name='AppName'),
      updateTime?: long(name='UpdateTime'),
      labels?: [ string ](name='Labels'),
      show?: boolean(name='Show'),
      createTime?: long(name='CreateTime'),
      pid?: string(name='Pid'),
      appId?: long(name='AppId'),
      userId?: string(name='UserId'),
      regionId?: string(name='RegionId'),
    }
  ](name='TraceApps'),
  requestId?: string(name='RequestId'),
}

model SearchTraceAppByNameResponse = {
  headers: map[string]string(name='headers'),
  body: SearchTraceAppByNameResponseBody(name='body'),
}

async function searchTraceAppByNameWithOptions(request: SearchTraceAppByNameRequest, runtime: Util.RuntimeOptions): SearchTraceAppByNameResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SearchTraceAppByName', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function searchTraceAppByName(request: SearchTraceAppByNameRequest): SearchTraceAppByNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchTraceAppByNameWithOptions(request, runtime);
}

model SearchTraceAppByPageRequest {
  traceAppName?: string(name='TraceAppName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
}

model SearchTraceAppByPageResponseBody = {
  pageBean?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    traceApps?: [ 
      {
        type?: string(name='Type'),
        appName?: string(name='AppName'),
        updateTime?: long(name='UpdateTime'),
        labels?: [ string ](name='Labels'),
        show?: boolean(name='Show'),
        createTime?: long(name='CreateTime'),
        pid?: string(name='Pid'),
        appId?: long(name='AppId'),
        userId?: string(name='UserId'),
        regionId?: string(name='RegionId'),
      }
    ](name='TraceApps'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model SearchTraceAppByPageResponse = {
  headers: map[string]string(name='headers'),
  body: SearchTraceAppByPageResponseBody(name='body'),
}

async function searchTraceAppByPageWithOptions(request: SearchTraceAppByPageRequest, runtime: Util.RuntimeOptions): SearchTraceAppByPageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SearchTraceAppByPage', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function searchTraceAppByPage(request: SearchTraceAppByPageRequest): SearchTraceAppByPageResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchTraceAppByPageWithOptions(request, runtime);
}

model SearchTracesRequest {
  startTime?: long(name='StartTime'),
  endTime?: long(name='EndTime'),
  regionId?: string(name='RegionId'),
  serviceName?: string(name='ServiceName'),
  operationName?: string(name='OperationName'),
  minDuration?: long(name='MinDuration'),
  reverse?: boolean(name='Reverse'),
  serviceIp?: string(name='ServiceIp'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  exclusionFilters?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='ExclusionFilters'),
}

model SearchTracesResponseBody = {
  requestId?: string(name='RequestId'),
  traceInfos?: [ 
    {
      operationName?: string(name='OperationName'),
      serviceIp?: string(name='ServiceIp'),
      duration?: long(name='Duration'),
      timestamp?: long(name='Timestamp'),
      serviceName?: string(name='ServiceName'),
      traceID?: string(name='TraceID'),
    }
  ](name='TraceInfos'),
}

model SearchTracesResponse = {
  headers: map[string]string(name='headers'),
  body: SearchTracesResponseBody(name='body'),
}

async function searchTracesWithOptions(request: SearchTracesRequest, runtime: Util.RuntimeOptions): SearchTracesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SearchTraces', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function searchTraces(request: SearchTracesRequest): SearchTracesResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchTracesWithOptions(request, runtime);
}

model SearchTracesByPageRequest {
  startTime?: long(name='StartTime'),
  endTime?: long(name='EndTime'),
  regionId?: string(name='RegionId'),
  serviceName?: string(name='ServiceName'),
  operationName?: string(name='OperationName'),
  minDuration?: long(name='MinDuration'),
  reverse?: boolean(name='Reverse'),
  serviceIp?: string(name='ServiceIp'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  exclusionFilters?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='ExclusionFilters'),
}

model SearchTracesByPageResponseBody = {
  pageBean?: {
    traceInfos?: [ 
      {
        operationName?: string(name='OperationName'),
        serviceIp?: string(name='ServiceIp'),
        duration?: long(name='Duration'),
        timestamp?: long(name='Timestamp'),
        serviceName?: string(name='ServiceName'),
        traceID?: string(name='TraceID'),
      }
    ](name='TraceInfos'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='PageBean'),
  requestId?: string(name='RequestId'),
}

model SearchTracesByPageResponse = {
  headers: map[string]string(name='headers'),
  body: SearchTracesByPageResponseBody(name='body'),
}

async function searchTracesByPageWithOptions(request: SearchTracesByPageRequest, runtime: Util.RuntimeOptions): SearchTracesByPageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SearchTracesByPage', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function searchTracesByPage(request: SearchTracesByPageRequest): SearchTracesByPageResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchTracesByPageWithOptions(request, runtime);
}

model SendCustomIncidentsRequest {
  incidents?: string(name='Incidents'),
  regionId?: string(name='RegionId'),
  proxyUserId?: string(name='ProxyUserId'),
  productType?: string(name='ProductType'),
}

model SendCustomIncidentsResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SendCustomIncidentsResponse = {
  headers: map[string]string(name='headers'),
  body: SendCustomIncidentsResponseBody(name='body'),
}

async function sendCustomIncidentsWithOptions(request: SendCustomIncidentsRequest, runtime: Util.RuntimeOptions): SendCustomIncidentsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SendCustomIncidents', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function sendCustomIncidents(request: SendCustomIncidentsRequest): SendCustomIncidentsResponse {
  var runtime = new Util.RuntimeOptions{};
  return sendCustomIncidentsWithOptions(request, runtime);
}

model SendMseIncidentRequest {
  incidents?: string(name='Incidents'),
  regionId?: string(name='RegionId'),
  proxyUserId?: string(name='ProxyUserId'),
}

model SendMseIncidentResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SendMseIncidentResponse = {
  headers: map[string]string(name='headers'),
  body: SendMseIncidentResponseBody(name='body'),
}

async function sendMseIncidentWithOptions(request: SendMseIncidentRequest, runtime: Util.RuntimeOptions): SendMseIncidentResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SendMseIncident', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function sendMseIncident(request: SendMseIncidentRequest): SendMseIncidentResponse {
  var runtime = new Util.RuntimeOptions{};
  return sendMseIncidentWithOptions(request, runtime);
}

model SetRetcodeShareStatusRequest {
  pid?: string(name='Pid'),
  status?: boolean(name='Status'),
}

model SetRetcodeShareStatusResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model SetRetcodeShareStatusResponse = {
  headers: map[string]string(name='headers'),
  body: SetRetcodeShareStatusResponseBody(name='body'),
}

async function setRetcodeShareStatusWithOptions(request: SetRetcodeShareStatusRequest, runtime: Util.RuntimeOptions): SetRetcodeShareStatusResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SetRetcodeShareStatus', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function setRetcodeShareStatus(request: SetRetcodeShareStatusRequest): SetRetcodeShareStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return setRetcodeShareStatusWithOptions(request, runtime);
}

model StartAlertRequest {
  alertId?: string(name='AlertId'),
  proxyUserId?: string(name='ProxyUserId'),
  regionId?: string(name='RegionId'),
}

model StartAlertResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model StartAlertResponse = {
  headers: map[string]string(name='headers'),
  body: StartAlertResponseBody(name='body'),
}

async function startAlertWithOptions(request: StartAlertRequest, runtime: Util.RuntimeOptions): StartAlertResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('StartAlert', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function startAlert(request: StartAlertRequest): StartAlertResponse {
  var runtime = new Util.RuntimeOptions{};
  return startAlertWithOptions(request, runtime);
}

model StopAlertRequest {
  alertId?: string(name='AlertId'),
  proxyUserId?: string(name='ProxyUserId'),
  regionId?: string(name='RegionId'),
}

model StopAlertResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model StopAlertResponse = {
  headers: map[string]string(name='headers'),
  body: StopAlertResponseBody(name='body'),
}

async function stopAlertWithOptions(request: StopAlertRequest, runtime: Util.RuntimeOptions): StopAlertResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('StopAlert', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function stopAlert(request: StopAlertRequest): StopAlertResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopAlertWithOptions(request, runtime);
}

model UpdateAlertContactRequest {
  contactName?: string(name='ContactName'),
  phoneNum?: string(name='PhoneNum'),
  email?: string(name='Email'),
  dingRobotWebhookUrl?: string(name='DingRobotWebhookUrl'),
  systemNoc?: boolean(name='SystemNoc'),
  regionId?: string(name='RegionId'),
  proxyUserId?: string(name='ProxyUserId'),
  contactId?: long(name='ContactId'),
}

model UpdateAlertContactResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model UpdateAlertContactResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAlertContactResponseBody(name='body'),
}

async function updateAlertContactWithOptions(request: UpdateAlertContactRequest, runtime: Util.RuntimeOptions): UpdateAlertContactResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateAlertContact', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateAlertContact(request: UpdateAlertContactRequest): UpdateAlertContactResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAlertContactWithOptions(request, runtime);
}

model UpdateAlertContactGroupRequest {
  contactGroupName?: string(name='ContactGroupName'),
  contactIds?: string(name='ContactIds'),
  regionId?: string(name='RegionId'),
  proxyUserId?: string(name='ProxyUserId'),
  contactGroupId?: long(name='ContactGroupId'),
}

model UpdateAlertContactGroupResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model UpdateAlertContactGroupResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAlertContactGroupResponseBody(name='body'),
}

async function updateAlertContactGroupWithOptions(request: UpdateAlertContactGroupRequest, runtime: Util.RuntimeOptions): UpdateAlertContactGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateAlertContactGroup', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateAlertContactGroup(request: UpdateAlertContactGroupRequest): UpdateAlertContactGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAlertContactGroupWithOptions(request, runtime);
}

model UpdateAlertRuleRequest {
  regionId?: string(name='RegionId'),
  contactGroupIds?: string(name='ContactGroupIds'),
  isAutoStart?: boolean(name='IsAutoStart'),
  templageAlertConfig?: string(name='TemplageAlertConfig'),
  proxyUserId?: string(name='ProxyUserId'),
  alertId?: long(name='AlertId'),
}

model UpdateAlertRuleResponseBody = {
  alertId?: long(name='AlertId'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
}

model UpdateAlertRuleResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAlertRuleResponseBody(name='body'),
}

async function updateAlertRuleWithOptions(request: UpdateAlertRuleRequest, runtime: Util.RuntimeOptions): UpdateAlertRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateAlertRule', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateAlertRule(request: UpdateAlertRuleRequest): UpdateAlertRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAlertRuleWithOptions(request, runtime);
}

model UpdateWebhookRequest {
  contactName?: string(name='ContactName'),
  method?: string(name='Method'),
  url?: string(name='Url'),
  httpParams?: string(name='HttpParams'),
  httpHeaders?: string(name='HttpHeaders'),
  regionId?: string(name='RegionId'),
  proxyUserId?: string(name='ProxyUserId'),
  contactId?: long(name='ContactId'),
  body?: string(name='Body'),
}

model UpdateWebhookResponseBody = {
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model UpdateWebhookResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateWebhookResponseBody(name='body'),
}

async function updateWebhookWithOptions(request: UpdateWebhookRequest, runtime: Util.RuntimeOptions): UpdateWebhookResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateWebhook', '2019-08-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateWebhook(request: UpdateWebhookRequest): UpdateWebhookResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateWebhookWithOptions(request, runtime);
}

