/**
 *
 */
import Util;
import OpenApi;

import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
@endpointMap = {
    cn-qingdao = 'vpc.aliyuncs.com',
    cn-beijing = 'vpc.aliyuncs.com',
    cn-hangzhou = 'vpc.aliyuncs.com',
    cn-shanghai = 'vpc.aliyuncs.com',
    cn-shenzhen = 'vpc.aliyuncs.com',
    cn-hongkong = 'vpc.aliyuncs.com',
    ap-southeast-1 = 'vpc.aliyuncs.com',
    us-west-1 = 'vpc.aliyuncs.com',
    us-east-1 = 'vpc.aliyuncs.com',
    cn-shanghai-finance-1 = 'vpc.aliyuncs.com',
    cn-shenzhen-finance-1 = 'vpc.aliyuncs.com',
    cn-north-2-gov-1 = 'vpc.aliyuncs.com',
    ap-northeast-2-pop = 'vpc.aliyuncs.com',
    cn-beijing-finance-1 = 'vpc.aliyuncs.com',
    cn-beijing-finance-pop = 'vpc.aliyuncs.com',
    cn-beijing-gov-1 = 'vpc.aliyuncs.com',
    cn-beijing-nu16-b01 = 'vpc.aliyuncs.com',
    cn-edge-1 = 'vpc-nebula.cn-qingdao-nebula.aliyuncs.com',
    cn-fujian = 'vpc.aliyuncs.com',
    cn-haidian-cm12-c01 = 'vpc.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'vpc.aliyuncs.com',
    cn-hangzhou-finance = 'vpc.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'vpc.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'vpc.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'vpc.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'vpc.aliyuncs.com',
    cn-hangzhou-test-306 = 'vpc.aliyuncs.com',
    cn-hongkong-finance-pop = 'vpc.aliyuncs.com',
    cn-qingdao-nebula = 'vpc-nebula.cn-qingdao-nebula.aliyuncs.com',
    cn-shanghai-et15-b01 = 'vpc.aliyuncs.com',
    cn-shanghai-et2-b01 = 'vpc.aliyuncs.com',
    cn-shanghai-inner = 'vpc.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'vpc.aliyuncs.com',
    cn-shenzhen-inner = 'vpc.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'vpc.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'vpc.aliyuncs.com',
    cn-wuhan = 'vpc.aliyuncs.com',
    cn-yushanfang = 'vpc.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'vpc.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'vpc.cn-zhangjiakou.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'vpc-nebula.cn-qingdao-nebula.aliyuncs.com',
    eu-west-1-oxs = 'vpc-nebula.cn-shenzhen-cloudstone.aliyuncs.com',
    rus-west-1-pop = 'vpc.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('vpc', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model ActivateRouterInterfaceRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  routerInterfaceId?: string(name='RouterInterfaceId'),
}

model ActivateRouterInterfaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model ActivateRouterInterfaceResponse = {
  headers: map[string]string(name='headers'),
  body: ActivateRouterInterfaceResponseBody(name='body'),
}

async function activateRouterInterfaceWithOptions(request: ActivateRouterInterfaceRequest, runtime: Util.RuntimeOptions): ActivateRouterInterfaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ActivateRouterInterface', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function activateRouterInterface(request: ActivateRouterInterfaceRequest): ActivateRouterInterfaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return activateRouterInterfaceWithOptions(request, runtime);
}

model ActiveFlowLogRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  flowLogId?: string(name='FlowLogId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model ActiveFlowLogResponseBody = {
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model ActiveFlowLogResponse = {
  headers: map[string]string(name='headers'),
  body: ActiveFlowLogResponseBody(name='body'),
}

async function activeFlowLogWithOptions(request: ActiveFlowLogRequest, runtime: Util.RuntimeOptions): ActiveFlowLogResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ActiveFlowLog', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function activeFlowLog(request: ActiveFlowLogRequest): ActiveFlowLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return activeFlowLogWithOptions(request, runtime);
}

model AddBgpNetworkRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  dstCidrBlock?: string(name='DstCidrBlock'),
  vpcId?: string(name='VpcId'),
  routerId?: string(name='RouterId'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
}

model AddBgpNetworkResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddBgpNetworkResponse = {
  headers: map[string]string(name='headers'),
  body: AddBgpNetworkResponseBody(name='body'),
}

async function addBgpNetworkWithOptions(request: AddBgpNetworkRequest, runtime: Util.RuntimeOptions): AddBgpNetworkResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddBgpNetwork', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addBgpNetwork(request: AddBgpNetworkRequest): AddBgpNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  return addBgpNetworkWithOptions(request, runtime);
}

model AddCommonBandwidthPackageIpRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  ipInstanceId?: string(name='IpInstanceId'),
  ipType?: string(name='IpType'),
}

model AddCommonBandwidthPackageIpResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddCommonBandwidthPackageIpResponse = {
  headers: map[string]string(name='headers'),
  body: AddCommonBandwidthPackageIpResponseBody(name='body'),
}

async function addCommonBandwidthPackageIpWithOptions(request: AddCommonBandwidthPackageIpRequest, runtime: Util.RuntimeOptions): AddCommonBandwidthPackageIpResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddCommonBandwidthPackageIp', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addCommonBandwidthPackageIp(request: AddCommonBandwidthPackageIpRequest): AddCommonBandwidthPackageIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return addCommonBandwidthPackageIpWithOptions(request, runtime);
}

model AddCommonBandwidthPackageIpsRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  ipType?: string(name='IpType'),
  ipInstanceIds?: [ string ](name='IpInstanceIds'),
}

model AddCommonBandwidthPackageIpsResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddCommonBandwidthPackageIpsResponse = {
  headers: map[string]string(name='headers'),
  body: AddCommonBandwidthPackageIpsResponseBody(name='body'),
}

async function addCommonBandwidthPackageIpsWithOptions(request: AddCommonBandwidthPackageIpsRequest, runtime: Util.RuntimeOptions): AddCommonBandwidthPackageIpsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddCommonBandwidthPackageIps', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addCommonBandwidthPackageIps(request: AddCommonBandwidthPackageIpsRequest): AddCommonBandwidthPackageIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  return addCommonBandwidthPackageIpsWithOptions(request, runtime);
}

model AddGlobalAccelerationInstanceIpRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  globalAccelerationInstanceId?: string(name='GlobalAccelerationInstanceId'),
  ipInstanceId?: string(name='IpInstanceId'),
}

model AddGlobalAccelerationInstanceIpResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddGlobalAccelerationInstanceIpResponse = {
  headers: map[string]string(name='headers'),
  body: AddGlobalAccelerationInstanceIpResponseBody(name='body'),
}

async function addGlobalAccelerationInstanceIpWithOptions(request: AddGlobalAccelerationInstanceIpRequest, runtime: Util.RuntimeOptions): AddGlobalAccelerationInstanceIpResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddGlobalAccelerationInstanceIp', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addGlobalAccelerationInstanceIp(request: AddGlobalAccelerationInstanceIpRequest): AddGlobalAccelerationInstanceIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return addGlobalAccelerationInstanceIpWithOptions(request, runtime);
}

model AddIPv6TranslatorAclListEntryRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  aclId?: string(name='AclId'),
  aclEntryIp?: string(name='AclEntryIp'),
  aclEntryComment?: string(name='AclEntryComment'),
}

model AddIPv6TranslatorAclListEntryResponseBody = {
  requestId?: string(name='RequestId'),
  aclEntryId?: string(name='AclEntryId'),
}

model AddIPv6TranslatorAclListEntryResponse = {
  headers: map[string]string(name='headers'),
  body: AddIPv6TranslatorAclListEntryResponseBody(name='body'),
}

async function addIPv6TranslatorAclListEntryWithOptions(request: AddIPv6TranslatorAclListEntryRequest, runtime: Util.RuntimeOptions): AddIPv6TranslatorAclListEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddIPv6TranslatorAclListEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addIPv6TranslatorAclListEntry(request: AddIPv6TranslatorAclListEntryRequest): AddIPv6TranslatorAclListEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return addIPv6TranslatorAclListEntryWithOptions(request, runtime);
}

model AllocateEipAddressRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  bandwidth?: string(name='Bandwidth'),
  period?: int32(name='Period'),
  ISP?: string(name='ISP'),
  activityId?: long(name='ActivityId'),
  netmode?: string(name='Netmode'),
  autoPay?: boolean(name='AutoPay'),
  pricingCycle?: string(name='PricingCycle'),
  instanceChargeType?: string(name='InstanceChargeType'),
  internetChargeType?: string(name='InternetChargeType'),
  resourceGroupId?: string(name='ResourceGroupId'),
  ownerAccount?: string(name='OwnerAccount'),
  clientToken?: string(name='ClientToken'),
  name?: string(name='Name'),
  description?: string(name='Description'),
}

model AllocateEipAddressResponseBody = {
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  allocationId?: string(name='AllocationId'),
  eipAddress?: string(name='EipAddress'),
  orderId?: long(name='OrderId'),
}

model AllocateEipAddressResponse = {
  headers: map[string]string(name='headers'),
  body: AllocateEipAddressResponseBody(name='body'),
}

async function allocateEipAddressWithOptions(request: AllocateEipAddressRequest, runtime: Util.RuntimeOptions): AllocateEipAddressResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AllocateEipAddress', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function allocateEipAddress(request: AllocateEipAddressRequest): AllocateEipAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return allocateEipAddressWithOptions(request, runtime);
}

model AllocateEipAddressProRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  ipAddress?: string(name='IpAddress'),
  instanceId?: string(name='InstanceId'),
  bandwidth?: string(name='Bandwidth'),
  period?: int32(name='Period'),
  ISP?: string(name='ISP'),
  netmode?: string(name='Netmode'),
  autoPay?: boolean(name='AutoPay'),
  pricingCycle?: string(name='PricingCycle'),
  instanceChargeType?: string(name='InstanceChargeType'),
  internetChargeType?: string(name='InternetChargeType'),
  resourceGroupId?: string(name='ResourceGroupId'),
  ownerAccount?: string(name='OwnerAccount'),
  clientToken?: string(name='ClientToken'),
}

model AllocateEipAddressProResponseBody = {
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  allocationId?: string(name='AllocationId'),
  eipAddress?: string(name='EipAddress'),
  orderId?: long(name='OrderId'),
}

model AllocateEipAddressProResponse = {
  headers: map[string]string(name='headers'),
  body: AllocateEipAddressProResponseBody(name='body'),
}

async function allocateEipAddressProWithOptions(request: AllocateEipAddressProRequest, runtime: Util.RuntimeOptions): AllocateEipAddressProResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AllocateEipAddressPro', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function allocateEipAddressPro(request: AllocateEipAddressProRequest): AllocateEipAddressProResponse {
  var runtime = new Util.RuntimeOptions{};
  return allocateEipAddressProWithOptions(request, runtime);
}

model AllocateEipSegmentAddressRequest {
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerId?: long(name='OwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  clientToken?: string(name='ClientToken'),
  bandwidth?: string(name='Bandwidth'),
  regionId?: string(name='RegionId'),
  eipMask?: string(name='EipMask'),
  netmode?: string(name='Netmode'),
  internetChargeType?: string(name='InternetChargeType'),
  resourceGroupId?: string(name='ResourceGroupId'),
  isp?: string(name='Isp'),
}

model AllocateEipSegmentAddressResponseBody = {
  eipSegmentInstanceId?: string(name='EipSegmentInstanceId'),
  requestId?: string(name='RequestId'),
  orderId?: long(name='OrderId'),
}

model AllocateEipSegmentAddressResponse = {
  headers: map[string]string(name='headers'),
  body: AllocateEipSegmentAddressResponseBody(name='body'),
}

async function allocateEipSegmentAddressWithOptions(request: AllocateEipSegmentAddressRequest, runtime: Util.RuntimeOptions): AllocateEipSegmentAddressResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AllocateEipSegmentAddress', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function allocateEipSegmentAddress(request: AllocateEipSegmentAddressRequest): AllocateEipSegmentAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return allocateEipSegmentAddressWithOptions(request, runtime);
}

model AllocateIpv6InternetBandwidthRequest {
  regionId?: string(name='RegionId'),
  ipv6GatewayId?: string(name='Ipv6GatewayId'),
  ipv6AddressId?: string(name='Ipv6AddressId'),
  internetChargeType?: string(name='InternetChargeType'),
  bandwidth?: int32(name='Bandwidth'),
  clientToken?: string(name='ClientToken'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model AllocateIpv6InternetBandwidthResponseBody = {
  requestId?: string(name='RequestId'),
  internetBandwidthId?: string(name='InternetBandwidthId'),
  ipv6AddressId?: string(name='Ipv6AddressId'),
}

model AllocateIpv6InternetBandwidthResponse = {
  headers: map[string]string(name='headers'),
  body: AllocateIpv6InternetBandwidthResponseBody(name='body'),
}

async function allocateIpv6InternetBandwidthWithOptions(request: AllocateIpv6InternetBandwidthRequest, runtime: Util.RuntimeOptions): AllocateIpv6InternetBandwidthResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AllocateIpv6InternetBandwidth', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function allocateIpv6InternetBandwidth(request: AllocateIpv6InternetBandwidthRequest): AllocateIpv6InternetBandwidthResponse {
  var runtime = new Util.RuntimeOptions{};
  return allocateIpv6InternetBandwidthWithOptions(request, runtime);
}

model AssociateEipAddressRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  allocationId?: string(name='AllocationId'),
  instanceId?: string(name='InstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  instanceType?: string(name='InstanceType'),
  instanceRegionId?: string(name='InstanceRegionId'),
  privateIpAddress?: string(name='PrivateIpAddress'),
  mode?: string(name='Mode'),
  clientToken?: string(name='ClientToken'),
}

model AssociateEipAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateEipAddressResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateEipAddressResponseBody(name='body'),
}

async function associateEipAddressWithOptions(request: AssociateEipAddressRequest, runtime: Util.RuntimeOptions): AssociateEipAddressResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AssociateEipAddress', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function associateEipAddress(request: AssociateEipAddressRequest): AssociateEipAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateEipAddressWithOptions(request, runtime);
}

model AssociateGlobalAccelerationInstanceRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  globalAccelerationInstanceId?: string(name='GlobalAccelerationInstanceId'),
  backendServerId?: string(name='BackendServerId'),
  backendServerRegionId?: string(name='BackendServerRegionId'),
  ownerAccount?: string(name='OwnerAccount'),
  backendServerType?: string(name='BackendServerType'),
}

model AssociateGlobalAccelerationInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateGlobalAccelerationInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateGlobalAccelerationInstanceResponseBody(name='body'),
}

async function associateGlobalAccelerationInstanceWithOptions(request: AssociateGlobalAccelerationInstanceRequest, runtime: Util.RuntimeOptions): AssociateGlobalAccelerationInstanceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AssociateGlobalAccelerationInstance', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function associateGlobalAccelerationInstance(request: AssociateGlobalAccelerationInstanceRequest): AssociateGlobalAccelerationInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateGlobalAccelerationInstanceWithOptions(request, runtime);
}

model AssociateHaVipRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  clientToken?: string(name='ClientToken'),
  regionId?: string(name='RegionId'),
  haVipId?: string(name='HaVipId'),
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
}

model AssociateHaVipResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateHaVipResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateHaVipResponseBody(name='body'),
}

async function associateHaVipWithOptions(request: AssociateHaVipRequest, runtime: Util.RuntimeOptions): AssociateHaVipResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AssociateHaVip', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function associateHaVip(request: AssociateHaVipRequest): AssociateHaVipResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateHaVipWithOptions(request, runtime);
}

model AssociateNetworkAclRequest {
  networkAclId?: string(name='NetworkAclId'),
  regionId?: string(name='RegionId'),
  resource?: [ 
    {
      resourceType?: string(name='ResourceType'),
      resourceId?: string(name='ResourceId'),
    }
  ](name='Resource'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerId?: long(name='OwnerId'),
  clientToken?: string(name='ClientToken'),
}

model AssociateNetworkAclResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateNetworkAclResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateNetworkAclResponseBody(name='body'),
}

async function associateNetworkAclWithOptions(request: AssociateNetworkAclRequest, runtime: Util.RuntimeOptions): AssociateNetworkAclResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AssociateNetworkAcl', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function associateNetworkAcl(request: AssociateNetworkAclRequest): AssociateNetworkAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateNetworkAclWithOptions(request, runtime);
}

model AssociatePhysicalConnectionToVirtualBorderRouterRequest {
  regionId?: string(name='RegionId'),
  vbrId?: string(name='VbrId'),
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  vlanId?: string(name='VlanId'),
  circuitCode?: string(name='CircuitCode'),
  localGatewayIp?: string(name='LocalGatewayIp'),
  peerGatewayIp?: string(name='PeerGatewayIp'),
  peeringSubnetMask?: string(name='PeeringSubnetMask'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  localIpv6GatewayIp?: string(name='LocalIpv6GatewayIp'),
  peerIpv6GatewayIp?: string(name='PeerIpv6GatewayIp'),
  peeringIpv6SubnetMask?: string(name='PeeringIpv6SubnetMask'),
  enableIpv6?: string(name='EnableIpv6'),
}

model AssociatePhysicalConnectionToVirtualBorderRouterResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociatePhysicalConnectionToVirtualBorderRouterResponse = {
  headers: map[string]string(name='headers'),
  body: AssociatePhysicalConnectionToVirtualBorderRouterResponseBody(name='body'),
}

async function associatePhysicalConnectionToVirtualBorderRouterWithOptions(request: AssociatePhysicalConnectionToVirtualBorderRouterRequest, runtime: Util.RuntimeOptions): AssociatePhysicalConnectionToVirtualBorderRouterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AssociatePhysicalConnectionToVirtualBorderRouter', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function associatePhysicalConnectionToVirtualBorderRouter(request: AssociatePhysicalConnectionToVirtualBorderRouterRequest): AssociatePhysicalConnectionToVirtualBorderRouterResponse {
  var runtime = new Util.RuntimeOptions{};
  return associatePhysicalConnectionToVirtualBorderRouterWithOptions(request, runtime);
}

model AssociateRouteTableRequest {
  regionId?: string(name='RegionId'),
  routeTableId?: string(name='RouteTableId'),
  vSwitchId?: string(name='VSwitchId'),
  clientToken?: string(name='ClientToken'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model AssociateRouteTableResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateRouteTableResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateRouteTableResponseBody(name='body'),
}

async function associateRouteTableWithOptions(request: AssociateRouteTableRequest, runtime: Util.RuntimeOptions): AssociateRouteTableResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AssociateRouteTable', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function associateRouteTable(request: AssociateRouteTableRequest): AssociateRouteTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateRouteTableWithOptions(request, runtime);
}

model AssociateVpcCidrBlockRequest {
  regionId?: string(name='RegionId'),
  vpcId?: string(name='VpcId'),
  secondaryCidrBlock?: string(name='SecondaryCidrBlock'),
  IPv6CidrBlock?: string(name='IPv6CidrBlock'),
  IPv6CidrType?: string(name='IPv6CidrType'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model AssociateVpcCidrBlockResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateVpcCidrBlockResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateVpcCidrBlockResponseBody(name='body'),
}

async function associateVpcCidrBlockWithOptions(request: AssociateVpcCidrBlockRequest, runtime: Util.RuntimeOptions): AssociateVpcCidrBlockResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AssociateVpcCidrBlock', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function associateVpcCidrBlock(request: AssociateVpcCidrBlockRequest): AssociateVpcCidrBlockResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateVpcCidrBlockWithOptions(request, runtime);
}

model AssociateVpnGatewayWithCertificateRequest {
  regionId?: string(name='RegionId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  certificateType?: string(name='CertificateType'),
  certificateId?: string(name='CertificateId'),
  callerBid?: string(name='callerBid'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model AssociateVpnGatewayWithCertificateResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateVpnGatewayWithCertificateResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateVpnGatewayWithCertificateResponseBody(name='body'),
}

async function associateVpnGatewayWithCertificateWithOptions(request: AssociateVpnGatewayWithCertificateRequest, runtime: Util.RuntimeOptions): AssociateVpnGatewayWithCertificateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AssociateVpnGatewayWithCertificate', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function associateVpnGatewayWithCertificate(request: AssociateVpnGatewayWithCertificateRequest): AssociateVpnGatewayWithCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateVpnGatewayWithCertificateWithOptions(request, runtime);
}

model AttachDhcpOptionsSetToVpcRequest {
  regionId?: string(name='RegionId'),
  dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
  vpcId?: string(name='VpcId'),
  clientToken?: string(name='ClientToken'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  dryRun?: boolean(name='DryRun'),
}

model AttachDhcpOptionsSetToVpcResponseBody = {
  requestId?: string(name='RequestId'),
}

model AttachDhcpOptionsSetToVpcResponse = {
  headers: map[string]string(name='headers'),
  body: AttachDhcpOptionsSetToVpcResponseBody(name='body'),
}

async function attachDhcpOptionsSetToVpcWithOptions(request: AttachDhcpOptionsSetToVpcRequest, runtime: Util.RuntimeOptions): AttachDhcpOptionsSetToVpcResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AttachDhcpOptionsSetToVpc', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function attachDhcpOptionsSetToVpc(request: AttachDhcpOptionsSetToVpcRequest): AttachDhcpOptionsSetToVpcResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachDhcpOptionsSetToVpcWithOptions(request, runtime);
}

model CancelCommonBandwidthPackageIpBandwidthRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  eipId?: string(name='EipId'),
}

model CancelCommonBandwidthPackageIpBandwidthResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelCommonBandwidthPackageIpBandwidthResponse = {
  headers: map[string]string(name='headers'),
  body: CancelCommonBandwidthPackageIpBandwidthResponseBody(name='body'),
}

async function cancelCommonBandwidthPackageIpBandwidthWithOptions(request: CancelCommonBandwidthPackageIpBandwidthRequest, runtime: Util.RuntimeOptions): CancelCommonBandwidthPackageIpBandwidthResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CancelCommonBandwidthPackageIpBandwidth', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function cancelCommonBandwidthPackageIpBandwidth(request: CancelCommonBandwidthPackageIpBandwidthRequest): CancelCommonBandwidthPackageIpBandwidthResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelCommonBandwidthPackageIpBandwidthWithOptions(request, runtime);
}

model CancelExpressCloudConnectionRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  eccId?: string(name='EccId'),
}

model CancelExpressCloudConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelExpressCloudConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: CancelExpressCloudConnectionResponseBody(name='body'),
}

async function cancelExpressCloudConnectionWithOptions(request: CancelExpressCloudConnectionRequest, runtime: Util.RuntimeOptions): CancelExpressCloudConnectionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CancelExpressCloudConnection', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function cancelExpressCloudConnection(request: CancelExpressCloudConnectionRequest): CancelExpressCloudConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelExpressCloudConnectionWithOptions(request, runtime);
}

model CancelPhysicalConnectionRequest {
  regionId?: string(name='RegionId'),
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
}

model CancelPhysicalConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelPhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: CancelPhysicalConnectionResponseBody(name='body'),
}

async function cancelPhysicalConnectionWithOptions(request: CancelPhysicalConnectionRequest, runtime: Util.RuntimeOptions): CancelPhysicalConnectionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CancelPhysicalConnection', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function cancelPhysicalConnection(request: CancelPhysicalConnectionRequest): CancelPhysicalConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelPhysicalConnectionWithOptions(request, runtime);
}

model ConfirmPhysicalConnectionRequest {
  regionId?: string(name='RegionId'),
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
}

model ConfirmPhysicalConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ConfirmPhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: ConfirmPhysicalConnectionResponseBody(name='body'),
}

async function confirmPhysicalConnectionWithOptions(request: ConfirmPhysicalConnectionRequest, runtime: Util.RuntimeOptions): ConfirmPhysicalConnectionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ConfirmPhysicalConnection', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function confirmPhysicalConnection(request: ConfirmPhysicalConnectionRequest): ConfirmPhysicalConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return confirmPhysicalConnectionWithOptions(request, runtime);
}

model ConnectRouterInterfaceRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  routerInterfaceId?: string(name='RouterInterfaceId'),
}

model ConnectRouterInterfaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model ConnectRouterInterfaceResponse = {
  headers: map[string]string(name='headers'),
  body: ConnectRouterInterfaceResponseBody(name='body'),
}

async function connectRouterInterfaceWithOptions(request: ConnectRouterInterfaceRequest, runtime: Util.RuntimeOptions): ConnectRouterInterfaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ConnectRouterInterface', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function connectRouterInterface(request: ConnectRouterInterfaceRequest): ConnectRouterInterfaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return connectRouterInterfaceWithOptions(request, runtime);
}

model ConvertBandwidthPackageRequest {
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerId?: long(name='OwnerId'),
  clientToken?: string(name='ClientToken'),
}

model ConvertBandwidthPackageResponseBody = {
  requestId?: string(name='RequestId'),
  convertInstanceId?: string(name='ConvertInstanceId'),
}

model ConvertBandwidthPackageResponse = {
  headers: map[string]string(name='headers'),
  body: ConvertBandwidthPackageResponseBody(name='body'),
}

async function convertBandwidthPackageWithOptions(request: ConvertBandwidthPackageRequest, runtime: Util.RuntimeOptions): ConvertBandwidthPackageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ConvertBandwidthPackage', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function convertBandwidthPackage(request: ConvertBandwidthPackageRequest): ConvertBandwidthPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return convertBandwidthPackageWithOptions(request, runtime);
}

model CopyNetworkAclEntriesRequest {
  regionId?: string(name='RegionId'),
  networkAclId?: string(name='NetworkAclId'),
  sourceNetworkAclId?: string(name='SourceNetworkAclId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerId?: long(name='OwnerId'),
  clientToken?: string(name='ClientToken'),
}

model CopyNetworkAclEntriesResponseBody = {
  requestId?: string(name='RequestId'),
}

model CopyNetworkAclEntriesResponse = {
  headers: map[string]string(name='headers'),
  body: CopyNetworkAclEntriesResponseBody(name='body'),
}

async function copyNetworkAclEntriesWithOptions(request: CopyNetworkAclEntriesRequest, runtime: Util.RuntimeOptions): CopyNetworkAclEntriesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CopyNetworkAclEntries', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function copyNetworkAclEntries(request: CopyNetworkAclEntriesRequest): CopyNetworkAclEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return copyNetworkAclEntriesWithOptions(request, runtime);
}

model CreateBgpGroupRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  routerId?: string(name='RouterId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  localAsn?: long(name='LocalAsn'),
  peerAsn?: long(name='PeerAsn'),
  authKey?: string(name='AuthKey'),
  isFakeAsn?: boolean(name='IsFakeAsn'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ipVersion?: string(name='IpVersion'),
}

model CreateBgpGroupResponseBody = {
  requestId?: string(name='RequestId'),
  bgpGroupId?: string(name='BgpGroupId'),
}

model CreateBgpGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateBgpGroupResponseBody(name='body'),
}

async function createBgpGroupWithOptions(request: CreateBgpGroupRequest, runtime: Util.RuntimeOptions): CreateBgpGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateBgpGroup', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createBgpGroup(request: CreateBgpGroupRequest): CreateBgpGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBgpGroupWithOptions(request, runtime);
}

model CreateBgpPeerRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  bgpGroupId?: string(name='BgpGroupId'),
  peerIpAddress?: string(name='PeerIpAddress'),
  enableBfd?: boolean(name='EnableBfd'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ipVersion?: string(name='IpVersion'),
  bfdMultiHop?: int32(name='BfdMultiHop'),
}

model CreateBgpPeerResponseBody = {
  bgpPeerId?: string(name='BgpPeerId'),
  requestId?: string(name='RequestId'),
}

model CreateBgpPeerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateBgpPeerResponseBody(name='body'),
}

async function createBgpPeerWithOptions(request: CreateBgpPeerRequest, runtime: Util.RuntimeOptions): CreateBgpPeerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateBgpPeer', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createBgpPeer(request: CreateBgpPeerRequest): CreateBgpPeerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBgpPeerWithOptions(request, runtime);
}

model CreateCommonBandwidthPackageRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  zone?: string(name='Zone'),
  ISP?: string(name='ISP'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  clientToken?: string(name='ClientToken'),
  resourceGroupId?: string(name='ResourceGroupId'),
  bandwidth?: int32(name='Bandwidth'),
  ratio?: int32(name='Ratio'),
  internetChargeType?: string(name='InternetChargeType'),
}

model CreateCommonBandwidthPackageResponseBody = {
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
}

model CreateCommonBandwidthPackageResponse = {
  headers: map[string]string(name='headers'),
  body: CreateCommonBandwidthPackageResponseBody(name='body'),
}

async function createCommonBandwidthPackageWithOptions(request: CreateCommonBandwidthPackageRequest, runtime: Util.RuntimeOptions): CreateCommonBandwidthPackageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateCommonBandwidthPackage', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createCommonBandwidthPackage(request: CreateCommonBandwidthPackageRequest): CreateCommonBandwidthPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCommonBandwidthPackageWithOptions(request, runtime);
}

model CreateCustomerGatewayRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  ipAddress?: string(name='IpAddress'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  asn?: string(name='Asn'),
}

model CreateCustomerGatewayResponseBody = {
  description?: string(name='Description'),
  requestId?: string(name='RequestId'),
  customerGatewayId?: string(name='CustomerGatewayId'),
  createTime?: long(name='CreateTime'),
  ipAddress?: string(name='IpAddress'),
  name?: string(name='Name'),
}

model CreateCustomerGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: CreateCustomerGatewayResponseBody(name='body'),
}

async function createCustomerGatewayWithOptions(request: CreateCustomerGatewayRequest, runtime: Util.RuntimeOptions): CreateCustomerGatewayResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateCustomerGateway', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createCustomerGateway(request: CreateCustomerGatewayRequest): CreateCustomerGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCustomerGatewayWithOptions(request, runtime);
}

model CreateDhcpOptionsSetRequest {
  regionId?: string(name='RegionId'),
  domainNameServers?: string(name='DomainNameServers'),
  dhcpOptionsSetName?: string(name='DhcpOptionsSetName'),
  dhcpOptionsSetDescription?: string(name='DhcpOptionsSetDescription'),
  domainName?: string(name='DomainName'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
}

model CreateDhcpOptionsSetResponseBody = {
  dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
  requestId?: string(name='RequestId'),
}

model CreateDhcpOptionsSetResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDhcpOptionsSetResponseBody(name='body'),
}

async function createDhcpOptionsSetWithOptions(request: CreateDhcpOptionsSetRequest, runtime: Util.RuntimeOptions): CreateDhcpOptionsSetResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateDhcpOptionsSet', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createDhcpOptionsSet(request: CreateDhcpOptionsSetRequest): CreateDhcpOptionsSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDhcpOptionsSetWithOptions(request, runtime);
}

model CreateExpressCloudConnectionRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  peerCity?: string(name='PeerCity'),
  peerLocation?: string(name='PeerLocation'),
  idcSP?: string(name='IdcSP'),
  portType?: string(name='PortType'),
  bandwidth?: int32(name='Bandwidth'),
  contactTel?: string(name='ContactTel'),
  contactMail?: string(name='ContactMail'),
  IDCardNo?: string(name='IDCardNo'),
  redundantEccId?: string(name='RedundantEccId'),
}

model CreateExpressCloudConnectionResponseBody = {
  requestId?: string(name='RequestId'),
  eccId?: string(name='EccId'),
}

model CreateExpressCloudConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: CreateExpressCloudConnectionResponseBody(name='body'),
}

async function createExpressCloudConnectionWithOptions(request: CreateExpressCloudConnectionRequest, runtime: Util.RuntimeOptions): CreateExpressCloudConnectionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateExpressCloudConnection', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createExpressCloudConnection(request: CreateExpressCloudConnectionRequest): CreateExpressCloudConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createExpressCloudConnectionWithOptions(request, runtime);
}

model CreateFlowLogRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  flowLogName?: string(name='FlowLogName'),
  description?: string(name='Description'),
  resourceType?: string(name='ResourceType'),
  resourceId?: string(name='ResourceId'),
  trafficType?: string(name='TrafficType'),
  projectName?: string(name='ProjectName'),
  logStoreName?: string(name='LogStoreName'),
  ownerAccount?: string(name='OwnerAccount'),
}

model CreateFlowLogResponseBody = {
  requestId?: string(name='RequestId'),
  flowLogId?: string(name='FlowLogId'),
  success?: string(name='Success'),
}

model CreateFlowLogResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFlowLogResponseBody(name='body'),
}

async function createFlowLogWithOptions(request: CreateFlowLogRequest, runtime: Util.RuntimeOptions): CreateFlowLogResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateFlowLog', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createFlowLog(request: CreateFlowLogRequest): CreateFlowLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFlowLogWithOptions(request, runtime);
}

model CreateForwardEntryRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  forwardTableId?: string(name='ForwardTableId'),
  externalIp?: string(name='ExternalIp'),
  externalPort?: string(name='ExternalPort'),
  internalIp?: string(name='InternalIp'),
  internalPort?: string(name='InternalPort'),
  ipProtocol?: string(name='IpProtocol'),
  forwardEntryName?: string(name='ForwardEntryName'),
  clientToken?: string(name='ClientToken'),
  portBreak?: boolean(name='PortBreak'),
}

model CreateForwardEntryResponseBody = {
  requestId?: string(name='RequestId'),
  forwardEntryId?: string(name='ForwardEntryId'),
}

model CreateForwardEntryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateForwardEntryResponseBody(name='body'),
}

async function createForwardEntryWithOptions(request: CreateForwardEntryRequest, runtime: Util.RuntimeOptions): CreateForwardEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateForwardEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createForwardEntry(request: CreateForwardEntryRequest): CreateForwardEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createForwardEntryWithOptions(request, runtime);
}

model CreateGlobalAccelerationInstanceRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  serviceLocation?: string(name='ServiceLocation'),
  bandwidth?: string(name='Bandwidth'),
  bandwidthType?: string(name='BandwidthType'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  ownerAccount?: string(name='OwnerAccount'),
  clientToken?: string(name='ClientToken'),
}

model CreateGlobalAccelerationInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  ipAddress?: string(name='IpAddress'),
  globalAccelerationInstanceId?: string(name='GlobalAccelerationInstanceId'),
}

model CreateGlobalAccelerationInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateGlobalAccelerationInstanceResponseBody(name='body'),
}

async function createGlobalAccelerationInstanceWithOptions(request: CreateGlobalAccelerationInstanceRequest, runtime: Util.RuntimeOptions): CreateGlobalAccelerationInstanceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateGlobalAccelerationInstance', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createGlobalAccelerationInstance(request: CreateGlobalAccelerationInstanceRequest): CreateGlobalAccelerationInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGlobalAccelerationInstanceWithOptions(request, runtime);
}

model CreateHaVipRequest {
  name?: string(name='Name'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  clientToken?: string(name='ClientToken'),
  regionId?: string(name='RegionId'),
  vSwitchId?: string(name='VSwitchId'),
  ipAddress?: string(name='IpAddress'),
  description?: string(name='Description'),
}

model CreateHaVipResponseBody = {
  requestId?: string(name='RequestId'),
  ipAddress?: string(name='IpAddress'),
  haVipId?: string(name='HaVipId'),
}

model CreateHaVipResponse = {
  headers: map[string]string(name='headers'),
  body: CreateHaVipResponseBody(name='body'),
}

async function createHaVipWithOptions(request: CreateHaVipRequest, runtime: Util.RuntimeOptions): CreateHaVipResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateHaVip', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createHaVip(request: CreateHaVipRequest): CreateHaVipResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHaVipWithOptions(request, runtime);
}

model CreateIpsecServerRequest {
  regionId?: string(name='RegionId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  localSubnet?: string(name='LocalSubnet'),
  clientIpPool?: string(name='ClientIpPool'),
  ipSecServerName?: string(name='IpSecServerName'),
  effectImmediately?: boolean(name='EffectImmediately'),
  ikeConfig?: string(name='IkeConfig'),
  ipsecConfig?: string(name='IpsecConfig'),
  pskEnabled?: boolean(name='PskEnabled'),
  psk?: string(name='Psk'),
  multiFactorAuthEnabled?: boolean(name='MultiFactorAuthEnabled'),
  IDaaSInstanceId?: string(name='IDaaSInstanceId'),
  clientToken?: string(name='ClientToken'),
  callerBid?: string(name='callerBid'),
  dryRun?: string(name='DryRun'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateIpsecServerResponseBody = {
  requestId?: string(name='RequestId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  ipsecServerId?: string(name='IpsecServerId'),
  creationTime?: string(name='CreationTime'),
  regionId?: string(name='RegionId'),
  ipsecServerName?: string(name='IpsecServerName'),
}

model CreateIpsecServerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateIpsecServerResponseBody(name='body'),
}

async function createIpsecServerWithOptions(request: CreateIpsecServerRequest, runtime: Util.RuntimeOptions): CreateIpsecServerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateIpsecServer', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createIpsecServer(request: CreateIpsecServerRequest): CreateIpsecServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIpsecServerWithOptions(request, runtime);
}

model CreateIpv6EgressOnlyRuleRequest {
  regionId?: string(name='RegionId'),
  ipv6GatewayId?: string(name='Ipv6GatewayId'),
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  clientToken?: string(name='ClientToken'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model CreateIpv6EgressOnlyRuleResponseBody = {
  ipv6EgressRuleId?: string(name='Ipv6EgressRuleId'),
  requestId?: string(name='RequestId'),
}

model CreateIpv6EgressOnlyRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateIpv6EgressOnlyRuleResponseBody(name='body'),
}

async function createIpv6EgressOnlyRuleWithOptions(request: CreateIpv6EgressOnlyRuleRequest, runtime: Util.RuntimeOptions): CreateIpv6EgressOnlyRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateIpv6EgressOnlyRule', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createIpv6EgressOnlyRule(request: CreateIpv6EgressOnlyRuleRequest): CreateIpv6EgressOnlyRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIpv6EgressOnlyRuleWithOptions(request, runtime);
}

model CreateIpv6GatewayRequest {
  regionId?: string(name='RegionId'),
  vpcId?: string(name='VpcId'),
  spec?: string(name='Spec'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  clientToken?: string(name='ClientToken'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model CreateIpv6GatewayResponseBody = {
  requestId?: string(name='RequestId'),
  ipv6GatewayId?: string(name='Ipv6GatewayId'),
}

model CreateIpv6GatewayResponse = {
  headers: map[string]string(name='headers'),
  body: CreateIpv6GatewayResponseBody(name='body'),
}

async function createIpv6GatewayWithOptions(request: CreateIpv6GatewayRequest, runtime: Util.RuntimeOptions): CreateIpv6GatewayResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateIpv6Gateway', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createIpv6Gateway(request: CreateIpv6GatewayRequest): CreateIpv6GatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIpv6GatewayWithOptions(request, runtime);
}

model CreateIPv6TranslatorRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  name?: string(name='Name'),
  spec?: string(name='Spec'),
  payType?: string(name='PayType'),
  pricingCycle?: string(name='PricingCycle'),
  duration?: int32(name='Duration'),
  autoPay?: boolean(name='AutoPay'),
  bandwidth?: int32(name='Bandwidth'),
}

model CreateIPv6TranslatorResponseBody = {
  requestId?: string(name='RequestId'),
  ipv6TranslatorId?: string(name='Ipv6TranslatorId'),
  spec?: string(name='Spec'),
  orderId?: long(name='OrderId'),
  name?: string(name='Name'),
}

model CreateIPv6TranslatorResponse = {
  headers: map[string]string(name='headers'),
  body: CreateIPv6TranslatorResponseBody(name='body'),
}

async function createIPv6TranslatorWithOptions(request: CreateIPv6TranslatorRequest, runtime: Util.RuntimeOptions): CreateIPv6TranslatorResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateIPv6Translator', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createIPv6Translator(request: CreateIPv6TranslatorRequest): CreateIPv6TranslatorResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIPv6TranslatorWithOptions(request, runtime);
}

model CreateIPv6TranslatorAclListRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  aclName?: string(name='AclName'),
}

model CreateIPv6TranslatorAclListResponseBody = {
  requestId?: string(name='RequestId'),
  aclId?: string(name='AclId'),
}

model CreateIPv6TranslatorAclListResponse = {
  headers: map[string]string(name='headers'),
  body: CreateIPv6TranslatorAclListResponseBody(name='body'),
}

async function createIPv6TranslatorAclListWithOptions(request: CreateIPv6TranslatorAclListRequest, runtime: Util.RuntimeOptions): CreateIPv6TranslatorAclListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateIPv6TranslatorAclList', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createIPv6TranslatorAclList(request: CreateIPv6TranslatorAclListRequest): CreateIPv6TranslatorAclListResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIPv6TranslatorAclListWithOptions(request, runtime);
}

model CreateIPv6TranslatorEntryRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  ipv6TranslatorId?: string(name='Ipv6TranslatorId'),
  entryName?: string(name='EntryName'),
  entryDescription?: string(name='EntryDescription'),
  allocateIpv6Port?: int32(name='AllocateIpv6Port'),
  backendIpv4Addr?: string(name='BackendIpv4Addr'),
  backendIpv4Port?: int32(name='BackendIpv4Port'),
  transProtocol?: string(name='TransProtocol'),
  entryBandwidth?: int32(name='EntryBandwidth'),
  aclStatus?: string(name='AclStatus'),
  aclType?: string(name='AclType'),
  aclId?: string(name='AclId'),
}

model CreateIPv6TranslatorEntryResponseBody = {
  requestId?: string(name='RequestId'),
  ipv6TranslatorEntryId?: string(name='Ipv6TranslatorEntryId'),
}

model CreateIPv6TranslatorEntryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateIPv6TranslatorEntryResponseBody(name='body'),
}

async function createIPv6TranslatorEntryWithOptions(request: CreateIPv6TranslatorEntryRequest, runtime: Util.RuntimeOptions): CreateIPv6TranslatorEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateIPv6TranslatorEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createIPv6TranslatorEntry(request: CreateIPv6TranslatorEntryRequest): CreateIPv6TranslatorEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIPv6TranslatorEntryWithOptions(request, runtime);
}

model CreateNatGatewayRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  vpcId?: string(name='VpcId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  clientToken?: string(name='ClientToken'),
  spec?: string(name='Spec'),
  instanceChargeType?: string(name='InstanceChargeType'),
  pricingCycle?: string(name='PricingCycle'),
  duration?: string(name='Duration'),
  autoPay?: boolean(name='AutoPay'),
  vSwitchId?: string(name='VSwitchId'),
  natType?: string(name='NatType'),
  internetChargeType?: string(name='InternetChargeType'),
  bandwidthPackage?: [ 
    {
    }
  ](name='BandwidthPackage'),
}

model CreateNatGatewayResponseBody = {
  requestId?: string(name='RequestId'),
  snatTableIds?: {
    snatTableId?: [ string ](name='SnatTableId')
  }(name='SnatTableIds'),
  forwardTableIds?: {
    forwardTableId?: [ string ](name='ForwardTableId')
  }(name='ForwardTableIds'),
  natGatewayId?: string(name='NatGatewayId'),
}

model CreateNatGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNatGatewayResponseBody(name='body'),
}

async function createNatGatewayWithOptions(request: CreateNatGatewayRequest, runtime: Util.RuntimeOptions): CreateNatGatewayResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateNatGateway', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createNatGateway(request: CreateNatGatewayRequest): CreateNatGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNatGatewayWithOptions(request, runtime);
}

model CreateNetworkAclRequest {
  vpcId?: string(name='VpcId'),
  networkAclName?: string(name='NetworkAclName'),
  description?: string(name='Description'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerId?: long(name='OwnerId'),
  clientToken?: string(name='ClientToken'),
}

model CreateNetworkAclResponseBody = {
  networkAclId?: string(name='NetworkAclId'),
  requestId?: string(name='RequestId'),
  networkAclAttribute?: {
    status?: string(name='Status'),
    vpcId?: string(name='VpcId'),
    creationTime?: string(name='CreationTime'),
    description?: string(name='Description'),
    egressAclEntries?: {
      egressAclEntry?: [ 
      {
        networkAclEntryId?: string(name='NetworkAclEntryId'),
        entryType?: string(name='EntryType'),
        networkAclEntryName?: string(name='NetworkAclEntryName'),
        policy?: string(name='Policy'),
        description?: string(name='Description'),
        protocol?: string(name='Protocol'),
        destinationCidrIp?: string(name='DestinationCidrIp'),
        port?: string(name='Port'),
      }
    ](name='EgressAclEntry')
    }(name='EgressAclEntries'),
    networkAclName?: string(name='NetworkAclName'),
    ingressAclEntries?: {
      ingressAclEntry?: [ 
      {
        networkAclEntryId?: string(name='NetworkAclEntryId'),
        entryType?: string(name='EntryType'),
        networkAclEntryName?: string(name='NetworkAclEntryName'),
        policy?: string(name='Policy'),
        description?: string(name='Description'),
        sourceCidrIp?: string(name='SourceCidrIp'),
        protocol?: string(name='Protocol'),
        port?: string(name='Port'),
      }
    ](name='IngressAclEntry')
    }(name='IngressAclEntries'),
    networkAclId?: string(name='NetworkAclId'),
    resources?: {
      resource?: [ 
      {
        status?: string(name='Status'),
        resourceType?: string(name='ResourceType'),
        resourceId?: string(name='ResourceId'),
      }
    ](name='Resource')
    }(name='Resources'),
    regionId?: string(name='RegionId'),
  }(name='NetworkAclAttribute'),
}

model CreateNetworkAclResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNetworkAclResponseBody(name='body'),
}

async function createNetworkAclWithOptions(request: CreateNetworkAclRequest, runtime: Util.RuntimeOptions): CreateNetworkAclResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateNetworkAcl', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createNetworkAcl(request: CreateNetworkAclRequest): CreateNetworkAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNetworkAclWithOptions(request, runtime);
}

model CreatePhysicalConnectionOccupancyOrderRequest {
  regionId?: string(name='RegionId'),
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  period?: int32(name='Period'),
  instanceChargeType?: string(name='InstanceChargeType'),
  autoPay?: boolean(name='AutoPay'),
  pricingCycle?: string(name='PricingCycle'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
}

model CreatePhysicalConnectionOccupancyOrderResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreatePhysicalConnectionOccupancyOrderResponse = {
  headers: map[string]string(name='headers'),
  body: CreatePhysicalConnectionOccupancyOrderResponseBody(name='body'),
}

async function createPhysicalConnectionOccupancyOrderWithOptions(request: CreatePhysicalConnectionOccupancyOrderRequest, runtime: Util.RuntimeOptions): CreatePhysicalConnectionOccupancyOrderResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreatePhysicalConnectionOccupancyOrder', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createPhysicalConnectionOccupancyOrder(request: CreatePhysicalConnectionOccupancyOrderRequest): CreatePhysicalConnectionOccupancyOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPhysicalConnectionOccupancyOrderWithOptions(request, runtime);
}

model CreateRouteEntryRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  routeTableId?: string(name='RouteTableId'),
  destinationCidrBlock?: string(name='DestinationCidrBlock'),
  nextHopId?: string(name='NextHopId'),
  privateIpAddress?: string(name='PrivateIpAddress'),
  clientToken?: string(name='ClientToken'),
  routeEntryName?: string(name='RouteEntryName'),
  description?: string(name='Description'),
  nextHopType?: string(name='NextHopType'),
  ownerAccount?: string(name='OwnerAccount'),
  nextHopList?: [ 
    {
      nextHopId?: string(name='NextHopId'),
      weight?: int32(name='Weight'),
      nextHopType?: string(name='NextHopType'),
    }
  ](name='NextHopList'),
}

model CreateRouteEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRouteEntryResponseBody(name='body'),
}

async function createRouteEntryWithOptions(request: CreateRouteEntryRequest, runtime: Util.RuntimeOptions): CreateRouteEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateRouteEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createRouteEntry(request: CreateRouteEntryRequest): CreateRouteEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRouteEntryWithOptions(request, runtime);
}

model CreateRouteTableRequest {
  regionId?: string(name='RegionId'),
  vpcId?: string(name='VpcId'),
  routeTableName?: string(name='RouteTableName'),
  description?: string(name='Description'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  clientToken?: string(name='ClientToken'),
}

model CreateRouteTableResponseBody = {
  routeTableId?: string(name='RouteTableId'),
  requestId?: string(name='RequestId'),
}

model CreateRouteTableResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRouteTableResponseBody(name='body'),
}

async function createRouteTableWithOptions(request: CreateRouteTableRequest, runtime: Util.RuntimeOptions): CreateRouteTableResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateRouteTable', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createRouteTable(request: CreateRouteTableRequest): CreateRouteTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRouteTableWithOptions(request, runtime);
}

model CreateSnatEntryRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  snatTableId?: string(name='SnatTableId'),
  sourceVSwitchId?: string(name='SourceVSwitchId'),
  sourceCIDR?: string(name='SourceCIDR'),
  snatIp?: string(name='SnatIp'),
  snatEntryName?: string(name='SnatEntryName'),
  clientToken?: string(name='ClientToken'),
}

model CreateSnatEntryResponseBody = {
  requestId?: string(name='RequestId'),
  snatEntryId?: string(name='SnatEntryId'),
}

model CreateSnatEntryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSnatEntryResponseBody(name='body'),
}

async function createSnatEntryWithOptions(request: CreateSnatEntryRequest, runtime: Util.RuntimeOptions): CreateSnatEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateSnatEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createSnatEntry(request: CreateSnatEntryRequest): CreateSnatEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSnatEntryWithOptions(request, runtime);
}

model CreateSslVpnClientCertRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  clientToken?: string(name='ClientToken'),
  regionId?: string(name='RegionId'),
  sslVpnServerId?: string(name='SslVpnServerId'),
  name?: string(name='Name'),
}

model CreateSslVpnClientCertResponseBody = {
  requestId?: string(name='RequestId'),
  sslVpnClientCertId?: string(name='SslVpnClientCertId'),
  name?: string(name='Name'),
}

model CreateSslVpnClientCertResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSslVpnClientCertResponseBody(name='body'),
}

async function createSslVpnClientCertWithOptions(request: CreateSslVpnClientCertRequest, runtime: Util.RuntimeOptions): CreateSslVpnClientCertResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateSslVpnClientCert', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createSslVpnClientCert(request: CreateSslVpnClientCertRequest): CreateSslVpnClientCertResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSslVpnClientCertWithOptions(request, runtime);
}

model CreateSslVpnServerRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  clientToken?: string(name='ClientToken'),
  regionId?: string(name='RegionId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  name?: string(name='Name'),
  clientIpPool?: string(name='ClientIpPool'),
  localSubnet?: string(name='LocalSubnet'),
  proto?: string(name='Proto'),
  cipher?: string(name='Cipher'),
  port?: int32(name='Port'),
  compress?: boolean(name='Compress'),
  enableMultiFactorAuth?: boolean(name='EnableMultiFactorAuth'),
  IDaaSInstanceId?: string(name='IDaaSInstanceId'),
}

model CreateSslVpnServerResponseBody = {
  requestId?: string(name='RequestId'),
  sslVpnServerId?: string(name='SslVpnServerId'),
  name?: string(name='Name'),
}

model CreateSslVpnServerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSslVpnServerResponseBody(name='body'),
}

async function createSslVpnServerWithOptions(request: CreateSslVpnServerRequest, runtime: Util.RuntimeOptions): CreateSslVpnServerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateSslVpnServer', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createSslVpnServer(request: CreateSslVpnServerRequest): CreateSslVpnServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSslVpnServerWithOptions(request, runtime);
}

model CreateVpcRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  cidrBlock?: string(name='CidrBlock'),
  ipv6CidrBlock?: string(name='Ipv6CidrBlock'),
  enableIpv6?: boolean(name='EnableIpv6'),
  vpcName?: string(name='VpcName'),
  description?: string(name='Description'),
  resourceGroupId?: string(name='ResourceGroupId'),
  dryRun?: boolean(name='DryRun'),
  userCidr?: string(name='UserCidr'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
}

model CreateVpcResponseBody = {
  VRouterId?: string(name='VRouterId'),
  routeTableId?: string(name='RouteTableId'),
  vpcId?: string(name='VpcId'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model CreateVpcResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVpcResponseBody(name='body'),
}

async function createVpcWithOptions(request: CreateVpcRequest, runtime: Util.RuntimeOptions): CreateVpcResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateVpc', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createVpc(request: CreateVpcRequest): CreateVpcResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVpcWithOptions(request, runtime);
}

model CreateVpnConnectionRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  customerGatewayId?: string(name='CustomerGatewayId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  name?: string(name='Name'),
  localSubnet?: string(name='LocalSubnet'),
  remoteSubnet?: string(name='RemoteSubnet'),
  effectImmediately?: boolean(name='EffectImmediately'),
  ikeConfig?: string(name='IkeConfig'),
  ipsecConfig?: string(name='IpsecConfig'),
  healthCheckConfig?: string(name='HealthCheckConfig'),
  autoConfigRoute?: boolean(name='AutoConfigRoute'),
  enableDpd?: boolean(name='EnableDpd'),
  enableNatTraversal?: boolean(name='EnableNatTraversal'),
  bgpConfig?: string(name='BgpConfig'),
  remoteCaCertificate?: string(name='RemoteCaCertificate'),
}

model CreateVpnConnectionResponseBody = {
  requestId?: string(name='RequestId'),
  createTime?: long(name='CreateTime'),
  vpnConnectionId?: string(name='VpnConnectionId'),
  name?: string(name='Name'),
}

model CreateVpnConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVpnConnectionResponseBody(name='body'),
}

async function createVpnConnectionWithOptions(request: CreateVpnConnectionRequest, runtime: Util.RuntimeOptions): CreateVpnConnectionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateVpnConnection', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createVpnConnection(request: CreateVpnConnectionRequest): CreateVpnConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVpnConnectionWithOptions(request, runtime);
}

model CreateVpnGatewayRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  vpcId?: string(name='VpcId'),
  instanceChargeType?: string(name='InstanceChargeType'),
  period?: int32(name='Period'),
  autoPay?: boolean(name='AutoPay'),
  bandwidth?: int32(name='Bandwidth'),
  enableIpsec?: boolean(name='EnableIpsec'),
  enableSsl?: boolean(name='EnableSsl'),
  sslConnections?: int32(name='SslConnections'),
  vSwitchId?: string(name='VSwitchId'),
  vpnType?: string(name='VpnType'),
  clientToken?: string(name='ClientToken'),
}

model CreateVpnGatewayResponseBody = {
  requestId?: string(name='RequestId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  orderId?: long(name='OrderId'),
  name?: string(name='Name'),
}

model CreateVpnGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVpnGatewayResponseBody(name='body'),
}

async function createVpnGatewayWithOptions(request: CreateVpnGatewayRequest, runtime: Util.RuntimeOptions): CreateVpnGatewayResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateVpnGateway', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createVpnGateway(request: CreateVpnGatewayRequest): CreateVpnGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVpnGatewayWithOptions(request, runtime);
}

model CreateVpnPbrRouteEntryRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  routeSource?: string(name='RouteSource'),
  routeDest?: string(name='RouteDest'),
  nextHop?: string(name='NextHop'),
  weight?: int32(name='Weight'),
  publishVpc?: boolean(name='PublishVpc'),
  description?: string(name='Description'),
  overlayMode?: string(name='OverlayMode'),
}

model CreateVpnPbrRouteEntryResponseBody = {
  routeDest?: string(name='RouteDest'),
  description?: string(name='Description'),
  vpnInstanceId?: string(name='VpnInstanceId'),
  requestId?: string(name='RequestId'),
  overlayMode?: string(name='OverlayMode'),
  nextHop?: string(name='NextHop'),
  state?: string(name='State'),
  createTime?: long(name='CreateTime'),
  routeSource?: string(name='RouteSource'),
  weight?: int32(name='Weight'),
}

model CreateVpnPbrRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVpnPbrRouteEntryResponseBody(name='body'),
}

async function createVpnPbrRouteEntryWithOptions(request: CreateVpnPbrRouteEntryRequest, runtime: Util.RuntimeOptions): CreateVpnPbrRouteEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateVpnPbrRouteEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createVpnPbrRouteEntry(request: CreateVpnPbrRouteEntryRequest): CreateVpnPbrRouteEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVpnPbrRouteEntryWithOptions(request, runtime);
}

model CreateVpnRouteEntryRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  routeDest?: string(name='RouteDest'),
  nextHop?: string(name='NextHop'),
  weight?: int32(name='Weight'),
  publishVpc?: boolean(name='PublishVpc'),
  description?: string(name='Description'),
  overlayMode?: string(name='OverlayMode'),
}

model CreateVpnRouteEntryResponseBody = {
  routeDest?: string(name='RouteDest'),
  description?: string(name='Description'),
  vpnInstanceId?: string(name='VpnInstanceId'),
  requestId?: string(name='RequestId'),
  overlayMode?: string(name='OverlayMode'),
  nextHop?: string(name='NextHop'),
  state?: string(name='State'),
  createTime?: long(name='CreateTime'),
  weight?: int32(name='Weight'),
}

model CreateVpnRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVpnRouteEntryResponseBody(name='body'),
}

async function createVpnRouteEntryWithOptions(request: CreateVpnRouteEntryRequest, runtime: Util.RuntimeOptions): CreateVpnRouteEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateVpnRouteEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createVpnRouteEntry(request: CreateVpnRouteEntryRequest): CreateVpnRouteEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVpnRouteEntryWithOptions(request, runtime);
}

model CreateVSwitchRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneId?: string(name='ZoneId'),
  regionId?: string(name='RegionId'),
  cidrBlock?: string(name='CidrBlock'),
  ipv6CidrBlock?: int32(name='Ipv6CidrBlock'),
  vpcId?: string(name='VpcId'),
  vSwitchName?: string(name='VSwitchName'),
  description?: string(name='Description'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
}

model CreateVSwitchResponseBody = {
  requestId?: string(name='RequestId'),
  vSwitchId?: string(name='VSwitchId'),
}

model CreateVSwitchResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVSwitchResponseBody(name='body'),
}

async function createVSwitchWithOptions(request: CreateVSwitchRequest, runtime: Util.RuntimeOptions): CreateVSwitchResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateVSwitch', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createVSwitch(request: CreateVSwitchRequest): CreateVSwitchResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVSwitchWithOptions(request, runtime);
}

model DeactivateRouterInterfaceRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  routerInterfaceId?: string(name='RouterInterfaceId'),
}

model DeactivateRouterInterfaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeactivateRouterInterfaceResponse = {
  headers: map[string]string(name='headers'),
  body: DeactivateRouterInterfaceResponseBody(name='body'),
}

async function deactivateRouterInterfaceWithOptions(request: DeactivateRouterInterfaceRequest, runtime: Util.RuntimeOptions): DeactivateRouterInterfaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeactivateRouterInterface', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deactivateRouterInterface(request: DeactivateRouterInterfaceRequest): DeactivateRouterInterfaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deactivateRouterInterfaceWithOptions(request, runtime);
}

model DeactiveFlowLogRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  flowLogId?: string(name='FlowLogId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DeactiveFlowLogResponseBody = {
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DeactiveFlowLogResponse = {
  headers: map[string]string(name='headers'),
  body: DeactiveFlowLogResponseBody(name='body'),
}

async function deactiveFlowLogWithOptions(request: DeactiveFlowLogRequest, runtime: Util.RuntimeOptions): DeactiveFlowLogResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeactiveFlowLog', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deactiveFlowLog(request: DeactiveFlowLogRequest): DeactiveFlowLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return deactiveFlowLogWithOptions(request, runtime);
}

model DeleteBgpGroupRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  bgpGroupId?: string(name='BgpGroupId'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DeleteBgpGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteBgpGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteBgpGroupResponseBody(name='body'),
}

async function deleteBgpGroupWithOptions(request: DeleteBgpGroupRequest, runtime: Util.RuntimeOptions): DeleteBgpGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteBgpGroup', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteBgpGroup(request: DeleteBgpGroupRequest): DeleteBgpGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBgpGroupWithOptions(request, runtime);
}

model DeleteBgpNetworkRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  dstCidrBlock?: string(name='DstCidrBlock'),
  routerId?: string(name='RouterId'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DeleteBgpNetworkResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteBgpNetworkResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteBgpNetworkResponseBody(name='body'),
}

async function deleteBgpNetworkWithOptions(request: DeleteBgpNetworkRequest, runtime: Util.RuntimeOptions): DeleteBgpNetworkResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteBgpNetwork', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteBgpNetwork(request: DeleteBgpNetworkRequest): DeleteBgpNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBgpNetworkWithOptions(request, runtime);
}

model DeleteBgpPeerRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  bgpPeerId?: string(name='BgpPeerId'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DeleteBgpPeerResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteBgpPeerResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteBgpPeerResponseBody(name='body'),
}

async function deleteBgpPeerWithOptions(request: DeleteBgpPeerRequest, runtime: Util.RuntimeOptions): DeleteBgpPeerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteBgpPeer', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteBgpPeer(request: DeleteBgpPeerRequest): DeleteBgpPeerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBgpPeerWithOptions(request, runtime);
}

model DeleteCommonBandwidthPackageRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  force?: string(name='Force'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
}

model DeleteCommonBandwidthPackageResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteCommonBandwidthPackageResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteCommonBandwidthPackageResponseBody(name='body'),
}

async function deleteCommonBandwidthPackageWithOptions(request: DeleteCommonBandwidthPackageRequest, runtime: Util.RuntimeOptions): DeleteCommonBandwidthPackageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteCommonBandwidthPackage', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteCommonBandwidthPackage(request: DeleteCommonBandwidthPackageRequest): DeleteCommonBandwidthPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCommonBandwidthPackageWithOptions(request, runtime);
}

model DeleteCustomerGatewayRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  customerGatewayId?: string(name='CustomerGatewayId'),
}

model DeleteCustomerGatewayResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteCustomerGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteCustomerGatewayResponseBody(name='body'),
}

async function deleteCustomerGatewayWithOptions(request: DeleteCustomerGatewayRequest, runtime: Util.RuntimeOptions): DeleteCustomerGatewayResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteCustomerGateway', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteCustomerGateway(request: DeleteCustomerGatewayRequest): DeleteCustomerGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCustomerGatewayWithOptions(request, runtime);
}

model DeleteDhcpOptionsSetRequest {
  regionId?: string(name='RegionId'),
  dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
}

model DeleteDhcpOptionsSetResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDhcpOptionsSetResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDhcpOptionsSetResponseBody(name='body'),
}

async function deleteDhcpOptionsSetWithOptions(request: DeleteDhcpOptionsSetRequest, runtime: Util.RuntimeOptions): DeleteDhcpOptionsSetResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteDhcpOptionsSet', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteDhcpOptionsSet(request: DeleteDhcpOptionsSetRequest): DeleteDhcpOptionsSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDhcpOptionsSetWithOptions(request, runtime);
}

model DeleteExpressCloudConnectionRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  eccId?: string(name='EccId'),
}

model DeleteExpressCloudConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteExpressCloudConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteExpressCloudConnectionResponseBody(name='body'),
}

async function deleteExpressCloudConnectionWithOptions(request: DeleteExpressCloudConnectionRequest, runtime: Util.RuntimeOptions): DeleteExpressCloudConnectionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteExpressCloudConnection', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteExpressCloudConnection(request: DeleteExpressCloudConnectionRequest): DeleteExpressCloudConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteExpressCloudConnectionWithOptions(request, runtime);
}

model DeleteExpressConnectRequest {
  regionId?: string(name='RegionId'),
  routerInterfaceId?: string(name='RouterInterfaceId'),
  force?: boolean(name='Force'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DeleteExpressConnectResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteExpressConnectResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteExpressConnectResponseBody(name='body'),
}

async function deleteExpressConnectWithOptions(request: DeleteExpressConnectRequest, runtime: Util.RuntimeOptions): DeleteExpressConnectResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteExpressConnect', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteExpressConnect(request: DeleteExpressConnectRequest): DeleteExpressConnectResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteExpressConnectWithOptions(request, runtime);
}

model DeleteFlowLogRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  flowLogId?: string(name='FlowLogId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DeleteFlowLogResponseBody = {
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DeleteFlowLogResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFlowLogResponseBody(name='body'),
}

async function deleteFlowLogWithOptions(request: DeleteFlowLogRequest, runtime: Util.RuntimeOptions): DeleteFlowLogResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteFlowLog', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteFlowLog(request: DeleteFlowLogRequest): DeleteFlowLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFlowLogWithOptions(request, runtime);
}

model DeleteForwardEntryRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  forwardTableId?: string(name='ForwardTableId'),
  forwardEntryId?: string(name='ForwardEntryId'),
  clientToken?: string(name='ClientToken'),
}

model DeleteForwardEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteForwardEntryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteForwardEntryResponseBody(name='body'),
}

async function deleteForwardEntryWithOptions(request: DeleteForwardEntryRequest, runtime: Util.RuntimeOptions): DeleteForwardEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteForwardEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteForwardEntry(request: DeleteForwardEntryRequest): DeleteForwardEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteForwardEntryWithOptions(request, runtime);
}

model DeleteGlobalAccelerationInstanceRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  globalAccelerationInstanceId?: string(name='GlobalAccelerationInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DeleteGlobalAccelerationInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteGlobalAccelerationInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteGlobalAccelerationInstanceResponseBody(name='body'),
}

async function deleteGlobalAccelerationInstanceWithOptions(request: DeleteGlobalAccelerationInstanceRequest, runtime: Util.RuntimeOptions): DeleteGlobalAccelerationInstanceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteGlobalAccelerationInstance', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteGlobalAccelerationInstance(request: DeleteGlobalAccelerationInstanceRequest): DeleteGlobalAccelerationInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGlobalAccelerationInstanceWithOptions(request, runtime);
}

model DeleteHaVipRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  clientToken?: string(name='ClientToken'),
  regionId?: string(name='RegionId'),
  haVipId?: string(name='HaVipId'),
}

model DeleteHaVipResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteHaVipResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteHaVipResponseBody(name='body'),
}

async function deleteHaVipWithOptions(request: DeleteHaVipRequest, runtime: Util.RuntimeOptions): DeleteHaVipResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteHaVip', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteHaVip(request: DeleteHaVipRequest): DeleteHaVipResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHaVipWithOptions(request, runtime);
}

model DeleteIpsecServerRequest {
  regionId?: string(name='RegionId'),
  ipsecServerId?: string(name='IpsecServerId'),
  clientToken?: string(name='ClientToken'),
  callerBid?: string(name='callerBid'),
  dryRun?: string(name='DryRun'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteIpsecServerResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIpsecServerResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIpsecServerResponseBody(name='body'),
}

async function deleteIpsecServerWithOptions(request: DeleteIpsecServerRequest, runtime: Util.RuntimeOptions): DeleteIpsecServerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteIpsecServer', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteIpsecServer(request: DeleteIpsecServerRequest): DeleteIpsecServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIpsecServerWithOptions(request, runtime);
}

model DeleteIpv6EgressOnlyRuleRequest {
  regionId?: string(name='RegionId'),
  ipv6EgressOnlyRuleId?: string(name='Ipv6EgressOnlyRuleId'),
  clientToken?: string(name='ClientToken'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DeleteIpv6EgressOnlyRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIpv6EgressOnlyRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIpv6EgressOnlyRuleResponseBody(name='body'),
}

async function deleteIpv6EgressOnlyRuleWithOptions(request: DeleteIpv6EgressOnlyRuleRequest, runtime: Util.RuntimeOptions): DeleteIpv6EgressOnlyRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteIpv6EgressOnlyRule', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteIpv6EgressOnlyRule(request: DeleteIpv6EgressOnlyRuleRequest): DeleteIpv6EgressOnlyRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIpv6EgressOnlyRuleWithOptions(request, runtime);
}

model DeleteIpv6GatewayRequest {
  regionId?: string(name='RegionId'),
  ipv6GatewayId?: string(name='Ipv6GatewayId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DeleteIpv6GatewayResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIpv6GatewayResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIpv6GatewayResponseBody(name='body'),
}

async function deleteIpv6GatewayWithOptions(request: DeleteIpv6GatewayRequest, runtime: Util.RuntimeOptions): DeleteIpv6GatewayResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteIpv6Gateway', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteIpv6Gateway(request: DeleteIpv6GatewayRequest): DeleteIpv6GatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIpv6GatewayWithOptions(request, runtime);
}

model DeleteIpv6InternetBandwidthRequest {
  regionId?: string(name='RegionId'),
  ipv6AddressId?: string(name='Ipv6AddressId'),
  ipv6InternetBandwidthId?: string(name='Ipv6InternetBandwidthId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DeleteIpv6InternetBandwidthResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIpv6InternetBandwidthResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIpv6InternetBandwidthResponseBody(name='body'),
}

async function deleteIpv6InternetBandwidthWithOptions(request: DeleteIpv6InternetBandwidthRequest, runtime: Util.RuntimeOptions): DeleteIpv6InternetBandwidthResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteIpv6InternetBandwidth', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteIpv6InternetBandwidth(request: DeleteIpv6InternetBandwidthRequest): DeleteIpv6InternetBandwidthResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIpv6InternetBandwidthWithOptions(request, runtime);
}

model DeleteIPv6TranslatorRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  clientToken?: string(name='ClientToken'),
  regionId?: string(name='RegionId'),
  ipv6TranslatorId?: string(name='Ipv6TranslatorId'),
}

model DeleteIPv6TranslatorResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIPv6TranslatorResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIPv6TranslatorResponseBody(name='body'),
}

async function deleteIPv6TranslatorWithOptions(request: DeleteIPv6TranslatorRequest, runtime: Util.RuntimeOptions): DeleteIPv6TranslatorResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteIPv6Translator', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteIPv6Translator(request: DeleteIPv6TranslatorRequest): DeleteIPv6TranslatorResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIPv6TranslatorWithOptions(request, runtime);
}

model DeleteIPv6TranslatorAclListRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  clientToken?: string(name='ClientToken'),
  regionId?: string(name='RegionId'),
  aclId?: string(name='AclId'),
}

model DeleteIPv6TranslatorAclListResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIPv6TranslatorAclListResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIPv6TranslatorAclListResponseBody(name='body'),
}

async function deleteIPv6TranslatorAclListWithOptions(request: DeleteIPv6TranslatorAclListRequest, runtime: Util.RuntimeOptions): DeleteIPv6TranslatorAclListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteIPv6TranslatorAclList', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteIPv6TranslatorAclList(request: DeleteIPv6TranslatorAclListRequest): DeleteIPv6TranslatorAclListResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIPv6TranslatorAclListWithOptions(request, runtime);
}

model DeleteIPv6TranslatorEntryRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  clientToken?: string(name='ClientToken'),
  regionId?: string(name='RegionId'),
  ipv6TranslatorEntryId?: string(name='Ipv6TranslatorEntryId'),
  ipv6TranslatorId?: string(name='Ipv6TranslatorId'),
}

model DeleteIPv6TranslatorEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIPv6TranslatorEntryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIPv6TranslatorEntryResponseBody(name='body'),
}

async function deleteIPv6TranslatorEntryWithOptions(request: DeleteIPv6TranslatorEntryRequest, runtime: Util.RuntimeOptions): DeleteIPv6TranslatorEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteIPv6TranslatorEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteIPv6TranslatorEntry(request: DeleteIPv6TranslatorEntryRequest): DeleteIPv6TranslatorEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIPv6TranslatorEntryWithOptions(request, runtime);
}

model DeleteNatGatewayRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  natGatewayId?: string(name='NatGatewayId'),
  force?: boolean(name='Force'),
}

model DeleteNatGatewayResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteNatGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNatGatewayResponseBody(name='body'),
}

async function deleteNatGatewayWithOptions(request: DeleteNatGatewayRequest, runtime: Util.RuntimeOptions): DeleteNatGatewayResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteNatGateway', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteNatGateway(request: DeleteNatGatewayRequest): DeleteNatGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNatGatewayWithOptions(request, runtime);
}

model DeleteNetworkAclRequest {
  networkAclId?: string(name='NetworkAclId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerId?: long(name='OwnerId'),
  clientToken?: string(name='ClientToken'),
}

model DeleteNetworkAclResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteNetworkAclResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNetworkAclResponseBody(name='body'),
}

async function deleteNetworkAclWithOptions(request: DeleteNetworkAclRequest, runtime: Util.RuntimeOptions): DeleteNetworkAclResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteNetworkAcl', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteNetworkAcl(request: DeleteNetworkAclRequest): DeleteNetworkAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNetworkAclWithOptions(request, runtime);
}

model DeletePhysicalConnectionRequest {
  regionId?: string(name='RegionId'),
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DeletePhysicalConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeletePhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: DeletePhysicalConnectionResponseBody(name='body'),
}

async function deletePhysicalConnectionWithOptions(request: DeletePhysicalConnectionRequest, runtime: Util.RuntimeOptions): DeletePhysicalConnectionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeletePhysicalConnection', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deletePhysicalConnection(request: DeletePhysicalConnectionRequest): DeletePhysicalConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePhysicalConnectionWithOptions(request, runtime);
}

model DeleteRouteEntryRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  routeTableId?: string(name='RouteTableId'),
  routeEntryId?: string(name='RouteEntryId'),
  destinationCidrBlock?: string(name='DestinationCidrBlock'),
  nextHopId?: string(name='NextHopId'),
  ownerAccount?: string(name='OwnerAccount'),
  nextHopList?: [ 
    {
      nextHopId?: string(name='NextHopId'),
      nextHopType?: string(name='NextHopType'),
    }
  ](name='NextHopList'),
}

model DeleteRouteEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRouteEntryResponseBody(name='body'),
}

async function deleteRouteEntryWithOptions(request: DeleteRouteEntryRequest, runtime: Util.RuntimeOptions): DeleteRouteEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteRouteEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteRouteEntry(request: DeleteRouteEntryRequest): DeleteRouteEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRouteEntryWithOptions(request, runtime);
}

model DeleteRouterInterfaceRequest {
  regionId?: string(name='RegionId'),
  routerInterfaceId?: string(name='RouterInterfaceId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DeleteRouterInterfaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteRouterInterfaceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRouterInterfaceResponseBody(name='body'),
}

async function deleteRouterInterfaceWithOptions(request: DeleteRouterInterfaceRequest, runtime: Util.RuntimeOptions): DeleteRouterInterfaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteRouterInterface', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteRouterInterface(request: DeleteRouterInterfaceRequest): DeleteRouterInterfaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRouterInterfaceWithOptions(request, runtime);
}

model DeleteRouteTableRequest {
  regionId?: string(name='RegionId'),
  routeTableId?: string(name='RouteTableId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DeleteRouteTableResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteRouteTableResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRouteTableResponseBody(name='body'),
}

async function deleteRouteTableWithOptions(request: DeleteRouteTableRequest, runtime: Util.RuntimeOptions): DeleteRouteTableResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteRouteTable', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteRouteTable(request: DeleteRouteTableRequest): DeleteRouteTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRouteTableWithOptions(request, runtime);
}

model DeleteSnatEntryRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  snatTableId?: string(name='SnatTableId'),
  snatEntryId?: string(name='SnatEntryId'),
  clientToken?: string(name='ClientToken'),
}

model DeleteSnatEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSnatEntryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSnatEntryResponseBody(name='body'),
}

async function deleteSnatEntryWithOptions(request: DeleteSnatEntryRequest, runtime: Util.RuntimeOptions): DeleteSnatEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteSnatEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteSnatEntry(request: DeleteSnatEntryRequest): DeleteSnatEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSnatEntryWithOptions(request, runtime);
}

model DeleteSslVpnClientCertRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  sslVpnClientCertId?: string(name='SslVpnClientCertId'),
}

model DeleteSslVpnClientCertResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSslVpnClientCertResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSslVpnClientCertResponseBody(name='body'),
}

async function deleteSslVpnClientCertWithOptions(request: DeleteSslVpnClientCertRequest, runtime: Util.RuntimeOptions): DeleteSslVpnClientCertResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteSslVpnClientCert', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteSslVpnClientCert(request: DeleteSslVpnClientCertRequest): DeleteSslVpnClientCertResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSslVpnClientCertWithOptions(request, runtime);
}

model DeleteSslVpnServerRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  sslVpnServerId?: string(name='SslVpnServerId'),
}

model DeleteSslVpnServerResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSslVpnServerResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSslVpnServerResponseBody(name='body'),
}

async function deleteSslVpnServerWithOptions(request: DeleteSslVpnServerRequest, runtime: Util.RuntimeOptions): DeleteSslVpnServerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteSslVpnServer', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteSslVpnServer(request: DeleteSslVpnServerRequest): DeleteSslVpnServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSslVpnServerWithOptions(request, runtime);
}

model DeleteVirtualBorderRouterRequest {
  regionId?: string(name='RegionId'),
  vbrId?: string(name='VbrId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DeleteVirtualBorderRouterResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVirtualBorderRouterResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVirtualBorderRouterResponseBody(name='body'),
}

async function deleteVirtualBorderRouterWithOptions(request: DeleteVirtualBorderRouterRequest, runtime: Util.RuntimeOptions): DeleteVirtualBorderRouterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteVirtualBorderRouter', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteVirtualBorderRouter(request: DeleteVirtualBorderRouterRequest): DeleteVirtualBorderRouterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVirtualBorderRouterWithOptions(request, runtime);
}

model DeleteVpcRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpcId?: string(name='VpcId'),
  regionId?: string(name='RegionId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DeleteVpcResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVpcResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVpcResponseBody(name='body'),
}

async function deleteVpcWithOptions(request: DeleteVpcRequest, runtime: Util.RuntimeOptions): DeleteVpcResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteVpc', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteVpc(request: DeleteVpcRequest): DeleteVpcResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVpcWithOptions(request, runtime);
}

model DeleteVpnConnectionRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  vpnConnectionId?: string(name='VpnConnectionId'),
}

model DeleteVpnConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVpnConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVpnConnectionResponseBody(name='body'),
}

async function deleteVpnConnectionWithOptions(request: DeleteVpnConnectionRequest, runtime: Util.RuntimeOptions): DeleteVpnConnectionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteVpnConnection', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteVpnConnection(request: DeleteVpnConnectionRequest): DeleteVpnConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVpnConnectionWithOptions(request, runtime);
}

model DeleteVpnGatewayRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model DeleteVpnGatewayResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVpnGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVpnGatewayResponseBody(name='body'),
}

async function deleteVpnGatewayWithOptions(request: DeleteVpnGatewayRequest, runtime: Util.RuntimeOptions): DeleteVpnGatewayResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteVpnGateway', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteVpnGateway(request: DeleteVpnGatewayRequest): DeleteVpnGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVpnGatewayWithOptions(request, runtime);
}

model DeleteVpnPbrRouteEntryRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  routeSource?: string(name='RouteSource'),
  routeDest?: string(name='RouteDest'),
  nextHop?: string(name='NextHop'),
  weight?: int32(name='Weight'),
  overlayMode?: string(name='OverlayMode'),
}

model DeleteVpnPbrRouteEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVpnPbrRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVpnPbrRouteEntryResponseBody(name='body'),
}

async function deleteVpnPbrRouteEntryWithOptions(request: DeleteVpnPbrRouteEntryRequest, runtime: Util.RuntimeOptions): DeleteVpnPbrRouteEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteVpnPbrRouteEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteVpnPbrRouteEntry(request: DeleteVpnPbrRouteEntryRequest): DeleteVpnPbrRouteEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVpnPbrRouteEntryWithOptions(request, runtime);
}

model DeleteVpnRouteEntryRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  routeDest?: string(name='RouteDest'),
  nextHop?: string(name='NextHop'),
  weight?: int32(name='Weight'),
  overlayMode?: string(name='OverlayMode'),
}

model DeleteVpnRouteEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVpnRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVpnRouteEntryResponseBody(name='body'),
}

async function deleteVpnRouteEntryWithOptions(request: DeleteVpnRouteEntryRequest, runtime: Util.RuntimeOptions): DeleteVpnRouteEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteVpnRouteEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteVpnRouteEntry(request: DeleteVpnRouteEntryRequest): DeleteVpnRouteEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVpnRouteEntryWithOptions(request, runtime);
}

model DeleteVSwitchRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vSwitchId?: string(name='VSwitchId'),
  regionId?: string(name='RegionId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DeleteVSwitchResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVSwitchResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVSwitchResponseBody(name='body'),
}

async function deleteVSwitchWithOptions(request: DeleteVSwitchRequest, runtime: Util.RuntimeOptions): DeleteVSwitchResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteVSwitch', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteVSwitch(request: DeleteVSwitchRequest): DeleteVSwitchResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVSwitchWithOptions(request, runtime);
}

model DeletionProtectionRequest {
  protectionEnable?: boolean(name='ProtectionEnable'),
  type?: string(name='Type'),
  instanceId?: string(name='InstanceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerId?: long(name='OwnerId'),
  clientToken?: string(name='ClientToken'),
  regionId?: string(name='RegionId'),
}

model DeletionProtectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeletionProtectionResponse = {
  headers: map[string]string(name='headers'),
  body: DeletionProtectionResponseBody(name='body'),
}

async function deletionProtectionWithOptions(request: DeletionProtectionRequest, runtime: Util.RuntimeOptions): DeletionProtectionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeletionProtection', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deletionProtection(request: DeletionProtectionRequest): DeletionProtectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletionProtectionWithOptions(request, runtime);
}

model DescribeAccessPointsRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  type?: string(name='Type'),
  name?: string(name='Name'),
  hostOperator?: string(name='HostOperator'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  filter?: [ 
    {
    }
  ](name='Filter'),
}

model DescribeAccessPointsResponseBody = {
  accessPointSet?: {
    accessPointType?: [ 
    {
      status?: string(name='Status'),
      type?: string(name='Type'),
      hostOperator?: string(name='HostOperator'),
      description?: string(name='Description'),
      attachedRegionNo?: string(name='AttachedRegionNo'),
      accessPointFeatureModels?: {
        accessPointFeatureModel?: [ 
        {
          featureValue?: string(name='FeatureValue'),
          featureKey?: string(name='FeatureKey'),
        }
      ](name='AccessPointFeatureModel')
      }(name='AccessPointFeatureModels'),
      name?: string(name='Name'),
      accessPointId?: string(name='AccessPointId'),
      location?: string(name='Location'),
    }
  ](name='AccessPointType')
  }(name='AccessPointSet'),
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
}

model DescribeAccessPointsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAccessPointsResponseBody(name='body'),
}

async function describeAccessPointsWithOptions(request: DescribeAccessPointsRequest, runtime: Util.RuntimeOptions): DescribeAccessPointsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeAccessPoints', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeAccessPoints(request: DescribeAccessPointsRequest): DescribeAccessPointsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAccessPointsWithOptions(request, runtime);
}

model DescribeBgpGroupsRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routerId?: string(name='RouterId'),
  bgpGroupId?: string(name='BgpGroupId'),
  regionId?: string(name='RegionId'),
  isDefault?: boolean(name='IsDefault'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DescribeBgpGroupsResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  bgpGroups?: {
    bgpGroup?: [ 
    {
      status?: string(name='Status'),
      routerId?: string(name='RouterId'),
      bgpGroupId?: string(name='BgpGroupId'),
      peerAsn?: string(name='PeerAsn'),
      localAsn?: string(name='LocalAsn'),
      regionId?: string(name='RegionId'),
      hold?: string(name='Hold'),
      keepalive?: string(name='Keepalive'),
      description?: string(name='Description'),
      ipVersion?: string(name='IpVersion'),
      routeLimit?: string(name='RouteLimit'),
      isFake?: string(name='IsFake'),
      name?: string(name='Name'),
      authKey?: string(name='AuthKey'),
    }
  ](name='BgpGroup')
  }(name='BgpGroups'),
}

model DescribeBgpGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBgpGroupsResponseBody(name='body'),
}

async function describeBgpGroupsWithOptions(request: DescribeBgpGroupsRequest, runtime: Util.RuntimeOptions): DescribeBgpGroupsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeBgpGroups', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeBgpGroups(request: DescribeBgpGroupsRequest): DescribeBgpGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBgpGroupsWithOptions(request, runtime);
}

model DescribeBgpNetworksRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routerId?: string(name='RouterId'),
  regionId?: string(name='RegionId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DescribeBgpNetworksResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  bgpNetworks?: {
    bgpNetwork?: [ 
    {
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
      routerId?: string(name='RouterId'),
      dstCidrBlock?: string(name='DstCidrBlock'),
    }
  ](name='BgpNetwork')
  }(name='BgpNetworks'),
}

model DescribeBgpNetworksResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBgpNetworksResponseBody(name='body'),
}

async function describeBgpNetworksWithOptions(request: DescribeBgpNetworksRequest, runtime: Util.RuntimeOptions): DescribeBgpNetworksResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeBgpNetworks', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeBgpNetworks(request: DescribeBgpNetworksRequest): DescribeBgpNetworksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBgpNetworksWithOptions(request, runtime);
}

model DescribeBgpPeersRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routerId?: string(name='RouterId'),
  bgpPeerId?: string(name='BgpPeerId'),
  bgpGroupId?: string(name='BgpGroupId'),
  regionId?: string(name='RegionId'),
  isDefault?: boolean(name='IsDefault'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DescribeBgpPeersResponseBody = {
  totalCount?: int32(name='TotalCount'),
  bgpPeers?: {
    bgpPeer?: [ 
    {
      peerIpAddress?: string(name='PeerIpAddress'),
      status?: string(name='Status'),
      bgpGroupId?: string(name='BgpGroupId'),
      routerId?: string(name='RouterId'),
      bgpStatus?: string(name='BgpStatus'),
      peerAsn?: string(name='PeerAsn'),
      bfdMultiHop?: int32(name='BfdMultiHop'),
      localAsn?: string(name='LocalAsn'),
      regionId?: string(name='RegionId'),
      bgpPeerId?: string(name='BgpPeerId'),
      enableBfd?: boolean(name='EnableBfd'),
      hold?: string(name='Hold'),
      ipVersion?: string(name='IpVersion'),
      keepalive?: string(name='Keepalive'),
      description?: string(name='Description'),
      routeLimit?: string(name='RouteLimit'),
      isFake?: string(name='IsFake'),
      authKey?: string(name='AuthKey'),
      name?: string(name='Name'),
    }
  ](name='BgpPeer')
  }(name='BgpPeers'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
}

model DescribeBgpPeersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBgpPeersResponseBody(name='body'),
}

async function describeBgpPeersWithOptions(request: DescribeBgpPeersRequest, runtime: Util.RuntimeOptions): DescribeBgpPeersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeBgpPeers', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeBgpPeers(request: DescribeBgpPeersRequest): DescribeBgpPeersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBgpPeersWithOptions(request, runtime);
}

model DescribeCommonBandwidthPackagesRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  includeReservationData?: boolean(name='IncludeReservationData'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  name?: string(name='Name'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  dryRun?: boolean(name='DryRun'),
  tag?: [ 
    {
    }
  ](name='Tag'),
}

model DescribeCommonBandwidthPackagesResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  commonBandwidthPackages?: {
    commonBandwidthPackage?: [ 
    {
      publicIpAddresses?: {
        publicIpAddresse?: [ 
        {
          ipAddress?: string(name='IpAddress'),
          allocationId?: string(name='AllocationId'),
          bandwidthPackageIpRelationStatus?: string(name='BandwidthPackageIpRelationStatus'),
        }
      ](name='PublicIpAddresse')
      }(name='PublicIpAddresses'),
      creationTime?: string(name='CreationTime'),
      status?: string(name='Status'),
      reservationActiveTime?: string(name='ReservationActiveTime'),
      reservationOrderType?: string(name='ReservationOrderType'),
      deletionProtection?: boolean(name='DeletionProtection'),
      regionId?: string(name='RegionId'),
      instanceChargeType?: string(name='InstanceChargeType'),
      ratio?: int32(name='Ratio'),
      reservationInternetChargeType?: string(name='ReservationInternetChargeType'),
      bandwidthPackageId?: string(name='BandwidthPackageId'),
      serviceManaged?: int32(name='ServiceManaged'),
      bandwidth?: string(name='Bandwidth'),
      description?: string(name='Description'),
      expiredTime?: string(name='ExpiredTime'),
      reservationBandwidth?: string(name='ReservationBandwidth'),
      resourceGroupId?: string(name='ResourceGroupId'),
      internetChargeType?: string(name='InternetChargeType'),
      businessStatus?: string(name='BusinessStatus'),
      name?: string(name='Name'),
      ISP?: string(name='ISP'),
      hasReservationData?: string(name='HasReservationData'),
    }
  ](name='CommonBandwidthPackage')
  }(name='CommonBandwidthPackages'),
}

model DescribeCommonBandwidthPackagesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCommonBandwidthPackagesResponseBody(name='body'),
}

async function describeCommonBandwidthPackagesWithOptions(request: DescribeCommonBandwidthPackagesRequest, runtime: Util.RuntimeOptions): DescribeCommonBandwidthPackagesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeCommonBandwidthPackages', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeCommonBandwidthPackages(request: DescribeCommonBandwidthPackagesRequest): DescribeCommonBandwidthPackagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCommonBandwidthPackagesWithOptions(request, runtime);
}

model DescribeCustomerGatewayRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  customerGatewayId?: string(name='CustomerGatewayId'),
}

model DescribeCustomerGatewayResponseBody = {
  description?: string(name='Description'),
  requestId?: string(name='RequestId'),
  customerGatewayId?: string(name='CustomerGatewayId'),
  createTime?: long(name='CreateTime'),
  ipAddress?: string(name='IpAddress'),
  asn?: int32(name='Asn'),
  name?: string(name='Name'),
}

model DescribeCustomerGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCustomerGatewayResponseBody(name='body'),
}

async function describeCustomerGatewayWithOptions(request: DescribeCustomerGatewayRequest, runtime: Util.RuntimeOptions): DescribeCustomerGatewayResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeCustomerGateway', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeCustomerGateway(request: DescribeCustomerGatewayRequest): DescribeCustomerGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomerGatewayWithOptions(request, runtime);
}

model DescribeCustomerGatewaysRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  customerGatewayId?: string(name='CustomerGatewayId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeCustomerGatewaysResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  customerGateways?: {
    customerGateway?: [ 
    {
      ipAddress?: string(name='IpAddress'),
      asn?: int32(name='Asn'),
      description?: string(name='Description'),
      customerGatewayId?: string(name='CustomerGatewayId'),
      createTime?: long(name='CreateTime'),
      name?: string(name='Name'),
    }
  ](name='CustomerGateway')
  }(name='CustomerGateways'),
}

model DescribeCustomerGatewaysResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCustomerGatewaysResponseBody(name='body'),
}

async function describeCustomerGatewaysWithOptions(request: DescribeCustomerGatewaysRequest, runtime: Util.RuntimeOptions): DescribeCustomerGatewaysResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeCustomerGateways', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeCustomerGateways(request: DescribeCustomerGatewaysRequest): DescribeCustomerGatewaysResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomerGatewaysWithOptions(request, runtime);
}

model DescribeEipAddressesRequest {
  filter?: [
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Filter'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  includeReservationData?: boolean(name='IncludeReservationData'),
  status?: string(name='Status'),
  eipAddress?: string(name='EipAddress'),
  allocationId?: string(name='AllocationId'),
  segmentInstanceId?: string(name='SegmentInstanceId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  ISP?: string(name='ISP'),
  ownerAccount?: string(name='OwnerAccount'),
  lockReason?: string(name='LockReason'),
  associatedInstanceType?: string(name='AssociatedInstanceType'),
  associatedInstanceId?: string(name='AssociatedInstanceId'),
  chargeType?: string(name='ChargeType'),
  dryRun?: boolean(name='DryRun'),
  tag?: [ 
    {
    }
  ](name='Tag'),
}

model DescribeEipAddressesResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  eipAddresses?: {
    eipAddress?: [ 
    {
      reservationActiveTime?: string(name='ReservationActiveTime'),
      status?: string(name='Status'),
      reservationOrderType?: string(name='ReservationOrderType'),
      allocationTime?: string(name='AllocationTime'),
      operationLocks?: {
        lockReason?: [ 
        {
          lockReason?: string(name='LockReason'),
        }
      ](name='LockReason')
      }(name='OperationLocks'),
      netmode?: string(name='Netmode'),
      chargeType?: string(name='ChargeType'),
      descritpion?: string(name='Descritpion'),
      segmentInstanceId?: string(name='SegmentInstanceId'),
      reservationInternetChargeType?: string(name='ReservationInternetChargeType'),
      bandwidthPackageId?: string(name='BandwidthPackageId'),
      ipAddress?: string(name='IpAddress'),
      bandwidth?: string(name='Bandwidth'),
      reservationBandwidth?: string(name='ReservationBandwidth'),
      eipBandwidth?: string(name='EipBandwidth'),
      availableRegions?: {
        availableRegion?: [ string ](name='AvailableRegion')
      }(name='AvailableRegions'),
      name?: string(name='Name'),
      instanceRegionId?: string(name='InstanceRegionId'),
      deletionProtection?: boolean(name='DeletionProtection'),
      instanceId?: string(name='InstanceId'),
      secondLimited?: boolean(name='SecondLimited'),
      instanceType?: string(name='InstanceType'),
      HDMonitorStatus?: string(name='HDMonitorStatus'),
      regionId?: string(name='RegionId'),
      bandwidthPackageBandwidth?: string(name='BandwidthPackageBandwidth'),
      serviceManaged?: int32(name='ServiceManaged'),
      expiredTime?: string(name='ExpiredTime'),
      resourceGroupId?: string(name='ResourceGroupId'),
      allocationId?: string(name='AllocationId'),
      internetChargeType?: string(name='InternetChargeType'),
      businessStatus?: string(name='BusinessStatus'),
      bandwidthPackageType?: string(name='BandwidthPackageType'),
      hasReservationData?: string(name='HasReservationData'),
      ISP?: string(name='ISP'),
    }
  ](name='EipAddress')
  }(name='EipAddresses'),
  pageNumber?: int32(name='PageNumber'),
}

model DescribeEipAddressesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEipAddressesResponseBody(name='body'),
}

async function describeEipAddressesWithOptions(request: DescribeEipAddressesRequest, runtime: Util.RuntimeOptions): DescribeEipAddressesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeEipAddresses', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeEipAddresses(request: DescribeEipAddressesRequest): DescribeEipAddressesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEipAddressesWithOptions(request, runtime);
}

model DescribeEipGatewayInfoRequest {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DescribeEipGatewayInfoResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  eipInfos?: {
    eipInfo?: [ 
    {
      ipGw?: string(name='IpGw'),
      ipMask?: string(name='IpMask'),
      ip?: string(name='Ip'),
    }
  ](name='EipInfo')
  }(name='EipInfos'),
}

model DescribeEipGatewayInfoResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEipGatewayInfoResponseBody(name='body'),
}

async function describeEipGatewayInfoWithOptions(request: DescribeEipGatewayInfoRequest, runtime: Util.RuntimeOptions): DescribeEipGatewayInfoResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeEipGatewayInfo', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeEipGatewayInfo(request: DescribeEipGatewayInfoRequest): DescribeEipGatewayInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEipGatewayInfoWithOptions(request, runtime);
}

model DescribeEipMonitorDataRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  allocationId?: string(name='AllocationId'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
  period?: int32(name='Period'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DescribeEipMonitorDataResponseBody = {
  requestId?: string(name='RequestId'),
  eipMonitorDatas?: {
    eipMonitorData?: [ 
    {
      eipTX?: long(name='EipTX'),
      eipPackets?: int32(name='EipPackets'),
      eipBandwidth?: int32(name='EipBandwidth'),
      timeStamp?: string(name='TimeStamp'),
      eipFlow?: int32(name='EipFlow'),
      eipRX?: long(name='EipRX'),
    }
  ](name='EipMonitorData')
  }(name='EipMonitorDatas'),
}

model DescribeEipMonitorDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEipMonitorDataResponseBody(name='body'),
}

async function describeEipMonitorDataWithOptions(request: DescribeEipMonitorDataRequest, runtime: Util.RuntimeOptions): DescribeEipMonitorDataResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeEipMonitorData', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeEipMonitorData(request: DescribeEipMonitorDataRequest): DescribeEipMonitorDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEipMonitorDataWithOptions(request, runtime);
}

model DescribeEipSegmentRequest {
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerId?: long(name='OwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  clientToken?: string(name='ClientToken'),
  regionId?: string(name='RegionId'),
  segmentInstanceId?: string(name='SegmentInstanceId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeEipSegmentResponseBody = {
  eipSegments?: {
    eipSegment?: [ 
    {
      creationTime?: string(name='CreationTime'),
      status?: string(name='Status'),
      descritpion?: string(name='Descritpion'),
      instanceId?: string(name='InstanceId'),
      ipCount?: string(name='IpCount'),
      name?: string(name='Name'),
      segment?: string(name='Segment'),
      regionId?: string(name='RegionId'),
    }
  ](name='EipSegment')
  }(name='EipSegments'),
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
}

model DescribeEipSegmentResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEipSegmentResponseBody(name='body'),
}

async function describeEipSegmentWithOptions(request: DescribeEipSegmentRequest, runtime: Util.RuntimeOptions): DescribeEipSegmentResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeEipSegment', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeEipSegment(request: DescribeEipSegmentRequest): DescribeEipSegmentResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEipSegmentWithOptions(request, runtime);
}

model DescribeExpressCloudConnectionsRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  filter?: [ 
    {
      key?: string(name='Key'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter'),
}

model DescribeExpressCloudConnectionsResponseBody = {
  expressCloudConnectionSet?: {
    expressCloudConnectionType?: [ 
    {
      reservationActiveTime?: string(name='ReservationActiveTime'),
      type?: string(name='Type'),
      status?: string(name='Status'),
      reservationOrderType?: string(name='ReservationOrderType'),
      distance?: int32(name='Distance'),
      constructionPeriod?: string(name='ConstructionPeriod'),
      chargeType?: string(name='ChargeType'),
      applicationBandwidth?: string(name='ApplicationBandwidth'),
      ceIp?: string(name='CeIp'),
      bgpAs?: string(name='BgpAs'),
      IDCardNo?: string(name='IDCardNo'),
      reservationInternetChargeType?: string(name='ReservationInternetChargeType'),
      description?: string(name='Description'),
      bandwidth?: int32(name='Bandwidth'),
      reservationBandwidth?: string(name='ReservationBandwidth'),
      applicationStatus?: string(name='ApplicationStatus'),
      peerCity?: string(name='PeerCity'),
      name?: string(name='Name'),
      peerLocation?: string(name='PeerLocation'),
      peIp?: string(name='PeIp'),
      contactMail?: string(name='ContactMail'),
      gmtModify?: string(name='GmtModify'),
      circuitCode?: string(name='CircuitCode'),
      applicationType?: string(name='ApplicationType'),
      instanceId?: string(name='InstanceId'),
      redundantEccId?: string(name='RedundantEccId'),
      virtualBorderRouterModels?: {
        virtualBorderRouterModel?: [ 
        {
          instanceId?: string(name='InstanceId'),
          accessPointId?: string(name='AccessPointId'),
          physicalConnectionId?: string(name='PhysicalConnectionId'),
        }
      ](name='VirtualBorderRouterModel')
      }(name='VirtualBorderRouterModels'),
      isp?: string(name='Isp'),
      endTime?: string(name='EndTime'),
      contactTel?: string(name='ContactTel'),
      idcSP?: string(name='IdcSP'),
      estimatedTime?: string(name='EstimatedTime'),
      portType?: string(name='PortType'),
      gmtCreate?: string(name='GmtCreate'),
      businessStatus?: string(name='BusinessStatus'),
      applicationId?: string(name='ApplicationId'),
      hasReservationData?: string(name='HasReservationData'),
    }
  ](name='ExpressCloudConnectionType')
  }(name='ExpressCloudConnectionSet'),
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
}

model DescribeExpressCloudConnectionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeExpressCloudConnectionsResponseBody(name='body'),
}

async function describeExpressCloudConnectionsWithOptions(request: DescribeExpressCloudConnectionsRequest, runtime: Util.RuntimeOptions): DescribeExpressCloudConnectionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeExpressCloudConnections', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeExpressCloudConnections(request: DescribeExpressCloudConnectionsRequest): DescribeExpressCloudConnectionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeExpressCloudConnectionsWithOptions(request, runtime);
}

model DescribeFlowLogsRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  flowLogName?: string(name='FlowLogName'),
  flowLogId?: string(name='FlowLogId'),
  description?: string(name='Description'),
  resourceType?: string(name='ResourceType'),
  resourceId?: string(name='ResourceId'),
  trafficType?: string(name='TrafficType'),
  projectName?: string(name='ProjectName'),
  logStoreName?: string(name='LogStoreName'),
  status?: string(name='Status'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  ownerAccount?: string(name='OwnerAccount'),
  vpcId?: string(name='VpcId'),
}

model DescribeFlowLogsResponseBody = {
  totalCount?: string(name='TotalCount'),
  flowLogs?: {
    flowLog?: [ 
    {
      status?: string(name='Status'),
      creationTime?: string(name='CreationTime'),
      flowLogName?: string(name='FlowLogName'),
      trafficType?: string(name='TrafficType'),
      resourceType?: string(name='ResourceType'),
      description?: string(name='Description'),
      projectName?: string(name='ProjectName'),
      logStoreName?: string(name='LogStoreName'),
      resourceId?: string(name='ResourceId'),
      regionId?: string(name='RegionId'),
      flowLogId?: string(name='FlowLogId'),
    }
  ](name='FlowLog')
  }(name='FlowLogs'),
  pageSize?: string(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: string(name='PageNumber'),
  success?: string(name='Success'),
}

model DescribeFlowLogsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFlowLogsResponseBody(name='body'),
}

async function describeFlowLogsWithOptions(request: DescribeFlowLogsRequest, runtime: Util.RuntimeOptions): DescribeFlowLogsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeFlowLogs', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeFlowLogs(request: DescribeFlowLogsRequest): DescribeFlowLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFlowLogsWithOptions(request, runtime);
}

model DescribeForwardTableEntriesRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  forwardTableId?: string(name='ForwardTableId'),
  forwardEntryId?: string(name='ForwardEntryId'),
  externalIp?: string(name='ExternalIp'),
  externalPort?: string(name='ExternalPort'),
  internalIp?: string(name='InternalIp'),
  internalPort?: string(name='InternalPort'),
  ipProtocol?: string(name='IpProtocol'),
  forwardEntryName?: string(name='ForwardEntryName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeForwardTableEntriesResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  forwardTableEntries?: {
    forwardTableEntry?: [ 
    {
      status?: string(name='Status'),
      forwardEntryId?: string(name='ForwardEntryId'),
      internalIp?: string(name='InternalIp'),
      internalPort?: string(name='InternalPort'),
      forwardEntryName?: string(name='ForwardEntryName'),
      forwardTableId?: string(name='ForwardTableId'),
      ipProtocol?: string(name='IpProtocol'),
      externalPort?: string(name='ExternalPort'),
      externalIp?: string(name='ExternalIp'),
    }
  ](name='ForwardTableEntry')
  }(name='ForwardTableEntries'),
}

model DescribeForwardTableEntriesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeForwardTableEntriesResponseBody(name='body'),
}

async function describeForwardTableEntriesWithOptions(request: DescribeForwardTableEntriesRequest, runtime: Util.RuntimeOptions): DescribeForwardTableEntriesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeForwardTableEntries', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeForwardTableEntries(request: DescribeForwardTableEntriesRequest): DescribeForwardTableEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeForwardTableEntriesWithOptions(request, runtime);
}

model DescribeGlobalAccelerationInstancesRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  includeReservationData?: boolean(name='IncludeReservationData'),
  globalAccelerationInstanceId?: string(name='GlobalAccelerationInstanceId'),
  ipAddress?: string(name='IpAddress'),
  name?: string(name='Name'),
  status?: string(name='Status'),
  bandwidthType?: string(name='BandwidthType'),
  serviceLocation?: string(name='ServiceLocation'),
  serverId?: string(name='ServerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DescribeGlobalAccelerationInstancesResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  globalAccelerationInstances?: {
    globalAccelerationInstance?: [ 
    {
      publicIpAddresses?: {
        publicIpAddress?: [ 
        {
          ipAddress?: string(name='IpAddress'),
          allocationId?: string(name='AllocationId'),
        }
      ](name='PublicIpAddress')
      }(name='PublicIpAddresses'),
      status?: string(name='Status'),
      creationTime?: string(name='CreationTime'),
      backendServers?: {
        backendServer?: [ 
        {
          serverIpAddress?: string(name='ServerIpAddress'),
          serverId?: string(name='ServerId'),
          serverType?: string(name='ServerType'),
          regionId?: string(name='RegionId'),
        }
      ](name='BackendServer')
      }(name='BackendServers'),
      bandwidthType?: string(name='BandwidthType'),
      chargeType?: string(name='ChargeType'),
      globalAccelerationInstanceId?: string(name='GlobalAccelerationInstanceId'),
      serviceLocation?: string(name='ServiceLocation'),
      regionId?: string(name='RegionId'),
      accelerationLocation?: string(name='AccelerationLocation'),
      ipAddress?: string(name='IpAddress'),
      description?: string(name='Description'),
      bandwidth?: string(name='Bandwidth'),
      expiredTime?: string(name='ExpiredTime'),
      internetChargeType?: string(name='InternetChargeType'),
      name?: string(name='Name'),
    }
  ](name='GlobalAccelerationInstance')
  }(name='GlobalAccelerationInstances'),
  pageNumber?: int32(name='PageNumber'),
}

model DescribeGlobalAccelerationInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGlobalAccelerationInstancesResponseBody(name='body'),
}

async function describeGlobalAccelerationInstancesWithOptions(request: DescribeGlobalAccelerationInstancesRequest, runtime: Util.RuntimeOptions): DescribeGlobalAccelerationInstancesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeGlobalAccelerationInstances', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeGlobalAccelerationInstances(request: DescribeGlobalAccelerationInstancesRequest): DescribeGlobalAccelerationInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGlobalAccelerationInstancesWithOptions(request, runtime);
}

model DescribeGrantRulesToCenRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
  resourceGroupId?: string(name='ResourceGroupId'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DescribeGrantRulesToCenResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  cenGrantRules?: {
    cbnGrantRule?: [ 
    {
      cenInstanceId?: string(name='CenInstanceId'),
      cenOwnerId?: long(name='CenOwnerId'),
      creationTime?: string(name='CreationTime'),
    }
  ](name='CbnGrantRule')
  }(name='CenGrantRules'),
}

model DescribeGrantRulesToCenResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGrantRulesToCenResponseBody(name='body'),
}

async function describeGrantRulesToCenWithOptions(request: DescribeGrantRulesToCenRequest, runtime: Util.RuntimeOptions): DescribeGrantRulesToCenResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeGrantRulesToCen', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeGrantRulesToCen(request: DescribeGrantRulesToCenRequest): DescribeGrantRulesToCenResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGrantRulesToCenWithOptions(request, runtime);
}

model DescribeHaVipsRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  filter?: [ 
    {
      key?: string(name='Key'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter'),
}

model DescribeHaVipsResponseBody = {
  totalCount?: int32(name='TotalCount'),
  haVips?: {
    haVip?: [ 
    {
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
      associatedInstanceType?: string(name='AssociatedInstanceType'),
      haVipId?: string(name='HaVipId'),
      createTime?: string(name='CreateTime'),
      chargeType?: string(name='ChargeType'),
      regionId?: string(name='RegionId'),
      vSwitchId?: string(name='VSwitchId'),
      ipAddress?: string(name='IpAddress'),
      description?: string(name='Description'),
      associatedInstances?: {
        associatedInstance?: [ string ](name='associatedInstance')
      }(name='AssociatedInstances'),
      masterInstanceId?: string(name='MasterInstanceId'),
      associatedEipAddresses?: {
        associatedEipAddresse?: [ string ](name='associatedEipAddresse')
      }(name='AssociatedEipAddresses'),
      name?: string(name='Name'),
    }
  ](name='HaVip')
  }(name='HaVips'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
}

model DescribeHaVipsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeHaVipsResponseBody(name='body'),
}

async function describeHaVipsWithOptions(request: DescribeHaVipsRequest, runtime: Util.RuntimeOptions): DescribeHaVipsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeHaVips', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeHaVips(request: DescribeHaVipsRequest): DescribeHaVipsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHaVipsWithOptions(request, runtime);
}

model DescribeHighDefinitionMonitorLogAttributeRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DescribeHighDefinitionMonitorLogAttributeResponseBody = {
  requestId?: string(name='RequestId'),
  logStore?: string(name='LogStore'),
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
  logProject?: string(name='LogProject'),
  success?: string(name='Success'),
}

model DescribeHighDefinitionMonitorLogAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeHighDefinitionMonitorLogAttributeResponseBody(name='body'),
}

async function describeHighDefinitionMonitorLogAttributeWithOptions(request: DescribeHighDefinitionMonitorLogAttributeRequest, runtime: Util.RuntimeOptions): DescribeHighDefinitionMonitorLogAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeHighDefinitionMonitorLogAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeHighDefinitionMonitorLogAttribute(request: DescribeHighDefinitionMonitorLogAttributeRequest): DescribeHighDefinitionMonitorLogAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHighDefinitionMonitorLogAttributeWithOptions(request, runtime);
}

model DescribeInstanceAutoRenewAttributeRequest {
  regionId?: string(name='RegionId'),
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
  renewalStatus?: string(name='RenewalStatus'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
}

model DescribeInstanceAutoRenewAttributeResponseBody = {
  totalCount?: string(name='TotalCount'),
  instanceRenewAttributes?: {
    instanceRenewAttribute?: [ 
    {
      duration?: int32(name='Duration'),
      instanceId?: string(name='InstanceId'),
      renewalStatus?: string(name='RenewalStatus'),
      pricingCycle?: string(name='PricingCycle'),
    }
  ](name='InstanceRenewAttribute')
  }(name='InstanceRenewAttributes'),
  requestId?: string(name='RequestId'),
  pageSize?: string(name='PageSize'),
  pageNumber?: string(name='PageNumber'),
}

model DescribeInstanceAutoRenewAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceAutoRenewAttributeResponseBody(name='body'),
}

async function describeInstanceAutoRenewAttributeWithOptions(request: DescribeInstanceAutoRenewAttributeRequest, runtime: Util.RuntimeOptions): DescribeInstanceAutoRenewAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeInstanceAutoRenewAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeInstanceAutoRenewAttribute(request: DescribeInstanceAutoRenewAttributeRequest): DescribeInstanceAutoRenewAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceAutoRenewAttributeWithOptions(request, runtime);
}

model DescribeIpv6AddressesRequest {
  regionId?: string(name='RegionId'),
  ipv6AddressId?: string(name='Ipv6AddressId'),
  ipv6Address?: string(name='Ipv6Address'),
  name?: string(name='Name'),
  associatedInstanceId?: string(name='AssociatedInstanceId'),
  associatedInstanceType?: string(name='AssociatedInstanceType'),
  networkType?: string(name='NetworkType'),
  vpcId?: string(name='VpcId'),
  vSwitchId?: string(name='VSwitchId'),
  ipv6InternetBandwidthId?: string(name='Ipv6InternetBandwidthId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DescribeIpv6AddressesResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  ipv6Addresses?: {
    ipv6Address?: [ 
    {
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
      ipv6AddressId?: string(name='Ipv6AddressId'),
      allocationTime?: string(name='AllocationTime'),
      associatedInstanceType?: string(name='AssociatedInstanceType'),
      ipv6AddressName?: string(name='Ipv6AddressName'),
      associatedInstanceId?: string(name='AssociatedInstanceId'),
      networkType?: string(name='NetworkType'),
      ipv6Address?: string(name='Ipv6Address'),
      vSwitchId?: string(name='VSwitchId'),
      ipv6InternetBandwidth?: {
        bandwidth?: int32(name='Bandwidth'),
        internetChargeType?: string(name='InternetChargeType'),
        businessStatus?: string(name='BusinessStatus'),
        ipv6InternetBandwidthId?: string(name='Ipv6InternetBandwidthId'),
        instanceChargeType?: string(name='InstanceChargeType'),
      }(name='Ipv6InternetBandwidth'),
      ipv6GatewayId?: string(name='Ipv6GatewayId'),
      realBandwidth?: int32(name='RealBandwidth'),
    }
  ](name='Ipv6Address')
  }(name='Ipv6Addresses'),
}

model DescribeIpv6AddressesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIpv6AddressesResponseBody(name='body'),
}

async function describeIpv6AddressesWithOptions(request: DescribeIpv6AddressesRequest, runtime: Util.RuntimeOptions): DescribeIpv6AddressesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeIpv6Addresses', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeIpv6Addresses(request: DescribeIpv6AddressesRequest): DescribeIpv6AddressesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIpv6AddressesWithOptions(request, runtime);
}

model DescribeIpv6EgressOnlyRulesRequest {
  regionId?: string(name='RegionId'),
  ipv6GatewayId?: string(name='Ipv6GatewayId'),
  ipv6EgressOnlyRuleId?: string(name='Ipv6EgressOnlyRuleId'),
  name?: string(name='Name'),
  instanceType?: string(name='InstanceType'),
  instanceId?: string(name='InstanceId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DescribeIpv6EgressOnlyRulesResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  ipv6EgressOnlyRules?: {
    ipv6EgressOnlyRule?: [ 
    {
      status?: string(name='Status'),
      description?: string(name='Description'),
      ipv6EgressOnlyRuleId?: string(name='Ipv6EgressOnlyRuleId'),
      instanceId?: string(name='InstanceId'),
      instanceType?: string(name='InstanceType'),
      name?: string(name='Name'),
    }
  ](name='Ipv6EgressOnlyRule')
  }(name='Ipv6EgressOnlyRules'),
}

model DescribeIpv6EgressOnlyRulesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIpv6EgressOnlyRulesResponseBody(name='body'),
}

async function describeIpv6EgressOnlyRulesWithOptions(request: DescribeIpv6EgressOnlyRulesRequest, runtime: Util.RuntimeOptions): DescribeIpv6EgressOnlyRulesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeIpv6EgressOnlyRules', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeIpv6EgressOnlyRules(request: DescribeIpv6EgressOnlyRulesRequest): DescribeIpv6EgressOnlyRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIpv6EgressOnlyRulesWithOptions(request, runtime);
}

model DescribeIpv6GatewayAttributeRequest {
  regionId?: string(name='RegionId'),
  ipv6GatewayId?: string(name='Ipv6GatewayId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DescribeIpv6GatewayAttributeResponseBody = {
  status?: string(name='Status'),
  description?: string(name='Description'),
  requestId?: string(name='RequestId'),
  vpcId?: string(name='VpcId'),
  instanceChargeType?: string(name='InstanceChargeType'),
  expiredTime?: string(name='ExpiredTime'),
  creationTime?: string(name='CreationTime'),
  ipv6GatewayId?: string(name='Ipv6GatewayId'),
  regionId?: string(name='RegionId'),
  spec?: string(name='Spec'),
  businessStatus?: string(name='BusinessStatus'),
  name?: string(name='Name'),
}

model DescribeIpv6GatewayAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIpv6GatewayAttributeResponseBody(name='body'),
}

async function describeIpv6GatewayAttributeWithOptions(request: DescribeIpv6GatewayAttributeRequest, runtime: Util.RuntimeOptions): DescribeIpv6GatewayAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeIpv6GatewayAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeIpv6GatewayAttribute(request: DescribeIpv6GatewayAttributeRequest): DescribeIpv6GatewayAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIpv6GatewayAttributeWithOptions(request, runtime);
}

model DescribeIpv6GatewaysRequest {
  regionId?: string(name='RegionId'),
  ipv6GatewayId?: string(name='Ipv6GatewayId'),
  vpcId?: string(name='VpcId'),
  name?: string(name='Name'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DescribeIpv6GatewaysResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  ipv6Gateways?: {
    ipv6Gateway?: [ 
    {
      creationTime?: string(name='CreationTime'),
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
      spec?: string(name='Spec'),
      description?: string(name='Description'),
      ipv6GatewayId?: string(name='Ipv6GatewayId'),
      expiredTime?: string(name='ExpiredTime'),
      businessStatus?: string(name='BusinessStatus'),
      name?: string(name='Name'),
      instanceChargeType?: string(name='InstanceChargeType'),
      regionId?: string(name='RegionId'),
    }
  ](name='Ipv6Gateway')
  }(name='Ipv6Gateways'),
}

model DescribeIpv6GatewaysResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIpv6GatewaysResponseBody(name='body'),
}

async function describeIpv6GatewaysWithOptions(request: DescribeIpv6GatewaysRequest, runtime: Util.RuntimeOptions): DescribeIpv6GatewaysResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeIpv6Gateways', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeIpv6Gateways(request: DescribeIpv6GatewaysRequest): DescribeIpv6GatewaysResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIpv6GatewaysWithOptions(request, runtime);
}

model DescribeIPv6TranslatorAclListAttributesRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  aclId?: string(name='AclId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeIPv6TranslatorAclListAttributesResponseBody = {
  aclEntries?: {
    aclEntry?: [ 
    {
      aclEntryComment?: string(name='AclEntryComment'),
      aclEntryId?: string(name='AclEntryId'),
      aclEntryIp?: string(name='AclEntryIp'),
    }
  ](name='AclEntry')
  }(name='AclEntries'),
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  aclId?: string(name='AclId'),
  aclName?: string(name='AclName'),
}

model DescribeIPv6TranslatorAclListAttributesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIPv6TranslatorAclListAttributesResponseBody(name='body'),
}

async function describeIPv6TranslatorAclListAttributesWithOptions(request: DescribeIPv6TranslatorAclListAttributesRequest, runtime: Util.RuntimeOptions): DescribeIPv6TranslatorAclListAttributesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeIPv6TranslatorAclListAttributes', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeIPv6TranslatorAclListAttributes(request: DescribeIPv6TranslatorAclListAttributesRequest): DescribeIPv6TranslatorAclListAttributesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIPv6TranslatorAclListAttributesWithOptions(request, runtime);
}

model DescribeIPv6TranslatorAclListsRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  aclId?: string(name='AclId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  aclName?: string(name='AclName'),
}

model DescribeIPv6TranslatorAclListsResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  ipv6TranslatorAcls?: {
    IPv6TranslatorAcl?: [ 
    {
      aclId?: string(name='AclId'),
      aclName?: string(name='AclName'),
    }
  ](name='IPv6TranslatorAcl')
  }(name='Ipv6TranslatorAcls'),
}

model DescribeIPv6TranslatorAclListsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIPv6TranslatorAclListsResponseBody(name='body'),
}

async function describeIPv6TranslatorAclListsWithOptions(request: DescribeIPv6TranslatorAclListsRequest, runtime: Util.RuntimeOptions): DescribeIPv6TranslatorAclListsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeIPv6TranslatorAclLists', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeIPv6TranslatorAclLists(request: DescribeIPv6TranslatorAclListsRequest): DescribeIPv6TranslatorAclListsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIPv6TranslatorAclListsWithOptions(request, runtime);
}

model DescribeIPv6TranslatorEntriesRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  ipv6TranslatorId?: string(name='Ipv6TranslatorId'),
  ipv6TranslatorEntryId?: string(name='Ipv6TranslatorEntryId'),
  entryName?: string(name='EntryName'),
  allocateIpv6Addr?: string(name='AllocateIpv6Addr'),
  allocateIpv6Port?: int32(name='AllocateIpv6Port'),
  backendIpv4Addr?: string(name='BackendIpv4Addr'),
  backendIpv4Port?: int32(name='BackendIpv4Port'),
  transProtocol?: string(name='TransProtocol'),
  aclStatus?: string(name='AclStatus'),
  aclType?: string(name='AclType'),
  aclId?: string(name='AclId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  clientToken?: string(name='ClientToken'),
}

model DescribeIPv6TranslatorEntriesResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  ipv6TranslatorEntries?: {
    ipv6TranslatorEntry?: [ 
    {
      entryStatus?: string(name='EntryStatus'),
      aclType?: string(name='AclType'),
      transProtocol?: string(name='TransProtocol'),
      entryDescription?: string(name='EntryDescription'),
      ipv6TranslatorId?: string(name='Ipv6TranslatorId'),
      backendIpv4Addr?: string(name='BackendIpv4Addr'),
      allocateIpv6Port?: int32(name='AllocateIpv6Port'),
      ipv6TranslatorEntryId?: string(name='Ipv6TranslatorEntryId'),
      backendIpv4Port?: string(name='BackendIpv4Port'),
      regionId?: string(name='RegionId'),
      entryBandwidth?: string(name='EntryBandwidth'),
      aclId?: string(name='AclId'),
      entryName?: string(name='EntryName'),
      aclStatus?: string(name='AclStatus'),
      allocateIpv6Addr?: string(name='AllocateIpv6Addr'),
    }
  ](name='Ipv6TranslatorEntry')
  }(name='Ipv6TranslatorEntries'),
}

model DescribeIPv6TranslatorEntriesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIPv6TranslatorEntriesResponseBody(name='body'),
}

async function describeIPv6TranslatorEntriesWithOptions(request: DescribeIPv6TranslatorEntriesRequest, runtime: Util.RuntimeOptions): DescribeIPv6TranslatorEntriesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeIPv6TranslatorEntries', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeIPv6TranslatorEntries(request: DescribeIPv6TranslatorEntriesRequest): DescribeIPv6TranslatorEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIPv6TranslatorEntriesWithOptions(request, runtime);
}

model DescribeIPv6TranslatorsRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  ipv6TranslatorId?: string(name='Ipv6TranslatorId'),
  name?: string(name='Name'),
  spec?: string(name='Spec'),
  status?: string(name='Status'),
  allocateIpv6Addr?: string(name='AllocateIpv6Addr'),
  allocateIpv4Addr?: string(name='AllocateIpv4Addr'),
  payType?: string(name='PayType'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  businessStatus?: string(name='BusinessStatus'),
}

model DescribeIPv6TranslatorsResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  ipv6Translators?: {
    ipv6Translator?: [ 
    {
      status?: string(name='Status'),
      spec?: string(name='Spec'),
      createTime?: long(name='CreateTime'),
      payType?: string(name='PayType'),
      allocateIpv4Addr?: string(name='AllocateIpv4Addr'),
      ipv6TranslatorId?: string(name='Ipv6TranslatorId'),
      ipv6TranslatorEntryIds?: {
        ipv6TranslatorEntryId?: [ string ](name='Ipv6TranslatorEntryId')
      }(name='Ipv6TranslatorEntryIds'),
      availableBandwidth?: string(name='AvailableBandwidth'),
      regionId?: string(name='RegionId'),
      endTime?: long(name='EndTime'),
      bandwidth?: int32(name='Bandwidth'),
      description?: string(name='Description'),
      businessStatus?: string(name='BusinessStatus'),
      allocateIpv6Addr?: string(name='AllocateIpv6Addr'),
      name?: string(name='Name'),
    }
  ](name='Ipv6Translator')
  }(name='Ipv6Translators'),
}

model DescribeIPv6TranslatorsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIPv6TranslatorsResponseBody(name='body'),
}

async function describeIPv6TranslatorsWithOptions(request: DescribeIPv6TranslatorsRequest, runtime: Util.RuntimeOptions): DescribeIPv6TranslatorsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeIPv6Translators', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeIPv6Translators(request: DescribeIPv6TranslatorsRequest): DescribeIPv6TranslatorsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIPv6TranslatorsWithOptions(request, runtime);
}

model DescribeNatGatewaysRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  natGatewayId?: string(name='NatGatewayId'),
  vpcId?: string(name='VpcId'),
  name?: string(name='Name'),
  instanceChargeType?: string(name='InstanceChargeType'),
  spec?: string(name='Spec'),
  natType?: string(name='NatType'),
  resourceGroupId?: string(name='ResourceGroupId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  dryRun?: boolean(name='DryRun'),
  status?: string(name='Status'),
  tag?: [ 
    {
    }
  ](name='Tag'),
}

model DescribeNatGatewaysResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  natGateways?: {
    natGateway?: [ 
    {
      vpcId?: string(name='VpcId'),
      creationTime?: string(name='CreationTime'),
      status?: string(name='Status'),
      natType?: string(name='NatType'),
      spec?: string(name='Spec'),
      deletionProtection?: boolean(name='DeletionProtection'),
      regionId?: string(name='RegionId'),
      instanceChargeType?: string(name='InstanceChargeType'),
      ecsMetricEnabled?: boolean(name='EcsMetricEnabled'),
      description?: string(name='Description'),
      expiredTime?: string(name='ExpiredTime'),
      ipLists?: {
        ipList?: [ 
        {
          ipAddress?: string(name='IpAddress'),
          snatEntryEnabled?: boolean(name='SnatEntryEnabled'),
        }
      ](name='IpList')
      }(name='IpLists'),
      natGatewayPrivateInfo?: {
        vswitchId?: string(name='VswitchId'),
        eniInstanceId?: string(name='EniInstanceId'),
        maxBandwidth?: int32(name='MaxBandwidth'),
        privateIpAddress?: string(name='PrivateIpAddress'),
        izNo?: string(name='IzNo'),
      }(name='NatGatewayPrivateInfo'),
      resourceGroupId?: string(name='ResourceGroupId'),
      natGatewayId?: string(name='NatGatewayId'),
      internetChargeType?: string(name='InternetChargeType'),
      businessStatus?: string(name='BusinessStatus'),
      forwardTableIds?: {
        forwardTableId?: [ string ](name='ForwardTableId')
      }(name='ForwardTableIds'),
      snatTableIds?: {
        snatTableId?: [ string ](name='SnatTableId')
      }(name='SnatTableIds'),
      name?: string(name='Name'),
    }
  ](name='NatGateway')
  }(name='NatGateways'),
}

model DescribeNatGatewaysResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNatGatewaysResponseBody(name='body'),
}

async function describeNatGatewaysWithOptions(request: DescribeNatGatewaysRequest, runtime: Util.RuntimeOptions): DescribeNatGatewaysResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeNatGateways', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeNatGateways(request: DescribeNatGatewaysRequest): DescribeNatGatewaysResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNatGatewaysWithOptions(request, runtime);
}

model DescribeNetworkAclAttributesRequest {
  networkAclId?: string(name='NetworkAclId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerId?: long(name='OwnerId'),
  clientToken?: string(name='ClientToken'),
}

model DescribeNetworkAclAttributesResponseBody = {
  requestId?: string(name='RequestId'),
  networkAclAttribute?: {
    status?: string(name='Status'),
    vpcId?: string(name='VpcId'),
    creationTime?: string(name='CreationTime'),
    description?: string(name='Description'),
    egressAclEntries?: {
      egressAclEntry?: [ 
      {
        networkAclEntryId?: string(name='NetworkAclEntryId'),
        entryType?: string(name='EntryType'),
        networkAclEntryName?: string(name='NetworkAclEntryName'),
        policy?: string(name='Policy'),
        description?: string(name='Description'),
        protocol?: string(name='Protocol'),
        destinationCidrIp?: string(name='DestinationCidrIp'),
        port?: string(name='Port'),
      }
    ](name='EgressAclEntry')
    }(name='EgressAclEntries'),
    networkAclName?: string(name='NetworkAclName'),
    ingressAclEntries?: {
      ingressAclEntry?: [ 
      {
        networkAclEntryId?: string(name='NetworkAclEntryId'),
        entryType?: string(name='EntryType'),
        networkAclEntryName?: string(name='NetworkAclEntryName'),
        policy?: string(name='Policy'),
        description?: string(name='Description'),
        sourceCidrIp?: string(name='SourceCidrIp'),
        protocol?: string(name='Protocol'),
        port?: string(name='Port'),
      }
    ](name='IngressAclEntry')
    }(name='IngressAclEntries'),
    networkAclId?: string(name='NetworkAclId'),
    ownerId?: long(name='OwnerId'),
    resources?: {
      resource?: [ 
      {
        status?: string(name='Status'),
        resourceType?: string(name='ResourceType'),
        resourceId?: string(name='ResourceId'),
      }
    ](name='Resource')
    }(name='Resources'),
    regionId?: string(name='RegionId'),
  }(name='NetworkAclAttribute'),
}

model DescribeNetworkAclAttributesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNetworkAclAttributesResponseBody(name='body'),
}

async function describeNetworkAclAttributesWithOptions(request: DescribeNetworkAclAttributesRequest, runtime: Util.RuntimeOptions): DescribeNetworkAclAttributesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeNetworkAclAttributes', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeNetworkAclAttributes(request: DescribeNetworkAclAttributesRequest): DescribeNetworkAclAttributesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNetworkAclAttributesWithOptions(request, runtime);
}

model DescribeNetworkAclsRequest {
  networkAclId?: string(name='NetworkAclId'),
  networkAclName?: string(name='NetworkAclName'),
  vpcId?: string(name='VpcId'),
  resourceType?: string(name='ResourceType'),
  resourceId?: string(name='ResourceId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerId?: long(name='OwnerId'),
  clientToken?: string(name='ClientToken'),
}

model DescribeNetworkAclsResponseBody = {
  totalCount?: string(name='TotalCount'),
  networkAcls?: {
    networkAcl?: [ 
    {
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      egressAclEntries?: {
        egressAclEntry?: [ 
        {
          networkAclEntryId?: string(name='NetworkAclEntryId'),
          entryType?: string(name='EntryType'),
          networkAclEntryName?: string(name='NetworkAclEntryName'),
          policy?: string(name='Policy'),
          description?: string(name='Description'),
          protocol?: string(name='Protocol'),
          destinationCidrIp?: string(name='DestinationCidrIp'),
          port?: string(name='Port'),
        }
      ](name='EgressAclEntry')
      }(name='EgressAclEntries'),
      networkAclName?: string(name='NetworkAclName'),
      ingressAclEntries?: {
        ingressAclEntry?: [ 
        {
          networkAclEntryId?: string(name='NetworkAclEntryId'),
          entryType?: string(name='EntryType'),
          networkAclEntryName?: string(name='NetworkAclEntryName'),
          policy?: string(name='Policy'),
          description?: string(name='Description'),
          sourceCidrIp?: string(name='SourceCidrIp'),
          protocol?: string(name='Protocol'),
          port?: string(name='Port'),
        }
      ](name='IngressAclEntry')
      }(name='IngressAclEntries'),
      networkAclId?: string(name='NetworkAclId'),
      ownerId?: long(name='OwnerId'),
      resources?: {
        resource?: [ 
        {
          status?: string(name='Status'),
          resourceType?: string(name='ResourceType'),
          resourceId?: string(name='ResourceId'),
        }
      ](name='Resource')
      }(name='Resources'),
      regionId?: string(name='RegionId'),
    }
  ](name='NetworkAcl')
  }(name='NetworkAcls'),
  pageSize?: string(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: string(name='PageNumber'),
}

model DescribeNetworkAclsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNetworkAclsResponseBody(name='body'),
}

async function describeNetworkAclsWithOptions(request: DescribeNetworkAclsRequest, runtime: Util.RuntimeOptions): DescribeNetworkAclsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeNetworkAcls', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeNetworkAcls(request: DescribeNetworkAclsRequest): DescribeNetworkAclsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNetworkAclsWithOptions(request, runtime);
}

model DescribeNewProjectEipMonitorDataRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  allocationId?: string(name='AllocationId'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
  period?: int32(name='Period'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DescribeNewProjectEipMonitorDataResponseBody = {
  requestId?: string(name='RequestId'),
  eipMonitorDatas?: {
    eipMonitorData?: [ 
    {
      eipTX?: int32(name='EipTX'),
      eipPackets?: int32(name='EipPackets'),
      eipBandwidth?: int32(name='EipBandwidth'),
      timeStamp?: string(name='TimeStamp'),
      eipFlow?: int32(name='EipFlow'),
      eipRX?: int32(name='EipRX'),
    }
  ](name='EipMonitorData')
  }(name='EipMonitorDatas'),
}

model DescribeNewProjectEipMonitorDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNewProjectEipMonitorDataResponseBody(name='body'),
}

async function describeNewProjectEipMonitorDataWithOptions(request: DescribeNewProjectEipMonitorDataRequest, runtime: Util.RuntimeOptions): DescribeNewProjectEipMonitorDataResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeNewProjectEipMonitorData', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeNewProjectEipMonitorData(request: DescribeNewProjectEipMonitorDataRequest): DescribeNewProjectEipMonitorDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNewProjectEipMonitorDataWithOptions(request, runtime);
}

model DescribePhysicalConnectionLOARequest {
  regionId?: string(name='RegionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  instanceId?: string(name='InstanceId'),
}

model DescribePhysicalConnectionLOAResponseBody = {
  requestId?: string(name='RequestId'),
  physicalConnectionLOAType?: {
    status?: string(name='Status'),
    lineLabel?: string(name='LineLabel'),
    lineCode?: string(name='LineCode'),
    constructionTime?: string(name='ConstructionTime'),
    SI?: string(name='SI'),
    loaUrl?: string(name='LoaUrl'),
    companyLocalizedName?: string(name='CompanyLocalizedName'),
    instanceId?: string(name='InstanceId'),
    PMInfo?: {
      PMInfo?: [ 
      {
        PMCertificateNo?: string(name='PMCertificateNo'),
        PMName?: string(name='PMName'),
        PMCertificateType?: string(name='PMCertificateType'),
        PMGender?: string(name='PMGender'),
        PMContactInfo?: string(name='PMContactInfo'),
      }
    ](name='PMInfo')
    }(name='PMInfo'),
    lineType?: string(name='LineType'),
    companyName?: string(name='CompanyName'),
  }(name='PhysicalConnectionLOAType'),
}

model DescribePhysicalConnectionLOAResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePhysicalConnectionLOAResponseBody(name='body'),
}

async function describePhysicalConnectionLOAWithOptions(request: DescribePhysicalConnectionLOARequest, runtime: Util.RuntimeOptions): DescribePhysicalConnectionLOAResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribePhysicalConnectionLOA', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describePhysicalConnectionLOA(request: DescribePhysicalConnectionLOARequest): DescribePhysicalConnectionLOAResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePhysicalConnectionLOAWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  productType?: string(name='ProductType'),
  acceptLanguage?: string(name='AcceptLanguage'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DescribeRegionsResponseBody = {
  requestId?: string(name='RequestId'),
  regions?: {
    region?: [ 
    {
      localName?: string(name='LocalName'),
      regionEndpoint?: string(name='RegionEndpoint'),
      regionId?: string(name='RegionId'),
    }
  ](name='Region')
  }(name='Regions'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeRegions', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model DescribeRouteEntryListRequest {
  regionId?: string(name='RegionId'),
  routeTableId?: string(name='RouteTableId'),
  routeEntryId?: string(name='RouteEntryId'),
  destinationCidrBlock?: string(name='DestinationCidrBlock'),
  routeEntryName?: string(name='RouteEntryName'),
  ipVersion?: string(name='IpVersion'),
  routeEntryType?: string(name='RouteEntryType'),
  nextHopId?: string(name='NextHopId'),
  nextHopType?: string(name='NextHopType'),
  maxResult?: int32(name='MaxResult'),
  nextToken?: string(name='NextToken'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DescribeRouteEntryListResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  routeEntrys?: {
    routeEntry?: [ 
    {
      status?: string(name='Status'),
      type?: string(name='Type'),
      ipVersion?: string(name='IpVersion'),
      description?: string(name='Description'),
      routeEntryName?: string(name='RouteEntryName'),
      destinationCidrBlock?: string(name='DestinationCidrBlock'),
      routeEntryId?: string(name='RouteEntryId'),
      nextHops?: {
        nextHop?: [ 
        {
          weight?: int32(name='Weight'),
          nextHopId?: string(name='NextHopId'),
          enabled?: int32(name='Enabled'),
          nextHopType?: string(name='NextHopType'),
          nextHopRelatedInfo?: {
            instanceId?: string(name='InstanceId'),
            instanceType?: string(name='InstanceType'),
            regionId?: string(name='RegionId'),
          }(name='NextHopRelatedInfo'),
          nextHopRegionId?: string(name='NextHopRegionId'),
        }
      ](name='NextHop')
      }(name='NextHops'),
      routeTableId?: string(name='RouteTableId'),
    }
  ](name='RouteEntry')
  }(name='RouteEntrys'),
}

model DescribeRouteEntryListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRouteEntryListResponseBody(name='body'),
}

async function describeRouteEntryListWithOptions(request: DescribeRouteEntryListRequest, runtime: Util.RuntimeOptions): DescribeRouteEntryListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeRouteEntryList', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeRouteEntryList(request: DescribeRouteEntryListRequest): DescribeRouteEntryListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRouteEntryListWithOptions(request, runtime);
}

model DescribeRouterInterfaceAttributeRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  instanceId?: string(name='InstanceId'),
}

model DescribeRouterInterfaceAttributeResponseBody = {
  oppositeInterfaceId?: string(name='OppositeInterfaceId'),
  oppositeInterfaceStatus?: string(name='OppositeInterfaceStatus'),
  description?: string(name='Description'),
  oppositeRouterId?: string(name='OppositeRouterId'),
  message?: string(name='Message'),
  endTime?: string(name='EndTime'),
  gmtModified?: string(name='GmtModified'),
  routerId?: string(name='RouterId'),
  businessStatus?: string(name='BusinessStatus'),
  success?: boolean(name='Success'),
  name?: string(name='Name'),
  reservationOrderType?: string(name='ReservationOrderType'),
  oppositeRouterType?: string(name='OppositeRouterType'),
  oppositeBandwidth?: int32(name='OppositeBandwidth'),
  bandwidth?: int32(name='Bandwidth'),
  connectedTime?: string(name='ConnectedTime'),
  reservationActiveTime?: string(name='ReservationActiveTime'),
  hcThreshold?: int32(name='HcThreshold'),
  reservationBandwidth?: string(name='ReservationBandwidth'),
  status?: string(name='Status'),
  oppositeInterfaceOwnerId?: string(name='OppositeInterfaceOwnerId'),
  requestId?: string(name='RequestId'),
  oppositeRegionId?: string(name='OppositeRegionId'),
  healthCheckSourceIp?: string(name='HealthCheckSourceIp'),
  hasReservationData?: string(name='HasReservationData'),
  crossBorder?: boolean(name='CrossBorder'),
  hcRate?: int32(name='HcRate'),
  code?: string(name='Code'),
  reservationInternetChargeType?: string(name='ReservationInternetChargeType'),
  oppositeInterfaceSpec?: string(name='OppositeInterfaceSpec'),
  role?: string(name='Role'),
  oppositeVpcInstanceId?: string(name='OppositeVpcInstanceId'),
  routerType?: string(name='RouterType'),
  chargeType?: string(name='ChargeType'),
  creationTime?: string(name='CreationTime'),
  accessPointId?: string(name='AccessPointId'),
  vpcInstanceId?: string(name='VpcInstanceId'),
  oppositeInterfaceBusinessStatus?: string(name='OppositeInterfaceBusinessStatus'),
  oppositeAccessPointId?: string(name='OppositeAccessPointId'),
  spec?: string(name='Spec'),
  healthCheckStatus?: string(name='HealthCheckStatus'),
  healthCheckTargetIp?: string(name='HealthCheckTargetIp'),
  routerInterfaceId?: string(name='RouterInterfaceId'),
}

model DescribeRouterInterfaceAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRouterInterfaceAttributeResponseBody(name='body'),
}

async function describeRouterInterfaceAttributeWithOptions(request: DescribeRouterInterfaceAttributeRequest, runtime: Util.RuntimeOptions): DescribeRouterInterfaceAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeRouterInterfaceAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeRouterInterfaceAttribute(request: DescribeRouterInterfaceAttributeRequest): DescribeRouterInterfaceAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRouterInterfaceAttributeWithOptions(request, runtime);
}

model DescribeRouterInterfacesRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  includeReservationData?: boolean(name='IncludeReservationData'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  filter?: [ 
    {
      key?: string(name='Key'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter'),
}

model DescribeRouterInterfacesResponseBody = {
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  routerInterfaceSet?: {
    routerInterfaceType?: [ 
    {
      reservationActiveTime?: string(name='ReservationActiveTime'),
      healthCheckTargetIp?: string(name='HealthCheckTargetIp'),
      status?: string(name='Status'),
      creationTime?: string(name='CreationTime'),
      reservationOrderType?: string(name='ReservationOrderType'),
      oppositeInterfaceId?: string(name='OppositeInterfaceId'),
      spec?: string(name='Spec'),
      chargeType?: string(name='ChargeType'),
      routerInterfaceId?: string(name='RouterInterfaceId'),
      hcThreshold?: int32(name='HcThreshold'),
      oppositeRouterType?: string(name='OppositeRouterType'),
      oppositeInterfaceOwnerId?: string(name='OppositeInterfaceOwnerId'),
      vpcInstanceId?: string(name='VpcInstanceId'),
      oppositeVpcInstanceId?: string(name='OppositeVpcInstanceId'),
      reservationInternetChargeType?: string(name='ReservationInternetChargeType'),
      crossBorder?: boolean(name='CrossBorder'),
      description?: string(name='Description'),
      bandwidth?: int32(name='Bandwidth'),
      reservationBandwidth?: string(name='ReservationBandwidth'),
      hcRate?: int32(name='HcRate'),
      name?: string(name='Name'),
      oppositeRouterId?: string(name='OppositeRouterId'),
      oppositeInterfaceSpec?: string(name='OppositeInterfaceSpec'),
      routerId?: string(name='RouterId'),
      oppositeInterfaceBusinessStatus?: string(name='OppositeInterfaceBusinessStatus'),
      connectedTime?: string(name='ConnectedTime'),
      healthCheckSourceIp?: string(name='HealthCheckSourceIp'),
      oppositeInterfaceStatus?: string(name='OppositeInterfaceStatus'),
      endTime?: string(name='EndTime'),
      oppositeRegionId?: string(name='OppositeRegionId'),
      oppositeAccessPointId?: string(name='OppositeAccessPointId'),
      businessStatus?: string(name='BusinessStatus'),
      oppositeBandwidth?: int32(name='OppositeBandwidth'),
      routerType?: string(name='RouterType'),
      role?: string(name='Role'),
      hasReservationData?: string(name='HasReservationData'),
      accessPointId?: string(name='AccessPointId'),
    }
  ](name='RouterInterfaceType')
  }(name='RouterInterfaceSet'),
}

model DescribeRouterInterfacesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRouterInterfacesResponseBody(name='body'),
}

async function describeRouterInterfacesWithOptions(request: DescribeRouterInterfacesRequest, runtime: Util.RuntimeOptions): DescribeRouterInterfacesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeRouterInterfaces', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeRouterInterfaces(request: DescribeRouterInterfacesRequest): DescribeRouterInterfacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRouterInterfacesWithOptions(request, runtime);
}

model DescribeRouteTableListRequest {
  routerType?: string(name='RouterType'),
  routerId?: string(name='RouterId'),
  vpcId?: string(name='VpcId'),
  routeTableId?: string(name='RouteTableId'),
  routeTableName?: string(name='RouteTableName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceGroupId?: string(name='ResourceGroupId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  tag?: [ 
    {
    }
  ](name='Tag'),
}

model DescribeRouteTableListResponseBody = {
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  routerTableList?: {
    routerTableListType?: [ 
    {
      status?: string(name='Status'),
      creationTime?: string(name='CreationTime'),
      vpcId?: string(name='VpcId'),
      routerId?: string(name='RouterId'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
      routeTableId?: string(name='RouteTableId'),
      ownerId?: long(name='OwnerId'),
      description?: string(name='Description'),
      resourceGroupId?: string(name='ResourceGroupId'),
      routeTableType?: string(name='RouteTableType'),
      vSwitchIds?: {
        vSwitchId?: [ string ](name='VSwitchId')
      }(name='VSwitchIds'),
      routerType?: string(name='RouterType'),
      routeTableName?: string(name='RouteTableName'),
    }
  ](name='RouterTableListType')
  }(name='RouterTableList'),
}

model DescribeRouteTableListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRouteTableListResponseBody(name='body'),
}

async function describeRouteTableListWithOptions(request: DescribeRouteTableListRequest, runtime: Util.RuntimeOptions): DescribeRouteTableListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeRouteTableList', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeRouteTableList(request: DescribeRouteTableListRequest): DescribeRouteTableListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRouteTableListWithOptions(request, runtime);
}

model DescribeRouteTablesRequest {
  regionId?: string(name='RegionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  VRouterId?: string(name='VRouterId'),
  routeTableId?: string(name='RouteTableId'),
  routerType?: string(name='RouterType'),
  routerId?: string(name='RouterId'),
  type?: string(name='Type'),
  routeTableName?: string(name='RouteTableName'),
  resourceGroupId?: string(name='ResourceGroupId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DescribeRouteTablesResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  routeTables?: {
    routeTable?: [ 
    {
      creationTime?: string(name='CreationTime'),
      status?: string(name='Status'),
      VRouterId?: string(name='VRouterId'),
      routeEntrys?: {
        routeEntry?: [ 
        {
          status?: string(name='Status'),
          type?: string(name='Type'),
          nextHopType?: string(name='NextHopType'),
          routeEntryName?: string(name='RouteEntryName'),
          routeEntryId?: string(name='RouteEntryId'),
          instanceId?: string(name='InstanceId'),
          routeTableId?: string(name='RouteTableId'),
          description?: string(name='Description'),
          destinationCidrBlock?: string(name='DestinationCidrBlock'),
          nextHops?: {
            nextHop?: [ 
            {
              nextHopId?: string(name='NextHopId'),
              weight?: int32(name='Weight'),
              nextHopType?: string(name='NextHopType'),
              enabled?: int32(name='Enabled'),
            }
          ](name='NextHop')
          }(name='NextHops'),
        }
      ](name='RouteEntry')
      }(name='RouteEntrys'),
      routeTableType?: string(name='RouteTableType'),
      resourceGroupId?: string(name='ResourceGroupId'),
      vSwitchIds?: {
        vSwitchId?: [ string ](name='VSwitchId')
      }(name='VSwitchIds'),
      routeTableId?: string(name='RouteTableId'),
    }
  ](name='RouteTable')
  }(name='RouteTables'),
}

model DescribeRouteTablesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRouteTablesResponseBody(name='body'),
}

async function describeRouteTablesWithOptions(request: DescribeRouteTablesRequest, runtime: Util.RuntimeOptions): DescribeRouteTablesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeRouteTables', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeRouteTables(request: DescribeRouteTablesRequest): DescribeRouteTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRouteTablesWithOptions(request, runtime);
}

model DescribeServerRelatedGlobalAccelerationInstancesRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  serverId?: string(name='ServerId'),
  serverType?: string(name='ServerType'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DescribeServerRelatedGlobalAccelerationInstancesResponseBody = {
  requestId?: string(name='RequestId'),
  globalAccelerationInstances?: {
    globalAccelerationInstance?: [ 
    {
      serverIpAddress?: string(name='ServerIpAddress'),
      ipAddress?: string(name='IpAddress'),
      globalAccelerationInstanceId?: string(name='GlobalAccelerationInstanceId'),
      regionId?: string(name='RegionId'),
    }
  ](name='GlobalAccelerationInstance')
  }(name='GlobalAccelerationInstances'),
}

model DescribeServerRelatedGlobalAccelerationInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeServerRelatedGlobalAccelerationInstancesResponseBody(name='body'),
}

async function describeServerRelatedGlobalAccelerationInstancesWithOptions(request: DescribeServerRelatedGlobalAccelerationInstancesRequest, runtime: Util.RuntimeOptions): DescribeServerRelatedGlobalAccelerationInstancesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeServerRelatedGlobalAccelerationInstances', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeServerRelatedGlobalAccelerationInstances(request: DescribeServerRelatedGlobalAccelerationInstancesRequest): DescribeServerRelatedGlobalAccelerationInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServerRelatedGlobalAccelerationInstancesWithOptions(request, runtime);
}

model DescribeSnatTableEntriesRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  snatTableId?: string(name='SnatTableId'),
  snatEntryId?: string(name='SnatEntryId'),
  sourceVSwitchId?: string(name='SourceVSwitchId'),
  sourceCIDR?: string(name='SourceCIDR'),
  snatIp?: string(name='SnatIp'),
  snatEntryName?: string(name='SnatEntryName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeSnatTableEntriesResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  snatTableEntries?: {
    snatTableEntry?: [ 
    {
      status?: string(name='Status'),
      snatEntryName?: string(name='SnatEntryName'),
      sourceVSwitchId?: string(name='SourceVSwitchId'),
      sourceCIDR?: string(name='SourceCIDR'),
      snatEntryId?: string(name='SnatEntryId'),
      snatTableId?: string(name='SnatTableId'),
      snatIp?: string(name='SnatIp'),
    }
  ](name='SnatTableEntry')
  }(name='SnatTableEntries'),
}

model DescribeSnatTableEntriesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSnatTableEntriesResponseBody(name='body'),
}

async function describeSnatTableEntriesWithOptions(request: DescribeSnatTableEntriesRequest, runtime: Util.RuntimeOptions): DescribeSnatTableEntriesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeSnatTableEntries', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeSnatTableEntries(request: DescribeSnatTableEntriesRequest): DescribeSnatTableEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSnatTableEntriesWithOptions(request, runtime);
}

model DescribeSslVpnClientCertRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  sslVpnClientCertId?: string(name='SslVpnClientCertId'),
}

model DescribeSslVpnClientCertResponseBody = {
  status?: string(name='Status'),
  clientCert?: string(name='ClientCert'),
  endTime?: long(name='EndTime'),
  requestId?: string(name='RequestId'),
  createTime?: long(name='CreateTime'),
  clientKey?: string(name='ClientKey'),
  sslVpnClientCertId?: string(name='SslVpnClientCertId'),
  sslVpnServerId?: string(name='SslVpnServerId'),
  caCert?: string(name='CaCert'),
  regionId?: string(name='RegionId'),
  clientConfig?: string(name='ClientConfig'),
  name?: string(name='Name'),
}

model DescribeSslVpnClientCertResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSslVpnClientCertResponseBody(name='body'),
}

async function describeSslVpnClientCertWithOptions(request: DescribeSslVpnClientCertRequest, runtime: Util.RuntimeOptions): DescribeSslVpnClientCertResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeSslVpnClientCert', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeSslVpnClientCert(request: DescribeSslVpnClientCertRequest): DescribeSslVpnClientCertResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSslVpnClientCertWithOptions(request, runtime);
}

model DescribeSslVpnClientCertsRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  sslVpnServerId?: string(name='SslVpnServerId'),
  sslVpnClientCertId?: string(name='SslVpnClientCertId'),
  name?: string(name='Name'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeSslVpnClientCertsResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  sslVpnClientCertKeys?: {
    sslVpnClientCertKey?: [ 
    {
      status?: string(name='Status'),
      endTime?: long(name='EndTime'),
      createTime?: long(name='CreateTime'),
      sslVpnClientCertId?: string(name='SslVpnClientCertId'),
      sslVpnServerId?: string(name='SslVpnServerId'),
      name?: string(name='Name'),
      regionId?: string(name='RegionId'),
    }
  ](name='SslVpnClientCertKey')
  }(name='SslVpnClientCertKeys'),
}

model DescribeSslVpnClientCertsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSslVpnClientCertsResponseBody(name='body'),
}

async function describeSslVpnClientCertsWithOptions(request: DescribeSslVpnClientCertsRequest, runtime: Util.RuntimeOptions): DescribeSslVpnClientCertsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeSslVpnClientCerts', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeSslVpnClientCerts(request: DescribeSslVpnClientCertsRequest): DescribeSslVpnClientCertsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSslVpnClientCertsWithOptions(request, runtime);
}

model DescribeSslVpnServersRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  sslVpnServerId?: string(name='SslVpnServerId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  name?: string(name='Name'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeSslVpnServersResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  sslVpnServers?: {
    sslVpnServer?: [ 
    {
      internetIp?: string(name='InternetIp'),
      IDaaSInstanceId?: string(name='IDaaSInstanceId'),
      createTime?: long(name='CreateTime'),
      vpnGatewayId?: string(name='VpnGatewayId'),
      compress?: boolean(name='Compress'),
      port?: int32(name='Port'),
      localSubnet?: string(name='LocalSubnet'),
      regionId?: string(name='RegionId'),
      cipher?: string(name='Cipher'),
      connections?: int32(name='Connections'),
      sslVpnServerId?: string(name='SslVpnServerId'),
      maxConnections?: int32(name='MaxConnections'),
      name?: string(name='Name'),
      enableMultiFactorAuth?: boolean(name='EnableMultiFactorAuth'),
      clientIpPool?: string(name='ClientIpPool'),
      proto?: string(name='Proto'),
    }
  ](name='SslVpnServer')
  }(name='SslVpnServers'),
}

model DescribeSslVpnServersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSslVpnServersResponseBody(name='body'),
}

async function describeSslVpnServersWithOptions(request: DescribeSslVpnServersRequest, runtime: Util.RuntimeOptions): DescribeSslVpnServersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeSslVpnServers', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeSslVpnServers(request: DescribeSslVpnServersRequest): DescribeSslVpnServersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSslVpnServersWithOptions(request, runtime);
}

model DescribeVirtualBorderRoutersRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  filter?: [ 
    {
      key?: string(name='Key'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter'),
}

model DescribeVirtualBorderRoutersResponseBody = {
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  virtualBorderRouterSet?: {
    virtualBorderRouterType?: [ 
    {
      creationTime?: string(name='CreationTime'),
      status?: string(name='Status'),
      type?: string(name='Type'),
      minTxInterval?: long(name='MinTxInterval'),
      associatedCens?: {
        associatedCen?: [ 
        {
          cenOwnerId?: long(name='CenOwnerId'),
          cenId?: string(name='CenId'),
          cenStatus?: string(name='CenStatus'),
        }
      ](name='AssociatedCen')
      }(name='AssociatedCens'),
      peerIpv6GatewayIp?: string(name='PeerIpv6GatewayIp'),
      PConnVbrExpireTime?: string(name='PConnVbrExpireTime'),
      physicalConnectionOwnerUid?: string(name='PhysicalConnectionOwnerUid'),
      activationTime?: string(name='ActivationTime'),
      physicalConnectionBusinessStatus?: string(name='PhysicalConnectionBusinessStatus'),
      description?: string(name='Description'),
      terminationTime?: string(name='TerminationTime'),
      peerGatewayIp?: string(name='PeerGatewayIp'),
      minRxInterval?: long(name='MinRxInterval'),
      name?: string(name='Name'),
      vbrId?: string(name='VbrId'),
      vlanId?: int32(name='VlanId'),
      vlanInterfaceId?: string(name='VlanInterfaceId'),
      circuitCode?: string(name='CircuitCode'),
      localIpv6GatewayIp?: string(name='LocalIpv6GatewayIp'),
      associatedPhysicalConnections?: {
        associatedPhysicalConnection?: [ 
        {
          vlanInterfaceId?: string(name='VlanInterfaceId'),
          status?: string(name='Status'),
          peerIpv6GatewayIp?: string(name='PeerIpv6GatewayIp'),
          circuitCode?: string(name='CircuitCode'),
          localIpv6GatewayIp?: string(name='LocalIpv6GatewayIp'),
          physicalConnectionOwnerUid?: string(name='PhysicalConnectionOwnerUid'),
          localGatewayIp?: string(name='LocalGatewayIp'),
          physicalConnectionBusinessStatus?: string(name='PhysicalConnectionBusinessStatus'),
          peeringSubnetMask?: string(name='PeeringSubnetMask'),
          enableIpv6?: boolean(name='EnableIpv6'),
          physicalConnectionStatus?: string(name='PhysicalConnectionStatus'),
          peerGatewayIp?: string(name='PeerGatewayIp'),
          peeringIpv6SubnetMask?: string(name='PeeringIpv6SubnetMask'),
          physicalConnectionId?: string(name='PhysicalConnectionId'),
          vlanId?: string(name='VlanId'),
        }
      ](name='AssociatedPhysicalConnection')
      }(name='AssociatedPhysicalConnections'),
      localGatewayIp?: string(name='LocalGatewayIp'),
      peeringSubnetMask?: string(name='PeeringSubnetMask'),
      enableIpv6?: boolean(name='EnableIpv6'),
      routeTableId?: string(name='RouteTableId'),
      detectMultiplier?: long(name='DetectMultiplier'),
      eccId?: string(name='EccId'),
      recoveryTime?: string(name='RecoveryTime'),
      physicalConnectionStatus?: string(name='PhysicalConnectionStatus'),
      peeringIpv6SubnetMask?: string(name='PeeringIpv6SubnetMask'),
      accessPointId?: string(name='AccessPointId'),
      physicalConnectionId?: string(name='PhysicalConnectionId'),
    }
  ](name='VirtualBorderRouterType')
  }(name='VirtualBorderRouterSet'),
}

model DescribeVirtualBorderRoutersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVirtualBorderRoutersResponseBody(name='body'),
}

async function describeVirtualBorderRoutersWithOptions(request: DescribeVirtualBorderRoutersRequest, runtime: Util.RuntimeOptions): DescribeVirtualBorderRoutersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeVirtualBorderRouters', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeVirtualBorderRouters(request: DescribeVirtualBorderRoutersRequest): DescribeVirtualBorderRoutersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVirtualBorderRoutersWithOptions(request, runtime);
}

model DescribeVirtualBorderRoutersForPhysicalConnectionRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  filter?: [ 
    {
      key?: string(name='Key'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter'),
}

model DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody = {
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  virtualBorderRouterForPhysicalConnectionSet?: {
    virtualBorderRouterForPhysicalConnectionType?: [ 
    {
      type?: string(name='Type'),
      creationTime?: string(name='CreationTime'),
      status?: string(name='Status'),
      circuitCode?: string(name='CircuitCode'),
      peerIpv6GatewayIp?: string(name='PeerIpv6GatewayIp'),
      PConnVbrExpireTime?: string(name='PConnVbrExpireTime'),
      localIpv6GatewayIp?: string(name='LocalIpv6GatewayIp'),
      localGatewayIp?: string(name='LocalGatewayIp'),
      activationTime?: string(name='ActivationTime'),
      bandwidthStatus?: string(name='BandwidthStatus'),
      vbrOwnerUid?: long(name='VbrOwnerUid'),
      peeringSubnetMask?: string(name='PeeringSubnetMask'),
      enableIpv6?: boolean(name='EnableIpv6'),
      eccId?: string(name='EccId'),
      bandwidth?: string(name='Bandwidth'),
      recoveryTime?: string(name='RecoveryTime'),
      terminationTime?: string(name='TerminationTime'),
      PConnVbrBussinessStatus?: string(name='PConnVbrBussinessStatus'),
      peerGatewayIp?: string(name='PeerGatewayIp'),
      peeringIpv6SubnetMask?: string(name='PeeringIpv6SubnetMask'),
      vbrId?: string(name='VbrId'),
      PConnVbrChargeType?: string(name='PConnVbrChargeType'),
      vlanId?: int32(name='VlanId'),
    }
  ](name='VirtualBorderRouterForPhysicalConnectionType')
  }(name='VirtualBorderRouterForPhysicalConnectionSet'),
}

model DescribeVirtualBorderRoutersForPhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody(name='body'),
}

async function describeVirtualBorderRoutersForPhysicalConnectionWithOptions(request: DescribeVirtualBorderRoutersForPhysicalConnectionRequest, runtime: Util.RuntimeOptions): DescribeVirtualBorderRoutersForPhysicalConnectionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeVirtualBorderRoutersForPhysicalConnection', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeVirtualBorderRoutersForPhysicalConnection(request: DescribeVirtualBorderRoutersForPhysicalConnectionRequest): DescribeVirtualBorderRoutersForPhysicalConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVirtualBorderRoutersForPhysicalConnectionWithOptions(request, runtime);
}

model DescribeVpcAttributeRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpcId?: string(name='VpcId'),
  regionId?: string(name='RegionId'),
  dryRun?: boolean(name='DryRun'),
  isDefault?: boolean(name='IsDefault'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DescribeVpcAttributeResponseBody = {
  status?: string(name='Status'),
  isDefault?: boolean(name='IsDefault'),
  dhcpOptionsSetStatus?: string(name='DhcpOptionsSetStatus'),
  description?: string(name='Description'),
  classicLinkEnabled?: boolean(name='ClassicLinkEnabled'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  vSwitchIds?: {
    vSwitchId?: [ string ](name='VSwitchId')
  }(name='VSwitchIds'),
  secondaryCidrBlocks?: {
    secondaryCidrBlock?: [ string ](name='SecondaryCidrBlock')
  }(name='SecondaryCidrBlocks'),
  cidrBlock?: string(name='CidrBlock'),
  userCidrs?: {
    userCidr?: [ string ](name='UserCidr')
  }(name='UserCidrs'),
  VRouterId?: string(name='VRouterId'),
  dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
  vpcId?: string(name='VpcId'),
  ownerId?: long(name='OwnerId'),
  associatedCens?: {
    associatedCen?: [ 
    {
      cenOwnerId?: long(name='CenOwnerId'),
      cenId?: string(name='CenId'),
      cenStatus?: string(name='CenStatus'),
    }
  ](name='AssociatedCen')
  }(name='AssociatedCens'),
  creationTime?: string(name='CreationTime'),
  vpcName?: string(name='VpcName'),
  regionId?: string(name='RegionId'),
  ipv6CidrBlock?: string(name='Ipv6CidrBlock'),
  cloudResources?: {
    cloudResourceSetType?: [ 
    {
      resourceCount?: int32(name='ResourceCount'),
      resourceType?: string(name='ResourceType'),
    }
  ](name='CloudResourceSetType')
  }(name='CloudResources'),
}

model DescribeVpcAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVpcAttributeResponseBody(name='body'),
}

async function describeVpcAttributeWithOptions(request: DescribeVpcAttributeRequest, runtime: Util.RuntimeOptions): DescribeVpcAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeVpcAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeVpcAttribute(request: DescribeVpcAttributeRequest): DescribeVpcAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpcAttributeWithOptions(request, runtime);
}

model DescribeVpcsRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpcId?: string(name='VpcId'),
  regionId?: string(name='RegionId'),
  vpcName?: string(name='VpcName'),
  isDefault?: boolean(name='IsDefault'),
  dryRun?: boolean(name='DryRun'),
  resourceGroupId?: string(name='ResourceGroupId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  ownerAccount?: string(name='OwnerAccount'),
  vpcOwnerId?: long(name='VpcOwnerId'),
  advancedFeature?: boolean(name='AdvancedFeature'),
  dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
  tag?: [ 
    {
    }
  ](name='Tag'),
}

model DescribeVpcsResponseBody = {
  totalCount?: int32(name='TotalCount'),
  vpcs?: {
    vpc?: [ 
    {
      vpcId?: string(name='VpcId'),
      status?: string(name='Status'),
      creationTime?: string(name='CreationTime'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
      userCidrs?: {
        userCidr?: [ string ](name='UserCidr')
      }(name='UserCidrs'),
      natGatewayIds?: {
        natGatewayIds?: [ string ](name='NatGatewayIds')
      }(name='NatGatewayIds'),
      ownerId?: long(name='OwnerId'),
      vpcName?: string(name='VpcName'),
      cidrBlock?: string(name='CidrBlock'),
      dhcpOptionsSetStatus?: string(name='DhcpOptionsSetStatus'),
      description?: string(name='Description'),
      dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
      vSwitchIds?: {
        vSwitchId?: [ string ](name='VSwitchId')
      }(name='VSwitchIds'),
      ipv6CidrBlock?: string(name='Ipv6CidrBlock'),
      routerTableIds?: {
        routerTableIds?: [ string ](name='RouterTableIds')
      }(name='RouterTableIds'),
      isDefault?: boolean(name='IsDefault'),
      regionId?: string(name='RegionId'),
      VRouterId?: string(name='VRouterId'),
      secondaryCidrBlocks?: {
        secondaryCidrBlock?: [ string ](name='SecondaryCidrBlock')
      }(name='SecondaryCidrBlocks'),
      resourceGroupId?: string(name='ResourceGroupId'),
      cenStatus?: string(name='CenStatus'),
    }
  ](name='Vpc')
  }(name='Vpcs'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
}

model DescribeVpcsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVpcsResponseBody(name='body'),
}

async function describeVpcsWithOptions(request: DescribeVpcsRequest, runtime: Util.RuntimeOptions): DescribeVpcsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeVpcs', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeVpcs(request: DescribeVpcsRequest): DescribeVpcsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpcsWithOptions(request, runtime);
}

model DescribeVpnConnectionRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  vpnConnectionId?: string(name='VpnConnectionId'),
}

model DescribeVpnConnectionResponseBody = {
  status?: string(name='Status'),
  localSubnet?: string(name='LocalSubnet'),
  requestId?: string(name='RequestId'),
  customerGatewayId?: string(name='CustomerGatewayId'),
  createTime?: long(name='CreateTime'),
  name?: string(name='Name'),
  effectImmediately?: boolean(name='EffectImmediately'),
  remoteSubnet?: string(name='RemoteSubnet'),
  vcoHealthCheck?: {
    status?: string(name='Status'),
    dip?: string(name='Dip'),
    interval?: int32(name='Interval'),
    retry?: int32(name='Retry'),
    sip?: string(name='Sip'),
    enable?: string(name='Enable'),
  }(name='VcoHealthCheck'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  ipsecConfig?: {
    ipsecLifetime?: long(name='IpsecLifetime'),
    ipsecEncAlg?: string(name='IpsecEncAlg'),
    ipsecPfs?: string(name='IpsecPfs'),
    ipsecAuthAlg?: string(name='IpsecAuthAlg'),
  }(name='IpsecConfig'),
  remoteCaCertificate?: string(name='RemoteCaCertificate'),
  vpnConnectionId?: string(name='VpnConnectionId'),
  enableNatTraversal?: boolean(name='EnableNatTraversal'),
  enableDpd?: boolean(name='EnableDpd'),
  ikeConfig?: {
    remoteId?: string(name='RemoteId'),
    ikeLifetime?: long(name='IkeLifetime'),
    ikeEncAlg?: string(name='IkeEncAlg'),
    localId?: string(name='LocalId'),
    ikeMode?: string(name='IkeMode'),
    ikeVersion?: string(name='IkeVersion'),
    ikePfs?: string(name='IkePfs'),
    psk?: string(name='Psk'),
    ikeAuthAlg?: string(name='IkeAuthAlg'),
  }(name='IkeConfig'),
  vpnBgpConfig?: {
    status?: string(name='Status'),
    peerBgpIp?: string(name='PeerBgpIp'),
    tunnelCidr?: string(name='TunnelCidr'),
    enableBgp?: string(name='EnableBgp'),
    localBgpIp?: string(name='LocalBgpIp'),
    peerAsn?: string(name='PeerAsn'),
    localAsn?: string(name='LocalAsn'),
  }(name='VpnBgpConfig'),
}

model DescribeVpnConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVpnConnectionResponseBody(name='body'),
}

async function describeVpnConnectionWithOptions(request: DescribeVpnConnectionRequest, runtime: Util.RuntimeOptions): DescribeVpnConnectionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeVpnConnection', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeVpnConnection(request: DescribeVpnConnectionRequest): DescribeVpnConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpnConnectionWithOptions(request, runtime);
}

model DescribeVpnConnectionsRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  customerGatewayId?: string(name='CustomerGatewayId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  vpnConnectionId?: string(name='VpnConnectionId'),
}

model DescribeVpnConnectionsResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  vpnConnections?: {
    vpnConnection?: [ 
    {
      status?: string(name='Status'),
      vpnBgpConfig?: {
        status?: string(name='Status'),
        peerBgpIp?: string(name='PeerBgpIp'),
        tunnelCidr?: string(name='TunnelCidr'),
        localBgpIp?: string(name='LocalBgpIp'),
        peerAsn?: string(name='PeerAsn'),
        localAsn?: string(name='LocalAsn'),
      }(name='VpnBgpConfig'),
      remoteCaCertificate?: string(name='RemoteCaCertificate'),
      enableNatTraversal?: boolean(name='EnableNatTraversal'),
      effectImmediately?: boolean(name='EffectImmediately'),
      createTime?: long(name='CreateTime'),
      vcoHealthCheck?: {
        status?: string(name='Status'),
        dip?: string(name='Dip'),
        interval?: int32(name='Interval'),
        retry?: int32(name='Retry'),
        sip?: string(name='Sip'),
        enable?: string(name='Enable'),
      }(name='VcoHealthCheck'),
      vpnGatewayId?: string(name='VpnGatewayId'),
      ipsecConfig?: {
        ipsecLifetime?: long(name='IpsecLifetime'),
        ipsecEncAlg?: string(name='IpsecEncAlg'),
        ipsecPfs?: string(name='IpsecPfs'),
        ipsecAuthAlg?: string(name='IpsecAuthAlg'),
      }(name='IpsecConfig'),
      ikeConfig?: {
        remoteId?: string(name='RemoteId'),
        ikeLifetime?: long(name='IkeLifetime'),
        ikeEncAlg?: string(name='IkeEncAlg'),
        localId?: string(name='LocalId'),
        ikeMode?: string(name='IkeMode'),
        ikeVersion?: string(name='IkeVersion'),
        ikePfs?: string(name='IkePfs'),
        psk?: string(name='Psk'),
        ikeAuthAlg?: string(name='IkeAuthAlg'),
      }(name='IkeConfig'),
      localSubnet?: string(name='LocalSubnet'),
      vpnConnectionId?: string(name='VpnConnectionId'),
      remoteSubnet?: string(name='RemoteSubnet'),
      customerGatewayId?: string(name='CustomerGatewayId'),
      name?: string(name='Name'),
      enableDpd?: boolean(name='EnableDpd'),
    }
  ](name='VpnConnection')
  }(name='VpnConnections'),
}

model DescribeVpnConnectionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVpnConnectionsResponseBody(name='body'),
}

async function describeVpnConnectionsWithOptions(request: DescribeVpnConnectionsRequest, runtime: Util.RuntimeOptions): DescribeVpnConnectionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeVpnConnections', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeVpnConnections(request: DescribeVpnConnectionsRequest): DescribeVpnConnectionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpnConnectionsWithOptions(request, runtime);
}

model DescribeVpnGatewayRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  includeReservationData?: boolean(name='IncludeReservationData'),
}

model DescribeVpnGatewayResponseBody = {
  status?: string(name='Status'),
  ipsecVpn?: string(name='IpsecVpn'),
  sslVpn?: string(name='SslVpn'),
  vpnType?: string(name='VpnType'),
  description?: string(name='Description'),
  enableBgp?: boolean(name='EnableBgp'),
  endTime?: long(name='EndTime'),
  requestId?: string(name='RequestId'),
  createTime?: long(name='CreateTime'),
  vSwitchId?: string(name='VSwitchId'),
  autoPropagate?: boolean(name='AutoPropagate'),
  businessStatus?: string(name='BusinessStatus'),
  name?: string(name='Name'),
  vpcId?: string(name='VpcId'),
  internetIp?: string(name='InternetIp'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  chargeType?: string(name='ChargeType'),
  tag?: string(name='Tag'),
  spec?: string(name='Spec'),
  sslMaxConnections?: long(name='SslMaxConnections'),
  tags?: {
    tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag')
  }(name='Tags'),
  reservationData?: {
    status?: string(name='Status'),
    reservationOrderType?: string(name='ReservationOrderType'),
    reservationIpsec?: string(name='ReservationIpsec'),
    reservationSpec?: string(name='ReservationSpec'),
    reservationSsl?: string(name='ReservationSsl'),
    reservationMaxConnections?: int32(name='ReservationMaxConnections'),
    reservationEndTime?: string(name='ReservationEndTime'),
  }(name='ReservationData'),
}

model DescribeVpnGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVpnGatewayResponseBody(name='body'),
}

async function describeVpnGatewayWithOptions(request: DescribeVpnGatewayRequest, runtime: Util.RuntimeOptions): DescribeVpnGatewayResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeVpnGateway', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeVpnGateway(request: DescribeVpnGatewayRequest): DescribeVpnGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpnGatewayWithOptions(request, runtime);
}

model DescribeVpnGatewaysRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  vpcId?: string(name='VpcId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  status?: string(name='Status'),
  businessStatus?: string(name='BusinessStatus'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  includeReservationData?: boolean(name='IncludeReservationData'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model DescribeVpnGatewaysResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  vpnGateways?: {
    vpnGateway?: [ 
    {
      vpcId?: string(name='VpcId'),
      status?: string(name='Status'),
      vpnType?: string(name='VpnType'),
      sslMaxConnections?: long(name='SslMaxConnections'),
      internetIp?: string(name='InternetIp'),
      spec?: string(name='Spec'),
      createTime?: long(name='CreateTime'),
      chargeType?: string(name='ChargeType'),
      autoPropagate?: boolean(name='AutoPropagate'),
      vpnGatewayId?: string(name='VpnGatewayId'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
      tag?: string(name='Tag'),
      ipsecVpn?: string(name='IpsecVpn'),
      endTime?: long(name='EndTime'),
      vSwitchId?: string(name='VSwitchId'),
      description?: string(name='Description'),
      enableBgp?: boolean(name='EnableBgp'),
      businessStatus?: string(name='BusinessStatus'),
      sslVpn?: string(name='SslVpn'),
      name?: string(name='Name'),
      reservationData?: {
        status?: string(name='Status'),
        reservationOrderType?: string(name='ReservationOrderType'),
        reservationIpsec?: string(name='ReservationIpsec'),
        reservationSpec?: string(name='ReservationSpec'),
        reservationSsl?: string(name='ReservationSsl'),
        reservationMaxConnections?: int32(name='ReservationMaxConnections'),
        reservationEndTime?: string(name='ReservationEndTime'),
      }(name='ReservationData'),
    }
  ](name='VpnGateway')
  }(name='VpnGateways'),
}

model DescribeVpnGatewaysResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVpnGatewaysResponseBody(name='body'),
}

async function describeVpnGatewaysWithOptions(request: DescribeVpnGatewaysRequest, runtime: Util.RuntimeOptions): DescribeVpnGatewaysResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeVpnGateways', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeVpnGateways(request: DescribeVpnGatewaysRequest): DescribeVpnGatewaysResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpnGatewaysWithOptions(request, runtime);
}

model DescribeVpnPbrRouteEntriesRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeVpnPbrRouteEntriesResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  vpnPbrRouteEntries?: {
    vpnPbrRouteEntry?: [ 
    {
      nextHop?: string(name='NextHop'),
      weight?: int32(name='Weight'),
      routeDest?: string(name='RouteDest'),
      state?: string(name='State'),
      createTime?: long(name='CreateTime'),
      vpnInstanceId?: string(name='VpnInstanceId'),
      routeSource?: string(name='RouteSource'),
    }
  ](name='VpnPbrRouteEntry')
  }(name='VpnPbrRouteEntries'),
}

model DescribeVpnPbrRouteEntriesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVpnPbrRouteEntriesResponseBody(name='body'),
}

async function describeVpnPbrRouteEntriesWithOptions(request: DescribeVpnPbrRouteEntriesRequest, runtime: Util.RuntimeOptions): DescribeVpnPbrRouteEntriesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeVpnPbrRouteEntries', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeVpnPbrRouteEntries(request: DescribeVpnPbrRouteEntriesRequest): DescribeVpnPbrRouteEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpnPbrRouteEntriesWithOptions(request, runtime);
}

model DescribeVpnRouteEntriesRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  routeEntryType?: string(name='RouteEntryType'),
}

model DescribeVpnRouteEntriesResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  vpnRouteEntries?: {
    vpnRouteEntry?: [ 
    {
      routeEntryType?: string(name='RouteEntryType'),
      nextHop?: string(name='NextHop'),
      weight?: int32(name='Weight'),
      routeDest?: string(name='RouteDest'),
      asPath?: string(name='AsPath'),
      state?: string(name='State'),
      createTime?: long(name='CreateTime'),
      community?: string(name='Community'),
      source?: string(name='Source'),
      vpnInstanceId?: string(name='VpnInstanceId'),
    }
  ](name='VpnRouteEntry')
  }(name='VpnRouteEntries'),
  pageNumber?: int32(name='PageNumber'),
}

model DescribeVpnRouteEntriesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVpnRouteEntriesResponseBody(name='body'),
}

async function describeVpnRouteEntriesWithOptions(request: DescribeVpnRouteEntriesRequest, runtime: Util.RuntimeOptions): DescribeVpnRouteEntriesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeVpnRouteEntries', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeVpnRouteEntries(request: DescribeVpnRouteEntriesRequest): DescribeVpnRouteEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpnRouteEntriesWithOptions(request, runtime);
}

model DescribeVpnSslServerLogsRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  vpnSslServerId?: string(name='VpnSslServerId'),
  sslVpnClientCertId?: string(name='SslVpnClientCertId'),
  from?: int32(name='From'),
  to?: int32(name='To'),
  minutePeriod?: int32(name='MinutePeriod'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeVpnSslServerLogsResponseBody = {
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  isCompleted?: boolean(name='IsCompleted'),
  data?: {
    logs?: [ string ](name='Logs')
  }(name='Data'),
  count?: int32(name='Count'),
}

model DescribeVpnSslServerLogsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVpnSslServerLogsResponseBody(name='body'),
}

async function describeVpnSslServerLogsWithOptions(request: DescribeVpnSslServerLogsRequest, runtime: Util.RuntimeOptions): DescribeVpnSslServerLogsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeVpnSslServerLogs', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeVpnSslServerLogs(request: DescribeVpnSslServerLogsRequest): DescribeVpnSslServerLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpnSslServerLogsWithOptions(request, runtime);
}

model DescribeVRoutersRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  VRouterId?: string(name='VRouterId'),
  regionId?: string(name='RegionId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DescribeVRoutersResponseBody = {
  VRouters?: {
    VRouter?: [ 
    {
      vpcId?: string(name='VpcId'),
      creationTime?: string(name='CreationTime'),
      VRouterId?: string(name='VRouterId'),
      description?: string(name='Description'),
      VRouterName?: string(name='VRouterName'),
      routeTableIds?: {
        routeTableId?: [ string ](name='RouteTableId')
      }(name='RouteTableIds'),
      regionId?: string(name='RegionId'),
    }
  ](name='VRouter')
  }(name='VRouters'),
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
}

model DescribeVRoutersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVRoutersResponseBody(name='body'),
}

async function describeVRoutersWithOptions(request: DescribeVRoutersRequest, runtime: Util.RuntimeOptions): DescribeVRoutersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeVRouters', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeVRouters(request: DescribeVRoutersRequest): DescribeVRoutersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVRoutersWithOptions(request, runtime);
}

model DescribeVSwitchAttributesRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vSwitchId?: string(name='VSwitchId'),
  regionId?: string(name='RegionId'),
  dryRun?: boolean(name='DryRun'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DescribeVSwitchAttributesResponseBody = {
  status?: string(name='Status'),
  isDefault?: boolean(name='IsDefault'),
  description?: string(name='Description'),
  networkAclId?: string(name='NetworkAclId'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  zoneId?: string(name='ZoneId'),
  availableIpAddressCount?: long(name='AvailableIpAddressCount'),
  vSwitchId?: string(name='VSwitchId'),
  cidrBlock?: string(name='CidrBlock'),
  routeTable?: {
    routeTableType?: string(name='RouteTableType'),
    routeTableId?: string(name='RouteTableId'),
  }(name='RouteTable'),
  vpcId?: string(name='VpcId'),
  ownerId?: long(name='OwnerId'),
  creationTime?: string(name='CreationTime'),
  vSwitchName?: string(name='VSwitchName'),
  ipv6CidrBlock?: string(name='Ipv6CidrBlock'),
}

model DescribeVSwitchAttributesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVSwitchAttributesResponseBody(name='body'),
}

async function describeVSwitchAttributesWithOptions(request: DescribeVSwitchAttributesRequest, runtime: Util.RuntimeOptions): DescribeVSwitchAttributesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeVSwitchAttributes', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeVSwitchAttributes(request: DescribeVSwitchAttributesRequest): DescribeVSwitchAttributesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVSwitchAttributesWithOptions(request, runtime);
}

model DescribeVSwitchesRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpcId?: string(name='VpcId'),
  vSwitchId?: string(name='VSwitchId'),
  zoneId?: string(name='ZoneId'),
  regionId?: string(name='RegionId'),
  vSwitchName?: string(name='VSwitchName'),
  dryRun?: boolean(name='DryRun'),
  isDefault?: boolean(name='IsDefault'),
  routeTableId?: string(name='RouteTableId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  ownerAccount?: string(name='OwnerAccount'),
  vSwitchOwnerId?: long(name='VSwitchOwnerId'),
  tag?: [ 
    {
    }
  ](name='Tag'),
}

model DescribeVSwitchesResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  vSwitches?: {
    vSwitch?: [ 
    {
      creationTime?: string(name='CreationTime'),
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
      isDefault?: boolean(name='IsDefault'),
      availableIpAddressCount?: long(name='AvailableIpAddressCount'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
      routeTable?: {
        routeTableType?: string(name='RouteTableType'),
        routeTableId?: string(name='RouteTableId'),
      }(name='RouteTable'),
      networkAclId?: string(name='NetworkAclId'),
      ownerId?: long(name='OwnerId'),
      vSwitchId?: string(name='VSwitchId'),
      cidrBlock?: string(name='CidrBlock'),
      description?: string(name='Description'),
      resourceGroupId?: string(name='ResourceGroupId'),
      zoneId?: string(name='ZoneId'),
      ipv6CidrBlock?: string(name='Ipv6CidrBlock'),
      vSwitchName?: string(name='VSwitchName'),
    }
  ](name='VSwitch')
  }(name='VSwitches'),
}

model DescribeVSwitchesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVSwitchesResponseBody(name='body'),
}

async function describeVSwitchesWithOptions(request: DescribeVSwitchesRequest, runtime: Util.RuntimeOptions): DescribeVSwitchesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeVSwitches', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeVSwitches(request: DescribeVSwitchesRequest): DescribeVSwitchesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVSwitchesWithOptions(request, runtime);
}

model DescribeZonesRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DescribeZonesResponseBody = {
  requestId?: string(name='RequestId'),
  zones?: {
    zone?: [ 
    {
      localName?: string(name='LocalName'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Zone')
  }(name='Zones'),
}

model DescribeZonesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeZonesResponseBody(name='body'),
}

async function describeZonesWithOptions(request: DescribeZonesRequest, runtime: Util.RuntimeOptions): DescribeZonesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeZones', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeZones(request: DescribeZonesRequest): DescribeZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeZonesWithOptions(request, runtime);
}

model DetachDhcpOptionsSetFromVpcRequest {
  regionId?: string(name='RegionId'),
  dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
  vpcId?: string(name='VpcId'),
  clientToken?: string(name='ClientToken'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  dryRun?: boolean(name='DryRun'),
}

model DetachDhcpOptionsSetFromVpcResponseBody = {
  requestId?: string(name='RequestId'),
}

model DetachDhcpOptionsSetFromVpcResponse = {
  headers: map[string]string(name='headers'),
  body: DetachDhcpOptionsSetFromVpcResponseBody(name='body'),
}

async function detachDhcpOptionsSetFromVpcWithOptions(request: DetachDhcpOptionsSetFromVpcRequest, runtime: Util.RuntimeOptions): DetachDhcpOptionsSetFromVpcResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DetachDhcpOptionsSetFromVpc', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function detachDhcpOptionsSetFromVpc(request: DetachDhcpOptionsSetFromVpcRequest): DetachDhcpOptionsSetFromVpcResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachDhcpOptionsSetFromVpcWithOptions(request, runtime);
}

model DisableNatGatewayEcsMetricRequest {
  regionId?: string(name='RegionId'),
  dryRun?: boolean(name='DryRun'),
  natGatewayId?: string(name='NatGatewayId'),
}

model DisableNatGatewayEcsMetricResponseBody = {
  requestId?: string(name='RequestId'),
}

model DisableNatGatewayEcsMetricResponse = {
  headers: map[string]string(name='headers'),
  body: DisableNatGatewayEcsMetricResponseBody(name='body'),
}

async function disableNatGatewayEcsMetricWithOptions(request: DisableNatGatewayEcsMetricRequest, runtime: Util.RuntimeOptions): DisableNatGatewayEcsMetricResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DisableNatGatewayEcsMetric', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function disableNatGatewayEcsMetric(request: DisableNatGatewayEcsMetricRequest): DisableNatGatewayEcsMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableNatGatewayEcsMetricWithOptions(request, runtime);
}

model DisableVpcClassicLinkRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  vpcId?: string(name='VpcId'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
}

model DisableVpcClassicLinkResponseBody = {
  requestId?: string(name='RequestId'),
}

model DisableVpcClassicLinkResponse = {
  headers: map[string]string(name='headers'),
  body: DisableVpcClassicLinkResponseBody(name='body'),
}

async function disableVpcClassicLinkWithOptions(request: DisableVpcClassicLinkRequest, runtime: Util.RuntimeOptions): DisableVpcClassicLinkResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DisableVpcClassicLink', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function disableVpcClassicLink(request: DisableVpcClassicLinkRequest): DisableVpcClassicLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableVpcClassicLinkWithOptions(request, runtime);
}

model DissociateVpnGatewayWithCertificateRequest {
  regionId?: string(name='RegionId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  certificateType?: string(name='CertificateType'),
  certificateId?: string(name='CertificateId'),
  callerBid?: string(name='callerBid'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DissociateVpnGatewayWithCertificateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DissociateVpnGatewayWithCertificateResponse = {
  headers: map[string]string(name='headers'),
  body: DissociateVpnGatewayWithCertificateResponseBody(name='body'),
}

async function dissociateVpnGatewayWithCertificateWithOptions(request: DissociateVpnGatewayWithCertificateRequest, runtime: Util.RuntimeOptions): DissociateVpnGatewayWithCertificateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DissociateVpnGatewayWithCertificate', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function dissociateVpnGatewayWithCertificate(request: DissociateVpnGatewayWithCertificateRequest): DissociateVpnGatewayWithCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return dissociateVpnGatewayWithCertificateWithOptions(request, runtime);
}

model DownloadVpnConnectionConfigRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  vpnConnectionId?: string(name='VpnConnectionId'),
}

model DownloadVpnConnectionConfigResponseBody = {
  requestId?: string(name='RequestId'),
  vpnConnectionConfig?: {
    remote?: string(name='Remote'),
    local?: string(name='Local'),
    remoteSubnet?: string(name='RemoteSubnet'),
    ipsecConfig?: {
      ipsecLifetime?: long(name='IpsecLifetime'),
      ipsecEncAlg?: string(name='IpsecEncAlg'),
      ipsecPfs?: string(name='IpsecPfs'),
      ipsecAuthAlg?: string(name='IpsecAuthAlg'),
    }(name='IpsecConfig'),
    ikeConfig?: {
      remoteId?: string(name='RemoteId'),
      ikeLifetime?: long(name='IkeLifetime'),
      ikeEncAlg?: string(name='IkeEncAlg'),
      localId?: string(name='LocalId'),
      ikeMode?: string(name='IkeMode'),
      ikeVersion?: string(name='IkeVersion'),
      ikePfs?: string(name='IkePfs'),
      psk?: string(name='Psk'),
      ikeAuthAlg?: string(name='IkeAuthAlg'),
    }(name='IkeConfig'),
    localSubnet?: string(name='LocalSubnet'),
  }(name='VpnConnectionConfig'),
}

model DownloadVpnConnectionConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DownloadVpnConnectionConfigResponseBody(name='body'),
}

async function downloadVpnConnectionConfigWithOptions(request: DownloadVpnConnectionConfigRequest, runtime: Util.RuntimeOptions): DownloadVpnConnectionConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DownloadVpnConnectionConfig', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function downloadVpnConnectionConfig(request: DownloadVpnConnectionConfigRequest): DownloadVpnConnectionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return downloadVpnConnectionConfigWithOptions(request, runtime);
}

model EnableNatGatewayEcsMetricRequest {
  regionId?: string(name='RegionId'),
  dryRun?: boolean(name='DryRun'),
  natGatewayId?: string(name='NatGatewayId'),
}

model EnableNatGatewayEcsMetricResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnableNatGatewayEcsMetricResponse = {
  headers: map[string]string(name='headers'),
  body: EnableNatGatewayEcsMetricResponseBody(name='body'),
}

async function enableNatGatewayEcsMetricWithOptions(request: EnableNatGatewayEcsMetricRequest, runtime: Util.RuntimeOptions): EnableNatGatewayEcsMetricResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('EnableNatGatewayEcsMetric', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function enableNatGatewayEcsMetric(request: EnableNatGatewayEcsMetricRequest): EnableNatGatewayEcsMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableNatGatewayEcsMetricWithOptions(request, runtime);
}

model EnablePhysicalConnectionRequest {
  regionId?: string(name='RegionId'),
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
}

model EnablePhysicalConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnablePhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: EnablePhysicalConnectionResponseBody(name='body'),
}

async function enablePhysicalConnectionWithOptions(request: EnablePhysicalConnectionRequest, runtime: Util.RuntimeOptions): EnablePhysicalConnectionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('EnablePhysicalConnection', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function enablePhysicalConnection(request: EnablePhysicalConnectionRequest): EnablePhysicalConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return enablePhysicalConnectionWithOptions(request, runtime);
}

model EnableVpcClassicLinkRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  vpcId?: string(name='VpcId'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
}

model EnableVpcClassicLinkResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnableVpcClassicLinkResponse = {
  headers: map[string]string(name='headers'),
  body: EnableVpcClassicLinkResponseBody(name='body'),
}

async function enableVpcClassicLinkWithOptions(request: EnableVpcClassicLinkRequest, runtime: Util.RuntimeOptions): EnableVpcClassicLinkResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('EnableVpcClassicLink', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function enableVpcClassicLink(request: EnableVpcClassicLinkRequest): EnableVpcClassicLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableVpcClassicLinkWithOptions(request, runtime);
}

model GetDhcpOptionsSetRequest {
  regionId?: string(name='RegionId'),
  dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model GetDhcpOptionsSetResponseBody = {
  status?: string(name='Status'),
  dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
  dhcpOptions?: {
    domainNameServers?: string(name='DomainNameServers'),
    domainName?: string(name='DomainName'),
  }(name='DhcpOptions'),
  requestId?: string(name='RequestId'),
  ownerId?: long(name='OwnerId'),
  dhcpOptionsSetName?: string(name='DhcpOptionsSetName'),
  associateVpcs?: [ 
    {
      associateStatus?: string(name='AssociateStatus'),
      vpcId?: string(name='VpcId'),
    }
  ](name='AssociateVpcs'),
  dhcpOptionsSetDescription?: string(name='DhcpOptionsSetDescription'),
}

model GetDhcpOptionsSetResponse = {
  headers: map[string]string(name='headers'),
  body: GetDhcpOptionsSetResponseBody(name='body'),
}

async function getDhcpOptionsSetWithOptions(request: GetDhcpOptionsSetRequest, runtime: Util.RuntimeOptions): GetDhcpOptionsSetResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetDhcpOptionsSet', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getDhcpOptionsSet(request: GetDhcpOptionsSetRequest): GetDhcpOptionsSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDhcpOptionsSetWithOptions(request, runtime);
}

model GetNatGatewayAttributeRequest {
  regionId?: string(name='RegionId'),
  natGatewayId?: string(name='NatGatewayId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model GetNatGatewayAttributeResponseBody = {
  status?: string(name='Status'),
  forwardTable?: {
    forwardEntryCount?: int32(name='ForwardEntryCount'),
    forwardTableId?: string(name='ForwardTableId'),
  }(name='ForwardTable'),
  description?: string(name='Description'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  ipList?: [ 
    {
      usingStatus?: string(name='UsingStatus'),
      ipAddress?: string(name='IpAddress'),
      allocationId?: string(name='AllocationId'),
    }
  ](name='IpList'),
  deletionProtectionInfo?: {
    enabled?: boolean(name='Enabled'),
  }(name='DeletionProtectionInfo'),
  billingConfig?: {
    autoPay?: string(name='AutoPay'),
    spec?: string(name='Spec'),
    internetChargeType?: string(name='InternetChargeType'),
    instanceChargeType?: string(name='InstanceChargeType'),
  }(name='BillingConfig'),
  natType?: string(name='NatType'),
  businessStatus?: string(name='BusinessStatus'),
  snatTable?: {
    snatEntryCount?: int32(name='SnatEntryCount'),
    snatTableId?: string(name='SnatTableId'),
  }(name='SnatTable'),
  name?: string(name='Name'),
  ecsMetricEnabled?: boolean(name='EcsMetricEnabled'),
  vpcId?: string(name='VpcId'),
  expiredTime?: string(name='ExpiredTime'),
  creationTime?: string(name='CreationTime'),
  privateInfo?: {
    vswitchId?: string(name='VswitchId'),
    eniInstanceId?: string(name='EniInstanceId'),
    maxBandwidth?: int32(name='MaxBandwidth'),
    privateIpAddress?: string(name='PrivateIpAddress'),
    izNo?: string(name='IzNo'),
  }(name='PrivateInfo'),
  regionId?: string(name='RegionId'),
  natGatewayId?: string(name='NatGatewayId'),
}

model GetNatGatewayAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: GetNatGatewayAttributeResponseBody(name='body'),
}

async function getNatGatewayAttributeWithOptions(request: GetNatGatewayAttributeRequest, runtime: Util.RuntimeOptions): GetNatGatewayAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetNatGatewayAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getNatGatewayAttribute(request: GetNatGatewayAttributeRequest): GetNatGatewayAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNatGatewayAttributeWithOptions(request, runtime);
}

model GetNatGatewayConvertStatusRequest {
  regionId?: string(name='RegionId'),
  natGatewayId?: string(name='NatGatewayId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model GetNatGatewayConvertStatusResponseBody = {
  requestId?: string(name='RequestId'),
  dstNatType?: string(name='DstNatType'),
  convertSteps?: [ 
    {
      stepStartTime?: string(name='StepStartTime'),
      stepStatus?: string(name='StepStatus'),
      stepName?: string(name='StepName'),
    }
  ](name='ConvertSteps'),
  natGatewayId?: string(name='NatGatewayId'),
}

model GetNatGatewayConvertStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetNatGatewayConvertStatusResponseBody(name='body'),
}

async function getNatGatewayConvertStatusWithOptions(request: GetNatGatewayConvertStatusRequest, runtime: Util.RuntimeOptions): GetNatGatewayConvertStatusResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetNatGatewayConvertStatus', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getNatGatewayConvertStatus(request: GetNatGatewayConvertStatusRequest): GetNatGatewayConvertStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNatGatewayConvertStatusWithOptions(request, runtime);
}

model GrantInstanceToCenRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
  cenId?: string(name='CenId'),
  cenOwnerId?: long(name='CenOwnerId'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
}

model GrantInstanceToCenResponseBody = {
  requestId?: string(name='RequestId'),
}

model GrantInstanceToCenResponse = {
  headers: map[string]string(name='headers'),
  body: GrantInstanceToCenResponseBody(name='body'),
}

async function grantInstanceToCenWithOptions(request: GrantInstanceToCenRequest, runtime: Util.RuntimeOptions): GrantInstanceToCenResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GrantInstanceToCen', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function grantInstanceToCen(request: GrantInstanceToCenRequest): GrantInstanceToCenResponse {
  var runtime = new Util.RuntimeOptions{};
  return grantInstanceToCenWithOptions(request, runtime);
}

model ListDhcpOptionsSetsRequest {
  regionId?: string(name='RegionId'),
  nextToken?: string(name='NextToken'),
  maxResults?: int32(name='MaxResults'),
  domainName?: string(name='DomainName'),
  dhcpOptionsSetName?: string(name='DhcpOptionsSetName'),
  dhcpOptionsSetId?: [ string ](name='DhcpOptionsSetId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model ListDhcpOptionsSetsResponseBody = {
  dhcpOptionsSets?: [ 
    {
      dhcpOptionsSetDescription?: string(name='DhcpOptionsSetDescription'),
      status?: string(name='Status'),
      dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
      dhcpOptions?: {
        domainNameServers?: string(name='DomainNameServers'),
        domainName?: string(name='DomainName'),
      }(name='DhcpOptions'),
      dhcpOptionsSetName?: string(name='DhcpOptionsSetName'),
      associateVpcCount?: int32(name='AssociateVpcCount'),
      ownerId?: long(name='OwnerId'),
    }
  ](name='DhcpOptionsSets'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model ListDhcpOptionsSetsResponse = {
  headers: map[string]string(name='headers'),
  body: ListDhcpOptionsSetsResponseBody(name='body'),
}

async function listDhcpOptionsSetsWithOptions(request: ListDhcpOptionsSetsRequest, runtime: Util.RuntimeOptions): ListDhcpOptionsSetsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListDhcpOptionsSets', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listDhcpOptionsSets(request: ListDhcpOptionsSetsRequest): ListDhcpOptionsSetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDhcpOptionsSetsWithOptions(request, runtime);
}

model ListEnhanhcedNatGatewayAvailableZonesRequest {
  regionId?: string(name='RegionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model ListEnhanhcedNatGatewayAvailableZonesResponseBody = {
  requestId?: string(name='RequestId'),
  zones?: [ 
    {
      localName?: string(name='LocalName'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Zones'),
}

model ListEnhanhcedNatGatewayAvailableZonesResponse = {
  headers: map[string]string(name='headers'),
  body: ListEnhanhcedNatGatewayAvailableZonesResponseBody(name='body'),
}

async function listEnhanhcedNatGatewayAvailableZonesWithOptions(request: ListEnhanhcedNatGatewayAvailableZonesRequest, runtime: Util.RuntimeOptions): ListEnhanhcedNatGatewayAvailableZonesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListEnhanhcedNatGatewayAvailableZones', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listEnhanhcedNatGatewayAvailableZones(request: ListEnhanhcedNatGatewayAvailableZonesRequest): ListEnhanhcedNatGatewayAvailableZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEnhanhcedNatGatewayAvailableZonesWithOptions(request, runtime);
}

model ListIpsecServersRequest {
  regionId?: string(name='RegionId'),
  ipsecServerName?: string(name='IpsecServerName'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  nextToken?: string(name='NextToken'),
  maxResults?: int32(name='MaxResults'),
  ipsecServerId?: [ string ](name='IpsecServerId'),
  callerBid?: string(name='callerBid'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListIpsecServersResponseBody = {
  totalCount?: int32(name='TotalCount'),
  ipsecServers?: [ 
    {
      creationTime?: string(name='CreationTime'),
      onlineClientCount?: int32(name='OnlineClientCount'),
      internetIp?: string(name='InternetIp'),
      IDaaSInstanceId?: string(name='IDaaSInstanceId'),
      ipsecServerName?: string(name='IpsecServerName'),
      effectImmediately?: boolean(name='EffectImmediately'),
      vpnGatewayId?: string(name='VpnGatewayId'),
      ikeConfig?: {
        remoteId?: string(name='RemoteId'),
        ikeLifetime?: long(name='IkeLifetime'),
        ikeEncAlg?: string(name='IkeEncAlg'),
        localId?: string(name='LocalId'),
        ikeMode?: string(name='IkeMode'),
        ikeVersion?: string(name='IkeVersion'),
        ikePfs?: string(name='IkePfs'),
        ikeAuthAlg?: string(name='IkeAuthAlg'),
      }(name='IkeConfig'),
      ipsecConfig?: {
        ipsecLifetime?: long(name='IpsecLifetime'),
        ipsecEncAlg?: string(name='IpsecEncAlg'),
        ipsecPfs?: string(name='IpsecPfs'),
        ipsecAuthAlg?: string(name='IpsecAuthAlg'),
      }(name='IpsecConfig'),
      psk?: string(name='Psk'),
      localSubnet?: string(name='LocalSubnet'),
      regionId?: string(name='RegionId'),
      pskEnabled?: boolean(name='PskEnabled'),
      ipsecServerId?: string(name='IpsecServerId'),
      multiFactorAuthEnabled?: boolean(name='MultiFactorAuthEnabled'),
      maxConnections?: int32(name='MaxConnections'),
      clientIpPool?: string(name='ClientIpPool'),
    }
  ](name='IpsecServers'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  maxResults?: int32(name='MaxResults'),
}

model ListIpsecServersResponse = {
  headers: map[string]string(name='headers'),
  body: ListIpsecServersResponseBody(name='body'),
}

async function listIpsecServersWithOptions(request: ListIpsecServersRequest, runtime: Util.RuntimeOptions): ListIpsecServersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListIpsecServers', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listIpsecServers(request: ListIpsecServersRequest): ListIpsecServersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listIpsecServersWithOptions(request, runtime);
}

model ListNatGatewayEcsMetricRequest {
  regionId?: string(name='RegionId'),
  dryRun?: boolean(name='DryRun'),
  natGatewayId?: string(name='NatGatewayId'),
  timePoint?: long(name='TimePoint'),
  orderKey?: string(name='OrderKey'),
  orderType?: string(name='OrderType'),
  privateIpAddress?: string(name='PrivateIpAddress'),
  nextToken?: string(name='NextToken'),
  maxResults?: string(name='MaxResults'),
}

model ListNatGatewayEcsMetricResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  metricDataList?: [ 
    {
      rxBps?: long(name='RxBps'),
      activeSessionNum?: long(name='ActiveSessionNum'),
      txBps?: long(name='TxBps'),
      newSessionRate?: long(name='NewSessionRate'),
      txPps?: long(name='TxPps'),
      natGatewayId?: string(name='NatGatewayId'),
      timestamp?: long(name='Timestamp'),
      rxPps?: long(name='RxPps'),
      privateIpAddress?: string(name='PrivateIpAddress'),
    }
  ](name='MetricDataList'),
  maxResults?: int32(name='MaxResults'),
}

model ListNatGatewayEcsMetricResponse = {
  headers: map[string]string(name='headers'),
  body: ListNatGatewayEcsMetricResponseBody(name='body'),
}

async function listNatGatewayEcsMetricWithOptions(request: ListNatGatewayEcsMetricRequest, runtime: Util.RuntimeOptions): ListNatGatewayEcsMetricResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListNatGatewayEcsMetric', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listNatGatewayEcsMetric(request: ListNatGatewayEcsMetricRequest): ListNatGatewayEcsMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNatGatewayEcsMetricWithOptions(request, runtime);
}

model ListPhysicalConnectionFeaturesRequest {
  regionId?: string(name='RegionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  physicalConnectionId?: string(name='PhysicalConnectionId'),
}

model ListPhysicalConnectionFeaturesResponseBody = {
  requestId?: string(name='RequestId'),
  physicalConnectionFeatures?: [ 
    {
      featureValue?: string(name='FeatureValue'),
      featureKey?: string(name='FeatureKey'),
    }
  ](name='PhysicalConnectionFeatures'),
}

model ListPhysicalConnectionFeaturesResponse = {
  headers: map[string]string(name='headers'),
  body: ListPhysicalConnectionFeaturesResponseBody(name='body'),
}

async function listPhysicalConnectionFeaturesWithOptions(request: ListPhysicalConnectionFeaturesRequest, runtime: Util.RuntimeOptions): ListPhysicalConnectionFeaturesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListPhysicalConnectionFeatures', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listPhysicalConnectionFeatures(request: ListPhysicalConnectionFeaturesRequest): ListPhysicalConnectionFeaturesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPhysicalConnectionFeaturesWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  resourceType?: string(name='ResourceType'),
  regionId?: string(name='RegionId'),
  nextToken?: string(name='NextToken'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  maxResults?: int32(name='MaxResults'),
  resourceId?: [ string ](name='ResourceId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceType?: string(name='ResourceType'),
      tagValue?: string(name='TagValue'),
      resourceId?: string(name='ResourceId'),
      tagKey?: string(name='TagKey'),
    }
  ](name='TagResource')
  }(name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListTagResources', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ListVpnCertificateAssociationsRequest {
  regionId?: string(name='RegionId'),
  certificateType?: string(name='CertificateType'),
  nextToken?: string(name='NextToken'),
  maxResults?: int32(name='MaxResults'),
  vpnGatewayId?: [ string ](name='VpnGatewayId'),
  certificateId?: [ string ](name='CertificateId'),
  callerBid?: string(name='callerBid'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListVpnCertificateAssociationsResponseBody = {
  totalCount?: int32(name='TotalCount'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  vpnCertificateRelations?: [ 
    {
      certificateType?: string(name='CertificateType'),
      associationTime?: string(name='AssociationTime'),
      vpnGatewayId?: string(name='VpnGatewayId'),
      certificateId?: string(name='CertificateId'),
      regionId?: string(name='RegionId'),
    }
  ](name='VpnCertificateRelations'),
  maxResults?: int32(name='MaxResults'),
}

model ListVpnCertificateAssociationsResponse = {
  headers: map[string]string(name='headers'),
  body: ListVpnCertificateAssociationsResponseBody(name='body'),
}

async function listVpnCertificateAssociationsWithOptions(request: ListVpnCertificateAssociationsRequest, runtime: Util.RuntimeOptions): ListVpnCertificateAssociationsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListVpnCertificateAssociations', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listVpnCertificateAssociations(request: ListVpnCertificateAssociationsRequest): ListVpnCertificateAssociationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVpnCertificateAssociationsWithOptions(request, runtime);
}

model ModifyBgpGroupAttributeRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  bgpGroupId?: string(name='BgpGroupId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  localAsn?: long(name='LocalAsn'),
  peerAsn?: long(name='PeerAsn'),
  authKey?: string(name='AuthKey'),
  isFakeAsn?: boolean(name='IsFakeAsn'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
}

model ModifyBgpGroupAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyBgpGroupAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyBgpGroupAttributeResponseBody(name='body'),
}

async function modifyBgpGroupAttributeWithOptions(request: ModifyBgpGroupAttributeRequest, runtime: Util.RuntimeOptions): ModifyBgpGroupAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyBgpGroupAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyBgpGroupAttribute(request: ModifyBgpGroupAttributeRequest): ModifyBgpGroupAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyBgpGroupAttributeWithOptions(request, runtime);
}

model ModifyBgpPeerAttributeRequest {
  regionId?: string(name='RegionId'),
  bgpPeerId?: string(name='BgpPeerId'),
  bgpGroupId?: string(name='BgpGroupId'),
  peerIpAddress?: string(name='PeerIpAddress'),
  enableBfd?: boolean(name='EnableBfd'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  bfdMultiHop?: int32(name='BfdMultiHop'),
}

model ModifyBgpPeerAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyBgpPeerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyBgpPeerAttributeResponseBody(name='body'),
}

async function modifyBgpPeerAttributeWithOptions(request: ModifyBgpPeerAttributeRequest, runtime: Util.RuntimeOptions): ModifyBgpPeerAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyBgpPeerAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyBgpPeerAttribute(request: ModifyBgpPeerAttributeRequest): ModifyBgpPeerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyBgpPeerAttributeWithOptions(request, runtime);
}

model ModifyCommonBandwidthPackageAttributeRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
}

model ModifyCommonBandwidthPackageAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyCommonBandwidthPackageAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyCommonBandwidthPackageAttributeResponseBody(name='body'),
}

async function modifyCommonBandwidthPackageAttributeWithOptions(request: ModifyCommonBandwidthPackageAttributeRequest, runtime: Util.RuntimeOptions): ModifyCommonBandwidthPackageAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyCommonBandwidthPackageAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyCommonBandwidthPackageAttribute(request: ModifyCommonBandwidthPackageAttributeRequest): ModifyCommonBandwidthPackageAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyCommonBandwidthPackageAttributeWithOptions(request, runtime);
}

model ModifyCommonBandwidthPackageInternetChargeTypeRequest {
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  autoPay?: boolean(name='AutoPay'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  bandwidth?: int32(name='Bandwidth'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  ratio?: int32(name='Ratio'),
  internetChargeType?: string(name='InternetChargeType'),
  instanceChargeType?: string(name='InstanceChargeType'),
}

model ModifyCommonBandwidthPackageInternetChargeTypeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyCommonBandwidthPackageInternetChargeTypeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyCommonBandwidthPackageInternetChargeTypeResponseBody(name='body'),
}

async function modifyCommonBandwidthPackageInternetChargeTypeWithOptions(request: ModifyCommonBandwidthPackageInternetChargeTypeRequest, runtime: Util.RuntimeOptions): ModifyCommonBandwidthPackageInternetChargeTypeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyCommonBandwidthPackageInternetChargeType', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyCommonBandwidthPackageInternetChargeType(request: ModifyCommonBandwidthPackageInternetChargeTypeRequest): ModifyCommonBandwidthPackageInternetChargeTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyCommonBandwidthPackageInternetChargeTypeWithOptions(request, runtime);
}

model ModifyCommonBandwidthPackageIpBandwidthRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  eipId?: string(name='EipId'),
  bandwidth?: string(name='Bandwidth'),
}

model ModifyCommonBandwidthPackageIpBandwidthResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyCommonBandwidthPackageIpBandwidthResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyCommonBandwidthPackageIpBandwidthResponseBody(name='body'),
}

async function modifyCommonBandwidthPackageIpBandwidthWithOptions(request: ModifyCommonBandwidthPackageIpBandwidthRequest, runtime: Util.RuntimeOptions): ModifyCommonBandwidthPackageIpBandwidthResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyCommonBandwidthPackageIpBandwidth', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyCommonBandwidthPackageIpBandwidth(request: ModifyCommonBandwidthPackageIpBandwidthRequest): ModifyCommonBandwidthPackageIpBandwidthResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyCommonBandwidthPackageIpBandwidthWithOptions(request, runtime);
}

model ModifyCommonBandwidthPackagePayTypeRequest {
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  payType?: string(name='PayType'),
  pricingCycle?: string(name='PricingCycle'),
  duration?: int32(name='Duration'),
  autoPay?: boolean(name='AutoPay'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  bandwidth?: string(name='Bandwidth'),
  kbpsBandwidth?: string(name='KbpsBandwidth'),
  ownerAccount?: string(name='OwnerAccount'),
  resourceBid?: string(name='ResourceBid'),
  resourceUid?: long(name='ResourceUid'),
  regionId?: string(name='RegionId'),
}

model ModifyCommonBandwidthPackagePayTypeResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  orderId?: long(name='OrderId'),
  code?: string(name='Code'),
}

model ModifyCommonBandwidthPackagePayTypeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyCommonBandwidthPackagePayTypeResponseBody(name='body'),
}

async function modifyCommonBandwidthPackagePayTypeWithOptions(request: ModifyCommonBandwidthPackagePayTypeRequest, runtime: Util.RuntimeOptions): ModifyCommonBandwidthPackagePayTypeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyCommonBandwidthPackagePayType', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyCommonBandwidthPackagePayType(request: ModifyCommonBandwidthPackagePayTypeRequest): ModifyCommonBandwidthPackagePayTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyCommonBandwidthPackagePayTypeWithOptions(request, runtime);
}

model ModifyCommonBandwidthPackageSpecRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  bandwidth?: string(name='Bandwidth'),
}

model ModifyCommonBandwidthPackageSpecResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyCommonBandwidthPackageSpecResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyCommonBandwidthPackageSpecResponseBody(name='body'),
}

async function modifyCommonBandwidthPackageSpecWithOptions(request: ModifyCommonBandwidthPackageSpecRequest, runtime: Util.RuntimeOptions): ModifyCommonBandwidthPackageSpecResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyCommonBandwidthPackageSpec', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyCommonBandwidthPackageSpec(request: ModifyCommonBandwidthPackageSpecRequest): ModifyCommonBandwidthPackageSpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyCommonBandwidthPackageSpecWithOptions(request, runtime);
}

model ModifyCustomerGatewayAttributeRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  customerGatewayId?: string(name='CustomerGatewayId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
}

model ModifyCustomerGatewayAttributeResponseBody = {
  description?: string(name='Description'),
  requestId?: string(name='RequestId'),
  customerGatewayId?: string(name='CustomerGatewayId'),
  createTime?: long(name='CreateTime'),
  ipAddress?: string(name='IpAddress'),
  name?: string(name='Name'),
}

model ModifyCustomerGatewayAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyCustomerGatewayAttributeResponseBody(name='body'),
}

async function modifyCustomerGatewayAttributeWithOptions(request: ModifyCustomerGatewayAttributeRequest, runtime: Util.RuntimeOptions): ModifyCustomerGatewayAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyCustomerGatewayAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyCustomerGatewayAttribute(request: ModifyCustomerGatewayAttributeRequest): ModifyCustomerGatewayAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyCustomerGatewayAttributeWithOptions(request, runtime);
}

model ModifyEipAddressAttributeRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  allocationId?: string(name='AllocationId'),
  bandwidth?: string(name='Bandwidth'),
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  ownerAccount?: string(name='OwnerAccount'),
}

model ModifyEipAddressAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyEipAddressAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyEipAddressAttributeResponseBody(name='body'),
}

async function modifyEipAddressAttributeWithOptions(request: ModifyEipAddressAttributeRequest, runtime: Util.RuntimeOptions): ModifyEipAddressAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyEipAddressAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyEipAddressAttribute(request: ModifyEipAddressAttributeRequest): ModifyEipAddressAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyEipAddressAttributeWithOptions(request, runtime);
}

model ModifyExpressCloudConnectionAttributeRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  description?: string(name='Description'),
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  eccId?: string(name='EccId'),
  bgpAs?: string(name='BgpAs'),
  peIp?: string(name='PeIp'),
  ceIp?: string(name='CeIp'),
}

model ModifyExpressCloudConnectionAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyExpressCloudConnectionAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyExpressCloudConnectionAttributeResponseBody(name='body'),
}

async function modifyExpressCloudConnectionAttributeWithOptions(request: ModifyExpressCloudConnectionAttributeRequest, runtime: Util.RuntimeOptions): ModifyExpressCloudConnectionAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyExpressCloudConnectionAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyExpressCloudConnectionAttribute(request: ModifyExpressCloudConnectionAttributeRequest): ModifyExpressCloudConnectionAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyExpressCloudConnectionAttributeWithOptions(request, runtime);
}

model ModifyExpressCloudConnectionBandwidthRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  bandwidth?: string(name='Bandwidth'),
  eccId?: string(name='EccId'),
}

model ModifyExpressCloudConnectionBandwidthResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyExpressCloudConnectionBandwidthResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyExpressCloudConnectionBandwidthResponseBody(name='body'),
}

async function modifyExpressCloudConnectionBandwidthWithOptions(request: ModifyExpressCloudConnectionBandwidthRequest, runtime: Util.RuntimeOptions): ModifyExpressCloudConnectionBandwidthResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyExpressCloudConnectionBandwidth', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyExpressCloudConnectionBandwidth(request: ModifyExpressCloudConnectionBandwidthRequest): ModifyExpressCloudConnectionBandwidthResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyExpressCloudConnectionBandwidthWithOptions(request, runtime);
}

model ModifyFlowLogAttributeRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  flowLogId?: string(name='FlowLogId'),
  flowLogName?: string(name='FlowLogName'),
  description?: string(name='Description'),
  ownerAccount?: string(name='OwnerAccount'),
}

model ModifyFlowLogAttributeResponseBody = {
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model ModifyFlowLogAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyFlowLogAttributeResponseBody(name='body'),
}

async function modifyFlowLogAttributeWithOptions(request: ModifyFlowLogAttributeRequest, runtime: Util.RuntimeOptions): ModifyFlowLogAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyFlowLogAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyFlowLogAttribute(request: ModifyFlowLogAttributeRequest): ModifyFlowLogAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyFlowLogAttributeWithOptions(request, runtime);
}

model ModifyForwardEntryRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  forwardTableId?: string(name='ForwardTableId'),
  forwardEntryId?: string(name='ForwardEntryId'),
  externalIp?: string(name='ExternalIp'),
  externalPort?: string(name='ExternalPort'),
  internalIp?: string(name='InternalIp'),
  internalPort?: string(name='InternalPort'),
  ipProtocol?: string(name='IpProtocol'),
  forwardEntryName?: string(name='ForwardEntryName'),
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  portBreak?: boolean(name='PortBreak'),
}

model ModifyForwardEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyForwardEntryResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyForwardEntryResponseBody(name='body'),
}

async function modifyForwardEntryWithOptions(request: ModifyForwardEntryRequest, runtime: Util.RuntimeOptions): ModifyForwardEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyForwardEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyForwardEntry(request: ModifyForwardEntryRequest): ModifyForwardEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyForwardEntryWithOptions(request, runtime);
}

model ModifyGlobalAccelerationInstanceAttributesRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  globalAccelerationInstanceId?: string(name='GlobalAccelerationInstanceId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  ownerAccount?: string(name='OwnerAccount'),
}

model ModifyGlobalAccelerationInstanceAttributesResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyGlobalAccelerationInstanceAttributesResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyGlobalAccelerationInstanceAttributesResponseBody(name='body'),
}

async function modifyGlobalAccelerationInstanceAttributesWithOptions(request: ModifyGlobalAccelerationInstanceAttributesRequest, runtime: Util.RuntimeOptions): ModifyGlobalAccelerationInstanceAttributesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyGlobalAccelerationInstanceAttributes', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyGlobalAccelerationInstanceAttributes(request: ModifyGlobalAccelerationInstanceAttributesRequest): ModifyGlobalAccelerationInstanceAttributesResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyGlobalAccelerationInstanceAttributesWithOptions(request, runtime);
}

model ModifyGlobalAccelerationInstanceSpecRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  globalAccelerationInstanceId?: string(name='GlobalAccelerationInstanceId'),
  bandwidth?: string(name='Bandwidth'),
  ownerAccount?: string(name='OwnerAccount'),
}

model ModifyGlobalAccelerationInstanceSpecResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyGlobalAccelerationInstanceSpecResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyGlobalAccelerationInstanceSpecResponseBody(name='body'),
}

async function modifyGlobalAccelerationInstanceSpecWithOptions(request: ModifyGlobalAccelerationInstanceSpecRequest, runtime: Util.RuntimeOptions): ModifyGlobalAccelerationInstanceSpecResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyGlobalAccelerationInstanceSpec', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyGlobalAccelerationInstanceSpec(request: ModifyGlobalAccelerationInstanceSpecRequest): ModifyGlobalAccelerationInstanceSpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyGlobalAccelerationInstanceSpecWithOptions(request, runtime);
}

model ModifyHaVipAttributeRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  clientToken?: string(name='ClientToken'),
  regionId?: string(name='RegionId'),
  haVipId?: string(name='HaVipId'),
  description?: string(name='Description'),
  name?: string(name='Name'),
}

model ModifyHaVipAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyHaVipAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyHaVipAttributeResponseBody(name='body'),
}

async function modifyHaVipAttributeWithOptions(request: ModifyHaVipAttributeRequest, runtime: Util.RuntimeOptions): ModifyHaVipAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyHaVipAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyHaVipAttribute(request: ModifyHaVipAttributeRequest): ModifyHaVipAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyHaVipAttributeWithOptions(request, runtime);
}

model ModifyInstanceAutoRenewalAttributeRequest {
  regionId?: string(name='RegionId'),
  instanceId?: string(name='InstanceId'),
  pricingCycle?: string(name='PricingCycle'),
  duration?: int32(name='Duration'),
  instanceType?: string(name='InstanceType'),
  clientToken?: string(name='ClientToken'),
  renewalStatus?: string(name='RenewalStatus'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyInstanceAutoRenewalAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyInstanceAutoRenewalAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceAutoRenewalAttributeResponseBody(name='body'),
}

async function modifyInstanceAutoRenewalAttributeWithOptions(request: ModifyInstanceAutoRenewalAttributeRequest, runtime: Util.RuntimeOptions): ModifyInstanceAutoRenewalAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyInstanceAutoRenewalAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyInstanceAutoRenewalAttribute(request: ModifyInstanceAutoRenewalAttributeRequest): ModifyInstanceAutoRenewalAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyInstanceAutoRenewalAttributeWithOptions(request, runtime);
}

model ModifyIpv6AddressAttributeRequest {
  regionId?: string(name='RegionId'),
  ipv6AddressId?: string(name='Ipv6AddressId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model ModifyIpv6AddressAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyIpv6AddressAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyIpv6AddressAttributeResponseBody(name='body'),
}

async function modifyIpv6AddressAttributeWithOptions(request: ModifyIpv6AddressAttributeRequest, runtime: Util.RuntimeOptions): ModifyIpv6AddressAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyIpv6AddressAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyIpv6AddressAttribute(request: ModifyIpv6AddressAttributeRequest): ModifyIpv6AddressAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIpv6AddressAttributeWithOptions(request, runtime);
}

model ModifyIpv6GatewayAttributeRequest {
  regionId?: string(name='RegionId'),
  ipv6GatewayId?: string(name='Ipv6GatewayId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model ModifyIpv6GatewayAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyIpv6GatewayAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyIpv6GatewayAttributeResponseBody(name='body'),
}

async function modifyIpv6GatewayAttributeWithOptions(request: ModifyIpv6GatewayAttributeRequest, runtime: Util.RuntimeOptions): ModifyIpv6GatewayAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyIpv6GatewayAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyIpv6GatewayAttribute(request: ModifyIpv6GatewayAttributeRequest): ModifyIpv6GatewayAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIpv6GatewayAttributeWithOptions(request, runtime);
}

model ModifyIpv6GatewaySpecRequest {
  regionId?: string(name='RegionId'),
  ipv6GatewayId?: string(name='Ipv6GatewayId'),
  spec?: string(name='Spec'),
  clientToken?: string(name='ClientToken'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model ModifyIpv6GatewaySpecResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyIpv6GatewaySpecResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyIpv6GatewaySpecResponseBody(name='body'),
}

async function modifyIpv6GatewaySpecWithOptions(request: ModifyIpv6GatewaySpecRequest, runtime: Util.RuntimeOptions): ModifyIpv6GatewaySpecResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyIpv6GatewaySpec', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyIpv6GatewaySpec(request: ModifyIpv6GatewaySpecRequest): ModifyIpv6GatewaySpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIpv6GatewaySpecWithOptions(request, runtime);
}

model ModifyIpv6InternetBandwidthRequest {
  regionId?: string(name='RegionId'),
  ipv6AddressId?: string(name='Ipv6AddressId'),
  ipv6InternetBandwidthId?: string(name='Ipv6InternetBandwidthId'),
  bandwidth?: long(name='Bandwidth'),
  clientToken?: string(name='ClientToken'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model ModifyIpv6InternetBandwidthResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyIpv6InternetBandwidthResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyIpv6InternetBandwidthResponseBody(name='body'),
}

async function modifyIpv6InternetBandwidthWithOptions(request: ModifyIpv6InternetBandwidthRequest, runtime: Util.RuntimeOptions): ModifyIpv6InternetBandwidthResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyIpv6InternetBandwidth', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyIpv6InternetBandwidth(request: ModifyIpv6InternetBandwidthRequest): ModifyIpv6InternetBandwidthResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIpv6InternetBandwidthWithOptions(request, runtime);
}

model ModifyIPv6TranslatorAclAttributeRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  aclId?: string(name='AclId'),
  aclName?: string(name='AclName'),
}

model ModifyIPv6TranslatorAclAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyIPv6TranslatorAclAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyIPv6TranslatorAclAttributeResponseBody(name='body'),
}

async function modifyIPv6TranslatorAclAttributeWithOptions(request: ModifyIPv6TranslatorAclAttributeRequest, runtime: Util.RuntimeOptions): ModifyIPv6TranslatorAclAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyIPv6TranslatorAclAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyIPv6TranslatorAclAttribute(request: ModifyIPv6TranslatorAclAttributeRequest): ModifyIPv6TranslatorAclAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIPv6TranslatorAclAttributeWithOptions(request, runtime);
}

model ModifyIPv6TranslatorAclListEntryRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  aclId?: string(name='AclId'),
  aclEntryId?: string(name='AclEntryId'),
  aclEntryComment?: string(name='AclEntryComment'),
}

model ModifyIPv6TranslatorAclListEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyIPv6TranslatorAclListEntryResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyIPv6TranslatorAclListEntryResponseBody(name='body'),
}

async function modifyIPv6TranslatorAclListEntryWithOptions(request: ModifyIPv6TranslatorAclListEntryRequest, runtime: Util.RuntimeOptions): ModifyIPv6TranslatorAclListEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyIPv6TranslatorAclListEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyIPv6TranslatorAclListEntry(request: ModifyIPv6TranslatorAclListEntryRequest): ModifyIPv6TranslatorAclListEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIPv6TranslatorAclListEntryWithOptions(request, runtime);
}

model ModifyIPv6TranslatorAttributeRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  ipv6TranslatorId?: string(name='Ipv6TranslatorId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
}

model ModifyIPv6TranslatorAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyIPv6TranslatorAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyIPv6TranslatorAttributeResponseBody(name='body'),
}

async function modifyIPv6TranslatorAttributeWithOptions(request: ModifyIPv6TranslatorAttributeRequest, runtime: Util.RuntimeOptions): ModifyIPv6TranslatorAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyIPv6TranslatorAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyIPv6TranslatorAttribute(request: ModifyIPv6TranslatorAttributeRequest): ModifyIPv6TranslatorAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIPv6TranslatorAttributeWithOptions(request, runtime);
}

model ModifyIPv6TranslatorBandwidthRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  ipv6TranslatorId?: string(name='Ipv6TranslatorId'),
  bandwidth?: int32(name='Bandwidth'),
  autoPay?: boolean(name='AutoPay'),
}

model ModifyIPv6TranslatorBandwidthResponseBody = {
  requestId?: string(name='RequestId'),
  orderId?: string(name='OrderId'),
}

model ModifyIPv6TranslatorBandwidthResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyIPv6TranslatorBandwidthResponseBody(name='body'),
}

async function modifyIPv6TranslatorBandwidthWithOptions(request: ModifyIPv6TranslatorBandwidthRequest, runtime: Util.RuntimeOptions): ModifyIPv6TranslatorBandwidthResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyIPv6TranslatorBandwidth', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyIPv6TranslatorBandwidth(request: ModifyIPv6TranslatorBandwidthRequest): ModifyIPv6TranslatorBandwidthResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIPv6TranslatorBandwidthWithOptions(request, runtime);
}

model ModifyIPv6TranslatorEntryRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  ipv6TranslatorEntryId?: string(name='Ipv6TranslatorEntryId'),
  entryName?: string(name='EntryName'),
  entryDescription?: string(name='EntryDescription'),
  allocateIpv6Port?: int32(name='AllocateIpv6Port'),
  backendIpv4Addr?: string(name='BackendIpv4Addr'),
  backendIpv4Port?: int32(name='BackendIpv4Port'),
  transProtocol?: string(name='TransProtocol'),
  entryBandwidth?: int32(name='EntryBandwidth'),
  aclStatus?: string(name='AclStatus'),
  aclType?: string(name='AclType'),
  aclId?: string(name='AclId'),
}

model ModifyIPv6TranslatorEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyIPv6TranslatorEntryResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyIPv6TranslatorEntryResponseBody(name='body'),
}

async function modifyIPv6TranslatorEntryWithOptions(request: ModifyIPv6TranslatorEntryRequest, runtime: Util.RuntimeOptions): ModifyIPv6TranslatorEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyIPv6TranslatorEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyIPv6TranslatorEntry(request: ModifyIPv6TranslatorEntryRequest): ModifyIPv6TranslatorEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIPv6TranslatorEntryWithOptions(request, runtime);
}

model ModifyNatGatewayAttributeRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  natGatewayId?: string(name='NatGatewayId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
}

model ModifyNatGatewayAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyNatGatewayAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyNatGatewayAttributeResponseBody(name='body'),
}

async function modifyNatGatewayAttributeWithOptions(request: ModifyNatGatewayAttributeRequest, runtime: Util.RuntimeOptions): ModifyNatGatewayAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyNatGatewayAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyNatGatewayAttribute(request: ModifyNatGatewayAttributeRequest): ModifyNatGatewayAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyNatGatewayAttributeWithOptions(request, runtime);
}

model ModifyNatGatewaySpecRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  natGatewayId?: string(name='NatGatewayId'),
  spec?: string(name='Spec'),
  autoPay?: boolean(name='AutoPay'),
  clientToken?: string(name='ClientToken'),
}

model ModifyNatGatewaySpecResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyNatGatewaySpecResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyNatGatewaySpecResponseBody(name='body'),
}

async function modifyNatGatewaySpecWithOptions(request: ModifyNatGatewaySpecRequest, runtime: Util.RuntimeOptions): ModifyNatGatewaySpecResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyNatGatewaySpec', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyNatGatewaySpec(request: ModifyNatGatewaySpecRequest): ModifyNatGatewaySpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyNatGatewaySpecWithOptions(request, runtime);
}

model ModifyNetworkAclAttributesRequest {
  networkAclId?: string(name='NetworkAclId'),
  networkAclName?: string(name='NetworkAclName'),
  description?: string(name='Description'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerId?: long(name='OwnerId'),
  clientToken?: string(name='ClientToken'),
}

model ModifyNetworkAclAttributesResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyNetworkAclAttributesResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyNetworkAclAttributesResponseBody(name='body'),
}

async function modifyNetworkAclAttributesWithOptions(request: ModifyNetworkAclAttributesRequest, runtime: Util.RuntimeOptions): ModifyNetworkAclAttributesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyNetworkAclAttributes', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyNetworkAclAttributes(request: ModifyNetworkAclAttributesRequest): ModifyNetworkAclAttributesResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyNetworkAclAttributesWithOptions(request, runtime);
}

model ModifyRouteEntryRequest {
  regionId?: string(name='RegionId'),
  routeEntryName?: string(name='RouteEntryName'),
  routeEntryId?: string(name='RouteEntryId'),
  description?: string(name='Description'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyRouteEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyRouteEntryResponseBody(name='body'),
}

async function modifyRouteEntryWithOptions(request: ModifyRouteEntryRequest, runtime: Util.RuntimeOptions): ModifyRouteEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyRouteEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyRouteEntry(request: ModifyRouteEntryRequest): ModifyRouteEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyRouteEntryWithOptions(request, runtime);
}

model ModifyRouterInterfaceAttributeRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  routerInterfaceId?: string(name='RouterInterfaceId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  oppositeInterfaceId?: string(name='OppositeInterfaceId'),
  oppositeRouterId?: string(name='OppositeRouterId'),
  oppositeRouterType?: string(name='OppositeRouterType'),
  oppositeInterfaceOwnerId?: long(name='OppositeInterfaceOwnerId'),
  healthCheckSourceIp?: string(name='HealthCheckSourceIp'),
  healthCheckTargetIp?: string(name='HealthCheckTargetIp'),
  hcThreshold?: int32(name='HcThreshold'),
  hcRate?: int32(name='HcRate'),
  deleteHealthCheckIp?: boolean(name='DeleteHealthCheckIp'),
}

model ModifyRouterInterfaceAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyRouterInterfaceAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyRouterInterfaceAttributeResponseBody(name='body'),
}

async function modifyRouterInterfaceAttributeWithOptions(request: ModifyRouterInterfaceAttributeRequest, runtime: Util.RuntimeOptions): ModifyRouterInterfaceAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyRouterInterfaceAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyRouterInterfaceAttribute(request: ModifyRouterInterfaceAttributeRequest): ModifyRouterInterfaceAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyRouterInterfaceAttributeWithOptions(request, runtime);
}

model ModifyRouterInterfaceSpecRequest {
  regionId?: string(name='RegionId'),
  routerInterfaceId?: string(name='RouterInterfaceId'),
  spec?: string(name='Spec'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
}

model ModifyRouterInterfaceSpecResponseBody = {
  requestId?: string(name='RequestId'),
  spec?: string(name='Spec'),
}

model ModifyRouterInterfaceSpecResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyRouterInterfaceSpecResponseBody(name='body'),
}

async function modifyRouterInterfaceSpecWithOptions(request: ModifyRouterInterfaceSpecRequest, runtime: Util.RuntimeOptions): ModifyRouterInterfaceSpecResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyRouterInterfaceSpec', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyRouterInterfaceSpec(request: ModifyRouterInterfaceSpecRequest): ModifyRouterInterfaceSpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyRouterInterfaceSpecWithOptions(request, runtime);
}

model ModifyRouteTableAttributesRequest {
  routeTableId?: string(name='RouteTableId'),
  routeTableName?: string(name='RouteTableName'),
  description?: string(name='Description'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  bandwidth?: string(name='Bandwidth'),
  kbpsBandwidth?: string(name='KbpsBandwidth'),
  ownerAccount?: string(name='OwnerAccount'),
  resourceBid?: string(name='ResourceBid'),
  resourceUid?: long(name='ResourceUid'),
  regionId?: string(name='RegionId'),
}

model ModifyRouteTableAttributesResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyRouteTableAttributesResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyRouteTableAttributesResponseBody(name='body'),
}

async function modifyRouteTableAttributesWithOptions(request: ModifyRouteTableAttributesRequest, runtime: Util.RuntimeOptions): ModifyRouteTableAttributesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyRouteTableAttributes', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyRouteTableAttributes(request: ModifyRouteTableAttributesRequest): ModifyRouteTableAttributesResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyRouteTableAttributesWithOptions(request, runtime);
}

model ModifySnatEntryRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  snatTableId?: string(name='SnatTableId'),
  snatEntryId?: string(name='SnatEntryId'),
  snatIp?: string(name='SnatIp'),
  snatEntryName?: string(name='SnatEntryName'),
  clientToken?: string(name='ClientToken'),
}

model ModifySnatEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifySnatEntryResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySnatEntryResponseBody(name='body'),
}

async function modifySnatEntryWithOptions(request: ModifySnatEntryRequest, runtime: Util.RuntimeOptions): ModifySnatEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifySnatEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifySnatEntry(request: ModifySnatEntryRequest): ModifySnatEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySnatEntryWithOptions(request, runtime);
}

model ModifySslVpnClientCertRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  clientToken?: string(name='ClientToken'),
  regionId?: string(name='RegionId'),
  sslVpnClientCertId?: string(name='SslVpnClientCertId'),
  name?: string(name='Name'),
}

model ModifySslVpnClientCertResponseBody = {
  requestId?: string(name='RequestId'),
  sslVpnClientCertId?: string(name='SslVpnClientCertId'),
  name?: string(name='Name'),
}

model ModifySslVpnClientCertResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySslVpnClientCertResponseBody(name='body'),
}

async function modifySslVpnClientCertWithOptions(request: ModifySslVpnClientCertRequest, runtime: Util.RuntimeOptions): ModifySslVpnClientCertResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifySslVpnClientCert', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifySslVpnClientCert(request: ModifySslVpnClientCertRequest): ModifySslVpnClientCertResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySslVpnClientCertWithOptions(request, runtime);
}

model ModifySslVpnServerRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  clientToken?: string(name='ClientToken'),
  regionId?: string(name='RegionId'),
  sslVpnServerId?: string(name='SslVpnServerId'),
  name?: string(name='Name'),
  clientIpPool?: string(name='ClientIpPool'),
  localSubnet?: string(name='LocalSubnet'),
  proto?: string(name='Proto'),
  cipher?: string(name='Cipher'),
  port?: int32(name='Port'),
  compress?: boolean(name='Compress'),
  enableMultiFactorAuth?: boolean(name='EnableMultiFactorAuth'),
  IDaaSInstanceId?: string(name='IDaaSInstanceId'),
}

model ModifySslVpnServerResponseBody = {
  compress?: boolean(name='Compress'),
  localSubnet?: string(name='LocalSubnet'),
  connections?: int32(name='Connections'),
  clientIpPool?: string(name='ClientIpPool'),
  IDaaSInstanceId?: string(name='IDaaSInstanceId'),
  requestId?: string(name='RequestId'),
  maxConnections?: int32(name='MaxConnections'),
  enableMultiFactorAuth?: boolean(name='EnableMultiFactorAuth'),
  createTime?: long(name='CreateTime'),
  port?: int32(name='Port'),
  sslVpnServerId?: string(name='SslVpnServerId'),
  name?: string(name='Name'),
  internetIp?: string(name='InternetIp'),
  proto?: string(name='Proto'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  regionId?: string(name='RegionId'),
  cipher?: string(name='Cipher'),
}

model ModifySslVpnServerResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySslVpnServerResponseBody(name='body'),
}

async function modifySslVpnServerWithOptions(request: ModifySslVpnServerRequest, runtime: Util.RuntimeOptions): ModifySslVpnServerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifySslVpnServer', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifySslVpnServer(request: ModifySslVpnServerRequest): ModifySslVpnServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySslVpnServerWithOptions(request, runtime);
}

model ModifyVirtualBorderRouterAttributeRequest {
  regionId?: string(name='RegionId'),
  vbrId?: string(name='VbrId'),
  vlanId?: int32(name='VlanId'),
  circuitCode?: string(name='CircuitCode'),
  localGatewayIp?: string(name='LocalGatewayIp'),
  peerGatewayIp?: string(name='PeerGatewayIp'),
  peeringSubnetMask?: string(name='PeeringSubnetMask'),
  minTxInterval?: long(name='MinTxInterval'),
  minRxInterval?: long(name='MinRxInterval'),
  detectMultiplier?: long(name='DetectMultiplier'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  associatedPhysicalConnections?: string(name='AssociatedPhysicalConnections'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  localIpv6GatewayIp?: string(name='LocalIpv6GatewayIp'),
  peerIpv6GatewayIp?: string(name='PeerIpv6GatewayIp'),
  peeringIpv6SubnetMask?: string(name='PeeringIpv6SubnetMask'),
  enableIpv6?: boolean(name='EnableIpv6'),
  bandwidth?: int32(name='Bandwidth'),
}

model ModifyVirtualBorderRouterAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVirtualBorderRouterAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVirtualBorderRouterAttributeResponseBody(name='body'),
}

async function modifyVirtualBorderRouterAttributeWithOptions(request: ModifyVirtualBorderRouterAttributeRequest, runtime: Util.RuntimeOptions): ModifyVirtualBorderRouterAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyVirtualBorderRouterAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyVirtualBorderRouterAttribute(request: ModifyVirtualBorderRouterAttributeRequest): ModifyVirtualBorderRouterAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVirtualBorderRouterAttributeWithOptions(request, runtime);
}

model ModifyVpcAttributeRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpcId?: string(name='VpcId'),
  description?: string(name='Description'),
  vpcName?: string(name='VpcName'),
  cidrBlock?: string(name='CidrBlock'),
  regionId?: string(name='RegionId'),
  enableIPv6?: boolean(name='EnableIPv6'),
  ownerAccount?: string(name='OwnerAccount'),
  ipv6CidrBlock?: string(name='Ipv6CidrBlock'),
}

model ModifyVpcAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVpcAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVpcAttributeResponseBody(name='body'),
}

async function modifyVpcAttributeWithOptions(request: ModifyVpcAttributeRequest, runtime: Util.RuntimeOptions): ModifyVpcAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyVpcAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyVpcAttribute(request: ModifyVpcAttributeRequest): ModifyVpcAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVpcAttributeWithOptions(request, runtime);
}

model ModifyVpnConnectionAttributeRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  vpnConnectionId?: string(name='VpnConnectionId'),
  name?: string(name='Name'),
  localSubnet?: string(name='LocalSubnet'),
  remoteSubnet?: string(name='RemoteSubnet'),
  effectImmediately?: boolean(name='EffectImmediately'),
  ikeConfig?: string(name='IkeConfig'),
  ipsecConfig?: string(name='IpsecConfig'),
  healthCheckConfig?: string(name='HealthCheckConfig'),
  autoConfigRoute?: boolean(name='AutoConfigRoute'),
  enableDpd?: boolean(name='EnableDpd'),
  enableNatTraversal?: boolean(name='EnableNatTraversal'),
  bgpConfig?: string(name='BgpConfig'),
  remoteCaCertificate?: string(name='RemoteCaCertificate'),
}

model ModifyVpnConnectionAttributeResponseBody = {
  localSubnet?: string(name='LocalSubnet'),
  description?: string(name='Description'),
  requestId?: string(name='RequestId'),
  customerGatewayId?: string(name='CustomerGatewayId'),
  createTime?: long(name='CreateTime'),
  name?: string(name='Name'),
  effectImmediately?: boolean(name='EffectImmediately'),
  remoteSubnet?: string(name='RemoteSubnet'),
  vcoHealthCheck?: {
    dip?: string(name='Dip'),
    interval?: int32(name='Interval'),
    retry?: int32(name='Retry'),
    sip?: string(name='Sip'),
    enable?: string(name='Enable'),
  }(name='VcoHealthCheck'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  ipsecConfig?: {
    ipsecLifetime?: long(name='IpsecLifetime'),
    ipsecEncAlg?: string(name='IpsecEncAlg'),
    ipsecPfs?: string(name='IpsecPfs'),
    ipsecAuthAlg?: string(name='IpsecAuthAlg'),
  }(name='IpsecConfig'),
  vpnConnectionId?: string(name='VpnConnectionId'),
  enableNatTraversal?: boolean(name='EnableNatTraversal'),
  enableDpd?: boolean(name='EnableDpd'),
  ikeConfig?: {
    remoteId?: string(name='RemoteId'),
    ikeLifetime?: long(name='IkeLifetime'),
    ikeEncAlg?: string(name='IkeEncAlg'),
    localId?: string(name='LocalId'),
    ikeMode?: string(name='IkeMode'),
    ikeVersion?: string(name='IkeVersion'),
    ikePfs?: string(name='IkePfs'),
    psk?: string(name='Psk'),
    ikeAuthAlg?: string(name='IkeAuthAlg'),
  }(name='IkeConfig'),
  vpnBgpConfig?: {
    status?: string(name='Status'),
    peerBgpIp?: string(name='PeerBgpIp'),
    tunnelCidr?: string(name='TunnelCidr'),
    enableBgp?: string(name='EnableBgp'),
    localBgpIp?: string(name='LocalBgpIp'),
    peerAsn?: int32(name='PeerAsn'),
    localAsn?: int32(name='LocalAsn'),
  }(name='VpnBgpConfig'),
}

model ModifyVpnConnectionAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVpnConnectionAttributeResponseBody(name='body'),
}

async function modifyVpnConnectionAttributeWithOptions(request: ModifyVpnConnectionAttributeRequest, runtime: Util.RuntimeOptions): ModifyVpnConnectionAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyVpnConnectionAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyVpnConnectionAttribute(request: ModifyVpnConnectionAttributeRequest): ModifyVpnConnectionAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVpnConnectionAttributeWithOptions(request, runtime);
}

model ModifyVpnGatewayAttributeRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  autoPropagate?: boolean(name='AutoPropagate'),
}

model ModifyVpnGatewayAttributeResponseBody = {
  status?: string(name='Status'),
  description?: string(name='Description'),
  enableBgp?: boolean(name='EnableBgp'),
  endTime?: long(name='EndTime'),
  requestId?: string(name='RequestId'),
  createTime?: long(name='CreateTime'),
  vSwitchId?: string(name='VSwitchId'),
  autoPropagate?: boolean(name='AutoPropagate'),
  intranetIp?: string(name='IntranetIp'),
  businessStatus?: string(name='BusinessStatus'),
  name?: string(name='Name'),
  vpcId?: string(name='VpcId'),
  internetIp?: string(name='InternetIp'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  spec?: string(name='Spec'),
}

model ModifyVpnGatewayAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVpnGatewayAttributeResponseBody(name='body'),
}

async function modifyVpnGatewayAttributeWithOptions(request: ModifyVpnGatewayAttributeRequest, runtime: Util.RuntimeOptions): ModifyVpnGatewayAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyVpnGatewayAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyVpnGatewayAttribute(request: ModifyVpnGatewayAttributeRequest): ModifyVpnGatewayAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVpnGatewayAttributeWithOptions(request, runtime);
}

model ModifyVpnPbrRouteEntryWeightRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  routeSource?: string(name='RouteSource'),
  routeDest?: string(name='RouteDest'),
  nextHop?: string(name='NextHop'),
  weight?: int32(name='Weight'),
  newWeight?: int32(name='NewWeight'),
  overlayMode?: string(name='OverlayMode'),
}

model ModifyVpnPbrRouteEntryWeightResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVpnPbrRouteEntryWeightResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVpnPbrRouteEntryWeightResponseBody(name='body'),
}

async function modifyVpnPbrRouteEntryWeightWithOptions(request: ModifyVpnPbrRouteEntryWeightRequest, runtime: Util.RuntimeOptions): ModifyVpnPbrRouteEntryWeightResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyVpnPbrRouteEntryWeight', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyVpnPbrRouteEntryWeight(request: ModifyVpnPbrRouteEntryWeightRequest): ModifyVpnPbrRouteEntryWeightResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVpnPbrRouteEntryWeightWithOptions(request, runtime);
}

model ModifyVpnRouteEntryWeightRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  routeDest?: string(name='RouteDest'),
  nextHop?: string(name='NextHop'),
  weight?: int32(name='Weight'),
  newWeight?: int32(name='NewWeight'),
  overlayMode?: string(name='OverlayMode'),
}

model ModifyVpnRouteEntryWeightResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVpnRouteEntryWeightResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVpnRouteEntryWeightResponseBody(name='body'),
}

async function modifyVpnRouteEntryWeightWithOptions(request: ModifyVpnRouteEntryWeightRequest, runtime: Util.RuntimeOptions): ModifyVpnRouteEntryWeightResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyVpnRouteEntryWeight', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyVpnRouteEntryWeight(request: ModifyVpnRouteEntryWeightRequest): ModifyVpnRouteEntryWeightResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVpnRouteEntryWeightWithOptions(request, runtime);
}

model ModifyVRouterAttributeRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  VRouterId?: string(name='VRouterId'),
  VRouterName?: string(name='VRouterName'),
  description?: string(name='Description'),
  ownerAccount?: string(name='OwnerAccount'),
}

model ModifyVRouterAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVRouterAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVRouterAttributeResponseBody(name='body'),
}

async function modifyVRouterAttributeWithOptions(request: ModifyVRouterAttributeRequest, runtime: Util.RuntimeOptions): ModifyVRouterAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyVRouterAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyVRouterAttribute(request: ModifyVRouterAttributeRequest): ModifyVRouterAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVRouterAttributeWithOptions(request, runtime);
}

model ModifyVSwitchAttributeRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vSwitchId?: string(name='VSwitchId'),
  vSwitchName?: string(name='VSwitchName'),
  regionId?: string(name='RegionId'),
  description?: string(name='Description'),
  ipv6CidrBlock?: int32(name='Ipv6CidrBlock'),
  ownerAccount?: string(name='OwnerAccount'),
  enableIPv6?: boolean(name='EnableIPv6'),
}

model ModifyVSwitchAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVSwitchAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVSwitchAttributeResponseBody(name='body'),
}

async function modifyVSwitchAttributeWithOptions(request: ModifyVSwitchAttributeRequest, runtime: Util.RuntimeOptions): ModifyVSwitchAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyVSwitchAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyVSwitchAttribute(request: ModifyVSwitchAttributeRequest): ModifyVSwitchAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVSwitchAttributeWithOptions(request, runtime);
}

model MoveResourceGroupRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceId?: string(name='ResourceId'),
  resourceType?: string(name='ResourceType'),
  newResourceGroupId?: string(name='NewResourceGroupId'),
  regionId?: string(name='RegionId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model MoveResourceGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model MoveResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  body: MoveResourceGroupResponseBody(name='body'),
}

async function moveResourceGroupWithOptions(request: MoveResourceGroupRequest, runtime: Util.RuntimeOptions): MoveResourceGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('MoveResourceGroup', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function moveResourceGroup(request: MoveResourceGroupRequest): MoveResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return moveResourceGroupWithOptions(request, runtime);
}

model PublishVpnRouteEntryRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  routeDest?: string(name='RouteDest'),
  nextHop?: string(name='NextHop'),
  routeType?: string(name='RouteType'),
  publishVpc?: boolean(name='PublishVpc'),
}

model PublishVpnRouteEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model PublishVpnRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  body: PublishVpnRouteEntryResponseBody(name='body'),
}

async function publishVpnRouteEntryWithOptions(request: PublishVpnRouteEntryRequest, runtime: Util.RuntimeOptions): PublishVpnRouteEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('PublishVpnRouteEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function publishVpnRouteEntry(request: PublishVpnRouteEntryRequest): PublishVpnRouteEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return publishVpnRouteEntryWithOptions(request, runtime);
}

model RecoverVirtualBorderRouterRequest {
  regionId?: string(name='RegionId'),
  vbrId?: string(name='VbrId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
}

model RecoverVirtualBorderRouterResponseBody = {
  requestId?: string(name='RequestId'),
}

model RecoverVirtualBorderRouterResponse = {
  headers: map[string]string(name='headers'),
  body: RecoverVirtualBorderRouterResponseBody(name='body'),
}

async function recoverVirtualBorderRouterWithOptions(request: RecoverVirtualBorderRouterRequest, runtime: Util.RuntimeOptions): RecoverVirtualBorderRouterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RecoverVirtualBorderRouter', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function recoverVirtualBorderRouter(request: RecoverVirtualBorderRouterRequest): RecoverVirtualBorderRouterResponse {
  var runtime = new Util.RuntimeOptions{};
  return recoverVirtualBorderRouterWithOptions(request, runtime);
}

model ReleaseEipAddressRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  allocationId?: string(name='AllocationId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model ReleaseEipAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleaseEipAddressResponse = {
  headers: map[string]string(name='headers'),
  body: ReleaseEipAddressResponseBody(name='body'),
}

async function releaseEipAddressWithOptions(request: ReleaseEipAddressRequest, runtime: Util.RuntimeOptions): ReleaseEipAddressResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ReleaseEipAddress', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function releaseEipAddress(request: ReleaseEipAddressRequest): ReleaseEipAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return releaseEipAddressWithOptions(request, runtime);
}

model ReleaseEipSegmentAddressRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  segmentInstanceId?: string(name='SegmentInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  clientToken?: string(name='ClientToken'),
}

model ReleaseEipSegmentAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleaseEipSegmentAddressResponse = {
  headers: map[string]string(name='headers'),
  body: ReleaseEipSegmentAddressResponseBody(name='body'),
}

async function releaseEipSegmentAddressWithOptions(request: ReleaseEipSegmentAddressRequest, runtime: Util.RuntimeOptions): ReleaseEipSegmentAddressResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ReleaseEipSegmentAddress', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function releaseEipSegmentAddress(request: ReleaseEipSegmentAddressRequest): ReleaseEipSegmentAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return releaseEipSegmentAddressWithOptions(request, runtime);
}

model RemoveCommonBandwidthPackageIpRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  ipInstanceId?: string(name='IpInstanceId'),
}

model RemoveCommonBandwidthPackageIpResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveCommonBandwidthPackageIpResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveCommonBandwidthPackageIpResponseBody(name='body'),
}

async function removeCommonBandwidthPackageIpWithOptions(request: RemoveCommonBandwidthPackageIpRequest, runtime: Util.RuntimeOptions): RemoveCommonBandwidthPackageIpResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RemoveCommonBandwidthPackageIp', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function removeCommonBandwidthPackageIp(request: RemoveCommonBandwidthPackageIpRequest): RemoveCommonBandwidthPackageIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeCommonBandwidthPackageIpWithOptions(request, runtime);
}

model RemoveGlobalAccelerationInstanceIpRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  globalAccelerationInstanceId?: string(name='GlobalAccelerationInstanceId'),
  ipInstanceId?: string(name='IpInstanceId'),
}

model RemoveGlobalAccelerationInstanceIpResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveGlobalAccelerationInstanceIpResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveGlobalAccelerationInstanceIpResponseBody(name='body'),
}

async function removeGlobalAccelerationInstanceIpWithOptions(request: RemoveGlobalAccelerationInstanceIpRequest, runtime: Util.RuntimeOptions): RemoveGlobalAccelerationInstanceIpResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RemoveGlobalAccelerationInstanceIp', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function removeGlobalAccelerationInstanceIp(request: RemoveGlobalAccelerationInstanceIpRequest): RemoveGlobalAccelerationInstanceIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeGlobalAccelerationInstanceIpWithOptions(request, runtime);
}

model RemoveIPv6TranslatorAclListEntryRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  clientToken?: string(name='ClientToken'),
  regionId?: string(name='RegionId'),
  aclId?: string(name='AclId'),
  aclEntryId?: string(name='AclEntryId'),
}

model RemoveIPv6TranslatorAclListEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveIPv6TranslatorAclListEntryResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveIPv6TranslatorAclListEntryResponseBody(name='body'),
}

async function removeIPv6TranslatorAclListEntryWithOptions(request: RemoveIPv6TranslatorAclListEntryRequest, runtime: Util.RuntimeOptions): RemoveIPv6TranslatorAclListEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RemoveIPv6TranslatorAclListEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function removeIPv6TranslatorAclListEntry(request: RemoveIPv6TranslatorAclListEntryRequest): RemoveIPv6TranslatorAclListEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeIPv6TranslatorAclListEntryWithOptions(request, runtime);
}

model RenewInstanceRequest {
  regionId?: string(name='RegionId'),
  instanceId?: string(name='InstanceId'),
  pricingCycle?: string(name='PricingCycle'),
  duration?: int32(name='Duration'),
  instanceType?: string(name='InstanceType'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model RenewInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  orderId?: string(name='OrderId'),
}

model RenewInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RenewInstanceResponseBody(name='body'),
}

async function renewInstanceWithOptions(request: RenewInstanceRequest, runtime: Util.RuntimeOptions): RenewInstanceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RenewInstance', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function renewInstance(request: RenewInstanceRequest): RenewInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return renewInstanceWithOptions(request, runtime);
}

model ReplaceVpcDhcpOptionsSetRequest {
  regionId?: string(name='RegionId'),
  dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
  vpcId?: string(name='VpcId'),
  clientToken?: string(name='ClientToken'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  dryRun?: boolean(name='DryRun'),
}

model ReplaceVpcDhcpOptionsSetResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReplaceVpcDhcpOptionsSetResponse = {
  headers: map[string]string(name='headers'),
  body: ReplaceVpcDhcpOptionsSetResponseBody(name='body'),
}

async function replaceVpcDhcpOptionsSetWithOptions(request: ReplaceVpcDhcpOptionsSetRequest, runtime: Util.RuntimeOptions): ReplaceVpcDhcpOptionsSetResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ReplaceVpcDhcpOptionsSet', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function replaceVpcDhcpOptionsSet(request: ReplaceVpcDhcpOptionsSetRequest): ReplaceVpcDhcpOptionsSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return replaceVpcDhcpOptionsSetWithOptions(request, runtime);
}

model RevokeInstanceFromCenRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
  cenId?: string(name='CenId'),
  cenOwnerId?: long(name='CenOwnerId'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
}

model RevokeInstanceFromCenResponseBody = {
  requestId?: string(name='RequestId'),
}

model RevokeInstanceFromCenResponse = {
  headers: map[string]string(name='headers'),
  body: RevokeInstanceFromCenResponseBody(name='body'),
}

async function revokeInstanceFromCenWithOptions(request: RevokeInstanceFromCenRequest, runtime: Util.RuntimeOptions): RevokeInstanceFromCenResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RevokeInstanceFromCen', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function revokeInstanceFromCen(request: RevokeInstanceFromCenRequest): RevokeInstanceFromCenResponse {
  var runtime = new Util.RuntimeOptions{};
  return revokeInstanceFromCenWithOptions(request, runtime);
}

model TagResourcesRequest {
  resourceType?: string(name='ResourceType'),
  regionId?: string(name='RegionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  resourceId?: [ string ](name='ResourceId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('TagResources', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model TerminatePhysicalConnectionRequest {
  regionId?: string(name='RegionId'),
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
}

model TerminatePhysicalConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model TerminatePhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: TerminatePhysicalConnectionResponseBody(name='body'),
}

async function terminatePhysicalConnectionWithOptions(request: TerminatePhysicalConnectionRequest, runtime: Util.RuntimeOptions): TerminatePhysicalConnectionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('TerminatePhysicalConnection', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function terminatePhysicalConnection(request: TerminatePhysicalConnectionRequest): TerminatePhysicalConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return terminatePhysicalConnectionWithOptions(request, runtime);
}

model TerminateVirtualBorderRouterRequest {
  regionId?: string(name='RegionId'),
  vbrId?: string(name='VbrId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
}

model TerminateVirtualBorderRouterResponseBody = {
  requestId?: string(name='RequestId'),
}

model TerminateVirtualBorderRouterResponse = {
  headers: map[string]string(name='headers'),
  body: TerminateVirtualBorderRouterResponseBody(name='body'),
}

async function terminateVirtualBorderRouterWithOptions(request: TerminateVirtualBorderRouterRequest, runtime: Util.RuntimeOptions): TerminateVirtualBorderRouterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('TerminateVirtualBorderRouter', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function terminateVirtualBorderRouter(request: TerminateVirtualBorderRouterRequest): TerminateVirtualBorderRouterResponse {
  var runtime = new Util.RuntimeOptions{};
  return terminateVirtualBorderRouterWithOptions(request, runtime);
}

model UnassociateEipAddressRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  force?: boolean(name='Force'),
  regionId?: string(name='RegionId'),
  allocationId?: string(name='AllocationId'),
  instanceId?: string(name='InstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  instanceType?: string(name='InstanceType'),
  privateIpAddress?: string(name='PrivateIpAddress'),
  clientToken?: string(name='ClientToken'),
}

model UnassociateEipAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnassociateEipAddressResponse = {
  headers: map[string]string(name='headers'),
  body: UnassociateEipAddressResponseBody(name='body'),
}

async function unassociateEipAddressWithOptions(request: UnassociateEipAddressRequest, runtime: Util.RuntimeOptions): UnassociateEipAddressResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UnassociateEipAddress', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function unassociateEipAddress(request: UnassociateEipAddressRequest): UnassociateEipAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return unassociateEipAddressWithOptions(request, runtime);
}

model UnassociateGlobalAccelerationInstanceRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  globalAccelerationInstanceId?: string(name='GlobalAccelerationInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  instanceType?: string(name='InstanceType'),
}

model UnassociateGlobalAccelerationInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnassociateGlobalAccelerationInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: UnassociateGlobalAccelerationInstanceResponseBody(name='body'),
}

async function unassociateGlobalAccelerationInstanceWithOptions(request: UnassociateGlobalAccelerationInstanceRequest, runtime: Util.RuntimeOptions): UnassociateGlobalAccelerationInstanceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UnassociateGlobalAccelerationInstance', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function unassociateGlobalAccelerationInstance(request: UnassociateGlobalAccelerationInstanceRequest): UnassociateGlobalAccelerationInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return unassociateGlobalAccelerationInstanceWithOptions(request, runtime);
}

model UnassociateHaVipRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  clientToken?: string(name='ClientToken'),
  regionId?: string(name='RegionId'),
  haVipId?: string(name='HaVipId'),
  instanceId?: string(name='InstanceId'),
  force?: string(name='Force'),
  instanceType?: string(name='InstanceType'),
}

model UnassociateHaVipResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnassociateHaVipResponse = {
  headers: map[string]string(name='headers'),
  body: UnassociateHaVipResponseBody(name='body'),
}

async function unassociateHaVipWithOptions(request: UnassociateHaVipRequest, runtime: Util.RuntimeOptions): UnassociateHaVipResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UnassociateHaVip', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function unassociateHaVip(request: UnassociateHaVipRequest): UnassociateHaVipResponse {
  var runtime = new Util.RuntimeOptions{};
  return unassociateHaVipWithOptions(request, runtime);
}

model UnassociateNetworkAclRequest {
  networkAclId?: string(name='NetworkAclId'),
  regionId?: string(name='RegionId'),
  resource?: [ 
    {
      resourceType?: string(name='ResourceType'),
      resourceId?: string(name='ResourceId'),
    }
  ](name='Resource'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerId?: long(name='OwnerId'),
  clientToken?: string(name='ClientToken'),
}

model UnassociateNetworkAclResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnassociateNetworkAclResponse = {
  headers: map[string]string(name='headers'),
  body: UnassociateNetworkAclResponseBody(name='body'),
}

async function unassociateNetworkAclWithOptions(request: UnassociateNetworkAclRequest, runtime: Util.RuntimeOptions): UnassociateNetworkAclResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UnassociateNetworkAcl', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function unassociateNetworkAcl(request: UnassociateNetworkAclRequest): UnassociateNetworkAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return unassociateNetworkAclWithOptions(request, runtime);
}

model UnassociatePhysicalConnectionFromVirtualBorderRouterRequest {
  regionId?: string(name='RegionId'),
  vbrId?: string(name='VbrId'),
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
}

model UnassociatePhysicalConnectionFromVirtualBorderRouterResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnassociatePhysicalConnectionFromVirtualBorderRouterResponse = {
  headers: map[string]string(name='headers'),
  body: UnassociatePhysicalConnectionFromVirtualBorderRouterResponseBody(name='body'),
}

async function unassociatePhysicalConnectionFromVirtualBorderRouterWithOptions(request: UnassociatePhysicalConnectionFromVirtualBorderRouterRequest, runtime: Util.RuntimeOptions): UnassociatePhysicalConnectionFromVirtualBorderRouterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UnassociatePhysicalConnectionFromVirtualBorderRouter', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function unassociatePhysicalConnectionFromVirtualBorderRouter(request: UnassociatePhysicalConnectionFromVirtualBorderRouterRequest): UnassociatePhysicalConnectionFromVirtualBorderRouterResponse {
  var runtime = new Util.RuntimeOptions{};
  return unassociatePhysicalConnectionFromVirtualBorderRouterWithOptions(request, runtime);
}

model UnassociateRouteTableRequest {
  regionId?: string(name='RegionId'),
  routeTableId?: string(name='RouteTableId'),
  vSwitchId?: string(name='VSwitchId'),
  clientToken?: string(name='ClientToken'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model UnassociateRouteTableResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnassociateRouteTableResponse = {
  headers: map[string]string(name='headers'),
  body: UnassociateRouteTableResponseBody(name='body'),
}

async function unassociateRouteTableWithOptions(request: UnassociateRouteTableRequest, runtime: Util.RuntimeOptions): UnassociateRouteTableResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UnassociateRouteTable', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function unassociateRouteTable(request: UnassociateRouteTableRequest): UnassociateRouteTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return unassociateRouteTableWithOptions(request, runtime);
}

model UnassociateVpcCidrBlockRequest {
  regionId?: string(name='RegionId'),
  vpcId?: string(name='VpcId'),
  secondaryCidrBlock?: string(name='SecondaryCidrBlock'),
  IPv6CidrBlock?: string(name='IPv6CidrBlock'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model UnassociateVpcCidrBlockResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnassociateVpcCidrBlockResponse = {
  headers: map[string]string(name='headers'),
  body: UnassociateVpcCidrBlockResponseBody(name='body'),
}

async function unassociateVpcCidrBlockWithOptions(request: UnassociateVpcCidrBlockRequest, runtime: Util.RuntimeOptions): UnassociateVpcCidrBlockResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UnassociateVpcCidrBlock', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function unassociateVpcCidrBlock(request: UnassociateVpcCidrBlockRequest): UnassociateVpcCidrBlockResponse {
  var runtime = new Util.RuntimeOptions{};
  return unassociateVpcCidrBlockWithOptions(request, runtime);
}

model UnTagResourcesRequest {
  resourceType?: string(name='ResourceType'),
  regionId?: string(name='RegionId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  all?: boolean(name='All'),
  resourceId?: [ string ](name='ResourceId'),
  tagKey?: [ string ](name='TagKey'),
  tag?: [ 
    {
    }
  ](name='Tag'),
}

model UnTagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: UnTagResourcesResponseBody(name='body'),
}

async function unTagResourcesWithOptions(request: UnTagResourcesRequest, runtime: Util.RuntimeOptions): UnTagResourcesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UnTagResources', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function unTagResources(request: UnTagResourcesRequest): UnTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return unTagResourcesWithOptions(request, runtime);
}

model UpdateDhcpOptionsSetAttributeRequest {
  regionId?: string(name='RegionId'),
  dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
  domainNameServers?: string(name='DomainNameServers'),
  domainName?: string(name='DomainName'),
  dhcpOptionsSetName?: string(name='DhcpOptionsSetName'),
  dhcpOptionsSetDescription?: string(name='DhcpOptionsSetDescription'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
}

model UpdateDhcpOptionsSetAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateDhcpOptionsSetAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDhcpOptionsSetAttributeResponseBody(name='body'),
}

async function updateDhcpOptionsSetAttributeWithOptions(request: UpdateDhcpOptionsSetAttributeRequest, runtime: Util.RuntimeOptions): UpdateDhcpOptionsSetAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateDhcpOptionsSetAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateDhcpOptionsSetAttribute(request: UpdateDhcpOptionsSetAttributeRequest): UpdateDhcpOptionsSetAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDhcpOptionsSetAttributeWithOptions(request, runtime);
}

model UpdateIpsecServerRequest {
  regionId?: string(name='RegionId'),
  ipsecServerId?: string(name='IpsecServerId'),
  localSubnet?: string(name='LocalSubnet'),
  clientIpPool?: string(name='ClientIpPool'),
  ipsecServerName?: string(name='IpsecServerName'),
  effectImmediately?: boolean(name='EffectImmediately'),
  ikeConfig?: string(name='IkeConfig'),
  ipsecConfig?: string(name='IpsecConfig'),
  pskEnabled?: boolean(name='PskEnabled'),
  psk?: string(name='Psk'),
  multiFactorAuthEnabled?: boolean(name='MultiFactorAuthEnabled'),
  IDaaSInstanceId?: string(name='IDaaSInstanceId'),
  callerBid?: string(name='callerBid'),
  clientToken?: string(name='ClientToken'),
  dryRun?: string(name='DryRun'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model UpdateIpsecServerResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateIpsecServerResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateIpsecServerResponseBody(name='body'),
}

async function updateIpsecServerWithOptions(request: UpdateIpsecServerRequest, runtime: Util.RuntimeOptions): UpdateIpsecServerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateIpsecServer', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateIpsecServer(request: UpdateIpsecServerRequest): UpdateIpsecServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateIpsecServerWithOptions(request, runtime);
}

model UpdateNatGatewayNatTypeRequest {
  regionId?: string(name='RegionId'),
  natGatewayId?: string(name='NatGatewayId'),
  vSwitchId?: string(name='VSwitchId'),
  natType?: string(name='NatType'),
  dryRun?: boolean(name='DryRun'),
  clientToken?: string(name='ClientToken'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
}

model UpdateNatGatewayNatTypeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateNatGatewayNatTypeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateNatGatewayNatTypeResponseBody(name='body'),
}

async function updateNatGatewayNatTypeWithOptions(request: UpdateNatGatewayNatTypeRequest, runtime: Util.RuntimeOptions): UpdateNatGatewayNatTypeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateNatGatewayNatType', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateNatGatewayNatType(request: UpdateNatGatewayNatTypeRequest): UpdateNatGatewayNatTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateNatGatewayNatTypeWithOptions(request, runtime);
}

model UpdateNetworkAclEntriesRequest {
  updateIngressAclEntries?: boolean(name='UpdateIngressAclEntries'),
  updateEgressAclEntries?: boolean(name='UpdateEgressAclEntries'),
  networkAclId?: string(name='NetworkAclId'),
  regionId?: string(name='RegionId'),
  ingressAclEntries?: [ 
    {
      networkAclEntryId?: string(name='NetworkAclEntryId'),
      entryType?: string(name='EntryType'),
      policy?: string(name='Policy'),
      networkAclEntryName?: string(name='NetworkAclEntryName'),
      description?: string(name='Description'),
      sourceCidrIp?: string(name='SourceCidrIp'),
      protocol?: string(name='Protocol'),
      port?: string(name='Port'),
    }
  ](name='IngressAclEntries'),
  egressAclEntries?: [ 
    {
      networkAclEntryId?: string(name='NetworkAclEntryId'),
      entryType?: string(name='EntryType'),
      policy?: string(name='Policy'),
      networkAclEntryName?: string(name='NetworkAclEntryName'),
      description?: string(name='Description'),
      protocol?: string(name='Protocol'),
      destinationCidrIp?: string(name='DestinationCidrIp'),
      port?: string(name='Port'),
    }
  ](name='EgressAclEntries'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerId?: long(name='OwnerId'),
  clientToken?: string(name='ClientToken'),
}

model UpdateNetworkAclEntriesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateNetworkAclEntriesResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateNetworkAclEntriesResponseBody(name='body'),
}

async function updateNetworkAclEntriesWithOptions(request: UpdateNetworkAclEntriesRequest, runtime: Util.RuntimeOptions): UpdateNetworkAclEntriesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateNetworkAclEntries', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateNetworkAclEntries(request: UpdateNetworkAclEntriesRequest): UpdateNetworkAclEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateNetworkAclEntriesWithOptions(request, runtime);
}

model UpdateVirtualBorderBandwidthRequest {
  regionId?: string(name='RegionId'),
  virtualBorderRouterId?: string(name='VirtualBorderRouterId'),
  bandwidth?: int32(name='Bandwidth'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
}

model UpdateVirtualBorderBandwidthResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  httpStatusCode?: string(name='HttpStatusCode'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model UpdateVirtualBorderBandwidthResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateVirtualBorderBandwidthResponseBody(name='body'),
}

async function updateVirtualBorderBandwidthWithOptions(request: UpdateVirtualBorderBandwidthRequest, runtime: Util.RuntimeOptions): UpdateVirtualBorderBandwidthResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateVirtualBorderBandwidth', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateVirtualBorderBandwidth(request: UpdateVirtualBorderBandwidthRequest): UpdateVirtualBorderBandwidthResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateVirtualBorderBandwidthWithOptions(request, runtime);
}

